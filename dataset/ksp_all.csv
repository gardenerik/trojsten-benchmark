id,competition,problem,solution,difficulty
ab2f6f2494877f6c,ksp,"# Organizácia projektov

Syseľ pracuje ako manažér softvérových projektov. Práve teraz sa snaží vymyslieť, ako čo najoptimálnejšie priradiť programátorov ku dvom projektom. O každom z programátorov vie, ako je zbehlý v technológiach potrebných na ten-ktorý projekt. Pracuje s obmedzeným rozpočtom, preto si na každý z projektov môže dovoliť iba určitý počet programátorov, zvyšok žiaľ bude musieť prepustiť. Syseľ by chcel nájsť čo najlepšie priradenie programátorov ku projektom. Pomôžete mu s týmto problémom?

## Úloha

Syseľ má $n$ programátorov. Z jeho výpočtov mu vyšlo, že na projekte A môže pracovať $x$ programátorov a na projekte B môže pracovať $y$ programátorov. Zároveň pre každého programátora vie, aké veľké skúsenosti má s technológiami na projekte A a na projekte B. Hodnoty skúseností pre $i$-teho programátora si označíme $a_i$ a $b_i$. Skúsenosť tímu, ktorý pracuje na projekte A je súčet hodnôt $a_i$ všetkých programátorov pracujúcich na tomto projekte. Analogicky, skúsenosť tímu pracujúceho na projekte B je súčet hodnôt $b_i$ všetkých programátorov, ktorí na ňom pracujú. Sysľovým cieľom je maximalizovať súčet skúseností oboch tímov, pričom jeden programátor môže pracovať iba na jednom projekte naraz. Povedané formálne, snažíme sa maximalizovať: $$\\sum\_{i \\in P_A} a_i + \\sum\_{i \\in P_B} b_i \\text{,}$$ pričom $P_A$ je množina programátorov pracujúcich na projekte A a $P_B$ je množina programátorov na projekte B.

## Formát vstupu

Na prvom riadku sa nachádzajú tri čísla $n$, $x$, $y$ -- celkový počet programátorov a počty programátorov, ktorí môžu pracovať na projekte A a na projekte B. Pritom platí: $x + y \\leq n$, $2 \\leq n \\leq 10^5$ a $x, y \\geq 1$.

Druhý riadok obsahuje čísla $a_1, \\dots, a_n$ ($1 \\leq a_i \\leq 10^9$), kde $a_i$ je skúsenosť $i$-teho programátora s technológiami používanými na projekte A.

Tretí riadok obsahuje čísla $b_1, \\dots, b_n$ ($1 \\leq b_i \\leq 10^9$), kde $b_i$ je skúsenosť $i$-teho programátora s technológiami na projekte B.

## Formát výstupu

Na výstupe sa nachádza jedno celé číslo -- maximálny možný súčet skúseností oboch tímov.

## Hodnotenie a obmedzenia

Pre jednotlivé sady testov navyše platia nasledovné obmedzenia. Za vyriešenie každej sady získate 2 body.

| číslo sady | obmezenie na $a_i$, $b_i$ | obmedzenie na $n$ | |:----------:|:--------------------------------|:--------------------------| | 1 | $1 \\leq a_i, b_i \\leq 1000$ | $2 \\leq n \\leq 10$ | | 2 | $1 \\leq a_i, b_i \\leq 10^9$ | $2 \\leq n \\leq 10^2$ | | 3 | $1 \\leq a_i, b_i \\leq 10^9$ | $2 \\leq n \\leq 10^3$ | | 4 | $1 \\leq a_i, b_i \\leq 10^9$ | $2 \\leq n \\leq 10^5$ |

## Príklady

```vstup
5 2 2
1 3 4 5 2
5 3 2 1 4
```

```vystup
18
```

_Syseľ priradí tretieho a štvrtého programátora na projekt A. Prvého a piateho priradí na projekt B. Druhého prepustí. Takto získa tím A s celkovou skúsenosťou $4+5 = 9$ a tím B s celkovou skúsenosťou $5+4 = 9$_

```vstup
4 2 2
10 8 8 3
10 7 9 4
```

```vystup
31
```

_Skúsenosť tímu A je $10+8 = 18$ a tímu B je $9+4 = 13$_

```vstup
5 3 1
5 2 5 1 7
6 3 1 6 3
```

```vystup
23
```
","# Organizácia projektov

Táto úloha sa dala riešiť viacerými spôsobmi. V tomto vzorovom riešení si postupne ukážeme tri rôzne prístupy, ktoré sa dali na riešenie použiť. Napriek tomu, že len jeden je dostatočne rýchly, každý z nich prináša iný pohľad na ten istý problém.

## Dynamické programovanie

V našej úlohe sa vlastne snažíme rozdeliť ľudí do troch skupín -- tím $A$, tím $B$ a skupinu, ktorú musíme prepustiť. Pri dynamickom programovaní sa snažíme rozdeliť problém na menšie podproblémy. Môžeme sa inšpirovať problémom batohu^\[knapsack -- <https://en.wikipedia.org/wiki/Knapsack_problem>\], kde sme sa snažili rozdeliť veci na dve kopy -- veci, ktoré dáme do batoha a veci, ktoré do batoha nedáme. Podproblémom bolo, že chceme nájsť optimálne riešenie pre prvých $i$ vecí a kapacitu batoha $j$.

V našom prípade by sme si mohli povedať, že chceme nájsť optimálne riešenie pre prvých $i$ programátorov, pričom v tíme $A$ sa z nich bude nachádzať $j$ programátorov a v tíme $B$ sa bude nachádzať $k$ programátorov. Označme si maximálny súčet skúseností oboch tímov pre takýto podproblém ako $P[i][j][k]$. Náš podproblém je jednoznačne určený trojicou čísel $(i,j,k)$.

Už sme si definovali, čo je náš podproblém a teraz nám už ostáva iba sa zamyslieť, ako vieme vypočítať nové riešenie z prechádzajúcich hodnôt. Zoberme si $i$-teho programátora. Kde sa môže tento programátor nachádzať v optimálnom riešení? Samozrejme, máme tri možnosti -- buď je v tíme $A$, v tíme $B$, alebo sa nenachádza v žiadnom tíme. Rozoberme si všetky tieto možnosti.

Nech sa nachádza v tíme $A$. Potom odobratím tohto programátora z tímu $A$ získame optimálne riešenie pre podproblém $(i-1, j-1, k)$. Prečo? Môžeme to dokázať sporom. Nech hodnota tohto riešenia je $r$. Predpokladajme, že toto nie je optimálne riešenie pre $(i-1, j-1, k)$, čiže $r < P[i-1][j-1][k]$. Potom vieme zobrať optimálne riešenie pre $(i-1, j-1, k)$ a pridať $i$-teho programátora do tímu $A$, čím dostaneme lepšie riešenie ako $P[i][j][k]$, lebo $P[i][j][k] = r + a_i < P[i-1][j-1][k] + a_i$. Tým sme sa však dostali do sporu. Čiže odobratím $i$-teho programátora sme museli nutne dostať riešenie s hodnotou $P[i-1][j-1][k]$. Tým pádom vieme povedať, že ak programátor $i$ skončí v tíme $A$, tak $P[i][j][k] = P[i-1][j-1][k] + a_i$.

Čo ak sa programátor $i$ nachádza v optimálnom riešení pre $(i, j, k)$ v tíme $B$? Potom ak ho odoberieme z tímu $B$, tak dostaneme optimálne riešenie pre podproblém $(i-1, j, k-1)$. Dôkaz je znova podobný tomu predchádzajúcemu. V takomto prípade bude platiť, že $P[i][j][k] = P[i-1][j][k-1] + b_i$.

Posledná možnosť je, že $i$-ty programátor sa nenachádza v žiadnom tíme. Potom platí,že toto riešenie je optimálnym riešením aj pre $(i-1, j, k)$, čiže $P[i][j][k] = P[i-1][j][k]$.

Ak si to zhrnieme, tak potom $P[i][j][k]$ vieme vypočítať ako maximum z troch hodnôt: $P[i-1][j-1][k] + a_i$, $P[i-1][j][k-1] + b_i$ a $P[i-1][j][k]$.

Ešte si musíme vyjasniť, ako inicializujeme pole `P[][][]`. Triviálnym prípadom je podproblém, keď máme $0$ programátorov. V takom prípade vieme inicializovať $P[0][0][0] = 0$. Ostatné hodnoty $P[0][j][k]$ inicializujeme na mínus nekonečno, lebo tieto prípady nemajú riešenie. Ak totiž máme nula programátorov, tak neviem mať v žiadnom tíme nenulový počet programátorov.

Časová zložitosť tohto riešenia je $O(n \\cdot x \\cdot y)$. Pamäťová zložitosť je tiež $O(n \\cdot x \\cdot y)$, ale dá sa zlepšiť, ak si všimneme, že na výpočet hodnoty $P[i][j][k]$ potrebujeme iba niekoľko políčok okolo a zvyšné môžeme zabudnúť.

## Párovanie a toky

Ďalší pohľad je grafový, využívajúci niekoľko pomerne štandardných algoritmov. Keďže toto riešenie stále nie je vzorové, tak tieto algoritmy nevysvetľujeme do podrobnosti. Ak ich teda nepoznáte, nič si z toho nerobte. Vo vzorovom riešení ich vôbec používať nebudeme.

Tento problém sa dá preformulovať aj ako problém maximálneho váhovaného párovania. Zostrojme si bipartitný graf. Vrcholy v prvej partícii zodpovedajú programátorom a vrcholy v druhej partícii zodpovedajú pozíciám v tíme. Teda prvá partícia má $n$ vrcholov a druhá $x+y$ vrcholov. Medzi každými dvoma vrcholmi z rôznych partícií vedie hrana, pričom ak máme hranu z $i$-teho programátora do $j$-tej pozície v tíme $A$, tak cena tejto hrany je $a_i$ a ak máme hranu do tímu $B$, tak cena tejto hrany je $b_i$. Na takýto graf potom vieme použiť niektorý z algoritmov na hľadanie maximálneho váhovaného párovania na bipartitnom grafe. Ani jeden však nebude dostatočne rýchly, keďže náš graf je pomerne veľký a hlavne obsahuje až $n(x+y)$ hrán.

Problém maximálneho párovania sa však dá preformulovať na problém maximálneho toku. Stačí nám pridať dva špeciálne vrcholy. Prvý vrchol bude pospájaný so všetkými vrcholmi v prvej partícii a druhý vrchol bude pospájaný so všetkými vrcholmi v druhej partícii. Prvý vrchol je zdroj (source) a druhý je odtok (sink). Kapacita každej hrany je jedna.

Môžeme si všimnúť, že v druhej partícii máme zbytočne veľa vrcholov. Všetky pozície v tíme $A$ predsa vieme skomprimovať do jedného vrchola a z tohto vrchola pridať hranu do odtoku s kapacitou $x$. A rovnako pre vrcholy patriace tímu $B$.

Na tomto grafe potom môžeme spustiť nejaký všeobecný algoritmus na hľadanie maximálneho toku s maximálnou cenou^\[<https://en.wikipedia.org/wiki/Minimum-cost_flow_problem>\]. Zmenšením druhej partície z $x+y$ na $2$ sme zmenšili počet hrán medzi týmito partíciami z $(x+y)n$ na $2n$, čím dostaneme lepšiu časovú zložitosť. Bohužiaľ, ani toto nestačí na vzorové riešenie.

## Vzorové riešenie

Vzorové riešenie je v podstate greedy algoritmus. Doteraz sme riešili o dosť všeobecnejšie problémy. Teraz budeme postupovať trocha ináč. Pozrieme sa na to, ako fungujú niektoré špeciálne prípady nášho problému.

Zamyslime sa nad prípadom, keď bude $y=0$. V tomto prípade sa nám oplatí utriediť programátorov podľa hodnoty $a_i$ zostupne a zobrať prvých $x$ programátorov.

Čo ak sa $y=1$? Nech máme znova utriedených programátorov podľa $a_i$. Potom sa nám môže oplatiť zobrať jedného z prvých $x$ programátorov a dať ich do tímu $B$ a doplniť programátora číslo $x+1$ do $A$. V opačnom prípade zoberieme prvých $x$ programátorov do tímu $A$ a zo zvyšku zoberieme programátora s najvyšším $b_i$ a dáme ho do tímu $B$.

Čo ak sa $y=2$? Určite vieme povedať, že prvých $x$ programátorov bude v tíme $A$ alebo $B$. Nechceme ich teda prepustiť. Vyberme prvého programátora do tímu $B$. Môže sa nám oplatiť zobrať niektorého z prvých $x$ programátorov (opäť usporiadaných podľa $a_i$). V takom prípade potrebujeme doplniť tím $A$, čo samozrejme spravíme $(x+1)$-vým programátorom. Ostáva ešte druhý človek do tímu $B$. A opäť to môže byť niekto z tímu $A$, alebo niekto úplne mimo. Ak je to niekto z $A$, tak tento tím doplníme $(x+2)$-hým programátorom.

Všimnime si nasledovný fakt: Ak si usporiadame všetkým programátorov podľa čísla $a_i$, tak v každom optimálnom riešení existuje taká hodnota $k$, že všetci programátori z tímu $A$ sú medzi prvými $k$ programátormi. Naviac vieme, že ak máme najmenšie také $k$, tak presne $k-x$ z týchto $k$ programátorov musíme umiestniť do tímu $B$ a zo zvyšných $n-k$ programátorov musíme umiestniť $y-(k-x)$ programátorov do tímu $B$. Otázkou ostáva, či pre zadané $k$ vieme efektívne vypočítať, ktorých programátorov kam umiestniť.

Z posledných $n-k$ programátorov chceme do tímu $B$ vybrať $y-(k-x)$ tých, ktorý majú najväčšiu hodnotu $b_i$. Musíme sa teda ešte zamyslieť, ako rozdeliť do tímov prvých $k$ programátorov. Predstavme si, že sme všetkých $k$ programátorov dali do tímu $A$. Čo sa stane, ak $i$-teho z nich presunieme do tímu $B$? Z tímu $A$ stratíme $a_i$ skúseností a do tímu $B$ pribudne $b_i$ skúseností. Takže celkový zisk/strata bude $b_i-a_i$. No a zjavne chceme presunúť tých $k-x$ programátorov, pri ktorých získame čo najviac, teda pre ktorých bude číslo $b_i-a_i$ čo najväčšie.

Nájsť optimálne riešenie teda vieme nasledovne: Programátorov si zoradíme podľa hodnoty $a_i$. Potom vyskúšame každú prípustnú hodnotu $k$, teda $x \\leq k \\leq x+y$. Pre dané $k$ vyberieme z prvých $k$ programátorov $k-x$ tých, ktorý majú najväčšiu hodnotu $b_i-a_i$ a týchto programátorov dáme do tímu $B$. Zvyšných z prvej $k$-tice dáme do tímu $A$. Následne z ostatných programátorov vyberieme $y-(k-x)$ programátorov s najvyšším $b_i$, ktorých zaradíme do tímu $B$. Pre každú hodnotu $k$ dostaneme nejaké riešeníe a optimálne bude to najlepšie z nich.

Ostáva už len navrhnúť rýchly algoritmus na zostrojenie tohto riešenia. V prvej časti spočítame pre každé $k$, koľko najviac vieme získať ak zoberieme prvých $k$ do tímu $A$ a následne $k-x$ z nich hodíme do tímu $B$. V druhej časti spočítame pre každé $k$ ako vieme najlepšie nahrabať zvyšných $y-(k-x)$ programátorov do tímu $B$. Aké dátové štruktúry budeme potrebovať? Aké operácie budeme často vykonávať? Pre oba problémy sa nám bude hodiť dátová štruktúra, ktorá dovolí efektívne vkladať hodnoty a vyberať najväčší prvok -- teda halda.

V prvej časti utriedime programátorov podľa $a_i$. Potom prechádzame cez takto utriedených programátorov a rátame si súčet $a_i$. V halde si udržiavame pre každého programátora v tíme $A$ držať rozdiel $b_i-a_i$. Chceme v nej teda mať najviac $x$ prvkov.

Postupne prechádzame programátorov, začínajúc od tých s najvyšším $a_i$. V každej iterácii priradíme ďalšieho programátor do tímu $A$ a jeho rozdiel vložíme do haldy. Ak máme v halde viac ako $x$ prvkov, tak vyberieme von programátora s najväčším rozdielom a preradíme ho do tímu $B$. Počítame si súčet rozdielov $b_i-a_i$ pre programátorov, ktorých sme vybrali z haldy a tiež si počítame súčet $\\sum\_{i=1}^{k} a_i$. Súčet rozdielov pre nejaké $k$ je náš zisk, ktorý dostaneme ak daných programátorov presunieme do tímu $B$. K tomuto číslu ešte môžeme pričítať $\\sum\_{i=1}^{k} a_i$. Toto dokopy tvorí súčet skúseností tímu $A$ a tímu $B$, ktorý sme doteraz dosiahli pre dané $k$.

V tomto čísle sa nenachádza súčet zvyšných $y-(k-x)$ programátorov, ktorých musím pridať do tímu $B$. Toto spočítame v druhej fáze. Aby sme tieto súčty spočítali, tak budeme iterovať cez programátorov odzadu v poradí v ako sa nachádzajú v utriedenom poli hodnôt $a_i$. Iterujeme od $i=n$ až po $i=x$. Tentokrát si v halde udržiavame hodnoty $b_i$. V každej iterácii pridáme novú hodnotu $b_i$. Ak $i < x+y$, tak vyberieme jedného programátora s najväčším $b_j$. Počítame si súčet $b_j$ pre vybratých programátorov. Všimnime si, že pre $k=x+y$ nevyberáme ešte žiadneho programátora. Pre $k=x+y-1$ však už potrebujeme do tímu $B$ doplniť jedného programátora a preto vyberieme toho s najväčším $b_i$. Súčet hodnôt $b_i$ vybranných programátorov korešponduje súčtu skúseností zvyšných $y-(k-x)$ programátorov, ktorých pridáme do tímu $B$.

Zhrňme si to na záver. V prvej fáze algoritmu sme počítali koľko skúseností získame ak zoberieme prvých $k$ programátorov a z nich $k-x$ s najväčším rozdielom $b_i-a_i$ dáme do $B$ a zvyšných $x$ dáme do $A$. V druhej fázi sme pre každé $k$ počítali, koľko skúseností vieme ešte navyše získať ak doplníme $y-(k-x)$ programátorov do tímu $B$. Ak sčítame súčet, ktorý sme dostali pre nejaké $k$ v prvej fáze sčítame s číslom, ktoré sme dostali v druhej fáze pre to isté $k$, tak dostaneme celkový najväčší súčet skúseností, ktorý vieme dostať pri rozdelení definovanom hodnotou $k$. Z týchto všetkých $k$ nám už ostáva iba vybrať to najlepšie.

Celková časová zložitosť nášho algoritmu je $O(n \\log n)$, lebo sme potrebovali triediť a používali sme haldu. Pamäťová zložitosť je $O(n)$.
",9
17917328220a902f,ksp,"﻿# Znova zašpinení programátori

*Zlé jazyky hovoria, že programátori sa neumývajú. Celé dni a noci vraj nerobia nič iné, iba sa aktívne vyhýbajú sprche. To ale vôbec nie je pravda! Kde sa nabrali také hrozné fámy? Programátori sú predsa čistotní!* Toto sme už počuli. Vieme, že vedci z Katedry Sprchovania a Plávania spravili [výskum](http://www.ksp.sk/ulohy/zadania/1039/)...

Adam tomu však neverí. Čo ak boli výsledky výskumu sfalšované? Na konci každého dňa mohol niekto gély preusporiadať tak, aby to vyzeralo, že sa programátori poctivo umývajú. Šandyna by rada obhájila nepošpinené meno programátorov, ale nemôže predsa striehnuť na ľudí v sprche. Preto je potrebné nájsť iný spôsob, ako odhaliť falšovanie výsledkov.

V sprche používanej $n$ programátormi je kopa sprchových gélov poukladaných jeden na druhom. Vždy, keď sa niekto sprchuje, vyberie svoj sprchový gél z kopy, čím sa všetky gély, ktoré boli nad ním, posunú nižšie. No a keď sa dosprchuje, položí svoj gél na samý vrch kopy. Každý programátor má v kope práve jeden vlastný sprchový gél, ktorý je označený tak, aby si ho nepomýlil. Zistili sme, že programátor sa môže sprchovať aj viackrát za deň.

Šandyna si zaznamenala, ako vyzeralo poradie gélov v kope na začiatku dňa, skôr, než sa ktokoľvek stihol osprchovať. Potom si v priebehu dňa zaznamenávala, v akom poradí programátori navštevovali sprchu. Na konci dňa chce Šandyna zistiť, ako by mala kopa vyzerať, ak nikto gély falošne nepreusporiadal.

## Úloha

Gély na začiatku dňa očíslujeme zhora nadol číslami od $1$ po $n$. Na vstupe dostanete postupnosť $m$ návštev jednotlivých programátorov. Každý programátor použije počas návštevy svoj gél. V sprche je v každom momente najviac jeden programátor, takže poradie vyberania a vkladania gélov je jednoznačné.

Zistite, ako by mala vyzerať postupnosť gélov na konci dňa.

## Formát vstupu

Prvý riadok vstupu obsahuje prirodzené čísla $n$ a $m$ udávajúce počet gélov a počet sprchovaní v daný deň. Platí, že $1 \\leq n, m \\leq 200,000$.

Na ďalšom riadku je postupnosť $m$ prirodzených čísel oddelených medzerami, pričom každé z nich je v rozsahu od $1$ po $n$. Sú to čísla gélov v poradí, v akom ich majitelia používali sprchu.

## Formát výstupu

Na jeden riadok vypíšte postupnosť čísel gélov na konci dňa v poradí zhora nadol. Čísla oddeľte medzerami a výstup ukončite znakom nového riadku. Za posledným číslom **ne**vypisujte zbytočnú medzeru.

## Príklad

```vstup
5 6
2 2 1 3 5 2
```

```vystup
2 5 3 1 4
```
","# Znova zašpinení programátori

Táto úloha sa dala riešiť viacerými spôsobmi. V tomto vzoráku si ukážeme jedno pomalé a dve rýchle riešenia.

## Naivná simulácia

Budeme robiť presne to, čo nám hovorí zadanie. V jednom poli si budeme pamätať, v akom poradí sú gély na kope a postupne budeme simulovať sprchovanie programátorov. Vždy, keď sa nejaký programátor osprchuje, nájdeme jeho gél v našom poli, všetky gély nad ním posunieme o jednu pozíciu nižšie a náš hľadaný gél dáme na samý vrch. Na konci vypíšeme poradie, v akom sú gély na kope. Pri implementácii si treba dať pozor na to, aby sme gély posúvali v dobrom poradí, inak sa nám môže stať, že si jedným gélom postupne prepíšeme celú posúvanú časť poľa.

### Zložitosť

Vždy, keď sa nejaký programátor osprchuje, budeme musieť posunúť všetky gély, ktoré sú v kope nad jeho gélom. V najhoršom prípade sa nám môže stať, že po každom sprchovaní budeme musieť posunúť všetkých $n$ gélov. Časová zložitosť je teda $O(mn)$, pamäťová zložitosť je $O(n)$.

## Spájaný zoznam

Opäť budeme celý dej simulovať, ale informáciu o kope si budeme pamätať trochu šikovnejšie. Namiesto toho, aby sme si pamätali poradie všetkých gélov, budeme si pre každý gél pamätať, ktorý gél je v kope hneď pod ním a ktorý gél je hneď nad ním (prípadne, že daný gél je na úplnom vrchu, alebo spodku kopy). K tomu si budeme navyše pamätať číslo gélu, ktorý je aktuálne na vrchu kopy. Všimnime si, že keď presúvame gél z nejakého miesta na vrch kopy, väčšine gélov sa susedia nezmenia. Konkrétne, ak chceme presunúť gél $A$, pričom nad ním bol gél $B$, pod ním bol gél $C$ a na vrchu kopy bol gél $D$, tak po presune pod gélom $B$ už nebude $A$, ale $C$, nad gélom $C$ bude gél $B$, nad gélom $D$ bude $A$ a gél $A$ bude na vrchu kopy, pričom pod ním bude gél $D$. Nič iné už v pamäti meniť nepotrebujeme.

Na konci vypíšeme gél, ktorý je na vrchu kopy, potom gél tesne pod ním, potom gél, ktorý bol pod ním atď., až kým neprídeme na spodok kopy.

Aby sme pri implementácii nemuseli špeciálne ošetrovať spodok a vrch kopy, môžeme urobiť nasledovný trik: na spodok aj na vrch kopy si pridáme po jednom virtuálnom géli (s číslami $0$ a $n+1$), s ktorými nikdy nebudeme hýbať. Vďaka tomu nikdy nebudeme musieť hýbať s gélami, ktoré sú na vrchu, alebo na spodku kopy. Potom si ani nebudeme musieť pamätať, ktorý gél je na vrchu skutočnej kopy, keďže to vždy bude gél tesne pod gélom $0$.

### Zložitosť

Na začiatku musíme nastaviť všetkým gélom susedov (v čase $O(n)$). Pri každom sprchovaní musíme zmeniť konštantne veľa premenných (dokopy v čase $O(m)$) a na konci musíme prejsť cez všetky gély a vypísať ich (v čase $O(n)$). Celková časová zložitosť je teda $O(m + n)$. Pamäťová zložitosť je $O(n)$

## Naspäť v čase

Nakoniec si ukážeme jedno riešenie, ktoré je myšlienkovo trochu náročnejšie, ale má jednoduchšiu implementáciu. Všimnime si, že ak sa programátor niekedy počas dňa osprchoval, potom všetci, ktorí sa sprchovali po ňom (presnejšie povedané, po tom, ako sa náš programátor osprchoval posledný raz), budú mať svoje gély v kope nad jeho gélom a všetci ostatní budú mať gély pod jeho gélom. Inými slovami, na konci bude na vrchu kopy gél programátora, ktorý sa sprchoval ako posledný. Pod ním bude gél programátora, ktorý sa sprchoval ako predposledný, atď.. Gély programátorov, ktorí sa nesprchovali, budú úplne na spodku kopy v rovnakom poradí, ako boli na začiatku.

Úlohu teda vyriešime nasledovne: budeme prechádzať zoznamom sprchovaní **v opačnom poradí**, ako bol na vstupe. Vždy, keď nájdeme nejakého programátora, ktorého sme ešte nevideli (teda sme našli posledné sprchovanie tohto programátora), vypíšeme jeho číslo. Keďže všetkých programátorov, ktorí sa sprchovali po ňom, sme už videli (a teda aj vypísali), tak sa nám nestane, že by sme niektoré číslo vypísali príliš skoro. Nakoniec ešte prejdeme všetky gély v poradí, v akom boli na začiatku (teda od $1$ do $n$) a vypíšeme tie, ktoré sme ešte nevypísali.

### Zložitosť

Musíme načítať a prejsť $m$-prvkový zoznam sprchovaní a potom ešte $n$-prvkový zoznam gélov. Časová zložitosť je teda $O(m + n)$. Potrebujeme si pamätať celý zoznam sprchovaní (lebo ho budeme prechádzať v opačnom poradí, ako bol na vstupe) a pre každého programátora si potrebujeme pamätať, či sme ho už videli (či sme už vypísali číslo jeho gélu). Preto aj pamäťová zložitosť je $O(m + n)$.
",2
4a564f0269b58241,ksp,"﻿# Zázračné platenie

Zygrov dlhoročný sen je navštíviť Švédsko. Dôkladne sa na to pripravuje: študuje históriu, učí sa jazyk^[Vedeli ste, že švédčina má 2 stredné rody?] a počúva škandinávske pesničky. Popri tom samozrejme pracuje (vo firme ""Vysávače a špagety, s.r.o.""), aby si zarobil peniaze na výlet.

Práca je ale náročná, a tak raz večer zaspal nad poviedkami o Pipi Dlhej Pančuche a ocitol sa v zázračnej švédskej dedinke s ešte zázračnejším spôsobom platenia.

Platenie sa líšilo tým, že ak máte za zmrzlinu zaplatiť napríklad $512$ eur, tak najprv podáte pokladníkovi $5$ eur, potom $1$ euro a nakoniec $2$ eurá (pozor na poradie!). Zygro bol samozrejme veľmi nadšený. Veď na kúpenie zmrzliny mu stačilo iba $8$ eur, čím ušetril $504$ eur. Celú noc preto behal po dedinke a zisťoval ceny jednotlivých výrobkov, aby zrátal, koľko peňazí dokáže ušetriť. Aj vo svojom sne je však veľmi unavený, a tak už nezvláda ani obyčajné odčítavanie. Keby tak na to mal program...

Pomôžete mu?

## Úloha

Máte dané celé nezáporné číslo $n$ -- cenu výrobku. Vašou úlohou je zistiť, koľko peňazí Zygro ušetrí, ak za výrobok zaplatí vyššie popísaným spôsobom.

## Formát vstupu

V prvom riadku vstupu je jediné číslo $n$ ($0 \\leq n \\leq 10^{18}$) udávajúce cenu. Všimnite si, že $n$ sa nezmestí do bežnej (32-bitovej) celočíselnej premennej. Pokiaľ programujete v Pascale, odporúčame vám použiť typ `int64`, v C++ typ `long long`.

## Formát výstupu

Vypíšte jeden riadok, na ktorom bude jediné číslo: množstvo peňazí, ktoré Zygro ušetrí.

## Príklady

```vstup
512
```

```vystup
504
```

*$512 - (5 + 1 + 2) = 512 - 8 = 504$*

```vstup
1000
```

```vystup
999
```

*$1000 - (1 + 0 + 0 + 0) = 1000 - 1 = 999$*
","# Zázračné platenie

Úloha je pomerne priamočiara -- je potrebné zrátať súčet cifier čísla na vstupe. Ako to spraviť? Na to existuje viacero rôznych prístupov a my si ukážeme dva z nich.

## Súčet cifier pomocou celočíselného delenia

Všimnime si, že poslednú cifru čísla $n$ vieme získať ako zvyšok po delení $10$ (operátor `%` v C++ a Pythone, `mod` v Pascale). Rovnako si všimnime, že celá časť čísla $n$ po delení $10$ (operátor `/` v C++, `//` v Python a `div` v Pascale) vyzerá ako pôvodné $n$, ale bez poslednej cifry. Zopakovaním tohto postupu sa vieme dostať aj ku predposlednej cifre čísla $n$. A potom k predpredposlednej. A tak ďalej.

Takýmto spôsobom vieme prejsť cez všetky cifry čísla $n$. Ak ich počas toho budeme aj sčítavať, tak získame náš želaný ciferný súčet -- $digits(n)$.

Časová zložitosť tohto prístupu je úmerná počtu cifier čísla $n$, čo je zhruba hodnota $\\log n$, preto dostávame zložitosť $O(\\log n)$. Pamäťová zložitosť je konštantná.

## Súčet cifier pomocou načítania čísla ako reťazca

Trikovejší spôsob, ako vyriešiť úlohu, je prečítať číslo na vstupe ako reťazec -- postupnosť znakov. Potom stačí každý znak skonvertovať na číslo a čísla ščítať. V jazyku Python sa toto robí obzvlášť pohodlne.
",2
f99bc0d8a09d8b9e,ksp,"# Lietajúce Taniere

Pozemšťanské Národné Múzeum v Sekulách vystavuje skutočný skvost: Najvzácnejšiu hlásku galaxie[^1]. Táto hláska je lokálny endemit -- nevyskytuje sa vo fonológií jazyka žiadnej inej planéty, a preto má obrovskú hodnotu. A práve preto bola v piatok cez obedovú prestávku ukradnutá rafinovaným páchateľom. Nie je ním nik iný, ako interstelárny kriminálnik Okáň Hruškový, prezývaný ""Bzučiak"". Samotná krádež bola pre neho hračkou, skutočná skúška jeho schopností nastáva až teraz: s ukradnutou hláskou sa musí dostať na najbližšiu matriku, kde si zmení meno na Okäň, čím zmätie agentov zákona, zahladí všetky stopy po svojej kriminálnej histórií a šťastný odíde do dôchodku. Samozrejme, poletí lietajúcim tanierom[^2].

Má to však háčik: Medzi Pozemšťanským Národným Múzeom v Sekulách a Sekulským Matričným Úradom nejde žiaden priamy let, preto musí Bzučiak prestúpiť na Hlavnej Tanierovej Stanici Sagittarius A.

Okrem toho je problémom, že galaktická polícia má agentov zákona všade. Normálne síce pre Bzučiaka žiaden problém nepredstavujú[^3], pokiaľ ale poletí rovnakým letom ako jeden z nich, môže sa s novým menom rozlúčiť.

Ako nový zamestnanec IT oddelenia galaktickej polície ste dostali časy odletov všetkých liniek, spolu s pridelenými financiami, za ktoré môžete nakúpiť niekoľkým policajtom letenky, aby ste Bzučiakovi znemožnili využitie týchto letov. Vašou úlohou je Bzučiakovi cestu čo najviac znepríjemniť, pokiaľ možno úplne znemožniť.

\[^1\]: Lokálne sa zaznačuje písenkom ä. \[^2\]: Nemýliť si s morským tanierom. \[^3\]: Dôvod, prečo Bzučiaka polícia nemôže chytiť mimo lietajúceho taniera, je úplne očividný a netreba ho vysvetľovať.

## Úloha

Máte dané časy odchodov všetkých $n$ letov z Národného Múzea do Tanierovej Stanice, ako aj ich dĺžku $d_a$, ktorá je, samozrejme, pre všetky rovnaká. Rovnako máte dané aj odchody všetkých $n$ letov z Tanierovej Stanice na Matričný Úrad, a ich dĺžku $d_b$. Máte peniaze na zablokovanie $k$ letov -- určte, v akom najneskoršom čase môžeme Bzučiaka prinútiť dostať sa na Matričný Úrad, respektíve či vieme Bzučiakovi v jeho dosiahnutí úplne zabrániť.

Bzučiak môže prestúpiť medzi dvoma letmi, pokiaľ čas príchodu prvého nie je vyšší ako čas odchodu druhého, pričom dĺžka letu je definovaná ako rozdiel v časoch jeho príchodu a odchodu.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú 4 celé čísla $n, d_a, d_b, k$ - počet letov na každej linke, dĺžky letov prvej a druhej linky, a počet lístkov, ktorý si môžeme dovoliť kúpiť, pričom vždy platí $1 \\leq d_a,d_b$ a $1 \\leq k \\leq 2n$.

Nasledujú dva riadky. Na prvom z nich je $n$ rôznych celých čísel $a_0$ až $a\_{n-1}$, ktoré označujú časy odchodov letov prvej linky. Na druhom z nich je $n$ rôznych celých čísel $b_0$ až $b\_{n-1}$, ktoré označujú časy odchodov letov druhej linky. Platí, že oba riadky sú zoradené vo vzostupnom poradí, a okrem toho všetky časy odletov $x$ spadajú do nasledovného rozmedzia: $1 \\leq x \\leq 10^{9}$.

## Formát výstupu

Na jediný riadok výstupu vypíšte jediné číslo -- najneskorší čas, v akom môžeme Bzučiaka donútiť doraziť do cieľovej zastávky. Pokiaľ je možné Bzučiakovi zabrániť v dosiahnutí cieľa úplne, vypíšte číslo $-1$. Nezabudnite na konci vypísať symbol konca riadku.

## Hodnotenie

Sú 4 sady vstupov:

- V prvej sade platí, že $1 \\leq n \\leq 100$, $d_a = d_b = 1$ a obe linky majú rovnaké časy odletov, teda $a_i = b_i$ pre všetky $0 \\leq i \\leq n-1$.
- V druhej sade platí, že $1 \\leq n \\leq 10,000$.
- V tretej sade platí, že $1 \\leq n \\leq 100,000$.
- V štvrtej sade platí, že $1 \\leq n \\leq 1,000,000$.

## Príklad

```vstup
4 3 5 3
1 2 3 6
6 7 8 9
```

```vystup
14
```

*Zablokujeme napríklad prvé tri lety z Národného Múzea. Bzučiak nebude mať inú možnosť, ako využiť ten posledný, s odchodom v čase 6. V Tanierovej Stanici bude v čase 9, stihne rýchlo nastúpiť na posledný let na Matričný Úrad, ktorý k nemu dorazí v čase 14. Alternatívne sme mohli zablokovať prvé tri lety druhej linky a dosiahnuť rovnaký výsledok.*

```vstup
6 2 1 4
1 3 5 7 9 11
3 4 5 6 10 13
```

```vystup
-1
```

*V tomto prípade vieme Bzučiaka od Matričného Úradu úplne odrezať, napríklad zablokovaním prvých dvoch letov z Národného Múzea a posledných dvoch letov z Tanierovej Stanice. Bzučiak odletí najskorším letom s odchodom v čase 5, v Tanierovej Stanici bude v čase 7, a nestíha už žiaden nezablokovaný let ďalej.*
","# Lietajúce taniere

Zamyslime sa, ktorými letmi sa Bzučiakovi oplatí letieť. Z Národného Múzea do Hlavnej Stanice sa mu určite oplatí letieť prvým neblokovaným letom. Teda pre nás nemá zmysel blokovať tieto lety, pokiaľ je nejaký skorší aj tak nezablokovaný. Takže jednoducho budeme blokovať niekoľko prvých letov prvej linky.

V prípade druhej linky to je podobne: Bzučiak určite nepoletí z Hlavnej Stanice na Matričný Úrad žiadnym letom po prvom neblokovanom. Zároveň ale, na rozdiel od prvej situácie, platí, že určite nepoletí takým letom, ktorý odlieta pred tým, ako priletí Bzučiakov prvý let (nie preto, že by sa to neoplatilo, ale preto, že je to jednoducho nemožné).

Teda všetky možné blokovania letov, aké sa nám teoreticky môžu oplatiť (majú potenciál viesť ku hľadanému optimálnemu výsledku), vyzerajú nasledovne: Zablokujeme $x$ prvých letov prvej linky, pričom $0 \\leq x \\leq k$ . Bzučiak poletí prvým neblokovaným letom, teda do Hlavnej Stanice doletí v čase $a_x + d_a$, respektíve ak $n \\leq x$, tak nepoletí vôbec, keďže sme zablokovali všetky lety na prvej linke. Ostáva nám $k-x$ letov, ktoré môžeme blokovať. Nemá zmysel blokovať lety druhej linky, ktoré odlietajú pred Bzučiakovym časom príchodu do hlavnej stanice. Zablokujeme teda prvých $k-x$ letov, ktoré z Hlavnej Stanice odlietajú v Bzučiakovom čase príchodu alebo neskôr. Opäť môže nastať možnosť, že $k-x$ je dosť na zablokovanie všetkých letov až po posledný. Ak nenastane, Bzučiak poletí letom číslo $y$, a do cieľa sa dostane v čase $b_y + d_b$.

Pre všetky možné hodnoty $x$ musíme nájsť najvyššie dosiahnuteľné $b_y + d_b$, prípadne či pre nejaké $x$ vieme dosiahnuť kompletné zablokovanie.

## Pomalé riešenie

Najzjavnejšie riešenie, ktoré nám môže napadnúť je postupne vyskúšať všetky možné počty zablokovaných letov prvej linky $x$, a pre každý nájsť riešenie. Jednoducho pre každý čas príchodu $a_x + d_a$ nájdeme v časoch odchodu druhej linky prvý let, ktorý neodlieta pred ním, posunieme sa o $k-x$ letov neskôr na nejaký let $b_y$, a pamätáme si výsledok $b_y + d_b$. Na konci vypíšeme z týchto výsledkov ten najvyšší, respektíve ak niekedy dosiahneme kompletné zablokovanie, tak môžeme hľadanie ihneď prerušiť a vypísať $-1$.

Časová zložitosť tohto riešenia môže byť $O(n^2)$, pokiaľ prvý let druhej linky, ktorý Bzučiak stíha, hľadáme lineárne, teda postupne od začiatku. Môžeme si trošku prilepšiť použitím binárneho vyhľadávania, čím zlepšíme zložitosť na $O(n \\cdot log(n))$. V oboch prípadoch pre každú možnú hodnotu $x$, ktorých určite nie je viac ako $2n$, hľadáme bod v usporiadanom poli, teda zložitosť je lineárna, vynásobená zložitosťou našeho hľadania. Posunúť sa po nájdení tohto letu o $k-x$ ďalej nám zaberie konštantný čas, keďže výstupom z hľadania je index nájdeného prvku, a k nemu jednoducho pripočítame $k-x$. Pamäťová zložitosť programu bude každopádne $O(n)$, keďže nám stačí pamätať si vstup a konštantné množstvo celočíselných premenných.

## Vzorové riešenie

Hľadanie, ktoré sme v pomalších riešeniach vylepšovali, môžeme zlepšiť ešte viac. Uvedomme si, že keď $x$ sa zvýši o $1$, tak čas príletu do Hlavnej Stanice sa určite nezníži. Teda nemusíme zakaždým prehľadávať celé pole odletov, ale stačí nám pokračovať tam, kde sme prestali (pretože vieme, že letíme neskorším letom, ako predtým, teda lety, ktoré sme nestihli predtým, určite nestihneme ani teraz). Postačí nám teda hľadať lineárne, no pamätať si vždy bod, kde sme naposledy prestali, a nabudúce pokračovať v hľadaní odtiaľ.

Toto nové hľadanie prejde najviac všetkými $n$ prvkami počas celého behu programu. Programu teda hľadanie celkovo zaberie najviac $n$ času, teda časová zložitosť bude $O(n+n) = O(n)$. Pamäťová zložitosť je rovnaká, ako v pomalších riešeniach - $O(n)$.
",4
40182f6a1143d7d6,ksp,"# Zábava musí byť

Pilný študent Slavo sa rozhodol dať si pauzu od každodenného kolobehu a vybral sa do zábavného parku. Zistil totiž, že tam budú mať aj jeho obľúbenú disciplínu -- strieľanie zo zbraní. Slavo je už starý harcovník, čo sa (aj) strieľania týka a je teda odhodlaný vyhrať akúkoľvek súťaž, čo sa tam bude organizovať.

Keď Slavo prišiel do parku, hneď sa zastavil pri tej najväčšej tabuli široko ďaleko:

<center>**Chceš byť ako kovboj z Divokého Západu? Vystrieľaj si výhru!**</center>

No, musíte uznať, že to^\[Až na toho **kovboj**-a.\] znie dosť dobre.

Vybral sa teda na strelnicu. Zistil, že sa strieľa z pušky a z brokovnice. S oboma už mal tú česť, takže v tom by problém nemal byť. Ba čo viac, všimol si, že vzdialenosť medzi jednotlivými terčmi je taká, že na jeden výstrel brokovnice dokáže trafiť aj dva terče vedľa seba. Už to len nedokašľať!

Terče na strelnici sú usporiadané zvláštnym spôsobom. Z pozície, odkiaľ sa strieľa, vidí strelec $n$ terčov umiestnených v pravidelných rozostupoch vedľa seba. Za každým z týchto terčov môže (ale nemusí) byť ešte niekoľko iných terčov, akoby v zástupe. Ich počet je strelcovi dopredu známy. Z vtáčej perspektívy to celé môže vyzerať napríklad takto:

Keď sa Slavo spýtal na pravidlá, dozvedel sa nasledovné:

- Terče sú labilné, teda pri zasiahnutí terču tento (tieto) padne^[Toto platí dupľom, keďže strieľa Slavo.] a odkryje sa ďalší za ním (ak tam ešte nejaký je).

- Strelec má k dispozícii neobmedzené množstvo nábojov do oboch zbraní a môže ich ľubovoľne kombinovať a striedať.

- Cieľom hry je zhodiť všetky terče na čo najmenej výstrelov.

Ako má Slavo skombinovať pušku s brokovnicou aby potreboval čo najmenej výstrelov? Kam strieľať čím? Chce vyhrať. Musí vyhrať. Chce byť ako z Divokého Západu. Pomôžte mu!

## Úloha

Pre dané počty terčov v jednotlivých zástupoch zistite, koľko výstrelov bude Slavo potrebovať, aby vyhral. Zaujíma nás teda najmenší možný počet výstrelov, na ktorý vie Slavo zasiahnuť (a zhodiť) všetky terče.

Predpokladajte, že **Slavo nikdy neminie cieľ**. Puškou vie trafiť ľubovoľný terč, na ktorý vidí (nezakrýva ho iný terč). Brokovnicou dokáže trafiť ľubovoľné dva terče stojace v susedných zástupoch (oba terče musí byť vidno).

## Formát vstupu

V prvom riadku je jedno celé číslo $n$ ($1 \\leq n \\leq 100,000$) -- počet radov terčov (teda počet terčov viditeľných na začiatku). Na ďalšom riadku je $n$ medzerou oddelených kladných celých čísel $1 \\leq t_i \\leq 10^9$ -- $i$-te číslo udáva počet terčov v $i$-tom rade (dokopy, vrátane toho terča, ktorý vidíme).

## Formát výstupu

Na výstup vypíšte jediné celé číslo -- počet výstrelov, ktoré Slavo vykoná pri najlepšej možnej stratégii.

Dávajte si pozor na veľkosť čísel, s ktorými pracujete. Všimnite si, že keď budete napríklad sčítavať čísla zo vstupu, výsledok sa vám nemusí zmestiť do 32-bitovej premennej. Odporúčame preto použiť `long long` v C++ a `Int64` v Pascale.

## Príklady

```vstup
3
1 6 1
```

```vystup
6
```

*Vstup predstavuje 3 rady terčov. V prvom a treťom rade je po jednom, v druhom rade je 6 terčov za sebou. Správna stratégia je napríklad vystreliť najprv puškou 4-krát do druhého radu a potom brokovnicou do prvých dvoch a druhých dvoch. Existujú aj iné, rovnako dobré stratégie.*

```vstup
5
5 1 8 5 5
```

```vystup
18
```

_Tento vstup zodpovedá obrázku v zadaní. Slavo strelí 8-krát puškou do stredného radu. Následne si vymení zbraň a 5-krát to brokovnicou napáli naraz na posledné dva rady. Zase si vymení zbraň, a 4-krát vystrelí na prvý rad. Nakoniec posledný krát vystrelí brokovnicou na prvý. Lepšie to nejde, no možností je opäť viac._

```vstup
6
1 5 5 5 5 3
```

```vystup
13
```
","# Zábava musí byť

Riešenie tejto úlohy sa síce dalo ľahko vymyslieť a aj ľahko a rýchlo naprogramovať, no dôležité bolo správne odargumentovať správnosť vášho riešenia.

### Nezáleží na poradí operácií

Zostreľovanie terčov si môžeme predstaviť ako zoznam operácií, v ktorom sa dá každá operácia zapísať ako `px` -- puška zostrelí jeden terč na pozícii $x$, alebo `bx` -- brokovnica zostrelí po jednom terči na pozíciách $x$ a $x+1$.

Pre každú pozíciu $1, 2, \\dots, n$ si môžeme spočítať, koľko výstrelov na ňu dopadne pri konkrétnom zozname operácií. Napríklad pri zozname `p1, b3, p4` dopadne po jednom výstrele na pozície 1, 3, dva výstrely na pozíciu 4 a žiadny výstrel na pozíciu 2.

Vďaka takémuto pohľadu na našu úlohu si môžeme uvedomiť, že ak v nejakom zozname preusporiadame poradie použitých operácií, na každú pozíciu dopadne stále rovnaký počet výstrelov ako pred preusporiadaním. Zoznamy operácií `p1, b3, p4` a napríklad `b3, p4, p1` budú mať teda rovnaký výsledný efekt.

Pri hľadaní riešenia nás teda **nebude zaujímať poradie operácií**, ale len to, koľkokrát musíme pozíciu $x$ zasiahnuť puškou a koľkokrát brokovnicou, teda len počet operácií `bx` a `px` pre každé $x$.

### Ako vymyslieť riešenie?

Puška zhodí v jednej operácii jeden terč, no brokovnica dva. Keďže chceme minimalizovať celkový počet použitých operácií, chceli by sme **čo najviackrát použiť brokovnicu** (a zasiahnuť tak dva terče naraz v čo najviac operáciách). Pri rozmiestňovaní výstrelov si ale musíme dať pozor, aby sme sa nepripravili o možnosť použiť brokovnicu.

Predstavme si, že na každej z pozícií $1,2,3,4$ stojí jeden terč. Všetky terče vieme zostreliť dvoma operáciami, napríklad `b1, b3`. Ak by sme ale brokovnicou strelili do stredu (použijeme `b2`), tak pri zostreľovaní zvyšných terčov nám už brokovnica nepomôže a potrebujeme aspoň 3 operácie (terče 1 a 4 zostrelíme puškou). Problém vznikol tým, že sme skupinku terčov vedľa seba (rozostavenie, ktoré sa dobre zostreľuje brokovnicou), rozdelili jednou *dierou* na dve skupinky, ktoré boli ďaleko od seba a už sa pre ne brokovnica nedala použiť.

Ako využiť potenciál brokovnice naplno? Ako dobrý nápad sa môže zdať, že budeme zostreľovať terče zľava doprava, pričom brokovnicou strieľame, kým sa dá (kým na pozícii $x$ aj $x+1$ sú terče) a ak sa náhodou minú terče na pozícii $x+1$ skôr ako terče na $x$, zvyšok terčov na $x$ zostrelíme puškou. Takto nikdy nevytvoríme žiadnu *dieru* navyše a použijeme brokovnicu čo najviackrát.

### Ako dokázať správnosť riešenia?

Naša predošlá úvaha nás síce doviedla k riešeniu, no vysvetlenie, prečo toto riešenie nájde minimálny počet operácií je trochu nejasné. Ukážeme si však, ako jasne dokázať, že riešenie je správne.

Ak na prvej pozícii stojí $k$ terčov, v ľubovoľnom (teda aj v tom najlepšom) zozname operácií, ktorý má zhodiť všetky terče, musí byť **práve** $k$ operácií, pri ktorých $x = 1$. Čo najviac z týchto terčov zostrelíme brokovnicou, a keď už brokovnicu nemôžeme použiť (lebo už nie sú terče na pozícii 2), zvyšok terčov zostrelíme puškou. Takto sa dostávame do stavu, kde na prvej pozícii nezostal žiadny terč, použili sme najmenší počet operácií, ktoré boli nutné na zostrelenie všetkých $k$ terčov na pozícii 1 a zároveň sme použili brokovnicu najviackrát ako sa dalo.

Dôležitý bod zamyslenia je, že síce sme použili brokovnicu najviackrát pri zostreľovaní terčov na prvej pozícii, no nemohli by sme dosiahnuť celkovo lepšie riešenie (celkovo väčší počet výstrelov brokovnicou a menší počet operácií), ak by sme na prvú pozíciu použili brokovnicu menejkrát? Nie. Ak by sme použili brokovnicu menejkrát, na zvyšných $n-1$ pozíciách by tak celkovo zostalo viac terčov ako v našom riešení. Na zostrelenie zvyšných terčov by tak bolo potrebných aspoň toľko operácií ako v našom riešení a tak vieme, že sa naše riešenie určite nedá zlepšiť.

Keďže na pozícii 1 už nezostáva žiadny terč, môžeme sa na našu úlohu pozrieť tak, ako keby sme ju riešili už len pre $n - 1$ terčov a použiť znova tú istú úvahu: Nech je na pozícii 2 $m$ terčov, potrebujeme aspoň $m$ operácií, čo najviac z nich chceme spraviť brokovnicou, atď.

### Implementácia po lopate

Postupne prechádzame rady terčov od $i=1$ po $i=n$: Pre rad $i$ použijeme brokovnicu kým sa dá (kým je v rade $i+1$ aspoň jeden terč), a potom dorazíme ostatné terče v rade $i$ puškou. Pokračujeme na ďalší rad. Toto sa dá implementovať jedným cyklom.

Časová zložitosť je teda lineárne závislá od počtu radov terčov a ničoho iného: $O(n)$.

Pamäťová zložitosť bude kvôli pamätaniu počtu terčov v jednotlivých radoch tiež: $O(n)$.

### Všímaj, že pamäť ušetriť môžeš!

Ešte raz si prečítajte predchádzajúci odsek. V každom momente sa pri výpočte pozeráme len na práve spracovávaný a nasledujúci rad terčov, teda nám stačí pamätať si len počty terčov v týchto dvoch radoch, čím dostávame konštantnú pamäťovú zložitosť: $O(1)$.

### Iné riešenie(a)

Optimálnych riešení tu je viac (keďže nezáleží na poradí operácií). Napr. by bolo rovnako správne najprv všetko čo sa dá postrieľať brokovnicou a potom všetko ostatné doraziť puškou. Toto by však nešlo s konštantnou pamäťovou zložitosťou.
",1
d5864d0adb1ba357,ksp,"# Abnormálne Veľký Hotel

## Úloha

Prideľovač^[Ujo, ktorého úlohou je ubytovávať a odubytovávať hostí] pracuje v hoteli s $n$ izbami číslovanými od $0$ po $n - 1$ vrátane.

Prideľovač dostáva dva druhy požiadaviek:

- check-in požiadavky, ktoré obsahujú číslo $x$ -- počet miestností potrebný pre skupinu hostí. Prideľovač týchto hostí ubytuje do $x$ po sebe idúcich voľných izieb. Prideľovač vždy vyberie taký usek izieb, ktorý minimalizuje minimálne číslo izby zo všetkých čísel izieb v úseku.
- check-out požiadavky, ktoré obsahujú číslo $i$ -- index skoršej check-in požiadavky. Check-in požiadavky indexujeme od $0$ a do indexovania nerátame check-out požiadavky. Skupina hostí ubytovaná v $i$-tej check-in požiadavke uvoľní svoje miestnosti a opustí hotel.

Je zaručené, že Prideľovač bude schopný naplniť všetky požiadavky.

Vašou úlohou je vypísať pre každú check-in požiadavku číslo najmenšej izby z úseku miestností pridelených skupine hostí.

## Formát vstupu

Na prvom riadku vstupu sú dve medzerou oddelené prirodzené čísla $n$, $q$ -- počet izieb v hoteli a počet požiadaviek.

Nasleduje $q$ riadkov. Každý riadok obsahuje jednu požiadavku. Check-in požiadavky majú tvar `I x`, $x$ -- počet miestností potrebný pre skupinu hostí. Check-out požiadavky majú tvar `O i`, $i$ -- index skoršej check-in požiadavky.

## Formát výstupu

Pre každú check-in požiadavku vypíšte na jeden riadok jediné číslo -- číslo najmenšej izby z úseku miestností pridelených skupine hostí.

## Hodnotenie

Sú 4 sady vstupov po 2 bodoch. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :----------------| -----: | -------: | ---------: | ---------: | | $1 \\leq n\\ \\leq$ | $10^3$ | $10^9$ | $10^9$ | $10^{18}$ | | $1 \\leq q\\ \\leq$ | $10$ | $5,000$ | $300,000$ | $600,000$ |

## Príklad

```vstup
9 7
I 3
I 3
O 0
I 2
I 2
I 1
I 1
```

```vystup
0
3
0
6
2
8
```

_Reprezentujme hotel stringov znakov, kde i-ty znak reprezentuje stav i-tej izby. Spočiatku je hotel prázdny `---------`. Príde skupina troch hostí `000------`. Príde ďaľšia skupina troch hostí `000111---`. Odubytuje sa skupina hostí 0 `---111---`. Príde skupina 2 hostí `22-111---` a na to ďaľšia `22-11133-`. Nakoniec príde jeden človek `22411133-` a za ním ďalší `224111335`._
","# Abnormálne Veľký Hotel {bodypopis=12 bodyprogram=8}

## Brute-force riešenie

Táto úloha má pomerne jednoduché bruteforce riešenie, ktoré stačí na polovicu bodov. Stačí simulovať proces prichádzania a odchádzania ľudí a udržiavať si pri tom dve informácie:

- Pole intervalov voľných izieb. Na začiatku behu obsahuje interval $\[0, n)$.

- Pole intervalov priradených izieb, v ktorom si pre každú skupinu pamätáme priradené izby, nech ich vieme odubytovať, keď na to príde čas. Na začiatku je prázdne. Počas behu `pole_i` obsahuje interval, ktorý bol priradený $i$-tej skupine.

Keď príde check-in požiadavka, lineárne prejdeme pole obsahujúce úseky voľných izieb a nájdeme taký úsek, ktorý je dosť dlhý na ubytovanie celej skupiny a zároven je najviac vľavo. Do nájdeného úseku ubytujeme hostí a vymažeme ho zo zoznamu voľných úsekov. Je však možné, že nájdený úsek bol dlhší než bolo nutné. V takom prípade pridáme naspäť do zoznamu nepoužitú časť úseku. Na záver vložíme na koniec poľa priradených intervalov izieb interval, ktorý sme priradili novej skupinke.

Keď príde check-out požiadavka, nazrieme do pola priradených izieb na korešpondujúci index. Tieto izby chceme uvoľniť, čo znamená, že ich chceme vložiť naspäť do poľa voľných úsekov izieb. Avšak, nemôžme tento úsek len tak vložiť naspäť do zoznamu voľných, lebo je možne, že existujú ďalšie izby v zozname voľných tesne pred/za naším úsekom. Napríklad, može sa stať, že pole voľných úsekov aktuálne obsahuje úseky $\[0, 3)$ a $\[4, 7)$ a úsek, ktorý sa snažíme vložiť je $\[3, 4)$. Za takých okolností najprv vymažeme úseky $\[0, 3)$ a $\[4, 7)$ zo zoznamu voľných úsekov, a potom vložíme dnu $\[0, 7)$. Inými slovami, vymažeme voľné susediace úseky a potom vložíme naspäť úsek, ktorý je zlúčením úseku patriaceho skupinke z check-out požiadavky a okolitých voľných úsekov.

Pre každú požiadavku robíme viacero lineárnych prehľadávaní a mazaní na poli obsahujúcom intervaly voľných izieb. Týchto intervalov je $O(q)$, lebo po každej check-out požiadavke nám mohol pribudnúť interval do zoznamu. Po check-in požiadavke ostala dĺžka zoznamu v najhoršom prípade rovnaká. Celková časová zložitosť je teda $O(q^2)$, lebo je $O(q)$ požiadaviek a na každú odpovieme v $O(q)$ čase. Pamäťová zložitosť je $O(q)$, lebo ako sme spomínali, dĺžka pola voľných izieb je $O(q)$ a dĺžka pola priradených izieb je tiež $O(q)$, lebo aspoň polovica požiadaviek sú check-in požiadavky.

## Vzorové riešenie

Vzorové riešenie sa od spomenutého brute-force riešenia líši len tým, ako si ukladáme voľné úseky. Brute-force riešenie je pomalé, lebo mu trvá lineárne dlho robiť operácie, ako napríklad hladať najľavejší dostatočne dlhý úsek izieb, mazať úseky izieb a hľadať susediace úseky izieb. Tieto operácie vieme všetky naimplementovať v logaritmickej zložitosti a to tak, že použijeme binárny vyhľadávací strom, napríklad [treap](https://www.ksp.sk/kucharka/treap/).

Majme teda treap voľných úsekov. Keď chceme mazať úseky izieb, je to jednoduché, lebo mazať z treapu sa dá v logaritmickom čase. Rovnako nájsť susediace úseky, v prípade, že kontrolujeme či je treba zjednocovať počas check-outu, je logaritmické, lebo treapy podporujú rýchle hľadanie najmenšieho väčšieho a najväčšieho menšieho prvku než je daný prvok.

Jediná operácia, ktorú treba domyslieť, je hľadanie najľavejšieho úseku dĺžky aspoň $L$. To dokážeme tak, náš treap upravíme, nech si každý vrchol pamätá okrem svojho intervalu aj dĺžku najdlhšieho intervalu vo svojom podstrome. Nájsť najľavejší úsek dĺžky aspoň $L$ vieme nasledovnou rekurziou z koreňa treapu:

- Ak má môj ľavý podstrom dosť dlhý úsek, rekurzívne ho nájdem a vrátim ho -- existuje dobrý úsek a dokonca existuje dobrý úsek vľavo, čo je to, čo chceme.

- Ak môj úsek je dosť dlhý, vrátim ho -- lebo už viem, že vľavo nič nie je a lepšie vrátiť svoj úsek než úsek sprava.

- Rekurzívne nájdem úsek v pravom podstrome -- musí tam byť, lebo viem že v mojom podstrome existuje dlhý úsek a viem že nie je ani vľavo, ani vo mne.

Posledná otázka, ktorú treba zodpovedať, je ako rátať pre každý podstrom dĺžku najdlhšieho úseku. Toto je relatívne triviálne, lebo stačí upraviť funckie treapu `split`, `merge`, `insert` a `erase` nech počas toho, ako manipulujú stromom prerátavajú hodnotu vo svojom vrchole z hodnôt vo svojom ľavom a pravom synovi a dĺžky svojho úseku.

Použitím treapu vieme všetky operácie potrebné na zodpovedanie jednej požiadavky spraviť v $O(\\log q)$, a teda celková časová zložitosť je $O(q \\cdot \\log q)$. Pamäťová zložitosť je stále $O(q)$.

## Riešenie intervaláčom

Existuje aj riešenie, ktoré stačí na 6 bodov, ktoré používa dynamický [lazy](https://www.ksp.sk/kucharka/lazy_intervalovy_strom/) [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/). Takéto riešenie sa dá často použiť a je dobré ho poznať. V každom vrchole stromu si pamätáme najdlhší voľný interval v podstrome vrcholu, plus počet po sebe idúcich voľných izieb od ľavého konca (prefix) a od pravého konca (sufix). Keď máme tieto informácie pre ľavý a pravý podstrom, vieme ich zrátať aj pre ich rodiča:

- Najdlhší voľný interval môže byť buď najdlhší voľný interval z ľavého podstromu alebo z pravého, alebo to môže byť kombinácia sufixu ľavého vrcholu a prefixu pravého vrcholu.
- Prefix intervalu je rovnaký ako prefix ľavého intervalu, okrem prípadu, kedy je prefix ľavého intervalu rovnako veľký ako celý ľavý interval (čo znamená, že celý ľavý interval je voľný). V takom prípade je prefix celého intervalu zlúčením ľavého intervalu s prefixom pravého intervalu.
- Sufix intervalu sa ráta podobne ako prefix.

Ak použijeme dynamickú alokáciu vrcholov na to, aby sme vytvorili iba tie časti stromu, ktoré sú potrebné, tak vieme dosiahnuť časovú zložitosť $O(q \\cdot \\log n)$, čo je trochu horšie, než vzorové riešenie. Trochu vačším problémom je však pamäťová zložitosť, ktorá je tiež $O(q \\cdot \\log n)$, čo je príliš veľa na poslednú sadu vstupov.

## Program

Riešenie treapom:

Riešenie intervaláčom:

Brute-force riešenie:
",10
a54856bd1feeab76,ksp,"# Dobrý recept

Jedno z najvýnosnejších čokoládových obchodných partnerstiev je medzi FKS (Francúzski Kuchári Sladkostí) a KMS (Konfederácia Maškrtných Spoločností) -- tri čokolády od FKSákov sú medzi KMSákmi veľmi obľúbené. Táto zlatá baňa však neunikla pozornosti KSP (Komora Slovenských Pekárov), a tak sa na poslednom zasadnutí rozhodli, že do budúceho roku vyvinú novú čokoládu, ktorou by mohli FKS konkurovať.

Bolo im však jasné, že na to, aby ich čokoláda zožala úspech, nesmie chutiť príliš podobne ako niektorá čokoláda, ktorú pre KMS dodávajú FKS (vďaka obchodnému partnerstvu majú totiž výhodné ceny). Rozhodli sa teda, že ich nová čokoláda musí mať rovnaký chuťový rozdiel od všetkých troch FKS čokolád.

Každá čokoláda na svete sa dá popísať ingredienciami, ktoré sa použivajú na jej prípravu. Chuť čokolády závisí len na jej ingredienciách -- teda rozdiel chutí dvoch čokolád je jednoducho počet ingrediencií, v ktorých sa čokolády líšia.

KSP teraz zaujíma koľko rôznych receptov na čokoládu by malo šancu na úspech.

## Úloha

Na svete existuje $n$ ingrediencií, ktoré sa môžu použiť na prípravu čokolády. Recept na čokoládu je teda reťazec dĺžky $n$, kde $i$-ty znak je `1` alebo `0`, podľa toho, či čokoláda $i$-tu ingredienciu obsahuje, alebo nie. Pre účely tejto úlohy budeme za recepty na čokoládu považovať všetky takéto reťazce (vrátane reťazca tvoreného samými nulami). Rozdiel chutí dvoch čokolád je počet takých ingrediencií, že jedna z čokolád ju obsahuje, ale druhá nie.

Zistite, koľko rôznych receptov na čokoládu má rovnaký rozdiel chutí od všetkých troch FKS čokolád.

## Formát vstupu

V prvom riadku je celé číslo $n$ ($1 \\leq n \\leq 3\\cdot 10^5$) -- počet ingrediencií použiteľných na prípravu čokolády.

Nasledujú tri binárne reťazce dĺžky $n$, každý na samostatnom riadku -- recepty FKS čokolád.

Je osem sád testovacích vstupov. Maximálne hodnoty $n$ v jednotlivých sadách sú nasledovné:

| číslo sady | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | |:----------:|:---:|:---:|:---:|:-----:|:------:|:------:|:------:|:------:| | $n \\leq$ | $15$ | $30$ | $60$ | $1,000$ | $5,000$ | $100,000$ | $200,000$ | $300,000$ |

Navyše, na získanie plného počtu za popis *stačí* riešenie s časovou zložitosťou $O(n \\log n)$. Za dobrý popis s lepšou zložitosťou je možné získať (najviac dva) bonusové body.

## Formát výstupu

Nájdite počet čokolád, ktorých rozdiel chutí je rovnaký od všetkých troch FKS čokolád. Keďže tento počet môže byť veľmi veľký, vypíšte jeho zvyšok po delení veľkým prvočíslom $p$.

Vo všetkých vstupoch bude platiť, že $p = 1,000,000,007$, avšak pri odhade časovej zložitosti toto číslo nepovažujte za konštantu. Môžete predpokladať, že $n$ je rádovo menej ako $p$, avšak nie príliš menej. Riešenie so zložitošťou $O(n)$ je teda oveľa lepšie ako riešenie so zložitosťou $O(p)$. Dokonca aj $O(n^{10})$ je stále lepšie ako $O(p)$. Na druhú stranu môžete predpokladať, že $O(\\log p) = O(\\log n)$, resp. že rozdiel medzi $n$ a $p$ je nanajvýš polynomiálny.^[$O(\\log(n^{100})) = O(100 \\log n)= O(\\log n)$] Pri popise riešenia môžete predpokladať, že $p$ je prvočíslo.

## Príklady

```vstup
3
101
110
000
```

```vystup
2
```

_Jednou možnosťou je použiť len prvú ingredienciu. Druhou je použiť práve druhú a tretiu._

```vstup
6
111111
000000
101110
```

```vystup
12
```
","# Dobrý recept

## Stará dobrá hrubá sila

Ako inak -- úloha sa dá riešiť aj hrubou silou. Chceme vedieť koľko receptov čokolád má rovnaký rozdiel chutí od tých troch na vstupe. Keďže každý recept je binárny reťazec dĺžky $n$, možných receptov je $2^n$. Pre daný recept vieme v lineárnom čase spočítať chuťový rozdiel od každej čokolády na vstupe a keď nám tento rozdiel vyjde rovnaký pre všetky tri čokolády, pripočítame k odpovedi $1$.

Ostáva nám už len vygenerovať všetky binárne reťazce dĺžky $n$ čo najpohodlnejšie -- napríklad použiť bitovú reprezentáciu čísel; prejdeme všetky čísla od $0$ po $2^n - 1$, pričom recept bude posledných $n$ bitov tohto čísla.

Stačí si nám pamätať reťazce zo vstupu a pár konštantných premenných, pamäťová zložitosť teda bude $O(n)$. Ako sme už spomínali, skúšame $2^n$ receptov a pre každý spočítame jeho rozdiel chutí od troch čokolád v lineárnom čase, teda časová zložitosť je $O(n2^n)$.

## Dynamické programovanie

Úlohu si môžeme zovšeobecniť. Namiesto toho, aby sme hľadali počet receptov, ktoré sa od každej čokolády líšia rovnako, pre každú trojicu $a,b,c$ spočítame koľko receptov sa líši od prvej čokolády na $a$ pozíciách, od druhej na $b$ pozíciách a od tretej na $c$ pozíciách. Navyše tieto hodnoty postupne spočítame pre $n$ prípadov: čo keby sme uvažovali len recepty dĺžky $i$ a porovnávali ich len s prvými $i$ ingredienciami? Počet reťazcov dĺžky $i$, ktoré sa od reťazcov na vstupe líšia postupne na $a$,$b$,$c$ z prvých $i$ pozícií, označíme $P[i,a,b,c]$.

Vyzerá to, že sme si veľmi nepomohli, lebo teraz musíme spočítať $O(n^4)$ hodnôt namiesto jednej. No opak je pravdou, pretože tieto hodnoty ľahko spočítame pomocou techniky *dynamického programovania*.

Pre $i = 0$ máme len jednu možnosť, ako môže reťazec vyzerať, a tento reťazec sa na žiadnej z $0$ pozícií od žiadnej z troch čokolád chuťovo nelíši. Takže $P[0,0,0,0] = 1$ a $P[0,a,b,c] = 0$ pre ostatné hodnoty $a,b,c$.

Teraz si ukážeme, ako spočítať $P[i,a,b,c]$ pre $i>0$, ak už poznáme hodnoty $P[,]$ pre $i-1$. Pozrime sa na $i$ tu ingredicenciu. Nech $a_i,b_i,c_i$ sú postupne $i$-te znaky (0 alebo 1) reťazcov na vstupe. Keď zoberieme ľubovoľný reťazec dĺžky $i-1$, ktorý sa od vstupných troch reťazcov odlišuje postupne na $a, b, c$ pozíciách, a pridáme na koniec nulu, bude sa od reťazcov líšiť na $a + a_i$, $b + b_i$ a $c + c_i$ pozíciách. Keby sme na koniec pridali jednotku, bude sa odlišovať na $a + (1 - a_i)$, $b

- (1 - b_i)$ a $c + (1 - c_i)$ pozíciách. Preto

$$P[i,a,b,c] = P[i-1,a-a_i,b-b_i,c-c_i] + P[i-1,a- (1-a_i),b - (1 -b_i),c - (1 -c_i)]$$

Všimnite si, že súčet hodnôt $P[i,a,b,c]$ pre všetky možné $a,b,c$ je $2^i$, čo je práve počet binárnych reťazcov dĺžky $i$.

Týmto výrazom dokážeme spočítať všetky hodnoty $P$ a na konci už len sčítame počet spôsobov, ktorými vieme získať recepty dĺžky $n$ s rozdielmi chutí $k$ od všetkých troch čokolád pre $0 \\leq k \\leq n$. Čiže postupne sčítame $P[n,k,k,k]$ pre všetky $k$.

Výpočet každej z $O(n^4)$ hodnôt nám trvá konštantne dlho, takže časová zložitosť je $O(n^4)$.

Pamätáme si všetkých $O(n^4)$ hodnôt, taká je teda pamäťová zložitosť. Ak si všimneme že pre odpovede na dĺžku receptov $i+1$ nás už zaujímajú len odpovede pre dĺžku $i$, môžeme si vždy pamätať len odpovede pre poslednú vypočítanú dĺžku a tú, ktorú práve počítame. Tým by sme sa zlepšili na $O(n^3)$.

## Myšlienka vzorového riešenia

Dôležité je všimnúť si, že na poradí ingrediencií vôbec nezáleží a jediné dôležité sú tieto štyri počty:

- počet ingrediencií, v ktorých sú druhá a tretia čokoláda rovnaké, ale odlišné od prvej
- počet ingrediencií, v ktorých sú prvá a tretia čokoláda rovnaké, ale odlišné od druhej
- počet ingrediencií, v ktorých sú prvá a druhá čokoláda rovnaké, ale odlišné od tretej
- počet ingrediencií, v ktorých sú všetky tri čokolády rovnaké

Tieto typy pozícií si postupne označíme pozície typu A, typu B, typu C a typu D. (Žiadne iné typy ingrediencií nie sú.) Počty týchto pozícií si označíme postupne $A,B,C,D$. Riešenie úlohy závisí len od týchto štyroch čísel, akonáhle ich poznáme, môžeme samotné recepty čokolád zabudnúť. Taktiež nie je dôležité, v akom poradí boli čokolády na vstupe uvedené, takže si čísla $A,B,C$ môžeme poprehadzovať, tak aby platilo $A\\leq B\\leq C$. Toto preusporiadanie nám zjednoduší riešenie, lebo nebudeme musieť rozoberať veľa prípadov.

Každý možný výsledný recept $R$ je charakterizovaný štyrmi číslami

- $a$ je počet pozícií typu A, na ktorých sa $R$ líši od prvého reťazca
- $b$ je počet pozícií typu B, na ktorých sa $R$ líši od druhého reťazca
- $c$ je počet pozícií typu C, na ktorých sa $R$ líši od tretieho reťazca
- $d$ je počet pozícií typu D, na ktorých sa $R$ líši od všetkých reťazcov

Pozor, $a,b,c$ v tejto časti znamenajú niečo úplne iné ako $a,b,c$ v časti o dynamickom programovaní.

Pomocou čísel $a,b,c,d$ vieme presne vyjadriť, na koľkých miestach sa líši $R$ od jednotlivých reťazcov. Napríklad od prvého reťazca sa líši na $a + (B-b) + (C-c) + d$ pozíciách. Aby sa náš recept líšil na rovnako veľa pozíciách aj od druhého reťazca, musí platiť, že toto číslo je rovné $(A-a) + b + (C-c) + d$. Čiže $b - a = (B-A)/2$. Podobne zistíme, že $c - a = (C-A)/2$.

To okrem iného znamená, že ak čísla $A,B,C$ nemajú rovnakú paritu, tak odpoveď na riešenie úlohy je 0. V opačnom prípade vieme, že rozdiel $b-a$ a $c-a$ je konštantný, takže hodnoty $b$ a $c$ sú určené hodnotou $a$. Na hodnote $d$ nezáleží, takže na pozíciách typu $D$ môže mať náš reťazec hocičo.

Pre spočítanie odpovede nám teda stačí pre každé $a$, $0\\leq a\\leq A$ zistiť, koľko existuje binárnych reťazcov dĺžky $n$, ktorých počty jednotiek na jednotlivých typoch pozícií sú $a$ pre typ A, $a + (B-A)/2$ pre typ B, $a + (C-A)/2$ pre typ C a hocikoľko pre typ $D$.

Pre konkrétne $a$ je tento počet $2^D\\binom{A}{a}\\binom{B}{a+(B-A)/2}\\binom{C}{a + (C-A)/2}$. Pričom $\\binom{n}{m}$ označuje ""koľkými možnosťami vieme vybrať $m$ prvkov z $n$ prvkovej množiny"", čoho hodnota je $\\frac{n!}{m!(n-m)!}$.

Celé riešenie úlohy je $$2^D\\sum\_{a=0}^{A}{\\binom{A}{a}\\binom{B}{a+(B-A)/2}\\binom{C}{a + (C-A)/2}}\\text{.}$$

A zostáva nám už len zistiť, ako čo najrýchlejšie spočítať túto sumu. Opäť si všimnite, že odpoveď závisí len od čísel $A,B,C,D$, ako sme spomínali na začiatku.

Odporúčame dať si na tomto mieste krátku pauzu a napiť sa vody.

Ako krátke intermezzo spomenieme, že spôsobov ako riešiť túto úlohu vzorovo je viacero a väčšina z nich eventuálne skončí tak, že chceme spočítať nejakú sumu, v ktorej nejako vystupujú kombinačné čísla (to sú tie zvieratká typu $\\binom{n}{m}$). Podľa toho, ako rýchlo dokážeme spočítať túto sumu rozlišujeme tri hlavné riešenia.

## Pomalé kombinačné čísla

Najjednoduchší spôsob ako spočítať sumu je, skonštruovať si prvých $C$ riadkov Pascalovho trojuholníka. V ňom sa nachádzajú všetky kombinačné čísla, ktoré v sume potrebujeme, takže samotnú sumu spočítame v čase $O(n)$. Spočítanie Pascalovho trojuholníka nám však zaberie čas $O(n^2)$.

## Modulárne umocňovanie

Už sme spomínali, že kombinačné číslo ${n \\choose m}$ sa rovná $\\frac{n!}{(n-m)!m!}$. Faktoriály vyriešime ľahko, tie si vieme na začiatku predpočítať v čase $O(n)$. Problém však robí delenie modulo $p$. Pre ilustráciu aké ťažké je deliť, môžete skúsiť zhlavy spočítať, koľko je $7$ deleno $13$ modulo $10^9+7$? (Je to $76923078$.) Namiesto delenia preto budeme násobiť inverzným prvkom. Náš prípad, pre $p = 10^9+7$, by vyzeral takto: $7/13 \\equiv 7\\cdot 13^{-1} \\equiv 7\\cdot 13^{p-2} \\equiv 7\\cdot 153846155 \\equiv 76923078 \\pmod p$. Pre overenie spočítame, že $13\\cdot 76923078 \\equiv 1000000014 \\equiv 7 \\pmod p$. Viac sa môžete dočítať v článku o [modulárnom umocňovaní a inverzných prvkoch](https://www.ksp.sk/kucharka/modularna_aritmetika).

Pre nás je dôležité, že inverzný prvok vieme spočítať v čase $O(\\log p)$. Inverzný prvok potrebujeme poznať pre každý faktoriál, takže dokopy je to $O(n\\log p)$ času, čo podľa podmienky v zadaní je $O(n\\log n)$.

Po tom, ako si rozpíšeme kombinačné čísla na faktoriály, dokážeme celú sumu napísať v tvare $\\sum\_{a=0}^{A}{\\left(\\frac{x_a}{y_a}\\right)}$. Ak si dopredu predpočítame hodnotu faktoriálov od $1!$ po $n!$ modulo $p$, dokážeme vypočítať každú z hodnôt $x_a$, $y_a$ v konštantnom čase.

Teraz si ukážeme všeobecný algoritmus, ktorý dokáže takúto sumu v tvare $\\sum\_{i=0}^{n}{\\frac{x_i}{y_i}}$ spočítať modulo ľubovoľné prvočíslo v čase $O(n)$. Tým vlastne dostaneme vzorové riešenie celej úlohy v čase $O(n)$. Kľúčom k riešeniu je, že chceme počítať inverzný prvok len raz (pretože ak by sme ho počítali $n$-krát, trvalo by nám to $O(n\\log n)$ času). Preto si sumu prevedieme na spoločný menovateľ čím dostaneme $$\\frac{x_1y_2\\cdots y_n + x_2y_1y_3\\cdots y_n + \\cdots + x_ny_1\\cdots y\_{n-1}}{y_1\\cdots y_n}$$

Už máme síce len jedno delenie, ale potrebujeme spočítať všetky súčiny $y_1\\cdots y_n$ bez jedného prvku. Postavme si teda binárny strom, ktorý bude mať v listoch hodnoty $y_1\\cdots y_n$, pričom postupnosť $y$ doplníme na konci jednotkami, aby jej dĺžka bola mocnina dvoch. Nájdeme teda také $k$, že $n\\leq 2^k$. Vrcholy stromu si zhora očíslujeme $1$ až $2^{k+1}-1$ (tak, že vrchol $v$ má synov $2v$ a $2v+1$). Tento strom prejdeme odspodu a pre každý vrchol $v$ si v konštantnom čase spočítame hodnotu $Y_v$, súčin $y$-ov v listoch jeho podstromu. Na to nám stačí vynásobiť hodnoty $Y$ v jeho synoch: $Y_v = Y\_{2v} \\cdot Y\_{2v+1} \\mod p$.

Prejdeme binárny strom znova, tentokrát odvrchu a spočítame si hodnoty $Y'\_v$ definované nasledovne:

- $Y'\_1 = 1$,
- $Y'\_{2v} = Y'_v \\cdot Y_{2v+1} \\mod p$ pre $1 \\leq v \\leq 2^k-1$
- $Y'\_{2v+1} = Y'_v \\cdot Y_{2v} \\mod p$, pre $1 \\leq v \\leq 2^k-1$

Rozmyslite si, že hodnoty $Y'\_v$ predstavujú súčin všetkých $y$ **okrem** tých v listoch podsromu $v$, takže hodnoty $Y'$ v listoch stromu sú hľadané súčiny.

Celé to vieme spočítať dvoma prechodmi binárneho stromu v čase $O(n)$. Pamäťová zložitosť riešenia je tiež $O(n)$. Lepšiu časovú zložitosť dosiahnuť nevieme, pretože musíme načítať celý vstup.
",9
72f90318c8672b06,ksp,"# Odplata drepovaním

Byť vedúci na sústredení je naozaj super. Hlavne preto, že máte na starosti 32 účastníkov, ktorí vás musia poslúchať bez ohľadu na to, čo im prikážete urobiť. A tak sa noví vedúci mstia ďalšej generácii za krivdy, ktoré im boli spôsobené, keď boli ešte účastníkmi. Takto potom tento kolobeh pokračuje donekonečna \\dots

Emo si tiež živo spomína na príkoria, ktoré podstupoval na sústredeniach. Najviac nemal rád rozcvičky, lebo ho vedúci vytiahli z postele a nútili behať, skákať a drepovať. Preto sa rozhodol, že teraz donúti účastníkov drepovať on. Vymyslel si na to vskutku zaujímavý spôsob.

Najskôr všetkých účastníkov usporiadal do $s$ zástupov. V každom z nich bolo $r$ účastníkov. Vytvoril tak obdĺžnik veľkosti $r \\times s$. Následne si opakovane vyberal riadok alebo stĺpec tohto obdĺžnika a nútil účastníkov v danom riadku alebo stĺpci spraviť poldrep. To znamená, že ak účastník stál, tak si musel čupnúť a ak čupel, tak sa musel postaviť.

Ak napríklad ukázal na tretí stĺpec, všetci účastníci v treťom zástupe si museli čupnúť a ostatní ostali stáť. Ak potom ukázal na druhý riadok, tak všetci účastníci v druhom riadku si museli čupnúť, okrem účastníka, ktorý bol v druhom riadku a treťom stĺpci. Ten totiž už čupel a preto sa musel postaviť.

Keď to Ema prestalo baviť^[Po asi hodine a pol.], pustil účastníkov na raňajky. Ešte pred tým si však zapamätal, že na konci čupelo presne $k$ účastníkov. Keď potom prišiel na raňajky, sadol si vedľa Miša, ktorému vysvetlil, čo robil. Miša táto hra zaujala a chcel vedieť, koľkými spôsobmi vedel Emo docieliť stav, pri ktorom na konci čupelo $k$ ľudí. Nevedel si s tým však poradiť, preto poprosil Ema, aby mu povedal ešte niečo viac. Emo mu preto prezradil, že keď si vyberal stĺpce a riadky, ktoré majú spraviť poldrep, riadok si vybral $p_r$-krát a stĺpec $p_s$-krát.

To už Mišovi na vyriešenie úlohy stačilo a povedal si, že vám takúto úlohu zadá, aby ste sa potrápili aj vy.

## Úloha

Na začiatku mal Emo stojacich účastníkov, ktorí boli rozdelení do obdĺžnika s $r$ riadkami a $s$ stĺpcami. Následne Emo určoval niektoré riadky alebo stĺpce a účastníci v nich museli zmeniť svoj stav -- ak stáli, museli si čupnúť, ak čupeli, museli sa postaviť.

Vypočítajte, koľkými spôsobmi mohol určiť $p_r$ riadkov a $p_s$ stĺpcov tak, aby na konci ostalo $k$ čupiacich ľudí. Dve možnosti považujeme za rôzne, ak existuje riadok alebo stĺpec, ktorý bol vybratý v oboch možnostiach rôzny počet krát. Nezáleží nám teda na poradí, v akom Emo riadky a stĺpce určoval.

Keďže výsledok môže byť príliš veľký, vypíšte iba jeho zvyšok po delení číslom $555,555,555$.

## Formát vstupu

Vstup obsahuje päť medzerou oddelených čísel $r$, $s$, $p_r$, $p_s$ a $k$ -- počet riadkov a stĺpcov obdĺžnika, počty vybratí niektorého riadka, počty vybratí niektorého stĺpca a počet účastníkov, ktorí na konci ostali čupieť.

Pre tieto hodnoty platí, že $1 \\leq r,s \\leq 1,500$, $0 \\leq p_r,p_s \\leq 1,500$ a $0 \\leq k \\leq rs$.

Naviac, v prvej sade vstupov platí, že $1 \\leq r,s,p_r,p_s \\leq 10$, v druhej sade vstupov platí, že $1 \\leq r,s \\leq 20$ a v tretej sade platí, že $1 \\leq r,s,p_r,p_s \\leq 100$.

## Formát výstupu

Vypíšte jedno číslo -- počet možností, ktorými vieme určiť $p_r$ riadkov a $p_s$ stĺpcov tak, aby ostalo čupieť $k$ účastníkov. Keďže toto číslo môže byť príliš veľké, vypíšte iba jeho zvyšok po delení číslom $555,555,555$.

## Príklad

```vstup
2 2 2 2 4
```

```vystup
4
```

_V dvoch možnostiach vybral Emo oba riadky a jeden zo stĺpcov dvakrát. V druhých dvoch možnostiach vybral oba stĺpce a jeden z riadkov dvakrát._

```vstup
2 2 0 0 1
```

```vystup
0
```

_Ak Emo nevybral žiaden riadok ani stĺpec, nie je možné aby niekto čupel._

```vstup
8 4 12 3 8
```

```vystup
27600
```
","# Odplata drepovaním

Začnime tým, že si zopakujeme, o čom bolo zadanie a zavedieme trochu iné pojmy, ktoré budeme používať na popis situácie. V zadaní sme mali mriežku $r \\times s$, v ktorej stáli účastníci. Každý účastník buď stál alebo čupel. Namiesto účastníkov však vyplňme našu mriežku 0 a 1. 0 bude predstavovať stojaceho účastníka a 1 čupiaceho.

Emo potom určoval riadky a stĺpce tejto mriežky a účastníci v príslušnom riadku alebo stĺpci si museli čupnúť ak stáli a naopak. Pri použití 0 a 1 to znamená, že vždy, keď určíme nejaký stĺpec alebo riadok, tak sa v ňom všetky 0 zmenia na 1 a naopak. Vieme, že Emo určil dokopy $p_r$ riadkov a $p_s$ stĺpcov a na konci bolo v mriežke $k$ čupiacich účastníkov -- teda $k$ hodnôt 1.

Našou úlohou bolo vypočítať, koľkými možnosťami mohol za uvedených podmienok tento výsledok dosiahnuť. Už v zadaní je napísané, že pri počítaní možností nám nezáleží na tom, v akom poradí Emo riadky a stĺpce určoval. Uvedomme si, že táto podmienka je rozumná, lebo poradie nezmení to, ako vyzerá výsledná mriežka a koľko jednotiek obsahuje.

## Pozorovanie

Čo teda ovplyvňuje to, ako vyzerá mriežka na konci? Kedy bude v $i$-tom riadku a $j$-tom stĺpci 1 a kedy tam bude 0?

Je jasné, že vybratie iného ako $i$-teho riadku alebo $j$-teho stĺpca nijak neovplyvňuje číslo na tomto políčku. Taktiež vieme, že na začiatku bola na tomto políčku 0. Vždy keď vyberieme $i$-ty riadok alebo $j$-ty stĺpec sa táto hodnota zmení na opačnú. Ak si označíme hodnotu $r_i$ počet vybraní $i$-teho riadku a $s_j$ počet vybraní $j$-teho stĺpca, tak ľahko nahliadneme, že hodnota na tomto políčku bude na konci $r_i + s_j \\mod 2$. Teda parita počtu vybratí, ktoré ovplyvnili toto políčko. To nás vedie k veľmi zaujímavej úvahe. Zjavne je jedno, koľkokrát určíme niektorý riadok alebo stĺpec, dôležitá je len parita tohto počtu určení.

Poďme však s touto úvahou ešte ďalej. Nech bolo $x_r$ riadkov a $x_s$ stĺpcov vybraných nepárny počet krát. Koľko 1 bude vo výslednej mriežke? Zjavne na miestach kde sa pretína takýto nepárny riadok a stĺpec bude 0, lebo tieto dve vybratia sa anulujú. Takže 1 bude len na miestach, kde sa pretína nepárny riadok s párnym stĺpcom alebo naopak. Počet 1 vo výslednej mriežke teda bude $x_r \\cdot (s-x_s) + (r-x_r) \\cdot x_s$. Ak si teda určíme koľko riadkov a koľko stĺpcov bolo vybraných nepárny počet krát, vieme ľahko overiť, či takéto vybratie viedlo ku $k$ jednotkám vo výslednej mriežke.

Avšak, všimnime si, že nás nezaujíma ani to, ktoré riadky a stĺpce to budú. Jediný dôležitý je ich počet. No a vzhľadom na veľkosť vstupu nie je problém vyskúšať všetky kombinácie počtov nepárnych riadkov a stĺpcov a zistiť, či je takáto kombinácia (dvojica -- počet nepárnych riadkov, počet nepárnych stĺpcov) vyhovujúca a vytvorí potrebný počet jednotiek.

To, čo sme spravili doteraz nám však predsa vôbec nepomáha. Veď stále nevieme, koľko bolo všetkých možností. Získali sme však dôležitú vec. Všetky výsledné možnosti sme si rozdelili do pomerne málo (najviac $(r+1) \\cdot (s+1)$) skupín podľa počtov nepárnych riadkov a stĺpcov. Pritom každá možnosť patrí do práve jednej takejto skupiny -- stačí sa pozrieť, koľko jej riadkov a koľko jej stĺpcov bolo vybraných nepárny počet krát. Ak sa teda vrátime späť a podarí sa nám rýchlo vypočítať, koľko výsledných možností leží v danej skupine budeme vedieť pomerne rýchlo zistiť výsledok. Jednoducho sčítame veľkosti správnych skupín -- tých, ktoré vedú k vytvoreniu $k$ jednotiek.

## Počítanie veľkosti jednej skupiny

Úloha sa teda zmenila: Koľko možností vybratia $p_r$ riadkov a $p_s$ stĺpcov vedie k tomu, že $x_r$ riadkov a $x_s$ stĺpcov vyberieme nepárny počet krát?

Pri tomto počítaní musíme postupne započítať všetko, čo sme zanedbali. To znamená výber konkrétnych $x_r$ riadkov (a to isté pre stĺpce), ktoré majú byť vybrané nepárny počet krát a samotné počty vybratí každého riadku (resp. stĺpca).

Začnime tým prvým. Ak máme hodnotu $x_r$, musíme započítať všetky možnosti, kde je práve $x_r$ riadkov vybraných nepárny počet krát. Ak ste už počuli o kombinačných číslach, tak by vám malo byť jasné, že tento počet možností je práve ${r \\choose x_r}$. Lebo práve kombinačné číslo $r$ nad $x_r$ vyjadruje to, koľkými možnosťami vieme z $r$ vecí (riadkov) vybrať $x_r$ (tých nepárnych riadkov). Pre ľahší zápis zapisujme toto číslo $P(r, x_r)$.

Ak ste o kombinačných číslach ešte nepočuli, nič si z toho nerobte. Za chvíľu sa dostaneme k tomu, ako ich počítať bez ohľadu na to, či viete, čo to je. Zatiaľ však akceptujte ich existenciu a to, že sú presne hodnotou, ktorú hľadáme.

Ostáva nám ešte druhý krok zovšeobecnenia. Aj keď sme priradili každému riadku paritu, musíme túto výslednú paritu dosiahnuť nejakým konkrétnym vybratím týchto riadkov. Koľko je však týchto možností? Zjavne, každý z nepárnych riadkov musel byť vybraný aspoň raz. To znamená, že nám ostáva rozdeliť $p_r - x_r$ vybraní. Tieto vybratia však musia ísť vždy v páre. Jedno vybratie by totiž zmenilo paritu a to nechceme. Takže ak sa rozhodneme priradiť niektorému riadku ďalšie vybratie, musíme to spraviť rovno dvakrát. Máme teda $\\frac{p_r-x_r}{2}$ párov vybratí a každý pár musíme priradiť niektorému riadku.

Opäť dostávame pomerne známu hodnotu -- počet kombinácií s opakovaním $C(r, (p_r-x_r)/2)$. Keďže nám nezáleží na poradí, tak z $r$ riadkov chceme vybrať $(p_r-x_r)/2$, niektoré riadky však môžeme aj opakovať -- priradiť viacerým párom. Opakovanie znamená, že danému riadku nepriradíme len 2 vybratia (1 pár), ale 4, 6...

Naviac, pre kombinácie s opakovaním platí veľmi užitočná vlastnosť, že $C(n, k) = P(n+k-1, k)$. To znamená, že ak vieme počítať kombinácie bez opakovania, vieme počítať aj tie s opakovaním.

Ak si teda zoberieme hodnoty $x_r$ a $x_s$ a tieto dve hodnoty vedú k požadovanému výsledku -- vytvoria $k$ jednotiek a taktiež $x_r$ má rovnakú paritu ako $p_r$ (párnym počtom vybratí riadku nemôžem vytvoriť nepárny počet nepárny počet krát vybraných riadkov) a $x_s$ má rovnakú paritu ako $p_s$, tak počet možností v takejto množine spočítame ako $P(r, x_r) \\cdot P(s, x_s) \\cdot C(r, (p_r-x_r)/2) \\cdot C(s, (p_s-x_s)/2)$.

## Riešenie

Na vypočítanie hodnôt $P(a,b)$ a $C(a,b)$ použijeme Pascalov trojuholník. Ten si na začiatku behu programu spočítame pre dostatočne veľké hodnoty, teda prvých $m$ riadkov, kde $m = max(2r, 2s, 2p_r, 2p_s)$. Potom už len pre každú z $(s+1)\\cdot(r+1)$ skupín v konštantnom čase overíme, či vytvára $k$ jednotiek a v konštantnom čase spočítame (pomocou Pascalovho trojuholníka), koľko možností patrí do danej skupiny. Celkovo tak dostaneme riešenie so zložitosťou $O(m^2 + r\\cdot s) = O(m^2)$.

## Kombinačné čísla

Možno si teraz hovoríte, že táto úloha je nefér pre niekoho, kto nikdy nepočul o kombinačných číslach. No aj keď je pre niekoho takého rozhodne ťažšia, zďaleka nie je neriešiteľná. Zabudnime preto na to, že existujú nejaké kombinačné čísla a riešme úlohu: Koľkými možnosťami vieme vybrať $k$ prvkov z $n$ možných, ak nám nezáleží na poradí a prvky sa nemôžu pri výbere opakovať?

Na začiatok môžeme vyriešiť nejaké jednoduché podproblémy. Napríklad ak je $k = n$ tak zjavne máme jedinú možnosť. Takisto ak je $k=0$, tak ostáva jediná možnosť, nič nevybrať. Ak je $k=1$, tak možností máme $n$, môžeme totiž vybrať ľubovoľný prvok. Zaujímavý je tiež prípad, keď $k > n$. V takom prípade je odpoveď 0, keďže neexistuje spôsob ako z $n$ prvkov vybrať $k$.

Pozrime sa teraz na všeobecný prípad, keď máme $n$ vecí, z ktorých chceme $k$ vybrať a $k \\geq 1$. Zoberme si teraz ľubovoľný z $n$ prvkov, označme si ho $x$. Keďže nám nezáleží na poradí vyberania, jediné čo sa musíme pýtať je, či tento prvok vyberieme alebo nie. Všetky možnosti sa teda rozdelia na dve skupiny -- možnosti, v ktorých prvok $x$ vyberieme a možnosti, kde $x$ nevyberieme.

Ak teda chceme zistiť hodnotu $P(n,k)$ vedeli by sme to vypočítať ako súčet možností v týchto dvoch skupinách. Skúsme teda vypočítať, koľko je takých možností, v ktorých $x$ vyberieme. Tento prvok už použiť nemôžeme, takže nám ostáva $n-1$ prvkov. Z nich ale potrebujeme vybrať už len $k-1$ prvkov, keďže sme už vybrali prvok $x$. Táto hodnota je preto $P(n-1, k-1)$. A podobnú vlastnosť nájdeme aj v prípade, keď prvok $x$ nevyberieme. Ostáva nám už len $n-1$ prvkov (lebo o prvku $x$ sme sa už rozhodli, že ho neberieme), z ktorých musíme vybrať ešte $k$. Takže máme hodnotu $P(n-1, k)$.

Dostávame vzorec:

$$P(n, k) = P(n-1, k) + P(n-1, k-1)$$

Toto je pomerne dôležitý kombinatorický vzorec, ktorého aplikáciou vzniká napríklad Pascalov trojuholník. A práve tento trojuholník je to, čo chceme počítať. Postupne budeme počítať všetky hodnoty $P(n,k)$. Keďže na vypočítanie $P(n,k)$ potrebujeme hodnoty s menším $n$, budeme tieto hodnoty počítať od najmenších hodnôt $n$.

Na začiatku vieme, že $P(0, 0) = 1$. Následne budeme počítať všetky kombinačné čísla s $n=1$. Aby sme sa nesnažili vyberať záporný počet prvkov, tak si určíme, že $P(1,0) = 1$ a zvyšné hodnoty vypočítame vzorcom uvedeným vyššie. Toto všetko si budeme značiť do tabuľky, kde $n$ je číslo riadku a $k$ číslo stĺpca.

Po vypočítaní všetkých hodnôt pre $n=1$ sa presunieme do riadku s $n=2$ atď. Pričom vždy si v riadku pevne určíme hodnotu $P(n,0) = 1$ a potom na výpočet všetkých $1 \\leq k \\leq n$ použijeme odvodený vzorec. A keďže hodnoty, ktoré potrebujeme vo vzorci, už máme vypočítané, vypočítanie novej hodnoty nám zaberie konštantný čas. Časová zložitosť výpočtu Pascalovho trojuholníka je preto $O(n^2)$.

Ešte sme však nevyriešili, ako počítať kombinácie s opakovaním. Hlavne ak nepoznáme vzorec na prevod na kombinácie bez opakovania. Žiaden strach, použijeme úplne rovnakú úvahu. Naša úloha znie: Koľkými spôsobmi viem z $n$ prvkov vybrať $k$, ak nám nezáleží na poradí, ale niektoré prvky môžeme vybrať aj viackrát.

Opäť si zoberieme prvok $x$, o ktorom sa budeme rozhodovať, či ho zoberieme alebo nie. Ak sa však rozhodneme, že prvok $x$ nevyberieme, už nemáme možnosť ho zobrať neskôr. Ak ho chceme vybrať, hoci aj viackrát, musíme to spraviť teraz.

Ak teda prvok $x$ nezoberieme, tak ako pred tým nám ostane $n-1$ prvkov, z ktorých musíme vybrať $k$. Ak však prvok $x$ vyberieme, budeme vyberať tiež $k-1$ prvkov, na výber však budeme mať všetkých $n$ prvkov, teda sa opäť môžeme rozhodnúť zobrať prvok $x$. To nám zaručí, že prvky vieme vyberať aj viac ako raz. A takisto nám to odvádza vzorec:

$$C(n, k) = C(n, k-1) + C(n-1, k-1)$$

Použitím rovnakej metódy ako pri počítaní Pascalovho trojuholníka vieme vypočítať aj tieto hodnoty s časovou zložitosťou $O(n^2)$. A nepotrebovali sme poznať zložité vzorce, stačilo vedieť správne použiť metódy dynamického programovania.

Posledná vec, ktorú treba spomenúť je, prečo sme na výpočet nepoužívali vzorec ${n \\choose k} = \\frac{n!}{k!(n-k)!}$. Problémom je, že výsledné číslo musíme modulovať, vrátiť len jeho zvyšok po delení $555,555,555$. Ak by sme chceli teda používať faktoriály, tak by sme si museli vypočítať ich hodnoty modulo toto číslo, keďže $1500!$ sa nám do žiadnej číselnej premennej nezmestí (už s 20! by sme mali problém).

Problém ale potom nastáva pri delení. Modulo síce pekne funguje pri násobení alebo sčítaní a napríklad $a\\cdot b \\pmod{m} = (a \\pmod{m})\\cdot (b \\pmod{m})\\pmod{m}$ je správna rovnica, pre delenie takáto rovnica neplatí. Použítím delenia by sme preto dostali nesprávne čísla.
",8
61b4b16b1345da42,ksp,"# Totálna pohroma

Syseľ sa s hlbokým výdychom zvalil na svoju kancelársku stoličku. Hotovo! Po mesiacoch úpornej driny sa mu konečne podarilo dokončiť samofunkčný vysávač poháňaný jadrovým reaktorom. Jediný vysávač takéhoto druhu na celom svete. Proste unikát.

Bol položený na stole pred ním, chrómované telo odrážalo svetlo, trubica vedúca zo stredu sa pomaly otáčala a snažila sa nájsť špinu na vysatie, to všetko doplnené jemným bzukotom reaktora. A všade naokolo papiere, nákresy, výpočty, kusy kódu. Naprogramovať umelú inteligenciu bola pre Sysľa hračka, konštrukcia vysávača tiež nebola problematická. Reaktor mu však dal zabrať. Ani by ste netušili, aký je problém zohnať dostatočné množstvo kvalitného uránu. Ale ani keď ho len tak hodíte do vnútra, tak to nezačne fungovať. Lietajúce neutróny treba celý čas precízne kontrolovať, jednak aby jadrová reakcia nevyhasla, jednak aby to celé nevybuchlo.

Tajomstvom je použitie špeciálnej kontrolnej matice rozmerov $n \\times n$, cez ktorú neutróny filtrujete. Každé políčko je buď priepustné alebo nepriepustné, je však dôležité, aby platilo, že v každom štvorci okolo hlavnej diagonály je práve párny počet nepriepustných políčok. Presnejšie, ak si ľavý horný roh matice označíte súradnicami $(1, 1)$ a pravý dolný súradnicami $(n, n)$, tak musí platiť, že každý štvorec, ktorého protiľahlé rohy sú na súradniciach $(i, i)$ a $(j, j)$ (pre $i < j$) má párne veľa nepriepustných políčok. Syseľ pohľadom zavadil o nákres tejto kontrolnej matice, ktorý ležal pred ním na stole. Asi by ho mal niekam odložiť, predsa je to len najdôležitejšia časť jeho výtvoru a on si ju ešte nestihol zálohovať.

V tom však do miestnosti vstúpila ona a Syseľ zabudol na všetko ostatné. Nikol. Najlepšia programátorka v celom VacuumLabs. Keby ste ju videli ako píše na svojej ergonomickej klávesnici. Prsty sa jej len tak mihajú po klávesách. A keď potom spraví pull request, pozerať sa naňho chodia ešte aj z Exponei. K tomu všetkému je ešte aj nesmierne krásna a nezadaná. Len nedávno sa síce rozišla so svojím priateľom^[Bol to hlupák, ak chcete počuť Sysľov názor.], ale je najvyšší čas, aby Syseľ spravil prvý krok. A jadrový vysávač môže byť presne tá vec, ktorá ju ohúri.

Keď Nikol vošla do miestnosti, Syseľ sa v okamžiku postavil zo stoličky, aby ju privítal. Pritom však na stôl vysypal omrvinky z keksíkov, ktoré jedol počas práce. Jeho inteligentný vysávač to hneď zaregistroval a začal otáčať trubicu aby ich vysal. Pritom však omylom prevrhol pohár vody a tá sa rozliala po nákrese kontrolnej matice. Katastrofa! Ako teraz Syseľ ohúri Nikol, keď je jeho výtvor zničený? Na mokrom papieri je vidno už iba niekoľko 0 a 1, ktoré predstavujú priepustné a nepriepustné políčka. Pomôžte Sysľovi zistiť, koľkými spôsobmi vie doplniť zvyšok matice, nech sa môže pustiť do opravovania.

## Úloha

Na vstupe dostanete veľkosť matice $n$ a políčka, ktoré ostali zachované spolu s ich pôvodnými hodnotami -- 0 alebo 1. Zistite, koľkými spôsobmi je možné doplniť zvyšné políčka tejto matice číslami 0 a 1 tak, aby platilo, že v každom štvorci okolo hlavnej diagonály so stranou väčšou ako 1 je párne veľa jednotiek.

Hlavná diagonála matice je tvorená políčkami, pre ktoré platí, že ich $x$-ová a $y$-ová súradnica je rovnaká. Ťahá sa preto od ľavého horného rohu (súradnice $(1, 1)$) k pravému dolnému rohu (súradnice $(n, n)$). Štvorec je okolo hlavnej diagonály vtedy, ak dva jeho protiľahlé rohy ležia na hlavnej diagonále.

Keďže počet spôsobov, ako doplniť maticu, môže byť naozaj veľký, vypíšte iba ich zvyšok po delení číslom $1,000,000,009$.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve celé čísla $n$ a $m$ ($2 \\leq n \\leq 10^5$, $0 \\leq m \\leq min(50,000, n^2)$) -- veľkosť matice a počet zachovaných políčok.

Nasleduje $m$ riadkov, každý popisuje jedno zachované políčko pomocou troch čísel $x_i$, $y_i$ a $c_i$ ($1 \\leq x_i, y_i \\leq n$, $0 \\leq c_i \\leq 1$) -- súradnice tohto políčka a jeho hodnota. Je zaručené, že jedno políčko sa môže objaviť na najviac jednom riadku vstupu.

Testovacie vstupy pre túto úlohu sú rozdelené do 8 sád, pre ktoré platia nasledovné dodatočné obmedzenia:

- V sade 1 platí, že $n = m$ a všetky zadané políčka ležia na hlavnej diagonále. Inými slovami, máte presne zadané ako vyzerá hlavná diagonála a nič naviac.
- V sade 2 a 3 platí, že $n \\leq m$ a medzi zadanými políčkami sa vyskytujú všetky políčka na hlavnej diagonále. Oproti vstupm zo sady 1 teda máte aj zadaných aj niekoľko dodatočných políčok.
- V sade 4 platí, že $n \\leq 20$.
- V zvyšných sadách neplatia žiadne dodatočné obmedzenia.

## Formát výstupu

Na výstup vypíšte jedno celé číslo -- počet možností, ktorými je možné doplniť maticu $n \\times n$ číslami 0 a 1 tak, aby platila zadaná podmienka. Toto číslo vypíšte modulo $1,000,000,009$.

## Príklad

```vstup
3 3
1 3 1
3 2 0
1 1 1
```

```vystup
8
```

*Všetky možné doplnenia sú uvedené na nasledovnom obrázku:*

```vstup
3 6
1 1 1
1 2 1
2 1 1
3 3 0
3 2 0
2 3 0
```

```vystup
0
```

*Ak do stredného políčka dopíšeme 0, štvorec $2\\times 2$ v ľavom hornom rohu nebude mať párne veľa jednotiek. A ak do stredného políčka dopíšeme 1, zlý bude pravý dolný $2 \\times 2$ štvorec.*
","# Totálna pohroma

Úloha vyzerá už na prvý pohľad komplikovane. Máme počítať počet možností, niektoré časti sú už vopred určené a tie dopĺňať nemáme a popritom ešte máme kontrolovať, že v každom diagonálnom štvorci bude párny počet jednotiek. Keďže je toho veľa, treba sa skúsiť zamerať na nejakú menšiu časť, objaviť niekoľko základných pravidiel a odtiaľ sa posúvať k všeobecnému riešeniu. A samozrejme celý čas si kresliť, to pomáha najviac. Nuž a keď sme si nie istý, ktorým smerom sa vydať, pomôcť nám môžu návodné, ľahšie, sady.

\\nadpis{Zadaná diagonála}

Hlavná diagonála našej matice je dôležitá, keďže nás zaujímajú iba štvorce v jej okolí. V prvej sade navyše máme zaručené, že všetky prvky tejto diagonály sú vopred určené a nič naviac sme nedostali. Pokúsme sa teda postupne vypĺňať zvyšné políčka. Začať môžeme od najmenších možných štvorcov veľkosti $2\\times 2$. V tomto prípade máme určené dve políčka na diagonále a doplniť treba zvyšné dve. Vieme, že súčet týchto prvkov musí byť párny (čo je len inak vyjadrená podmienka párneho počtu jednotiek), čísla z diagonály nám teda určujú či sú zvyšné dve čísla rovnaké alebo rozdielne.

Predstavme si, že súčet dvoch zadaných čísel na diagonále je párny. Potom aj zvyšné dve čísla musia mať párny súčet -- musia byť rovnaké. Naopak, ak čísla na diagonále dávajú nepárny súčet, sú rôzne, musia byť rôzne aj zvyšné dve čísla. V oboch prípadoch máme dve možnosti, ako tieto hodnoty doplniť. V párnom prípade to bude buď $0-0$ alebo $1-1$, v nepárnom buď $0-1$ alebo $1-0$ (na poradí záleží, keďže sú to rôzne políčka matice).

Našťastie, je jedno, ktorú možnosť si zvolíme, pri zvyšných štvorcoch to nemôže zavážiť. Môžete si totiž všimnúť, že ľubovoľný diagonálny štvorec, ktorý obsahuje jedno z týchto dvoch políčok musí nutne obsahovať aj druhé. No a ich súčet je určený diagonálnym štvorcom $2 \\times 2$ a je jedno, ktorými hodnotami sa k tomuto súčtu dopracujeme. Do výsledku si teda môžeme poznačiť, že sme získali dve rôzne možnosti a pokračovať ďalej s ľubovoľnou z nich.

Po doplnení štvorcov $2 \\times 2$ sa presunieme na štvorce $3 \\times 3$. Opäť nám na doplnenie ostávajú už len dve hodnoty -- rohy neležiace na hlavnej diagonále. Zvyšné políčka sú totiž zahrnuté v niektorom menšom diagonálnom štvorci. Zo súčtu už vyplnených políčok opäť zistíme, či má byť súčet týchto políčok párny alebo nepárny, teda či sú v nich čísla rovnaké alebo rôzne. Z toho opäť vyplývajú dve možné priradenia hodnôt, ktoré sú však ekvivalentné a je jedno, ktoré z nich si zvolíme, stačí že si zapamätáme, že sme mali dve možnosti na výber.

Vieme si však všimnúť zaujímavú vec. V skutočnosti je parita súčtu dvoch nedoplnených políčok rovnaká ako parita stredného políčka štvorca $3\\times 3$. Prečo? Všimnime si, že všetky už doplnené políčka sa dajú rozdeliť do dvoch diagonálnych štvorcov veľkosti $2 \\times 2$, ktoré sa prekrývajú v strednom políčku, označme si ho $x$. Súčet prvkov všetkých týchto políčok sa rovná súčtu oboch štvorcov $2\\times 2$ mínus $x$, ktoré sme započítali dvakrát. Ale súčet prvkov v štvorci $2 \\times 2$ musí byť párny. To znamená, že výsledný súčet musí mať rovnakú paritu ako hodnota $x$. Rohy štvorca $3\\times 3$ teda vieme doplniť iba na základe streného čísla, ktoré sa nachádza na hlavnej diagonále.

Pokúsme sa doplniť prvky v diagonálnych štvorcoch $k \\times k$, pričom $k > 3$ a všetky menšie štvorce sú úspešne vyplnené. Opäť vidíme, že nevyplnené ostávajú iba dve políčka v rohoch tohto štvorca. Naviac, vyplnené políčka tvoria dva diagonálne štvorce veľkosti $(k-1) \\times (k-1)$, ktoré sa prekrývajú v diagonálnom štvorci veľkosti $(k-2) \\times (k-2)$. Súčet týchto prvkov vieme teda vypočítať aj tak, že sčítame súčet štvorcov s hranou $k-1$ a odčítame súčet štvorca s hranou $(k-2)$. Súčty všetkých týchto štvorcov musia byť však podľa zadania párne. To znamená, že aj tento výsledok bude párny. Z toho vyplýva, že hodnoty v nediagonálnych rohoch štvorca $k \\times k$ **musia byť rovnaké** a navyše vôbec nezávisia od hodnôt na diagonále ani ničom inom.

_Sivé políčka ešte nie sú vyplnené. Červené aj modré štvorce musia obsahovať párny počet 1. Z toho vyplýva, že počet 1 v celom štvorci s výnimkou sivých políčok je párny. Sivé políčka teda musia obsahovať rovnakú hodnotu._

Tento prístup nefunguje pre štvorce $3\\times 3$ a $2\\times 2$, pretože menšie štvorce, z ktorých sa skladajú, nie sú veľkosti aspoň $2\\times 2$, a tým pádom pre ne neplatí predpoklad o párnosti ich súčtu.

Z vyššie uvedených tvrdení vidíme, že v okamihu keď máme vyplnenú diagonálu, riešenie je jednoduché. Políčka symetrické cez diagonálu sú od seba navzájom závislé, v prípade, že sú od diagonály príliš vzidalené musia mať rovnakú hodnotu, inak sú hodnotami na diagonále mierne ovplyvnené. V každom prípade však dostaneme dve možnosti ich hodnôt, a preto výsledok musí byť $2^{\\frac{n^2 - n}{2}}$ -- mimo diagonály je $n^2 - n$ políčok a ich hodnoty určujeme po dvojiciach.

Toto číslo vieme vypočítať metódou rýchleho umocňovania v čase $O(\\log n)$. Myšlienka tohto algoritmu je rekurzívna. Namiesto toho aby sme mocninu počítali postupným násobením číslom $2$, počítame hodnotu $2^a$ tak, že rekurzívne spočítame číslo $2^{a/2}$, ktoré potom umocníme na druhú. Namiesto postupného počítania všetkých hodnôt $2, 2^2, 2^3, 2^4 \\dots 2^{a-2}, 2^{a-1}, 2^a$ budeme počítať iba hodnoty $2^a, 2^{a/2}, 2^{a/4} \\dots 2^2, 2$, ktorých je výrazne menej, iba logaritmicky veľa.

\\nadpis{Vopred určené hodnoty}

V druhej sade sme okrem celej diagonály mali vyplnené aj nejaké ďalšie políčka. Ako to ovplyvní výsledok? Obmedzí to naše možnosti. Všetky možné doplnenia sa totiž vyskytovali v dvojiciach, napríklad sme mohli zistiť, že konkrétne dve políčka musia byť rovnaké, teda buď $0-0$ alebo $1-1$. Ak však máme určené, že jedno z týchto políčok má hodnotu 0, tak nám ostáva iba jedna možnosť. Navyše, ak by sme v takomto prípade zistili, že obe políčka sú predvyplnené rozdielnymi hodnotami, vieme, že maticu nevieme doplniť žiadnym spôsobom.

V tomto prípade musíme rozlišovať dva prípady podľa vzdialenosti zadaného políčka od hlavnej diagonály. Pre políčka, ktoré sú priďaleko, aspoň vo vzdialenosti 3 od diagonály nám stačí overiť, či nemáme zadané aj pre ne symetrické políčko s opačnom hodnotou. V takom prípade bude teda možných doplnený 0, inak započítame iba jednu, vstupom určenú, možnosť pre túto dvojicu políčok. Najjednoduchšie riešenie tohto problému je použitím binárneho vyhľadávacieho stromu (`set` v C++), ktoré ale vedia k riešeniu s časovou zložitosťou $O(m\\log m)$. Toho logaritmu sa však vieme zbaviť, či už použitím hash mapy alebo nejakého rýchlejšieho triedenia, napr. radix sort. Pri programovaní však takýto malý rozdiel zvyčajne nepotrebujeme riešiť, keďže set je skutočne rýchly.

Zadané políčka v blízkosti diagonály sú o niečo dôležitejšie, sú totiž ovplyvnené hodnotami na diagonále a nevieme dopredu povedať, či majú byť symetrické políčka rozdielne alebo rovnaké. Potrebujeme ich teda prejsť samostatne. Navyše, s týmito hodnotami budeme musieť oveľa viac pracovať aj v prípade, že diagonála nie je určená, preto si ich treba vhodne zapamätať. Pomôcť nám môže buď hash mapa, ale takisto sa dá použiť klasické pole, keďže si potrebujeme pamätať iba 5 diagonál -- hlavnú a po dvoch susedných na oboch strán.

\\nadpis{Určenie hodnôt na diagonále}

Zatiaľ sme riešili iba problém, v ktorom boli hodnoty na diagonále vopred určené. Toto však nie je všeobecný prípad. Ako si s ním teda poradíme?

Nuž, budeme si ju musieť určiť. Samozrejme, mohli by sme ju určovať celú naraz, v takom prípade by sme museli prejsť postupne každú z $2^n$ možností. Uvedomme si však, že na diagonále závisia iba štvorce veľkosti $2\\times 2$ a $3\\times 3$. To znamená, že hodnoty na spodku diagonály nijak neurčujú, ako majú vyzerať hodnoty na jej vrchu. Presnejšie, políčka na diagonále, ktoré sú od seba vo vzdialenosti viac ako 3 sa už vôbec neovplyvňujú.

Na riešenie teda použijeme dynamické programovanie. Väčšinou keď počítate počet možností, riešením bude nejaká verzia dynamického programovania. Stav nášho dynamického programovania bude $D\_{k,x,y}$ -- koľkými možnosťami vieme vyplniť diagonálne štvorce veľkosti $2\\times 2$ a $3\\times 3$ v štvorci začínajúcom na políčku $(0,0)$ a končiacom na políčku $(k,k)$ ak posledné dve hodnoty na diagonále budú $x$ a $y$?

Výpočet tejto hodnoty bude závisieť na tom, ako sme vyplnili o jedno menší štvorec, teda od hodnôt $D\_{k-1, 0, x}$ a $D\_{k-1, 1, x}$. V tomto prípade nás zaujíma iba to, koľkými možnosťami vieme doplniť políčka $(k-1, k)$, $(k-2, k)$, $(k, k-1)$ a $(k, k-2)$, keďže vyplnenie zvyšných políčok bolo určené hodnotami $D\_{k-1, z, x}$.

_Sivé políčka nás nezaujímajú, pretože sú od diagonály priďaleko. Aktuálne doplňané políčka sú červené. Modré boli vyplnené v predchádzajúcich iteráciách dynamického programovania a poznáme pre ne počet rôznych možností. Na diagonále sme si určili hodnoty $x$ a $y$, ktoré ovplyvňujú aktuálne počítané políčka. Pri tretej hodnote vyskúšame obe možnosti, aj 0 aj 1._

Toto overenie je navyše jednoduché, stačí sa pozrieť, či sú určené hodnoty kompatibilné s hodnotami, ktoré máme zadané na vstupe, hodnoty niektorých z týchto políčok totiž už môžu byť doplnené, a vrátiť jednu z hodnôt 0, 1 alebo 2.

Hodnotu jedného stavu dynamického programovania vieme vypočítať v konštantnom čase a všetkých stavov je $4n$. Celková časová zložitosť tohto kroku je preto $O(n)$. Celková časová zložitosť tohto riešenia je $O(n + m)$, pamäťová $O(n + m)$. Pred programovaním je ešte treba poriadne si rozmyslieť okrajové prípady, začiatok dynamického programovania a rozobrať krok samotnej dynamiky. Potom je to však pomerne priamočiare.
",8
63e55001297bbfd2,ksp,"# Zuzkino sudoku

Zuzka rada rieši a ešte radšej vytvára sudoku. Vo svojom rodnom meste dokonca vytvárala každý týždeň jedno sudoku pre miestny časopis.

Jedného dňa jej napísal vydavateľ celoslovenského denníka s ponukou, či by nechcela sudokami zásobovať celé Slovensko každý deň. Na každý deň by musela vytvoriť ľahkú, strednú aj ťažkú variantu. To je ale veľa práce, však? Ak by Zuzka ponuku prijala, síce by si zarobila, no nemala by čas na školu, spánok a kamarátov^[Veľa ľudí sa aj bez vytvárania sudoku sťažuje, že majú čas len na dve zo spomenutých troch vecí.].

Zuzka je ale programátorka, a preto nebude sudoku vyrábať ručne, ale programom. Nie je to však také jednoduché. Pri tvorbe si totiž treba dať záležať na tom, aby mali riešitelia z riešenia sudoku dobrý zážitok. Sudoku, v ktorom chýbajú iba jednotky, je veľmi nezáživné. Také, do ktorého treba počas riešenia doplniť rôzne čísla je rozhodne zaujímavejšie.

Pomôžte Zuzke zistiť, ktoré sudoku sú tie zaujímavejšie. Napíšte program, ktorý pre dané sudoku zistí, koľko ktorých čísel treba do sudoku doplniť pre jeho vyriešenie.

## Úloha

Sudoku sa hrá nasledovne. Dostanete tabuľku s $9 \\times 9$ políčkami. Tabuľka je rozdelená na $3 \\times 3$ bloky po $3 \\times 3$ políčkach. Na každom políčku je buď číslo od 1 po 9 alebo je políčko voľné. Úlohou v sudoku je doplniť čísla na všetky prázdne políčka tak, aby sa v žiadnom riadku, stĺpci ani v bloku nezopakovalo žiadne z čísel 1 až 9 viac ako raz.

Vašou úlohou je pre daný popis sudoku zistiť, koľko ktorých čísel doň treba doplniť.

## Formát vstupu

Na vstupe dostanete 9 riadkov. V každom z nich bude 9 čísel v rozsahu od 0 po 9 oddelených medzerami. Čísla 0 reprezentujú nevyplnené políčka sudoku.

Môžete predpokladať, že sudoku zo vstupu sa dá vyriešiť -- teda napríklad v žiadnom riadku, stĺpci ani v bloku sa nezopakuje to isté číslo (okrem nuly).

## Formát výstupu

Vypíšte 9 riadkov. Ak riadky očíslujeme od 1 po 9, na $i$-tom z nich sa má nachádzať jedno celé číslo -- počet čísel $i$, ktoré treba do sudoku doplniť.

## Príklad

```vstup
8 7 0 2 4 5 1 9 3
2 0 1 3 6 0 4 5 7
5 4 3 1 7 9 8 2 6
6 8 0 0 2 3 7 1 0
7 2 5 6 0 4 3 8 9
0 0 0 8 0 0 5 6 2
9 0 8 7 3 1 2 4 5
1 3 2 4 5 6 9 7 8
4 5 7 9 8 2 6 3 1
```

```vystup
2
0
1
2
1
2
1
1
3
```

_Jednotka chýba v piatom a v šiestom riadku. Dvojky sú všade tam, kde majú byť, ..._
","# Zuzkino sudoku

Vzhľadom na to, že každý vstup obsahoval iba $9\\times9$ čísel (čiže každý vstup bol malý), mohli ste v tejto úlohe robiť všeličo. Mohli ste rekurziou vyriešiť sudoku, mohli ste pre každý riadok zisťovať, čo v ňom chýba...

Na vyriešenie tejto úlohy však nebolo nič z toho potrebné a stačilo spraviť jediné pozorovanie: **v každom vyriešenom sudoku sa nachádza každé číslo (1-9) práve deväťkrát**. Raz v každom stĺpci a stĺpcov je 9. Raz v každom riadku a riadkov je 9. Raz v každom bloku a blokov je 9.

Preto nám bude stačiť prečítať vstup, spočítať, koľko je v zadaní jednotiek, dvojok, ..., deviatok a vypísať čísla $9 - pocet_jednotiek, 9 - pocet_dvojok, \\dots, 9 - pocet_deviatok$.

Na pamätanie počtov jednotlivých čísel môžeme použiť 9 premenných, ale krajšie riešenie je použiť pole `pocet_cisel[]`, ktoré si inicializujeme na samé nuly. Potom načítame zo vstupu 81 čísel a zakaždým zvýšime dané políčko poľa.

Veľmi podobným spôsobom si môžeme v poli pamätať, koľko čísel $i$ treba doplniť. Pole inicializujeme na samé deviatky a pri čítaní vstupu odčítame jednotku za každý výskyt čísla.

## Časová zložitosť

Hoci vstup je konštantnej (vždy rovnakej) veľkosti, a mohli by sme povedať, že program pracuje v konštantnom čase $O(1)$^[program beží rovnako dlho pre všetky vstupy $9 \\times 9$ a pre iné vstupy nebude pracovať správne], tak informatívnejšie by bolo povedať niečo takéto: Ak si dĺžku štvorca sudoku označíme ako $n$, potom náš algoritmus pracuje v čase $O(n^2)$.

Z takéhoto tvrdenia sa dá usúdiť, že rovnakým algoritmom by ste vedeli vyriešiť úlohu, v ktorej by bolo sudoku veľkosti $18\\times18$, no trvalo by to 4-krát dlhšie.

Všimnite si rozdiel medzi pojmami $program$ a $algoritmus$. Hoci vyššie uvedené programy by vstupy veľkostí $18 \\times 18$ nevyriešili, rovnaká myšlienka, postup -- algoritmus -- sa dá použiť aj na riešenie vstupov rôznych veľkostí. Preto má zmysel hovoriť o [časovej zložitosti](https://www.ksp.sk/kucharka/zlozitost0/) algoritmu aj v tejto úlohe.

## Pamäťová zložitosť

V našich riešeniach využívame len jedno pole veľkosti $10$ (v riešení, ktoré je napísané v Pythone, si ešte pamätáme jeden riadok vstupu) a niekoľko jednoduchých premenných. Mohli by sme teda, takisto ako v časti o časovej zložitosti, povedať, že pamäťová zložitosť je konštantná od veľkosti vstupu, $O(1)$. Informatívnejšie by ale bolo uviesť pamäťovú zložitosť lineárnu od dĺžky strany sudoku, $O(n)$.
",1
282e9a3b883d8f64,ksp,"# Analýza Egypta

Písal sa koniec roka 2019, keď si Korporácia Snímkovacích Podvodníkov vysúťažila tender na letecké osnímkovanie Egypta a následné počítačové spracovanie snímkov. ""Však čo, letecké snímkovanie zvládneme ľavou zadnou, a na počítačové spracovanie snímok nám sem dva krát do roka chodí približne $36$ stážistov. Niekto z nich to určite naprogramuje"", hovoril si Krtko, hlavný Snímkovací Podvodník. Avšak, stalo sa to, čo nikto nečakal. Prišla pandémia, a žiadne stáže sa nekonali. Korporácia na tento tender už takmer zabudla, až včera prišiel mail o tom, že deadline na dodanie snímkov a dát sa blíži. ""Čo teraz? Snímky máme, ale treba ich vyhodnotiť. Peniaze čo sme za tender dostali už nemáme, minuli sme ich na kofolu v akcii ^[Viete koľko litrov kofoly sa zmestí do bežného nákupného košíka? Približne 120. Ak chcete vedieť ako sme na na to prišli, spýtajte sa Sabinky, Krtka alebo Marcela :) ]"", uvažoval Krtko. ""Musíme si nájsť niekoho, kto to urobí zadarmo."", rozhodol sa Krtko a začal čítať malé písmenká na zmluvách pracovníkov KSP, a hľadať takých, ktorí to podľa zmluvy musia urobiť zadarmo.

A tak si Krtko niekoho našiel. Vás. Napíšte program, ktorý z každého snímku zistí aká vysoká pyramída je na ňom. Ale poponáhľajte sa, lebo podľa malých písmenok na zmluve Vám Krtko môže dať preplatiť pokutu z omeškania.

## Úloha

Na vstupe dostanete leteckú snímku pyramídy zjednodušenú do textu. Vypíšte koľko poschodí má pyramída, ktorá sa na fotke nachádza. Každá pyramída sa skladá z niekoľkých obdĺžnikových poschodí. Každé poschodie okrem spodného stojí celé na nejakom poschodí, žiadna jeho časť ""nepretŕča"". Každé poschodie je zo všetkých $4$ strán aspoň o $1$ menšie ako poschodie pod ním

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$, počet riadkov, ktorý má text reprezentujúci fotku. Nasleduje $n, 1 \\leq n \\leq 50$ rovnako dlhých riadkov.

Každý riadok má najviac $50$ znakov a skladá sa len zo znakov `.`, ktoré označujú piesok, znakov `|`, ktoré reprezentujú ľavú alebo pravú stranu pyramídy na fotke, a znakov `-`, ktoré označujú vrchnú alebo spodnú stranu pyramídy. Každé poschodie má tvar obdĺžnika. V rohoch pyramídy sa nachádza znak `.`, teda piesok.

## Formát výstupu

Vypíšte jediné číslo, počet poschodí, ktoré má pyramída na fotke. Nazabudnite za ním vypísať znak konca riadku. Je zaručené, že sa na každej fotke nachádza pyramída s aspoň jedným poschodím.

## Príklad

```vstup
6
......
..--..
.|..|.
.|..|.
..--..
......
```

```vystup
1
```

*Táto pyramída má len jedno poschodie.*

```vstup
12
.............
.............
..--------...
.|........|..
.|.-----..|..
.||.--..|.|..
.|||..|.|.|..
.|||..|.|.|..
.||.--..|.|..
.|.-----..|..
..--------...
.............
```

```vystup
3
```

*Táto pyramída má $3$ poschodia.*
","# Analýza Egypta {bodypopis=12 bodyprogram=8}

Snažíme sa spočítať, koľko poschodí pyramídy sa na vstupe nachádza. Vieme, že každé poschodie je z každej strany ohraničené stenou (na ľavej a pravej strane poschodia je znak `|` a znak `-` na vrchnej a spodnej). Asi najjednoduchší spôsob, ako zistiť počet poschodí je nájsť taký riadok vstupu, kde je najväčší počet bočných strán poschodí (keďže každé poschodie má práve dve bočné steny). Rovnako dobre by to fungovalo aj pre každý stĺpec vstupu, ale príjemnejšie sa to zisťuje pre riadok. Počet výskytov nejakého znaku v reťazci môžeme zistiť napríklad tak, že prechádzame riadok vstupu znak po znaku a vždy keď nájdeme ten znak, tak si zväčšíme nejaké počítadlo.

Iný spôsob je využiť funkciu programovacieho jazyka, ktorá počíta počet výskytov nejakého znaku.^\[Vo väčšine programovacích jazykov sa zvykne volať `count`, alebo nejako podobne.\]

Toto môžeme urobiť pre každý riadok. Potom stačí nájsť, pre ktorý z nich je tento počet najväčší. Počet poschodí pyramídy ale samozrejme nie je počet stien pyramídy, ale len polovica toho počtu keďže každé poschodie sme započítali $2$ krát (raz jeho začiatok a raz jeho koniec).

Takže, zrekapitulujme si riešenie: postupne načítavame riadky, a pre každý riadok spočítame, koľko bočných stien poschodia sa na ňom nachádza. Na konci vypíšeme polovicu tohoto maximálneho počtu.

Takéto riešenie má časovú zložitosť $O(n^2)$, keďže pre každý z $n$ riadkov prejdeme celý od začiatku po koniec. Pamäťová zložitosť je $O(n)$, keďže okrem niekoľko málo premenných si nám stačí pamätať iba aktuálny riadok vstupu.
",1
10fc996617dd1a05,ksp,"# Zjedená pizza

KSPáci majú radi jedlo -- to vie hádam každý. A tak si počas posledných príprav pred sústredkom objednali do T2 pizzu, aby mali dosť síl na pobalenie kufrov. Keď odchádzali na sústredko, každý niečo niesol, ale krabice od pizze ostali tam -- za ten týždeň, čo tu nebudeme, ich určite niekto vyhodí...

Sústredko prebehlo a všetci sa plní zážitkov vrátili do T2, kde s hrôzou zistili, že krabice od pizze sú stále tam. Adam si všimol, že krabica od jeho veľkej pizze má dvakrát takú dlhú stranu ako krabice od malých pízz a vložil 4 menšie krabice vedľa seba do jednej veľkej. Takéto šetrenie miesta sa mu zapáčilo. Zobral si do ruky meter a začal merať veľkosti všetkých krabíc. S prekvapením zistil, že dĺžka strany každej krabice bola nejaká mocnina dvojky. Do najväčšej krabice povkladal teda tak veľa menších, koľko sa dalo. Potom rovnako pokračoval so zvyškom. Zistite, koľko krabíc musel nakoniec Adam odniesť do kontajnera.

## Úloha

Máte zadané dĺžky strán všetkých krabíc. Každá krabica je štvorcová a dĺžka jej strany je mocnina dvojky.

Do každej krabice vieme vkladať len menšie krabice. Do krabice s dĺžkou strany $2^k$ vieme vložiť vedľa seba najviac $4$ krabice s dĺžkou strany $2^{k-1}$. Ak zostáva v krabici voľné miesto, môžeme ho vyplniť aj menšími krabicami. Jednoducho, celková plocha krabíc, ktoré sú uložené vedľa seba, nemôže byť väčšia ako plocha vonkajšej krabice.

Vašou úlohou je zistiť, koľko krabíc ostane po tom, ako ich optimálne povkladáme do seba.

## Formát vstupu

V jednom riadku je 20 čísel $a_0, a_1, \\dots, a\_{19}$ oddelených medzerami ($0 \\leq a_i \\leq 1,000,000$). Číslo $a_i$ hovorí o tom, koľko máme krabíc s dĺžkou strany $2^i$.

Na pamätanie si veľkých čísel^[Približne v rozsahu $-2^{63}$ až $2^{63}$.] môžete použiť 64-bitové premenné typu `long long` v C++, `Int64` v Pascale.

## Formát výstupu

Vypíšte jedno číslo -- počet krabíc, ktoré ostanú na konci.

## Príklad

```vstup
0 0 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

```vystup
2
```

_Ostane krabica so stranou dlhou $8$ (v ktorej sú 4 krabice s dĺžkou $4$), a jedna krabica s dĺžkou $4$, ktorá sa tam už nezmestila._

```vstup
0 0 13 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

```vystup
1
```

_Balíme trinásť krabíc s dĺžkou strany $4$, jednu s dĺžkou $8$ a jednu s dĺžkou $16$. Môžeme ich pobaliť nasledovne: Najprv do krabice s dĺžkou strany $8$ zabalíme jednu štvorkovú. Potom sa krabica $8 \\times 8$ a 12 krabíc $4 \\times 4$ presne vojdú do krabice $16 \\times 16$._

```vstup
0 0 20 4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

```vystup
5
```

_Zostanú 4 najmenšie krabice a 1 najväčšia._
","# Zjedená pizza

Aby sme vyriešili túto úlohu, stačí nám robiť to, čo robil Adam v rozprávke v zadaní. Začneme od najväčších krabíc -- vždy do nich vložíme toľko menších, koľko sa zmestí, pričom zvyšné krabice musia zostať vonku.

Aby sme si v našom riešení udržali poriadok, v jednej premennej `mozem_zabalit` si budeme pamätať, koľko aktuálne spracúvaných krabíc vieme zabaliť do väčších. Môžeme si všimnúť, že aj keď sú v krabici $8 \\times 8$ štyri krabice $4 \\times 4$, stále sa tam zmestí 16 krabíc $2 \\times 2$. Teda väčšie krabice neovplyvňujú tie menšie, ak sú spoločne v jednej krabici. Na spočítanie, koľko menších krabíc vieme zabaliť, nám preto stačí vynásobiť premennú `mozem_zabalit` štyrmi .

Postupovať budeme od najväčších krabíc po najmenšie a v každom kroku bude našou úlohou ""zabaliť krabice s hranou dĺžky $2^i$"". Zakaždým spočítame, koľko takýchto krabíc musí zostať vonku a koľko miesta bude pre menšie krabice.

Krabíc zabalíme najviac `mozem_zabalit`. Ak sa všetky krabice zmestia do väčších, veľkosť voľného miesta pre ešte menšie krabice bude `4 * mozem_zabalit`. Ak sa niektoré krabice nezmestia dnu, zostávajú vonku a teda ich pripočítame ku `krabice_vonku`. Tiež ale vytvoria nový priestor pre ešte menšie krabice, teda menších krabíc budeme vedieť zabaliť `4 * (mozem_zabalit + ostali_vonku)`.

Krabice jednej veľkosti ""zabalíme"" v konštantnom čase $O(1)$, teda ak máme $k$ veľkostí krabíc, riešenie bude potrebovať $O(k)$ času. Keďže vstup spracúvame odzadu, musíme ho celý načítať do poľa, teda aj pamäťová zložitosť bude $O(k)$. V tejto úlohe boli ale všetky vstupy s $k=20$, tak ste mohli tvrdiť, že beh programu nezávisí od veľkosti čísel na vstupe a prehlásiť časovú zložitosť za konštantnú (takéto tvrdenie je ale vždy potrebné vysvetliť, a predsalen, časový odhad $O(k)$ je informatívnejší).

Niektorí z vás skúšali aj opačný prístup -- vkladať krabice od najmenšej. Často ste si ale nevšimli, že nám vonku ostávajú krabice rôznych veľkostí. Ak totiž príde veľká krabica (napr. taká, do ktorej sa zmestia všetky menšie), počet tých, ktoré zostanú vonku sa nedá vyrátať bez toho, aby sme sa pozreli na každú menšiu veľkosť zvlášť.
",1
fa6d7fcbc2864bbc,ksp,"# Hlúpa chata

Ako sa tak blíži čas jesenného sústredenia, treba začať hľadať chatu. Keďže však KSP všetky financie od sponzorov drží v kryptomenách, nič luxusné si nemôže dovoliť. ""Zvýšme účastnícky poplatok na 150 eur!"", navrhol Dávid. ""Tak to vôbec! Kde si také niečo videl? To radšej ušetríme na záchodoch..."", rozhorčuje sa Emma vymýšľajúc ako z nedostatku toaliet spraviť zábavu. ""Hmmm, len aby to nebolo nespravodlivé..."".

## Úloha

Chata má iba jeden záchod. Každú hodinu vedúci jednotne náhodne vyžrebujú jedného účastníka alebo účastníčku, ktorej umožnia návštevu toalety. Vediac dĺžku trvania sústredenia a počet účastníkov, Emma by rada vedela odpoveď na nasledovnú otázku. Koľko možných žrebovaní má za následok, že práve jedna osoba navštívi toaletu najviackrát zo všetkých?

## Formát vstupu

Na prvom riadku sa nachádza číslo $t$ -- počet sústredení. Na $i$-tom z nasledovných $t$ riadkov sa nachádzajú čísla $n_i, k_i$ -- počet účastníkov a počet hodín $i$-teho sústredenia.

## Formát výstupu

Vypíšte $t$ riadkov. Na $i$-tom z nich odpoveď na $i$-tu otázku modulo $10^9 + 7$.

## Hodnotenie

Úloha má 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| | **1** | **2** | **3** | **4,5** | **6** | **7,8** | |-----------------|-------|-------|-------|---------|-------|---------| | $1 \\leq t \\leq$ | 10 | 10 | 10 | 10 | 3 | 10 |\
| $1 \\leq n \\leq$ | 10 | 100 | 4 | 50 | 100 | 100 | | $1 \\leq k \\leq$ | 10 | 4 | 100 | 50 | 100 | 100 |

## Príklady

```vstup
4
2 2
6 10
5 9
4 4
```

```vystup
2
2472
600
28
```

_V prvom prípade môže ísť na záchod dvakrát prvý účastník, alebo dvakrát druhá účastníčka. Vo všetkých ostatných možnostiach by nešla na toaletu najviac krát práve jedna osoba._
","# Hlúpa chata

Ked súťažná programátorka počuje ""počet možností"", okamžite by jej malo napadnúť slovo ""dynamika"".

## Hrubá sila

Pár bodov sa dalo získať za riešenie hrubou silou. Mohli sme napríklad vyskúšať všetky možné žrebovania a zrátať vyhovujúce.

## Obmedzenia v sadách

Niektoré sady mali malé obmedzenia na $n$, alebo $k$. Tieto sady sa pravdepodobne dali riešiť odvodením vhodných matematických vzorcov.

## Takmer vzorové riešenie

Nuž, ako by sme sa na túto úlohu mohli pozerať? Ako funkčný sa ukáže prístup, kde postupne skúsime všetky možnosti pre počet návštev záchoda najviackrát vyžrebovaného účastníka.

Keď vieme, koľkokrát bol vyžrebovaný najšťastnejší účastník, nech je to $w$, potrebujeme zodpovedať na nasledovnú otázku. Koľkými spôsobmi možno rozdeliť $k-w$ návštev toalety medzi zvyšných $n-1$ účastníčiek tak, že každá získa nanajvýš $w-1$ návštev?. Pre účastníčku, ktorá bola vyžrebovaná $w$ krát je $n$ možností, preto odpoveď na našu otázku potrebujeme prenásobiť $n$. Odpoveď na celú úlohu potom bude súčet cez všetky možné maximálne počty vyžrebovaní najúspešnejšieho účastníka.

Budeme teda potrebovať zrátať dynamiku `dp[x][y][z]`, ktorá bude hovoriť, koľkými možnosťami možno rozdeliť `x` vyžrebovaní medzi `y` účastničiek tak, že každá bude vyžrebovaná nanajvýš `z` krát. Triviálne prípady, kde aspoň jedno z `x`, `y`, `z` je 0, vieme určiť jednoducho. Ako následne zrátame `dp[x][y][z]`? Skúsime všetky možnosti pre to, koľkokrát bol vyžrebovaný posledný účastník. Bude teda platiť: $$dp[x][y][z] = \\sum\_{i=0}^z dp[x-i][y-1][z]$$

Priamočiary pohľad na toto riešenie hovorí, že jeho časová zložitosť bude $O(nk^3)$. Pamäťová zložitosť je $O(nk^2)$. Keďže nám vždy stačia posledné dva riadky tabuľky `dp`, vieme túto zložitosť zlepšiť na $O(nk)$.

## Vzorové riešenie

Ako pri dynamikách býva, aj predchádzajúce riešenie sa dá zoptimalizovať. Takáto optimalizácia často spočíva v tom, že sa zbavíme jedného rozmeru a možno pri tom nejak pomiešame zvyšné rozmery tak, aby sme tretí rozmer nepotrebovali.

Môžeme iterovať cez maximálny povolený počet vyžrebovaní jedného účastníka. Počas toho budeme počítať dynamiku iba so zvyšnými dvoma rozmermi.

Časová zložitosť riešenia po takejto optimalizácii bude $O(nk^2)$. Pamäťová zložitosť je $O(nk)$.
",8
ba7c6426869dea51,ksp,"# Trefa do čierneho

Rozpálené slnko už pár dní pieklo, a tak sa Emo so Samom rozhodli, že sa uchýlia do klimatizovanej haly a zahrajú si partičku squashu. Emo využíval všetky svoje tenisové schopnosti. Keď raz napriahol ruku a švihol raketou v snahe odbiť loptičku, trafil miesto nej Samovu nohu. Tak bol ich zápas predčasne ukončený a každý išiel späť svojou cestou.

Samo sa teraz potrebuje vrátiť na internát, ktorý sa nachádza od haly smerom presne na severovýchod. Najradšej by išiel najkratšou trasou -- priamo na severovýchod. Keďže po zničujúcom údere jeho noha nie je úplne v poriadku, nie celkom sa mu to darí. Chvíľu poskakuje na svojej zdravej ľavej nohe, no vtedy namiesto toho, aby išiel na severovýchod, ide smerom na východ. Chvíľu potom kráča po oboch a vtedy sa mu darí kráčať na sever. Potom ho noha ale zase začne bolieť a musí poskakovať, a teda ísť na východ. Toto sa dookola opakuje a Samo teda miesto priamo na severovýchod ide cik-cak, raz na východ, raz na sever.

Keďže si Samo nie je istý, či sa takto vôbec dostane na internát, zaujímalo by ho, koľkokrát by pretol svoju ideálnu trasu (polpriamku idúcu od haly na severovýchod), ak by takýmto spôsobom pokračoval donekonečna.

## Úloha

Samo sa na začiatku nachádza v bode $(0,0)$ súradnicovej sústavy. Jeho pohyb sa dá popísať pomocou dvoch čísel $d_x$ a $d_y$. Samo postupne donekonečna opakuje dva posuny:

- Posun o $d_x$ metrov smerom na východ (v smere rastúcej $x$-ovej súradnice)
- Posun o $d_y$ metrov smerom na sever (v smere rastúcej $y$-ovej súradnice)

Vašou úlohou je zistiť, koľkokrát takto pretne priamku $x=y$, pričom za pretnutie rátame aj dotyk s priamkou.

## Formát vstupu

Aby sme mohli presnejšie testovať rýchlosť vašich riešení, v každom testovacom vstupe bude potrebné vyriešiť úlohu pre viacero dvojíc $d_x, d_y$.

Na prvom riadku vstupu bude číslo $t ~ (1 \\leq t \\leq 1000)$, určujúce počet zadaní úlohy, ktoré treba vyriešiť. Nasleduje $t$ riadkov, každý z nich obsahuje dve celé čísla $d_x, d_y ~ (1 \\leq d_x, d_y \\leq 10^{15})$ oddelené medzerou: číslo $d_x$ predstavujúce dĺžku posunu smerom na východ a číslo $d_y$ predstavujúce dĺžku posunu smerom na sever.

## Formát výstupu

Pre každú zadanú dvojicu $d_x, d_y$ vypíšte do samostatného riadku počet pretnutí Samovej cesty s priamkou $x=y$. V prípade, že priamku cesta pretne nekonečne veľa ráz, vypíšte $-1$. Nezabudnite vypísať znak konca riadku aj za posledným riadkom výstupu.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| ----:| ----:| ----:| | Maximálne $d_x, d_y$ | $1000$| $10^{6}$| $10^{12}$| $10^{15}$|

Všimnite si, že čísla $d_x$ a $d_y$ presiahnu $2^{31} - 1$ (zhruba $2\\cdot 10^9$), čo je najväčšie číslo, ktoré sa dá uložiť v $32$-bitovej premennej so znamienkom. Použite preto $64$-bitové premenné typu `long long` v C++ a `Int64` v Pascale.

## Príklad

```vstup
2
1 1
3 2
```

```vystup
-1
1
```

_Pri prvej ceste sa Samo priamky dotkne nekonečne veľa ráz. Pri druhej ceste sa priamky dotkne iba v bode $(0, 0)$._
","# Trefa do čierneho

## Hrubá sila

Pri tomto riešení budeme často potrebovať zistiť, či sme pod alebo nad priamkou $y = x$. To je jednoduché: pod priamkou sa nachádzame, ak je súradnica $x$ väčšia ako $y$, v opačnom prípade sme nad priamkou.

Najjednoduchšie riešenie, ktoré by nám pri tejto úlohe mohlo napanúť, je postupné simulovanie Samových posunov a rátanie pretnutí s priamkou. Problém ale je, že takéto posuny by mohli trvať potenciálne donekonečna. Preto sa treba najprv zamyslieť, kedy môžeme so simuláciou prestať. Podľa toho, v akom vzťahu sú veľkosti posunov $d_x$ a $d_y$, môžu nastať nasledujúce prípady:

- $d_x=d_y$: po každých 2 posunoch sa ocitneme opäť na priamke $x=y$, teda dotykov s priamkou bude nekonečne veľa.
- $d_x>d_y$: s priamkou sa stretneme iba raz, a to v bode $(0,0)$. Od nášho prvého pohybu sa už budeme stále nachádzať iba pod priamkou (rozmyslite si).
- $d_x\<d_y$: tu sa budeme s priamkou stretávať rôzne veľa krát. Stačí nám ale uvedomiť si, že ak sa pri nejakom pohybe doprava nepretneme s priamkou, už nikdy sa s ňou nepretneme. Od tohto momentu budeme totiž celý čas už iba nad priamkou.

Keď už poznáme tieto tri situácie, môžeme sa pustiť do programovania nášho riešenia. Na začiatku skontrolujeme, či sa veľkosti posunov nerovnajú, alebo či nie je posun doprava väčší ako ten smerom hore. Ak áno, vypíšeme potrebný výsledok. Ak nie, simulujeme pohyb po mriežke a po každom kroku zistíme, či sme sa pretli s priamkou. S priamkou sa pretneme vtedy, ak sme išli spod priamky nad ňu, alebo naopak (samozrejme, nezabúdame na ošetrenie dotyku s priamkou). Ak sme sa pri niektorom pohybe doprava nepretli s priamkou, simuláciu ukončíme a vypíšeme počet pretnutí.

Pamäťová zložitosť tohto riešenia je $O(1)$, keďže miesto, kde sme, a veľkosti posunov si udržiavame v pár premenných.

Časová zložitosť riešenia je priamo úmerná počtu krokov, ktoré odsimulujeme. Ten je zhruba rovný počtu pretnutí s priamkou (ak dva kroky po sebe priamku nepretneme, simuláciu ukončíme). Ako si ukážeme v časti o ideálnom riešení, počet pretnutí je (v zaujímavom prípade $d_x < d_y$) zhruba $d_x/(d_y-d_x)$, časová zložitosť je preto $O(d_x/(d_y-d_x))$ = $O(d_x)$.

## Ideálne riešenie

Ako sme si pri riešení hrubou silou mohli všimnúť, v dvoch prípadoch sme mali odpoveď hneď, bez akejkoľvek simulácie. Ak sa bližšie zamyslíme a nakreslíme si pár obrázkov, zistíme, že aj v poslednom prípade vieme počet dotykov vypočítať v konštantnom čase.

Simuláciu sme ukončovali, keď sme prvý raz urobili krok doprava, pri ktorom sme našu priamku nepretli, ale zostali sme nad ňou. Bol to vlastne prvý krok doprava, po ktorom bola naša $y$-ová súradnica väčšia, než $x$-ová. Pozrime sa preto na body, v ktorých budeme po pohybe smerom vpravo, čiže po prvom kroku, po treťom kroku, atď. a všímajme si, o koľko je ich $x$-ová súradnica väčšia, než $y$-ová. Po prvom posune má $x$-ová súradnica ""náskok"" $d_x$, keďže sme v bode $(d_x, 0)$. Po každých dvoch krokoch však $y$-ová súradnica tento ""náskok"" stiahne o $d_y - d_x$. Na to, aby $y$-ová súradnica ""dobehla"" tú $x$-ovú, teda treba $\\lceil d_x/(d_y-d_x) \\rceil$ takýchto dvojkrokov. Pri každom takomto dvojkroku, možno s výnimkou posledného, pretneme priamku dvakrát, počet pretnutí teda bude zhruba $2 d_x/(d_y-d_x)$.

Do vzorca nesmieme zabudnúť pripočítať pretnutie v bode $(0,0)$ kde začíname. Ďalej je potrebné si uvedomiť, že nám vzniknú 2 prípady, pri ktorých sa počty mierne líšia:

- V prípade, že je $d_x$ deliteľné číslom $d_y-d_x$, po $d_x / (d_y-d_x)$ dvojkrokoch budeme presne na priamke. To znamená, že v každom dvojkroku priamku pretneme dvakrát, spolu s pretnutím v bode $(0, 0)$ teda dostávame vzorec: $2 \\cdot d_x/(d_y-d_x) + 1$

- Ak $d_x$ nie je deliteľné číslom $d_y - d_x$, po $\\lceil d_x / (d_y-d_x) \\rceil$ dvojkrokoch skončíme nad priamkou. To znamená, že v poslednom z týchto dvojkrokov sme priamku pretli iba raz. Spolu s pretnutím v $(0,0)$ teda dostaneme vzorec: $2 \\cdot \\lceil d_x/(d_y-d_x) \\rceil$.

Časová aj pamäťová zložitosť tohto riešenia je konštantná, keďže potrebujeme iba pár premenných na výpočet vzorca, teda $O(1)$.

### Technická poznámka

Pri výpočte hodnoty $\\lceil d_x/(d_y-d_x) \\rceil$ potrebujeme vydeliť dve čísla a výsledok zaokrúhliť nahor. Programovacie jazyky ako Python a C++ však pri celočíselnom delení zaokrúhľujú nadol. Preto v kóde vzorového riešenia využívame fakt, že $d_x$ nie je deliteľné číslom $d_y - d_x$, teda $\\lceil d_x/(d_y-d_x) \\rceil = \\lfloor d_x / (d_y - d_x) \\rfloor + 1$.
",1
8414db2f46c1ccde,ksp,"# Romantické výhľady

Kika je nadšený cestovateľ a Aďo je nadšený fotograf. Kika sa práve chystá krátky výlet. Snaží sa ho naplánovať tak, aby bol zaujímavý aj pre Aďa, ktorému sa cestovať až tak veľmi nechce. Dostala nápad na turistiku po náučnom chodníku. Chodník je vlastne okruh idúci po hrebeni kopca, na ktorý sa môžu pripojiť v ľubovoľnom mieste. V žiadnom bode sa však nesmú otočiť a ísť opačným smerom. Čiže, ak sa zarozprávajú, môžu prejsť fakt veľa koliesok.

Na chodníku leží aj zopár krásnych vyhliadok. Kike sa podarilo Aďa namotivovať na možnosť spraviť si zopár FAKT luxusných fotiek, a tak šli. Chodník šiel niekedy hore kopcom, niekedy dole kopcom.

Aďo prichádzajúci na vyhliadku by už chcel spraviť záber, no Kika majúc špeciálne požiadavky na miesto fotografie ho zastavila. Musia totiž nájsť trojicu vyhliadok, kde prostredná z nich bude vo vyššej nadmorskej výške ako tie druhé dve. Chceme predsa ten najlepší výhľad, kde v zábere sú aj ďalšie vyhliadky -- veď sa hovorí: ""Epická fotka, alebo sa to nestalo"", a teda by im možno ľudia neverili, že boli na turistike v kopcoch. Aďov foťák však nezaostrí do veľkej vzdialenosti, a preto chcú fotiť z vyhliadky, ktorá je čo najbližšie k svojim nižším susedným vyhliadkam.

Pochodujúc kopcami začínajú byť unavení, možno sa o chvíľu zotmie a na fotke nebude nič vidieť. Pomôžte im nájsť hľadané vyhliadky čo najrýchlejšie!

## Úloha

Vašou úlohou je nájsť tri vyhliadky $v_i$, $v_j$ a $v_k$ (nie nutne rôzne -- $v_i$ a $v_k$ môžu byť tie isté) také, že nadmorská výška vyhliadky $v_j$ je vyššia ako nadmorské výšky vyhliadok $v_i$ a $v_k$. Zároveň chceme aby vzdialenosti vyhliadok $(v_i$ a $v_j)$ a $(v_j$ a $v_k)$ boli najmenšie možné (ak $v_i$ a $v_k$ sú tá istá vyhliadka, tak nie nutne budú vzdialenosti zľava ku strednej a od strednej ku pravej rovnaké). Vzdialenosť medzi vyhliadkami $v_i$ a $v_j$ sa vypočíta ako $j-i$.

## Formát vstupu

V prvom riadku je číslo $n$ udávajúce počet vyhliadok na chodníku.

V druhom riadku nasleduje $n$ čísel, reprezentujúcich nadmorské výšky jednotlivých vyhliadok na chodníku. Nadmorské výšky jednotlivých vyhliadok sú navzájom rôzne a zároveň pre všetky výšky $v_i$ platí $v_i > 1$.

Nezabudnite na to, že náučný chodník je okruh, a teda prvá vyhliadka z trojice môže byť napríklad medzi poslednými číslami vstupu a tretia vyhliadka trojice medzi prvými.

Sú 4 sady vstupov a môžete v nich predpokladať nasledujúce obmedzenia ($n$ -- počet vyhliadok, $v_max$ -- obmedzenie výšok vyhliadok):

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|----------:|---------------:|---------------:|--------------:| | $2 \\leq n \\leq$ | $100$ | $10^3$ | $10^4$ | $10^5$| | $1 \\leq v\_{max} \\leq$ | $200$ | $2 \\cdot 10^3$ | $2 \\cdot 10^5$ | $2 \\cdot 10^6$|

## Formát výstupu

Vypíšte jeden riadok a v ňom tri čísla -- pozície vyhliadok z vybranej trojice v pôvodnom vstupe -- oddelené medzerou. Vypíšte ich v poradí ľavá, stredná a pravá.

## Príklady

```vstup
2
20 16
```

```vystup
1 0 1
```

*Ak odfotí fotku z vyhliadky vo výške 20, tak jej zľava susedná (s najmenšou vzdialenosťou) bude vo výške 16 a zároveň aj pravá susedná (s najmenšou vzdialenosťou) bude vo výške 16.*

```vstup
4
1 5 3 4
```

```vystup
0 1 2
```

```vstup
4
2 0 1 6
```

```vystup
2 3 0
```
","# Romantické výhľady

Vyhliadky, náučný chodník a okruh, po ktorom može Kika s Aďom chodiť, až do vysilenia. Aj o tom bola táto úloha a my sa teraz pozrieme na nejaké jej riešenia.

## Bruteforce

V prvom rade si však ujasnime jednu vec. Náučný chodník je síce okruh, ale aj tak si ho budeme reprezentovať ako obyčajné pole. Akurát, vždy, keď sa budeme pozerať na prvú (resp. poslednú) vyhliadku, tak za jej prvú ľavú (resp. pravú) susednú vyhliadku budeme považovať poslednú (resp. prvú) vyhliadku.

Aby sme sa však vyhli problémom s prvou a poslednou vyhliadkou, ich susedmi a ich indexami v našom poli, tak si jednoducho celé pole zapamätáme dvakrát za sebou (skopírujeme si danú postupnosť vyhliadok a vložíme ju za už zapamätanú postupnosť). Takže vo výsledku budeme mať hneď za posledným prvkom prvý.

Prvá myšlienka, ktorá nám môže napadnúť je vyskúšať všetky možnosti trojíc vyhliadok a zistiť, či pre ne platia Kikine podmienky.

Teda postupne si zvolíme jednotlivé výhliadky tak, že za prvú dosadíme postupne všetky možnosti, za tretiu tak isto a za prostrednú zvolime niektorú z vyhliadok medzi prvou a druhou. Pre túto trojicu musí platiť to, že dve krajné vyhliadky z tejto trojice majú súčet ich vzdialeností k prostrednej najmenší možný.

Môžeme teda ísť cez všetky takéto trojice a pamätať si, akú najlepšiu trojicu sme zatiaľ videli. Keďže sme si pole skopírovali, stačí nám prechádzať cez trojice indexov $(i, j, k)$ pre ktoré platí $0\\leq i \\leq j \\leq k < 2n$. Súčet vzdialeností k prostrednej je potom $k - i$. Na konci vypíšeme skutočné indexy najlepšej nájdenej trojice. Všimnite si, že na to, aby sme z upravených pozícií vyhliadok dostali ich skutočné pozície, stačí nám zobrať zvyšok po vydelení $n$.

Takže, čo sa týka zložitostí: jednorázovo kopírujeme vstupné $n$-prvkové pole a skúšame overovať všetky trojice, ktorých je rádovo $n^3$. Z tohoto nám vyjde časová zložitosť $O(n^3)$. Pamäťová bude $O(n)$ pretože si pamätáme len jedno pole, ktoré má $2n$ prvkov (ale 2 je konštanta, takže tú zanedbáme).

## Niečo lepšie

Skúšanie všetkých trojíc nie je úplne optimálne. Ak by sme však vedeli povedať niečo viac o tých troch vyhliadkach, tak by nám to pomohlo. Vieme že prostredná z nich musí byť vyššia ako jej susedné. To je ale len jej vzťah k jej susedným vyhliadkam a nehovorí to nič o vzťahu k ostatným vyhliadkam. Čiže môže mať kľudne tretiu najmenšiu nadmorskú výšku a s jej susednými spĺňať Kikine podmienky, ale môže to byť kľudne aj najvyššie položená vyhliadka s jej susedmi. A od tohoto sa odrazíme.

Dôležité pozorovanie je, že výšky vyhliadok sú navzájom _rôzne_. A tým pádom, ak zoberieme najvyššiu vyhliadku, jej susedné vyhliadky (z každej strany) musia byť nutne nižšie. Takáto trojica má súčet rozdielu vzdialeností $2$, a lepší súčet dosiahnuť nemôžme (zamyslite sa).

Takže nám stačí nájsť vyhliadku s najväčšou nadmorskou výškou a vziať jej susedov. Ako ju nájsť?

Ak by sme mali vyhliadky zoradené podľa výšky vzostupne, tak by to bola tá posledná. Ale ako potom nájdem jej najbližšie susedné vyhliadky, keď zmením ich poradie, tým že ich zoradím? Budem si jednoducho pamätať dve polia -- jedno bude kópia druhého, ale bude zoradené podľa nadmorských výšok. Zoradiť ho môžeme pomocou nejakého [triediaceho algoritmu](https://www.ksp.sk/kucharka/triedenie/) alebo jednoducho využijeme funkciu `sort`, ktorá je už vo väčšine jazykov implementovaná.

Teraz najvyššiu výhliadku nájdeme v pôvodnom, nezoradenom poli a vezmeme jej susedov. Tu nemusíme nejak špeciálne riešiť prípad, že prostredná je prvá alebo posledná v poli a teda jej najbližší sused je na opačnom konci pola. Skrátka jednoducho pridáme podmienky, ktoré nám vrátia presných susedov na základe pozície najvyššej vyhliadky.

Časová zložitosť tohoto riešenia bude $O(n \\log n)$ -- najzložitejšia časť v tomto riešení je triedenie, ktorého zložitosť je $O(n \\log n)$. Potom už len hľadáme pozíciu najvyššej vyhliadky v pôvodnom poli, čo bude v najhoršom prípade $O(n)$, ale to je oproti $O(n \\log n)$ zanedbateľné. Pamäťová zložitosť\
bude $O(n)$, lebo si pamätáme iba 2 polia dĺžky $n$.

## Optimálne riešenie

Keď sa lepšie pozrieme na predošlé riešenie, tak zistíme, že pri prechode poľa s nadmorskými výškami nemusíme iba hľadať pozíciu najvyššej vyhliadky, ale aj zisťovať, ktorá výhliadka je najvyššia. Vďaka tomu sa môžeme úplne zbaviť zoraďovania vyhliadok a zrýchliť naše riešenie.

Takže stačí nám raz prejsť pole zo vstupu a postupne hľadať najvyššiu vyhliadku. Budeme mať nejaké dve premenné, v ktorých si budeme v každom momente pamätať doteraz najvyššiu vyhliadku a jej pozíciu. Čiže pri prechode poľa, vždy keď nájdeme vyhliadku, ktorá je vyššie ako tá, ktorú si pamätáme ako doteraz najvyššiu, tak tie dve premenné prepíšeme. No a na konci budeme mať v premenných najvššiu vyhliadku aj s jej pozíciou.

Už nám stačí iba nájsť najbližšie susedné vyhliadky k najvyššej a vypísať ich.

Keďže algoritmus iba raz prejde $n$-prvkové pole, časová zložitosť bude $O(n)$ a pamätáme si tiež len toto pole a konštatný počet premenných, takže pamäťová zložitosť bude $O(n)$.
",2
ab3e0ac5ea1e332f,ksp,"# Zoraď všetky slová, vypíš $n$-té

Vlejdovi sa veľmi zapáčila úloha Zwarte doos z minulej série. Hneď vyriešil všetkých desať hlavolamov. Bohužiaľ, potrvá celkom dlho kým zwarte doos načerpá novú inšpiráciu a vymyslí nové hlavolamy. Preto sa Vlejd od nudy začal zamýšľať, ako taká zwarte doos funguje. Najviac sa mu zapáčil šiesty level z prvej série. Zistil, že krabička vie celkom rýchlo odpovedať aj keď do nej hodí veľmi veľké číslo. Rozhodol sa, že si to vyskúša naprogramovať.

## Úloha

Predstavte si, že zoberiete všetkých 26 veľkých písmen anglickej abecedy a poskladáte z nich všetky možné slová. Tieto slová potom zoradíte. Najskôr podľa dĺžky a potom podľa abecedy. Takto získate postupnosť, ktorej prvky vám vracala šiesta krabička. Prvé slovo je `A` a za ním nasledujú `B`, `C`, ..., `Z`, `AA`, `AB`, `AC`, `AZ`, `BA`, ..., `ZZ`, `AAA`, ...

Vašou úlohou bude urobiť program, ktorý na vstupe dostane číslo $n$ a vypíše $n$-té slovo vyššie spomenutej postupnosti. Pre $1$ má teda vypísať `A`, pre $28$ `AB` ...

## Vstup

Na prvom riadku vstupu je $1 \\leq t \\leq 10,000$ -- počet otázok pre krabičku. V každom z nasledujúcich $t$ riadkov sa nachádza číslo $1 \\leq n \\leq 10^{15}$.

## Výstup

Pre každú otázku vypíšte $n$-té slovo postupnosti.

## Príklady

```vstup
5
2
1
4961867752
47
7946
```

```vystup
B
A
PAPAGAJ
AU
KSP
```
","# Zoraď všetky slová, vypíš n-té

Začneme tým, že si spočítame akú dĺžku má $n$-té slovo. Slov dĺžky $1$ je $26$. Slov dĺžky $2$ je $26 \\cdot 26$, lebo na prvej pozícii môže byť $26$ rôznych písmen a na druhej môže byť tiež $26$ písmen. Vo všeobecnosti, slov dĺžky $k$ je $26^k$. Takže v cykle budeme postupne odčítavať počty slov dĺžky $i$ od $n$ kým bude platiť, že $n > 0$. Ak totiž platí $n - 26^i > 0$^[Uvedomte si, že hodnota $n$ v tejto nerovnici vyjadruje pôvodnú hodnotu $n$, od ktorej sme už odčítali všetky menšie mocniny $26$.], tak sa hľadané slovo nachádza v postupnosti až za všetkými slovami dĺžky $i$, čiže musí byť nutne dlhšie ako $i$. Ak $n - 26^i \\leq 0$, tak to znamená, že hľadané slovo má dĺžku $i$.

V ďalšej fáze zistíme, z akých písmen sa toto slovo skladá. Nech je naše slovo dĺžky $d$. Potom všetkých slov dĺžky $d-1$ je $26^{d-1}$. Teda slov dĺžky $d$ začínajúcich na písmeno `A` je $26^{d-1}$. Zasa by sme mohli v cykle odčítavať počty slov začínajúcich na písmeno `A`, potom na písmeno `B`, písmeno `C` atď. Myšlienka je rovnaká ako pri hľadaní dĺžky.

Všimnite si, že zakaždým odčítavame to isté číslo číslo, takže rozumnejšie bude použiť celočíselné delenie. Teda $n/26^{d-1}$ hovorí, koľkokrát môžeme odčítať $26^{d-1}$ od $n$ aby sme neklesli pod $0$ a zvyšok po delení je to čo nám z $n$ ostane po odčítavaní. Takýmto spôsobom zistíme každé písmeno slova. (V zdrojovom kóde, ktorý sa nachádza nižšie sme využili to, že hodnoty $26^{d-1}$ sme si predpočítali dopredu v predchádzajúcom cykle.)

Pamäťová zložitosť je zjavne $O(1)$, lebo sme na zapamätávanie použili len pár premenných.

Pozrime sa na časovú zložitosť tohto algoritmu. Nech dĺžka slova je $d$. Potom aj prvý, aj druhý cyklus urobí zhruba $d$ operácii. Poďme spočítať aké veľké je číslo $d$. Z predchádzajúceho algoritmu pre $d$ a $n$ platí:

$$n \\leq 26^0 + 26^1 + \\dots + 26^d$$

Toto nie je nič iné ako súčet členov geometrickej postupnosti na čo použijeme vzorec^\[Odporúčam vygoogliť.\]:

$$n \\leq \\frac{26^{d+1}-1}{25}$$

To znamená, že $n$ je zhruba tak veľké ako hodnota $26^d$ (Zanedbali sme nejaké konštanty, ktoré sa stratia v $O$-notácii.). Hodnotu $d$ preto môžeme slovne popísať ako: číslo, na ktoré keď umocním číslo $26$, dostanem hodnotu $n$.

No a na vyjadrenie takýchto hodnôt používajú matematici pojem logaritmus. Zapisuje sa to ako $\\log_a b = c$, číta sa to ako logaritmus z $b$ pri základe $a$ sa rovná $c$ a vyjadruje to, že ak umocním hodnotu $a$ na číslo $c$ dostanem číslo $b$ ($a^c=b$). Časovú zložitosť preto môžeme vyjadriť ako $O(\\log\_{26} n) = O(\\log n)$. Keďže tento výpočet urobíme pre každý riadok vstupu, tak celková zložitosť je $O(t \\log n)$.

Opäť si odporúčam pogoogliť niečo o logaritmoch, je to v informatike veľmi používaný pojem a oplatí sa poznať vzorce na ich úpravu a vedieť, čo zhruba znamenajú.
",4
9acbbcc8d8492ffc,ksp,"# Zakázané ohňostroje

Konečne deň, na ktorý sa Emo celý rok tešil -- *Silvester*. Tento rok ho chce stráviť na internáte v Bratislave. Keď sa to dozvedel jeho kamarát, neodpustil si štipľavú otázku, či už má nakúpené ohňostroje^[v Bratislave sú totiž po novom zakázané.]. Emo iróniu nepochopil a tak, keďže nemal, začal narýchlo nejaké zháňať.

Zobral auto a šup ho na cesty. Ešte sa vo svojom rodnom meste^[ktoré už trikrát vypálili, má 2 semafory (ak nerátame jeden nový pri hasičskej stanici) a 4 kruhové objazdy] zastavil v obchode s pyrotechnikou a minul tam takmer celú výplatu. Odtiaľ už išiel priamo do Bratislavy.

Keď zišiel z diaľnice, zastavil sa ešte na benzínke. Ako tak tankoval, započúval sa do rádia a takmer dostal infarkt. Práve totiž išli správy o situácii v Bratislave:

- Za púšťanie rakiet v Bratislave hrozí veľká *pokuta*.

- Keďže policajti očakávajú v tento deň veľký počet výtržností^[púšťania ohňostrojov], vymysleli si systém ako mať všetko pod kontrolou. Po meste na náhodné pevne určené miesta umiestnili **policajné kontroly**, kde kontrolujú obsah každého auta. Nemôžu dať síce pokutu za to, že niekto ohňostroj prepravuje, ale môžu si ho poznačiť a navštíviť večer.

- Aby bolo ťažké sa kontrole vyhnúť, na každej križovatke, kde nie je kontrola, stojí policajt ukazujúci len jeden prípustný smer jazdy. Každému, kto by z takejto križovatky chcel odísť iným, než povoleným smerom, dá pokutu (ale nechá ho ísť).

Emo si nejakú tú raketku neodpustí. Cesta na intrák tak preňho nebude iba o šoférovaní. Potrebuje v prvom rade zistiť **kade má na intrák ísť tak, aby minul čo najmenej peňazí na pokuty**.

Rýchlo preto zavolal Zajovi, nech mu pomôže. Zajo je totiž rodený Bratislavčan a má prístup k informáciám, o ktorých iní môžu len snívať. Potrebuje však vašu pomoc, aby vedel Emovi rýchlo odpovedať skôr ako si niekto všimne, že ešte aj telefonuje za volantom!

## Úloha

Pre účely tejto úlohy budeme Bratislavu považovať za obdĺžnik $r \\times s$ križovatiek. Na každej križovatke sa dá prejsť rovno, odbočiť vpravo, vľavo, aj otočiť sa.

Existujú križovatky nasledovných typov:

- _Križovatky s prikázaným smerom odjazdu_: tieto križovatky majú len jeden povolený smer odjazdu. Ak z nich Emo odíde iným ako povoleným smerom, dostane pokutu. Veľkosť tejto pokuty môže byť rôzna pre rôzne smery. Napríklad pre križovatky s prikázaným smerom odjazdu hore môže byť iná pokuta ako pre križovatky s prikázaným smerom odjazdu dole.

- _Križovatky s kontrolou_: tieto križovatky nemajú žiadne obmedzenia na to, ako cez ne môžete jazdiť, ale policajti na nich kontrolujú obsah kufra. Ak Emo počas cesty na internát prejde čo i len cez jednu takúto križovatku, o polnoci bude musieť zaplatiť pokutu za odpálenie rakety. Ak Emo prejde cez viacero takýchto križovatiek, bude platiť rovnako veľa, ako keby prešiel len cez jednu.

- _Križovatka s internátom_: táto križovatka je Emov cieľ. Prikázaný smer odjazdu z tejto križovatky nás nezaujíma, lebo Emo z tejto križovatky už nechce ísť ďalej.

- _Križovatka s benzínkou_: na tejto križovatke Emo začína a nie je tam ani kontrola, ani prikázaný smer odjazdu.

- Na niektorých políčkach obdĺžnika nie sú križovatky, ale _Dunaj_. Sem sa Emo s autom nikdy nechce dostať!

Dostanete popis situácie v Bratislave a aj veľkosti jednotlivých pokút. Zistite, koľko najmenej môže Emo zaplatiť na pokutách, ak chce prísť na internát a o polnoci tam odpáliť raketu. Počas svojej cesty nemôže opustiť Bratislavu.

**Nepredpokladajte**, že sa v Bratislave dá dostať na každú križovatku bez porušenia predpisov! Dokonca je možné, že na niektorých križovatkách je prikázaný smer jazdy do Dunaja.

## Formát vstupu

Na prvom riadku vstupu dostanete medzerami oddelené postupne veľkosti pokút $P_O, P_L, P_P, P_H, P_D$: veľkosť pokuty za ohňostroj (ktorú Emo zaplatí, ak prejde cez nejakú kontrolu) a za porušenie prikázaného smeru odjazdu vľavo, vpravo, hore a dole. Všetky pokuty sú celé čísla z rozsahu $0$ až $10^{12}$ (vrátane).

Nasleduje riadok s rozmermi mapy $r, s$ ($1 \\leq r \\cdot s \\leq 100,000$). Ďalej nasleduje $r$ riadkov po $s$ znakoch popisujúcich samotnú Bratislavu. Každý z týchto znakov určuje typ jednej križovatky.

Znaky popisujúce križovatky môžu byť nasledovné: `K` -- križovatka s kontrolou; `E` -- križovatka s benzínkou, kde Emo začína; `I` -- križovatka s internátom (cieľ); `L, P, H, D` -- križovatky s prikázaným smerom odjazdu vľavo, vpravo, hore alebo na dole; `~` -- Dunaj.

Môžete predpokladať, že na mape sa aj intrák aj Emo nachádzajú práve raz.

## Formát výstupu

Vypíšte, koľko najmenej môže Emo zaplatiť na pokutách, ak sa chce dostať na intrák a o polnoci tam odpáliť raketu. V prípade, že neexistuje cesta vypíšte `-1`.

## Hodnotenie a obmedzenia

Pre jednotlivé sady testov navyše platia nasledovné obmedzenia. Za vyriešenie každej sady získate 1 bod.

| číslo sady | križovatky typu `K`| veľkosti pokút | rozmery mapy | |:----------:|:-------------------|:--------------------------|:--------------------------| | 1 | na mape **nie** sú | pokuty sú 0 | $2 \\leq r \\cdot s \\leq 50$ | | 2 | na mape **nie** sú | pokuty sú buď 0 alebo 1 | $2 \\leq r \\cdot s \\leq 100,000$ | | 3 | na mape **nie** sú | pokuty sú ľubovoľné | $2 \\leq r \\cdot s \\leq 70$ | | 4 | na mape **nie** sú | pokuty sú ľubovoľné | $2 \\leq r \\cdot s \\leq 100,000$ | | 5 | na mape sú | pokuty sú ľubovoľné | $2 \\leq r \\cdot s \\leq 10,000$ | | 6 | na mape sú | pokuty sú ľubovoľné | $2 \\leq r \\cdot s \\leq 100,000$ |

## Príklad

```vstup
10 10 1 6 4
4 3
HLL
IPK
D~H
DLE
```

```vystup
8
```

_Optimálna cesta na internát vyzerá nasledovne: Z benzínky pôjde Emo doľava, pričom neplatí žiadnu pokutu, lebo na benzínke policajti nie sú. Potom pôjde opäť doľava, pričom opäť neplatí pokutu, lebo odišiel povoleným smerom. Následne pôjde dvakrát nahor, pričom oba razy poruší prikázaný smer jazdy nadol, teda dvakrát zaplatí pokutu $4$. Keďže Emo neprešiel cez žiadnu kontrolu, o polnoci nedostane žiadnu pokutu._

```vstup
1 2 3 4 5
2 2
E~
~I
```

```vystup
-1
```

_Emo môže rovno odparkovať, nikam sa nedostane._

```vstup
1000 1 2 3 4
4 6
DHHHPK
LELKHK
~P~PKL
PKLHI~
```

```vystup
1001
```

_Kontrole sa cestou na internát nedá vyhnúť. Optimálne je ísť najprv trikrát doprava, potom hore, doprava, dvakrát dole, doľava a dole. Všimnite si, že po ceste Emo prejde až cez štyri kontroly, pokutu za odpaľovanie ohňostrojov však aj tak zaplatí iba raz. Okrem toho ešte poruší jeden prikázaný smer odjazdu vľavo, takže dokopy na pokutách zaplatí $1000 + 1 = 1001$._
","# Zakázané ohňostroje

Na začiatku si ukážeme jedno korektné riešenie, ktoré síce správne vyrieši každý vstup, no je **príliš** pomalé pri veľkých rozmeroch. Na toto riešenie ďalšie nenaväzujú, preto, ak chcete, môžete toto preskočiť (bude označené hviezdičkou). Následne si ukážeme, ako bolo možné využiť spomínané obmedzenia na jednotlivé sady a na záver si predstavíme algoritmus, ktorý rýchlo a správne vyrieši všetky sady vstupov.

Pri implementácii všetkých riešení používame dva triky často používané pri úlohách s mriežkami: zarážky a polia zmien súradníc k susedom. Ak ste sa s týmito trikmi doteraz nestretli, viac sa o nich dozviete v [Kuchárke](https://ksp.sk/kucharka/mriezky_implementacia).

## Bratislava ako bludisko (\*)

Predstavme si Bratislavu, ktorú dostaneme na vstupe, ako bludisko. Ako nájsť cestu z bludiska? Jedna z možností je predstaviť si, že máme k dispozícii niť, ktorou si značíme kade chodíme^[Ariadnina niť]. Na každej križovatke odbočíme doprava. Akonáhle prídeme do slepej uličky alebo na miesto, kde sme už boli, vrátime sa späť a pôjdeme odbočkou, ktorou sme ešte nešli a zároveň je najviac napravo. Tento postup opakujeme, kým sa z bludiska nedostaneme von.

Pokúsme sa aplikovať tento postup na hľadanie najlacnejšej cesty na intrák. Potrebujeme si pri každom odbočovaní rátať sumu doteraz zaplatených pokút, a že či sme prešli cez nejaké kontroly. Ako niť použijeme pole booleanov `vis`. Na riešenie použijeme [rekurzívnu](https://ksp.sk/kucharka/rekurzia) funkciu, ktorá bude prehľadávať všetky cesty. Nech sme na políčku $(x, y)$. Ak je toto cieľové políčko, tak sme vyhrali a stačí nám obnoviť globálnu premennú, v ktorej si udržiavame cenu doteraz najlacnejšej nájdenej cesty do cieľa. V opačnom prípade skontrolujeme, že či toto políčko náhodou nie je Dunaj alebo políčko, na ktorom sa nachádza naša niť. V takom prípade nechcem ďalej pokračovať v ceste a vraciame sa späť. Inak nastavíme `vis[x][y] = true` a skúšame sa rekurzívne zavolať na všetkých susedov tohto políčka. Vracanie sa po niti predstavujú návraty z rekurzívnych volaní. Pri návrate z rekurzívneho volania sa pokúsime ísť ďalším smerom. Ak už sme prešli všetky smery, tak nastavíme `vis[x][y] = false`, čo prestavuje to, že niť sa už na tomto políčku nebude nachádzať, lebo ideme späť. Tento algoritmus sa volá aj **backtracking**.

### Časová a pamäťová zložitosť

Riešenie backtrackingom je pekné a jednoduché, ale má jednu nevýhodu -- je **pomalé** (samozrejme aj pomalé, správne riešenie dostane nejaké body). Cesta, pri ktorej Emo najmenej minie môže byť ozaj ktorákoľvek, a teda musíme vyskúšať **všetky**, ktoré existujú. Na každej križovatke rozoberieme 4 možnosti. Pre každú možnosť rozoberieme na ďalšej križovatke 4 možnosti, atď. Časová zložitosť tohto riešenia je teda $O(4^{rs})$. Pamäťová zložitosť je $O(r \\cdot s)$ -- veľkosť mapy Bratislavy a hĺbka zásobníka pri rekurzii.

Výsledný program by mohol vyzerať takto:

## Predstava Bratislavy ako grafu

Bratislava sa dá predstaviť ako orientovaný ohodnotený [graf](https://ksp.sk/kucharka/grafy_uvod). Križovatky sú vrcholy. Hrana z križovatky $a$ vedie do križovatky $b$, ak sú tieto križovatky susedné. Ohodnotenia hrán sú pokuty, ktoré Emo zaplatí, ak prejde medzi týmito dvoma križovatkami. Hrany sú orientované, lebo hoci sa Emo vie dostať aj opačne, môže to byť za inú pokutu. Ak je odbočenie zadarmo (v smere prikázaného smeru, prípadne z križovatky bez obmedzení), pridáme hranu s nulovou cenou. Z Dunaja hrany nepridávame. Kontroly zatiaľ neuvažujeme.

V tejto interpretácii je našou úlohou nájsť najlacnejšiu cestu v grafe, na čo existujú rozumne rýchle algoritmy.

## Čo ak pokuty neexistujú?

V prvej sade vstupov sa pokuty nenachádzali. V našej predstave to znamená, že všetky ceny v grafe sú nulové, a teda celková cena bude buď `0` ak existuje cesta na intrák, prípadne `-1` ak neexistuje.

Ako zistiť, či nejaká cesta existuje? Jedna z možností je použiť algoritmus prehľadávania do hĺbky. Tento algoritmus sa podobá backtrackingu, ktorý sme si vysvetlili pri pomalom riešení. Jediný rozdiel je, že keď pri vynáraní sa z rekurzie opúšťame nejaký vrchol, necháme ho označený ako navštívený. Toto nám zaručí, že každý vrchol navštívime iba raz a časová zložitosť bude $O(r \\cdot s)$. Takéto zrýchlenie si môžeme dovoliť urobiť vďaka tomu, že teraz na nájdenie najlacnejšej cesty nepotrebujeme vyskúšať všetky možnosti, keďže každá cesta je rovnako dobrá (má cenu nula). Ako a prečo to celé funguje sa dočítate v [Kuchárke](https://ksp.sk/kucharka/dfs).

Inou rovnako rýchlou možnosťou je použiť iný základný grafový algoritmus -- [prehľadávanie do šírky](https://ksp.sk/kucharka/bfs) (známe tiež pod anglickým názvom *breadth-first search*, BFS).

## Čo sa zmení, keď pridáme pokuty veľkosti 1?

Nakoľko už budeme chcieť nájsť aj reálne najlacnejšiu a nielen tak hocijakú cestu, prehľadávanie do hĺbky nám už nepomôže. Prehľadávanie do šírky však vieme rozumne vylepšiť tak, aby nám pre dva druhy cien -- jednu nulovú a druhú nejakú inú (napr. 1) hľadalo najlacnejšiu cestu.

Princíp prehľadávania do šírky sa opiera o to, že sa používa fronta. Vďaka nej vieme nájsť najlacnejšiu cestu v grafe, kde sú všetky hrany rovnakej dĺžky. Pri BFS platí, že v každom momente sú vrcholy vo fronte usporiadané podľa ceny, ktorou sa do vrcholu vieme dostať.

Predstavme si teraz, že nebudeme využívať frontu, ale **obojsmernú frontu**. Táto dátová štruktúra nám umožňuje pridávať prvky aj na začiatok, aj na koniec. Ak vedie do vrcholu nulová hrana, pridáme ho na začiatok. Ak doňho vedie jednotková hrana, pridáme ho na koniec. Všimnite si, že takýmto spôsobom udržiavame vrcholy vo fronte utriedené podľa dĺžky najkrajšej cesty.

Tento algoritmus sa tiež zvykne označovať ako **0/1 BFS**. Časová zložitosť je rovnaká ako pri klasickom BFS, $O(r \\cdot s)$, pamäťová takisto.

## Ale pokuty predsa môžu byť ľubovoľné...

Teraz sa pozrime na prípad, keď dĺžky hrán môžu byť ľubovoľné. Potrebujeme dátovú štruktúru, do ktorej vieme rýchlo pridávať prvky a vyberať z nej najmenší prvok. V prípade nulových a jednotkových hrán nám obojsmerná fronta postačila\\footnote{Namiesto obojsmernej fronty sme mohli použiť aj dva zásobníky, aby sme udržiavali prvky utriedené podľa ceny}. Vo všeobecnom prípade budeme potrebovať zbraň vyššieho kalibru. Vhodnou dátovou štruktúrou je napríklad halda. Použitím haldy vlastne získame [Dijkstrov algoritmus](https://ksp.sk/kucharka/dijkstra) na hľadanie najlacnejšej cesty. Dostaneme tak rýchle riešenie v časovej zložitosti $O(rs \\cdot \\log (rs))$ (počet vrcholov je $r \\cdot s$ a počet hrán je $4 \\cdot r \\cdot s$). Pamäťová zložitosť je $O(r \\cdot s)$ -- veľkosť mapy a v najhoršom prípade aj veľkosť haldy.

## Čo s kontrolami?

Stále sme si však od testovača zarobili len 4 body zo 6-tich. Potrebujeme ešte vyriešiť ako naložiť s križovatkami, kde prebiehajú kontroly.

Najjednoduchšie riešenie je uvedomiť si nasledovné: Emo buď dostane pokutu za ohňostroj, alebo nedostane. Celé prechádzanie bludiskom môžeme extrahovať do funkcie a túto dvakrát zavolať -- raz s tým, že nebudeme chodiť cez žiadne kontroly (a nezaplatíme pokutu za ohňostroj) a raz s tým, že môžeme prejsť cez ľubovoľne veľa kontrol, ale na konci pripočítame veľkosť pokuty za ohňostroj. Časovú zložitosť to nezhorší. Celé to robíme len dvakrát, čo je konštanta. Navyše, v podstate rozoberáme len dva jednoduché prípady.

Na demonštráciu tohto riešenia uvádzam zdrojový kód, ktorý podrobnejšie ukazuje, čo sme si práve opísali. Funkcii `spocitaj` realizuje Dijkstrov algoritmus. Premenná `flag` hovorí, či má ísť aj cez kontroly alebo sa k nim má správať rovnako ako ku križovatkám s Dunajom.

## Iný pohľad na kontroly

Rovnako rýchle riešenie je vytvoriť si **2 vrcholy pre každú križovatku**. Jeden typ reprezentuje križovatky s tým, že sme na ceste k nim ešte žiadnou kontrolou neprešli a druhý reprezentuje, že sme už aspoň cez jednu kontrolu prešli. Keďže nevieme, či bude optimálne ísť cez kontroly, alebo nie, potrebujeme si pamätať oba vrcholy. V 3D sa to dá predstaviť ako keby sme urobili kópiu nášho grafu a položili ju nad náš graf. Takto dostaneme dvojúrovňový graf. Dolná úroveň sú vrcholy, ktoré hovoria, že sme ešte neprešli žiadnou kontrolou a horná úroveň sú vrcholy, ktoré hovoria, že už sme prešli aspoň jednou kontrolou. Vrcholy v rámci jednej úrovne budú pospájané hranami rovnakých cien, ako sme si popisovali (na oboch úrovniach). Jediná výnimka budú križovatky s kontrolami v dolnej úrovni. Ak sa dostaneme do križovatky s kontrolou v dolnej úrovni, tak potom pokračujeme v našej ceste v hornej úrovni. Za prechod medzi úrovňami zaplatíme cenu pokuty za ohňostroj. Ďalej už pokračujeme iba po hornej vrstve.

Na tomto grafe spočítame Dijkstrovým algoritmom najlacnejšiu cestu na lacnejší vrchol internátu. Zaujíma nás totiž tá lacnejšia z týchto dvoch najlacnejších ciest na jednotlivé vrcholy. Je nám jedno na akej úrovni grafu skončíme.
",5
c9fd7ae155e88e95,ksp,"# O introvertných a extrovertných holuboch

**POZOR:** táto úloha má neštandardný spôsob hodnotenia. Viac sa dozviete v časti Hodnotenie.

Pán Dirichlet je veľkochovateľ poštových holubov. Vo svojich početných holubníkoch chová obrovské množstvo holubov, z ktorých občas niektoré predá malochovateľom.

Dávid sa chce stať malochovateľom poštových holubov. Na záhrade si postavil celý rad holubníkov, ktoré (v duchu najlepších chovateľských tradícií) očísloval číslami $1, 2, 3, \\dots$. Následne si u pána Dirichleta objednal $n$ holubov.

Pán Dirichlet teda Dávidovi pekne po jednom poslal^[taký poštový holub sa posiela veľmi jednoducho: poviete mu, na akú adresu má ísť a on tam doletí po vlastných] $n$ holubov.

Holuby sú teraz na ceste a Dávid sa pripravuje na ich prijatie. Plán je jednoduchý: holuby budú po jednom prilietať (v poradí, v akom boli poslané, keďže, ako je všeobecne známe, slušné poštové holuby sa navzájom nepredbiehajú) a vždy, keď nejaký holub priletí, Dávid ho strčí do niektorého z holubníkov. To však nemôže robiť len tak halabala. Sťahovanie sa z jedného holubníka do druhého je totiž pre takého holuba veľká udalosť a ak sa to urobí zle, holub si nikdy na svoj nový domov nezvykne, začne chradnúť a predčasne umrie. To, či sa holub v novom domove dobre aklimatizuje, sa riadi nasledovnými pravidlami:

- Každý holub má nejakú _extroverciu_. Extrovercia holuba je nezáporné celé číslo, ktoré je pri introvertných holuboch nízke a pri extrovertných holuboch vysoké.

- Keď holuba s extroverciou $e$ nasťahujeme do nového holubníka, v ktorom už býva **presne** $e$ iných holubov, náš holub sa do tejto spoločnosti bez problémov začlení a rýchlo (hneď) si na nový domov zvykne. Ak je však v holubníku iný počet holubov ako $e$ (menej, alebo viac), náš holub sa v kolektíve necíti dobre a na nový domov si nikdy nezvykne.

- Keď si už raz holub zvykne na svoj holubník (čo sa stane buď hneď po jeho príchode, alebo nikdy), nevadí mu, ak do tohto holubníka pridávame aj nové holuby.

Pán Dirichlet, ako dobrý chovateľ, pozná extrovercie všetkých svojich holubov a spolu s faktúrou poslal^[mailom, nie holubou poštou, takže to Dávidovi príde skôr, ako holuby] Dávidovi aj zoznam extrovercií odoslaných holubov, v poradí, v akom ich poslal. Dávid sa teraz na tento zoznam pozerá a snaží sa naplánovať, ako holuby napchať do holubníkov tak, aby sa všetky dobre aklimatizovali. Pomôžte mu!

## Úloha

Na vstupe dostanete postupnosť $n$ čísel $e_1, e_2, \\dots, e_n$ -- extrovercie holubov v poradí, v akom budú prilietať. Nájdite takú postupnosť prirodzených čísel $h_1, h_2, \\dots, h_n$, že ak Dávid strčí prvého holuba do holubníka číslo $h_1$, druhého do holubníka číslo $h_2$, tretieho do $h_3$ atď., všetky holuby si dobre zvyknú. Inými slovami, pre každé $i \\in {1, 2, \\dots, n}$ musí platiť, že presne $e_i$ spomedzi čísel $h_1, h_2, \\dots, h\_{i-1}$ sa rovná číslu $h_i$. Môžete predpokladať, že Dávid má aspoň $n$ holubníkov a aspoň jedna vhodná postupnosť existuje (pán Dirichlet je dobrý chovateľ a neposlal by svoje holuby tak, aby boli niektoré z nich odsúdené na chradnutie).

## Formát vstupu

V prvom riadku vstupu je celé číslo $n$ ($1 \\leq n \\leq 1,000,000$). V druhom riadku je $n$ medzerami oddelených nezáporných celých čísel $e_1, e_2, \\dots, e_n$ -- extrovercie holubov. Pre každé zmysluplné $i$ platí $0 \\leq e_i \\leq {n-1}$.

## Formát výstupu

Vypíšte jeden riadok a v ňom $n$ celých čísel oddelených medzerami -- jednu vhodnú postupnosť $h_1, h_2, \\dots, h_n$. Pre každé zmysluplné $i$ musí platiť $1 \\leq h_i \\leq n$ (aj tak určite nebudete potrebovať viac ako $n$ holubníkov). Ak je možných riešení viac, vypíšte ľubovoľné z nich.

## Hodnotenie

V tejto úlohe budeme primárne hodnotiť **pamäťovú zložitosť** vášho algoritmu a až sekundárne časovú. Na časovú zložitosť budeme prihliadať iba tak, ako v iných úlohách prihliadame na pamäťovú (teda algoritmus s lepšou pamäťovou a horšou časovou zložitosťou považujeme za lepší, pokiaľ nie je jeho časová zložitosť absurdne veľká). Tomu zodpovedá aj pomerne voľný časový limit a veľmi malý pamäťový limit (najväčšie vstupy sa vám nezmestia do pamäte) v praktickom testovaní.

Pre jednotlivé vstupné sady platí:

| číslo sady | 1 | 2 | 3, 4, 5 | |:-------------:|---:|-----:|------------:| | maximálne $n$ | 10 | 1000 | 1,000,000 |

V sade č. 3 navyše v každom vstupe platí, že existuje riešenie využívajúce nanajvýš $1,000$ holubníkov.

## Príklad

```vstup
4
0 0 0 0
```

```vystup
1 2 3 4
```

_Každý holub musí ísť do nového holubníka. Dobrým riešením je napríklad aj 4 3 2 1._

```vstup
5
0 1 2 3 4
```

```vystup
3 3 3 3 3
```

_Všetky holuby musíme dať do rovnakého holubníka._

```vstup
8
0 0 1 0 1 2 3 2
```

```vystup
4 2 4 3 2 2 2 4
```

_Jedno z mnohých možných riešení._
","# O introvertných a extrovertných holuboch

Vždy, keď Dávidovi priletí nejaký holub s extroverciou $e$, musí ho Dávid nasťahovať do holubníka, v ktorom je presne $e$ iných holubov. Niekedy sa môže stať, že Dávid má na výber viacero holubníkov s presne $e$ holubmi.

Všimnime si, že všetky holubníky s $e$ holubmi sa pre účely našej úlohy správajú úplne rovnako (do každého z nich môžeme strčiť holuba s extroverciou $e$ a ak to urobíme, stane sa z neho holubník s $e+1$ holubmi). To znamená, že vždy keď má Dávid na výber z viacerých holubníkov, môže si vybrať ľubovoľný z nich a určite tým nič nepokazí.

## Priamočiare riešenie

Asi najpriamočiarejšie je celú situáciu simulovať. V jednom poli si budeme pre každý holubník pamätať, koľko je v ňom holubov. Vždy, keď priletí holub, nájdeme prvý holubník s vhodným počtom iných holubov a strčíme ho tam. Budeme si musieť pamätať $n$ holubníkov (pre prípad, že by nám priletelo $n$ holubov s extroverciou $0$), teda pamäťová zložitosť bude $O(n)$. Hľadanie vhodného holubníka nám pri každom holubovi bude trvať v najhoršom prípade $O(n)$, teda časová zložitosť bude $O(n^2)$.

## Šetrenie pamäťou

Ľahký spôsob, ako toto riešenie vylepšiť, je nepamätať si $n$ holubníkov, ale len toľko, koľko potrebujeme. V najhoršom prípade to síce nepomôže (lebo v najhoršom prípade aj tak potrebujeme všetkých $n$ holubníkov), ale vyrieši to tretiu sadu testovacích vstupov, kde máme sľúbené, že stačí použiť nanajvýš $1,000$ holubníkov.

Samozrejme, na začiatku nevieme, koľko holubníkov budeme potrebovať. Preto si nebudeme pamätať žiaden. Vždy, keď priletí holub s extroverciou $0$, otvoríme mu nový holubník a začneme si pamätať počet holubov v ňom. Na tento účel sa veľmi hodí pole s možnosťou pridávania prvkov na koniec, napríklad `vector` v C++, alebo `ArrayList` v Jave.

## Rýchlejšie riešenie

V predošlom riešení sme každého nového holuba strkali do prvého vhodného holubníka. To okrem iného zaručuje, že počty holubov v jednotlivých holubníkoch tvorili v každom momente nerastúcu postupnosť. Teda nikdy sa nemohlo stať, že by v $i$-tom holubníku bolo menej holubov ako v $i+1$-vom.

V tomto riešení budeme holuby strkať do holubníkov rovnakým spôsobom, ale budeme si o holubníkoch pamätať inú informáciu. Konkrétne, pre každé číslo $x$ od $0$ po $n-1$ si budeme pamätať číslo prvého holubníka obsahujúceho $x$ holubov.

Trochu problém je s takými číslami $x$, pre ktoré neexistuje holubník s presne $x$ holubmi. Tento problém sa dá ošetriť rôznymi spôsobmi. Implementačne asi najjednoduchší z nich je pamätať si pre každé $x$ číslo prvého holubníka, ktorý obsahuje $x$ **alebo menej** holubov. Toto číslo má rozumnú hodnotu pre každé $x$ z rozsahu $0$ až $n-1$ a ako sa ukáže, veľmi ľahko sa aktualizuje.

Na začiatku si teda budeme pamätať $n$ jednotiek.

Vždy, keď priletí holub s nejakou extroverciou $e$, pozrieme sa na prvý holubník obsahujúci $e$ alebo menej holubov. Aspoň jeden holubník určite obsahuje presne $e$ holubov (inak by sa holuby nedali dobre ubytovať). Počty holubov v holubníkoch tvoria nerastúcu postupnosť, teda prvý holubník s $e$ alebo menej holubmi určite obsahuje presne $e$ holubov. To znamená, že tam môžeme strčiť nového holuba. Následne si musíme aktualizovať naše informácie: číslo prvého holubníka obsahujúceho $e$ alebo menej holubov sa nám zvýšilo o $1$. Žiadne iné z čísel, ktoré si pamätáme, sa nezmenilo.

Takto vieme každého holuba spracovať v konštantnom čase. Časová zložitosť tohto riešenia je teda $O(n)$, pamäťová je tiež $O(n)$.

## Šetrenie pamäťou

Aj v tomto riešení sa dá ušetriť nejaká pamäť. V podstate iba inak ošetríme čísla $x$, pre ktoré neexistuje holubník s $x$ holubmi. Doteraz sme si pre takéto čísla pamätali prvý holubník s menej ako $x$ holubmi. Teraz si pre ne nebudeme pamätať vôbec nič. Počas ubytovávania holubov sa nám totiž nikdy nestane, že by sme potrebovali zistiť číslo prvého holubníka s $x$ alebo menej holubmi, ak neexistuje holubník s presne $x$ holubmi.

To však prináša niekoľko technických problémov. Prvým problémom je, že už nám nestačí obyčajné pole indexované podľa počtu holubov v holubníku, keďže takéto pole by bolo príliš veľké. Stále však chceme byť schopní pre dané $x$ rýchlo nájsť prvý holubník s $x$ holubmi. Preto použijeme _mapu_ založenú na vyvažovanom vyhľadávacom strome. Vo väčšine rozumných programovacích jazykov sú takéto stromy už implementované, v C++ je to `std::map`, v Jave `TreeMap`^[Možno sa pýtate, prečo nepoužijeme hešmapu, keď je rýchlejšia. Dôvod je taký, že pri aktualizovaní informácie budeme chcieť cez našu mapu vedieť iterovať podľa veľkosti $x$.]. V takejto mape vieme k hodnote pre dané $x$ pristupovať v čase $O(\\log m)$, kde $m$ je počet prvkov v mape. V rovnakom čase vieme z mapy aj mazať a vkladať do nej nové prvky.

Druhý problém je aktualizácia našej informácie. Keď nám priletí holub s extroverciou $e$ a ubytujeme ho, zanikne nám jeden holubník s $e$ holubmi a vznikne nám holubník s $e+1$ holubmi. Musíme teda skontrolovať, či sme predtým mali nejaký holubník s $e+1$ holubmi. Ak nie, treba do našej mapy pridať informáciu o tom, že takýto holubník máme (aj s jeho číslom).

Ďalej potrebujeme overiť, či ešte stále máme nejaké holubníky s $e$ holubmi. Ak áno, potom musíme aktualizovať číslo prvého z nich (teda zvýšiť ho o $1$ oproti doterajšej hodnote). Ak nie, potom treba z mapy vyhodiť záznam o holubníkoch s $e$ holubmi. Aby sme zistili, či máme holubník s $e$ holubmi, stačí nám pozrieť sa na číslo prvého holubníka s menej ako $e$ holubmi. Ak je to holubník hneď za holubníkom, do ktorého sme práve nasťahovali $e+1$-vého holuba, znamená to, že žiadne holubníky s $e$ holubmi už nemáme. Ak je prvý holubník s menej ako $e$ holubmi až niekde ďalej, potom ešte nejaké holubníky s $e$ holubmi máme.

Polohu prvého holubníka s menej ako $e$ holubmi vieme za pomoci našej mapy nájsť v čase $O(\\log m)$, kde $m$ je počet záznamov v mape.

S odhadom pamäťovej zložitosti to bude tentoraz veselé. Pre každé číslo $x$ také, že v aspoň jednom holubníku je presne $x$ holubov, si pamätáme jeden záznam v mape. Takýchto čísel $x$ je však v každom momente najviac rádovo $\\sqrt{n}$. Ak totiž máme $k$ rôznych nezáporných celých čísel, ich súčet je minimálne $0 + 1 + \\dots + (k-1) = \\frac{k(k-1)}{2}$, čo je zhruba polovica z $k^2$. To znamená, že môžeme mať najviac zhruba $\\sqrt{2n}$ rôznych $x$, pre ktoré existuje holubník s $x$ holubmi, inak by sme dokopy v našich holubníkoch museli mať viac než $n$ holubov. Okrem mapy máme už iba konštantne veľa premenných, teda pamäťová zložitosť nášho algoritmu je $O(\\sqrt{n})$.

Každého holuba spracovávame v čase $O(\\log m)$, pričom v mape nikdy nebude viac ako rádovo $\\sqrt{n}$ čísel, teda môžeme povedať, že spracovanie jedného holuba nám bude trvať čas $O(\\log \\sqrt{n}) = O(\\log n)$. To znamená, že celý algoritmus pobeží v čase $O(n \\log n)$.
",8
0e37caa77ca5e0e3,ksp,"# Architektonický problém

Na Matfyze práve prebiehajú masívne rekonštrukcie. Za pavilónom matematiky stavajú novú budovu, v akvárkach[^1] vymieňajú staré drevené sedačky a ešte aj KSPáci si znovu prerobili T2ku[^2]. No a rekonštrukcií sa samozrejme nevyhnú ani záchody.

Vedenie by potrebovalo zistiť, koľko záchodových mís musia na rekonštrukciu objednať. Má to ale jeden háčik. Keď projektant kreslil plány budovy, musel si odskočiť a jeho kolega mu tam medzitým dokreslil ešte niekoľko záchodových mís. Na niektorých záchodoch sú teraz iné, väčšie misy, inde sa zase kadejako prekrývajú, čo by možno bolo skvelé na výstave moderného umenia, no na Matfyze by sme radšej chceli funkčné záchody.

Keďže záchodov je na Matfyze veľa, nikomu sa to nechcelo ručne kontrolovať, a preto požiadali KSPákov o pomoc. Tí momentálne ale kvôli organizovaniu Letnej školy Trojstenu nič nestíhajú, a tak túto úlohu nechali na vás.

## Úloha

Na vstupe dostanete pôdorys miestnosti pozostávajúci zo znakov `.` a `O`, ktoré označujú voľný priestor a časti záchodovej misy. Záchodová misa veľkosti $k$ vyzerá ako rovnoramenný trojuholník, ktorého rohy sú označené znakom `O`. Medzi ľavým a pravým vrcholom je vždy $2k-1$ prázdnych políčok (teda označených znakom `.`). Spodný vrchol trojuholníka sa nachádza o $k$ políčok nižšie, presne v strede medzi ľavým a pravým vrcholom. Všetok ostatný priestor, vrátane vnútra misy, je označený znakom `.`.

Záchodové misy v nákrese môžu mať rôzne veľkosti, vždy ale pozostávajú práve z troch znakov `O` a nikdy nie sú otočené inak.

Vašou úlohou je skontrolovať, či sú všetky záchody správne zakreslené a neprekryvajú sa. V prípade, že je všetko v poriadku, je treba spočítať počet záchodov, ktoré sa na nákrese nachádzajú.

## Formát vstupu

Na prvom riadku sa nachádzajú čísla $s$ a $r$, ktoré označujú počeť stĺpcov a riadkov nákresu. Na ďalších $r$ riadkoch nasleduje nákres miestnosti, pričom každý riadok má práve $s$ znakov.

## Formát výstupu

Ak je nákres miestnosti v poriadku, na výstup vypíšte jediné čislo -- počet záchodov, ktoré sa na nákrese nachádzajú. V opačnom prípade vypíšte `Zly nakres`.

## Príklad

```vstup
8 3
O.O..O.O
.O....O.
........
```

```vystup
2
```

_V tejto miestnosti sú iba 2 záchody rovnakej veľkosti vedľa seba._

```vstup
11 5
O.....O....
......O...O
...........
...O.O.OO..
......O....
```

```vystup
3
```

_V ľavom hornom rohu je záchod veľkosti 3, napravo od neho záchod veľkosti 2 a v strede pod nimi je záchod veľkosti 1._

```vstup
3 3
O.O
...
...
```

```vystup
Zly nakres
```

_Záchodu chýba tretí znak `O` -- nákres je nesprávny._

\[^1\]: Akvárka sú prednáškové miestnosti na Matfyze.

\[^2\]: T2-ka je miestosť KSPákov na Matfyze. Pre bližšie predstavenie si tejto miestnosti -- sú v nej skrine, gauče, stoly a veľká kopa eráru.
","# Architektonický problém {mail=""adrianza@ksp.sk"" bodypopis=12 bodyprogram=8}

Na vyriešenie tejto úlohy nebolo treba vymýšlať žiadne komplikované postupy. Stačí nám iba postupne hľadať záchodové misy, kontrolovať či sa v ich vnútri nič nenachádza a spočítať ich.

To urobíme nasledovne: Budeme prechádzať načítaný nákres po riadkoch a hľadať dvojice znakov `O` medzi ktorými sú iba znaky `.` (bodka), a žiadne iné . V prípade, že k niektorému znaku `O` nenájdeme jeho dvojicu, záchod nie je správne zakreslený a teda aj celý nákres je nesprávny.

Každá nájdená dvojica znakov `O` je potenciálne záchodovou misou, ktorej veľkosť $k$ vieme určiť zo vzdialenosti týchto znakov. Vďaka tomu vieme vypočítať, kde sa má nachádzať spodný vrchol trojuholníka reprezentujúceho misu. Následne si už len overíme, či sa na jeho mieste naozaj nachádza znak `O`.

Predtým, ako vyhlásime že je táto záchodová misa zakreslená správne, musíme ešte skontrolovať, či sa v jej vnútri naozaj nič nenachádza. Stačí nám jednoduchým cyklom skontrolovať plochu trojuholníka na nasledujúcich $k$ riadkoch. Ak nájdeme iný znak ako `.`, záchod sa s niečím kryje a nákres je nesprávny.

Aby sme sa pri hľadaní ďalších mís nepomýlili, preznačíme si spodný vrchol na nejaký iný znak (napríklad `#`), ktorý budeme pri hľadaní ľavého horného vrcholu ignorovať. Nebudeme ho ale ignorovať pri kontrole vnútra trojuholníka, vďaka čomu zistíme prípadné prekrývanie s už skontrolovaným záchodom.

Horné vrcholy trojuholníkov budeme hľadať v celom nákrese, čiže postupne prejdeme všetkých $r \\cdot s$ políčok. Pri kontrole vnútier trojuholníkov skontrolujeme určite menej ako $r \\cdot s$ políčok, keďže plocha pod záchodmi je určite menšia ako celý nákres, a pri prvom zistenom prekrývaní program končí. Výsledná časová zložitosť teda bude $O(rs)$.

Pamäťová zložitosť bude rovnako $O(rs)$ - pamätáme si celý nákres a zopár ďalších premenných.
",2
683d0df1c2fa6afa,ksp,"# Kopa kopania

Cisár Vespazián poveril staviteľa Oryctolaga veľkou úlohou: postaviť najväčší amfiteáter na svete.

Na veľkom amfiteátri je veľa roboty. Na začiatok treba, napríklad, pripraviť veľkú, rovnú stavebnú plochu. Ako na potvoru je však jediná veľká voľná plocha v okolí nerovná. Preto neostáva nič iné, ako ju umelo vyrovnať.

Na stavebnej ploche sú dva druhy nerovností, kopce a jamy, všetky rovnako veľké. Ak je teda nejaký kopec vedľa jamy, dá sa ich oboch veľmi jednoducho zbaviť -- hlinou z kopca zasypeme jamu. Nie pri každom kopci je však jama, preto sa Oryctolagus bojí, že mu na konci nejaké nerovnosti zostanú.

Oryctolagus bude, samozrejme, jamy zasypávať najlepším možným spôsobom (teda tak, aby mu na konci zostalo čo najmenej nerovností). Zaujímalo by ho, koľko nerovností mu na konci zostane. Keďže sa mu to nechce počítať, zveril túto robotu svojej pravej ruke, Angelice. Tá to zasa zverila vám. A vy, ak budete šikovní, to môžete zveriť svojmu počítaču.

## Úloha

Pre jednoduchosť budeme v tejto úlohe predpokladať, že svet je dvojrozmerný (má iba výšku a šírku) a stavebný pozemok má pôdorys v tvare úsečky. Pozdĺž tejto úsečky je niekoľko nerovností (jám a kopcov). Počet týchto nerovností aj ich poradie dostanete na vstupe. Máme povolené robiť nasledovnú operáciu:

- Ak medzi nejakou jamou a kopcom nie je žiadna iná nerovnosť (jama ani kopec), môžeme dať zasypať jamu hlinou z kopca. Daná jama aj kopec pri tom zaniknú.

Zistite, koľko nerovností nám ostane, ak pomocou tejto operácie odstránime najviac jám a kopcov, ako sa dá.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ ($1 \\leq n \\leq 200,000$) -- počet nerovností.

Na druhom riadku sa nachádza reťazec núl a jednotiek dlhý $n$. Tento reťazec popisuje nerovnosti v poradí od začiatku po koniec pozemku: nuly znamenajú jamy a jednotky znamenajú kopce.

## Formát výstupu

Na jediný riadok výstupu vypíšte najmenší možný počet nerovností, ktoré na konci zostanú.

## Príklady

```vstup
4
1100

```

```vystup
0

```

_Najprv zasypeme ľavú jamu hlinou z pravého kopca. To nám otvorí cestu, aby sme zasypali druhú jamu hlinou zo zostávajúceho kopca._

```vstup
5
01010
```

```vystup
1
```

_Jedným z možných postupov je:_

```vstup
6
111111
```

```vystup
6
```

_V tomto prípade sa nedá vyrovnať nič._
","# Kopa kopania

Na začiatok si uvedomme nasledovnú myšlienku: *Kým bude na stavebnej ploche aspoň jedna jama a zároveň aspoň jeden kopec, určite budeme vedieť niečo ešte zarovnať.*

Inými slovami, ak je na pozemku aspoň jedna jama a aspoň jeden kopec, tak je tam aj taká jama a taký kopec, medzi ktorými nie je žiadna iná nerovnosť.

Aj keď sa takéto tvrdenie môže zdať zrejmé, skúsme ho poriadne dokázať. Predpokladajme teda, že na pozemku je ešte aspoň jedna jama a aspoň jeden kopec. Zoberme si najľavejší kopec. Ak je bezprostredne naľavo od neho jama, tak sme práve našli hľadanú dvojicu. Ak naľavo od neho nie je jama, tak to znamená, že tento kopec je prvá nerovnosť na pozemku (lebo je to najľavejší kopec). Ak teraz budeme prechádzať postupne po pozemku smerom doprava, stretávame najprv kopce (možno len ten jeden najľavejší, možno aj ďalšie), až kým nestretneme jamu (na pozemku sa aspoň jedna musí nachádzať). Táto jama je však vedľa posledného kopca, ktorý sme videli, teda aj v tomto prípade sme našli susediacu dvojicu kopec-jama.

Zistili sme, že stavebnú plochu budeme vedieť zarovnávať, až kým nám neostanú samé kopce alebo samé jamy (prípadne ani jedno). Zároveň vieme, že pri každom zarovnaní zmizne jedna jama a jeden kopec. Počet nerovností, ktorý ostane na konci, bude preto rovný rozdielu medzi počtom kopcov a počtom jám na začiatku.

Lepší výsledok sa zjavne dosiahnuť nedá -- ak máme priveľa jám, môžeme ich zasypať iba toľko, koľko máme kopcov. Podobne, ak máme priveľa kopcov, môžeme sa zbaviť iba toľkých, koľko máme jám.

Na vyriešenie úlohy nám teda stačí spočítať, koľko je na pozemku jám a koľko kopcov (koľko je vo vstupnom reťazci núl a koľko jednotiek), odčítať od väčšieho čísla menšie a výsledok vypísať.

Priamočiara implementácia popísaného algoritmu v Pythone:

Už na načítanie vstupu je potrebná časová zložitosť $O(n)$ a v našom riešení len v jednom cykle prejdeme pole so vstupom, preto aj celé riešenie má zložitosť $O(n)$. Pamäťová zložitosť je, naopak, niečo, s čím pohnúť vieme. Ak načítame celý reťazec naraz, naša pamäťová zložitosť bude $O(n)$. Reťazec si ale nepotrebujeme pamätať celý naraz. Ak budeme vstup načítavať po jednom znaku, zlepšíme pamäťovú zložitosť na $O(1)$.

Tu uvádzame riešenie v jazyku C++ s konštantnou pamäťovou zložitosťou:
",1
eaabf624dcb57f8d,ksp,"# Istota čistoty

V T2 je špinavo. Dávid tam síce z času na čas povysáva, no Marcelovi to nestačí. Ako správny zdravotník si je vedomý toho, že pre odstránenie mikróbov bude nutné použiť niečo silnejšie. Doniesol si teda svoj tepovač a všetky koberce za doobedie dôkladne vyčistil.

Vtom si ale spomenul na ďalšiu nepríjemnosť. Totiž, vo vlhkom prostredí sa dobre darí plesniam. Zobral teda koberce a dal ich sušiť na slnečný trávnik. Trávnik je však malý a koberce sa nezmestia vedľa seba. Niektoré teda naukladal jeden na druhý. Nechcel ale, aby to bolo až príliš chaotické, nuž sa žiadne dva koberce nedotýkajú stranami ani rohmi. Môže však byť menší koberec položený na väčšom, alebo naopak.

Na slnečnom trávniku sa zvyknú hrávať deti. Nejaké koberce im vôbec neprekážajú. Keďže ale boli mokré, jedno z detí sa pošmyklo a rozsypalo po celom trávniku lentilky. Voda v kobercoch začala rozpúšťať farebnú cukrovú polevu. Pod každou lentilkou farba z polevy presiakla cez všetky koberce až po trávnik.

Keď si tú hrôzu Marcel všimol, prišlo mu zle. Potom si ale uvedomil, že sa vlastne nič zlé nestalo a začal namiesto toho rozmýšľať, koľko rôznych lentilkových farieb je na každom z kobercov. Je ale veľmi unavený z toľkého úmorného tepovania. Keby mu len niekto s touto úlohou pomohol...

## Úloha

Marcel vám povedal, ako rozmiestnil koberce. Koberce sa nepretínajú ani nedotýkajú stranami ani rohmi. Dva koberce môžu byť navzájom nad sebou iba ak je jeden z nich úplne obsiahnutý v druhom a nedotýkajú sa stranami. Teda môže sa stať že je menší pod väčším, ale aj to, že je väčší pod menším a dokonca môže byť celá kopa kobercov medzi nimi (pričom každá dvojica v tejto kope spĺňa tieto pravidlá).

Koberce sú obdĺžnikové a sú poukladané tak, aby ich strany boli rovnobežné s osami $x$ a $y$.

Ďalej vám povedal súradnice a farby jednotlivých lentiliek. Farieb môže byť mnoho, no môže byť viac lentiliek tej istej farby.

Vašou úlohou je povedať Marcelovi, koľko rôznych farieb z lentiliek sa dostalo na ktorý koberec.

## Formát vstupu

Na prvom riadku vstupu sú dve čísla $n$ a $m$ - počet kobercov a počet lentiliek. Platí, že $1 \\leq n, m \\leq 10^5$.

Nasleduje $n$ riadkov. Na $i$-tom z nich je popis $i$-teho koberca. Tento popis pozostáva zo 4 čísiel $1 \\leq x_1, y_1, x_2, y_2 \\leq 10^9$ - súradníc ľavého dolného a pravého horného rohu. Môžete predpokladať, že $x_1 < x_2$ a tiež $y_1 < y_2$.

Na $j$-tom z ďalších $m$ riadkov je popis $j$-tej lentilky. Pozostáva z 3 čísiel $1 \\leq x, y, f \\leq 10^9$ - súradníc lentilky a jej farby.

## Formát výstupu

Vypíšte $n$ riadkov. Na $i$-tom z nich bude jedno číslo - počet rôznych farieb, ktoré lentilky pridali na $i$-ty koberec.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:------------------------ |-------: | ------: | ---------: | ----------: | | $1 \\leq n, m \\leq$ | $1000$ | $50000$ | $100,000$ | $100,000$ |

## Príklad

```vstup
3 3
1 1 10 10
2 2 9 9
4 4 6 8
2 10 1
2 9 2
5 7 3
```

```vystup
3
2
1
```
","# Istota čistoty

Riešenie hrubou silou je jednoduché. Pre každý koberec môžeme mať `set` a farbu každej lentilky vložíme do `set`u každého koberca, na ktorom sa nachádza. Dostaneme riešenie s časovou zložitosťou $O(nm \\log m)$. Ak namiesto `set`u použijeme hešovaciu tabuľku, tak to zlepšíme na $O(nm)$. Pamäť bude $O(n + m)$, ak si zapamätáme iba koberce, lentilky a `set`y.

## Vzorové riešenie

Predstavme si, že by vždy ležal menší koberec na väčšom. Uvedomme si, že toto nijak nezmení odpoveď, pretože farba z lentilky presiakne cez všetky koberce pod ňou bez ohľadu na ich poradie. Môžeme teda predpokladať, že koberce skutočne ležia týmto spôsobom.

Keďže sa koberce nepretínajú stranami, tak nám vzniklo niekoľko kôpok kobercov. Každá z týchto kôpok je v podstate strom. Jeho koreňom je spodný, najväčší koberec.

Poďme si rozmyslieť, ako spraviť, aby sme každú lentilku nemuseli zapisovať do každého koberca, ktorý ofarbí, ale iba do jedného. Zapíšeme ju iba do najvrchnejšieho. To nám stačí, pretože pod ním sú už iba väčšie koberce. Keď zapíšeme všetky lentilky, tak nám bude stačit prejsť každý strom a každému vrcholu, čiže kobercu, priradiť farby tak, že zjednotíme farby všetkých jeho synov. Potlačíme teda farby z listov, kam sme ich zapísali, dohora.

Vieme to spraviť rýchlo? Pre každý koberec môžeme mať `set`, do ktorého budeme dávať jeho farby. Keby sme do otca vkladali farby zo synov len tak ledajako, mohlo by sa nám stať, že budeme jednu farbu kopírovať príliš veľa krát. Použijeme teda trik používaný napríklad v dátovej štruktúre `union-find`, kde spájame dve množiny tak, že kopírujeme prvky z menšej tabuľky do väčšej. Predstavme si spájanie jedného zo synov s otcom. Ak je viac farieb v otcovi, prekopírujeme farby zo syna do otca. Ak je viac farieb v synovi, prekopírujeme farby z otcovského `set`u do synovho a prehlásime ho za nový otcov `set`. Takto bude každá lentilka prekopírovaná nanajvýš $\\log m$-krát. Na tomto mieste sa vieme zbaviť jedného logaritmu tým, že namiesto `set`u použijeme hešovaciu tabuľku. Táto časť teda bude mať zložitosť $O(m \\log m)$.

Ostáva nám vyriešiť iba to, ako zapísať každú lentilku iba do najvrchnejšieho koberca. Toto je celkom známa úloha. Budeme mať intervalový strom. Z obdĺžnikov zoberieme začiatočnú a konečnú zvslú úsečku a o každej si zapamätáme, či je začiatočná, alebo konečná. Tieto úsečky si usporiadame podľa $x$-ovej súradnice spolu s lentilkami. Usporiadané úsečky pozametáme intervaláčom. Vždy, keď nájdeme začiatočnú úsečku, v intervalovom strome si zapamätáme že daný obdĺžnik je na celom intervale, ktorý pokrýva daná úsečka aktuálne najvyššie. Ináč povedané, na intervale danej úsečky pridáme na `stack` korešpondujúci obdĺžnik. Keď dojdeme ku koncu obdĺžnika, odoberieme daný obdĺžnik zo `stack`u na celom intervale tejto koncovej úsečky. Keď nájdeme lentilku, pozrieme sa do intervalového stromu, ktorý obdĺžnik je najvyššie na danom mieste a lentilku do neho zapíšeme. Keďže súradnice sú veľké, budeme pre intervalový strom potrebovať spraviť kompresiu súradníc, alebo ho stavať dynamicky. Táto časť bude mať zložitosť $O((n + m) \\log (n + m))$, čo bude aj výsledná časová zložitosť programu. Pamäťová zložitosť bude $O(n + m)$.
",9
a40ba7de408a3ba9,ksp,"# Okno do študentovej duše

Miško by si mal robiť domácu. A ísť postrúhať mrkvu. A už niekedy konečne pozrieť zo záznamu minulotýždňovú prednášku z toho či onoho predmetu. A pozbierať si zo sušiaka prádlo, nech sa dá prať ďalšia várka. A upratať po mačke, ktorá podľa zvuku práve zase na chodbe nagrcala. List povinností pokračuje ďalej a ďalej.

Čím je povinností viac, tým sa do nich Miškovi menej chce. A tak si radšej skúma najnovšiu matematickú zaujímavosť, na ktorú práve narazil: správanie sa ciferných súčinov keď ich robíme opakovane.

Začnime napríklad z čísla 47. Jeho ciferný súčin je $4\\times 7 = 28$. Ciferný súčin čísla 28 je $2\\times 8 = 16$. Ciferný súčin čísla 16 je $1\\times 6 = 6$. No a odkedy sme sa dostali k jednocifernému číslu, už je to nuda: ciferným súčinom jednociferného čísla je ono samo. Ak teda časom dosiahneme jednociferné číslo, celý postup ukončíme.

Niekedy je tento proces rýchlejší, inokedy pomalší. Napríklad číslo $987,654,321$ má ciferný súčin $9! = 326,880$ a číslo $326,880$ má ciferný súčin 0. Hoci sme začali s oveľa väčším číslom ako v predošlom príklade, skončili sme skôr. A možno sa niekedy stane aj to, že pre nejaký začiatok vôbec nikdy neskončíme na jednocifernom čísle. Alebo žeby sa to predsa len nemohlo stať? O tom Miško zatiaľ nič netuší.

Miško sa rozhodol, že niektorým nezáporným celým číslam priradí *skóre*, a to nasledovne:

- Každé jednociferné číslo $n$ dostane priradené Miškom zvolené malé nezáporné skóre $z_n$.
- Ak má viacciferné číslo $n$ ciferný súčin $s(n)$ a číslo $s(n)$ má skóre $x$, číslo $n$ dostane skóre $x+1$.

## Úloha

Na vstupe dostanete hodnoty $z_0$ až $z_9$ a tiež cieľové skóre $c$. Vašou úlohou je nájsť **najmenšie** nezáporné celé číslo, ktoré má skóre $c$.

Poriadne si pozrite obmedzenia pre veľkosť vstupu.

## Formát vstupu

V prvom riadku vstupu sú čísla $z_0$ až $z_9$, v druhom je číslo $c$.

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno číslo -- najmenšie nezáporné celé číslo so zadaným skóre.

## Obmedzenia a hodnotenie programov

Obmedzenia použité v testoch sme zvolili tak, že v každom teste správna odpoveď **existuje** (toto nie je úplne zjavné) a navyše vždy platí, že má hodnotu nanajvýš $10^{18}$ (toto už vonkoncom nie je zjavné ale tiež je to pravda). Tieto predpoklady môžete využiť vo svojich riešeniach.

Sú štyri sady vstupov. Vo všetkých štyroch platí:

- hodnoty $z_i$ sú z rozsahu od 0 po 3
- ak označíme $m=\\max z_i$, tak každú z hodnôt od 0 po $m$ má aspoň jedno $z_i$
- $c$ je z rozsahu od 0 po 11

Navyše v prvej sade platí, že odpoveď je nanajvýš 1000, v druhej sade platí, že odpoveď je z rozsahu od 1000 po $1,000,000$ a v tretej sade platí, že všetky $z_i$ sú rovné nule.

## Hodnotenie popisov

Pri hodnotení popisu nezáleží na asymptotickej zložitosti vášho riešenia (keďže všetky čísla na vstupe sú veľmi malé). Ľubovoľné riešenie dosť efektívne na to, aby získalo body za vstupy, môže dostať do 10 bodov za dôkaz toho, že dáva vždy korektný výstup. Posledné dva body sa budú udeľovať za efektívnosť hľadania.

## Príklady

```vstup
0 1 1 1 1 1 1 1 1 1
2
```

```vystup
11
```

- *Číslo 0 má skóre 0.*
- *Čísla od 1 po 9 majú skóre 1.*
- *Číslo 10 má ciferný súčin 0, a keďže 0 má skóre 0, tak 10 má skóre 1.*
- *Číslo 11 má ciferný súčin 1, a keďže 1 má skóre 1, tak 11 má skóre 2.*

```vstup
0 0 0 0 0 0 0 0 0 0
3
```

```vystup
39
```

- \*Číslo 4 má skóre 0, číslo 14 má ciferný súčin 4 a teda skóre 1, číslo 27 má ciferný súčin 14 a teda skóre 2, no a číslo 39 má ciferný súčin 27 a teda skóre 3. \*
- *Žiadne menšie číslo ako 39 nemá skóre 3.*

```vstup
2 0 0 0 0 0 0 0 0 1
2
```

```vystup
0
```

```vstup
2 1 2 2 1 1 1 0 1 0
6
```

```vystup
268
```
","# Okno do študentovej duše

Pripomeňme si, akú úlohu riešime. Máme predpísané, aké skóre majú jednociferné čísla. Každé väčšie číslo má skóre o jedno väčšie ako je skóre jeho ciferného súčinu. Našou úlohou je pre dané $c$ nájsť najmenšie číslo $n$, ktorého skóre je $c$.

## Pointa celej úlohy

Môže byť správnou odpoveďou číslo $n = 3,141,592$?

Nemôže. Prečo? Lebo číslo $1,123,459$ má presne tie isté cifry (a teda ten istý ciferný súčin, a teda aj to isté skóre) a je od $n$ menšie.

A môže byť číslo $1,123,459$ správnou odpoveďou?

Tiež nie. Prečo? Lebo číslo $23,459$ má tiež ten istý ciferný súčin a je ešte menšie.

Ale poďme sa na to celé pozrieť od začiatku a pekne pomaly.

## Každé číslo má skóre

Keď sa chvíľu pohráme s cifernými súčinmi, pomerne rýchlo si všimneme, že pre ľubovoľné $n\\geq 10$ nám jeho ciferný súčin $s(n)$ vyjde menší ako $n$. Je toto naozaj vždy pravda?

Keď už si to všimneme, dokázať to nie je ťažké. Pointa je v tom, že dopísanie ďalšej cifry na koniec čísla zväčší samotné číslo aspoň desaťkrát, zatiaľ čo jeho ciferný súčin len nanajvýš deväťkrát.

To isté ešte raz a poriadnejšie: Majme nejaké $x$-ciferné číslo $n$ ktorého prvá cifra je $y$. Čo o ňom vieme povedať?

- Hodnota $n$ je aspoň $y\\times 10^{x-1}$.
- Každá z $x-1$ cifier nasledujúcich za úvodným $y$ je nanajvýš 9, takže hodnota $s(n)$ je nanajvýš $y\\times 9^{x-1}$.
- A teda pre $x\\geq 2$ máme $n > s(n)$.

No a z toho už by malo byť zjavné, že úplne každé nezáporné celé číslo má korektne definované skóre. (Indukciou podľa $n$. Ak všetky čísla menšie ako $n$ majú korektne definované skóre, $s(n)$ je jedným z nich, a keďže $s(n)$ má skóre, aj $n$ má skóre.)

## Malé skóre vieme efektívne počítať

Pripomeňme si, že nás zaujímajú len čísla, ktorých skóre je nanajvýš 11. Skóre ľubovoľného čísla $n$ preto vieme ľahko a efektívne vyhodnotiť: postupne počítame $s(n)$, $s(s(n))$, atď., až kým sa buď nedostaneme k jednocifernému číslu (kedy vieme povedať, aké skóre má $n$) alebo nespravíme 12 krokov (kedy vieme povedať, že $n$, z ktorého sme začínali, bude mať určite priveľké skóre).

Neskôr si ukážeme, že ani to počítanie krokov do 12 nie je potrebné robiť, lebo úplne každé číslo do $10^{18}$ má vždy maličké skóre. Ak ste teda v programe len priamo implementovali počítanie skóre podľa definície, bolo to v praxi rovnako dobré.

## Ako vyzerá hľadané riešenie?

Zamyslime sa teraz, čo vieme povedať o správnej odpovedi.

Začneme tým, že skontrolujeme čísla od 0 po 19. Čísla od 0 po 9 majú skóre dané na vstupe a hociktoré z nich môže byť tým, ktoré hľadáme. Čísla od 10 po 19 sú najmenšie viacciferné čísla, ktorých ciferný súčin je od 0 po 9. Aj každé z nich môže byť správnou odpoveďou. Ak sme medzi nimi správnu odpoveď nenašli, vieme, že má hodnotu aspoň 20. Uvažujme teraz o situáciách, kedy je správna odpoveď aspoň 20:

- Správna odpoveď nemôže obsahovať cifru 0. Ak by ju obsahovala, mala by ciferný súčin 0, a teda rovnaké skóre ako číslo 10, ktoré je od nej menšie.

- Ako už vieme, správna odpoveď musí mať cifry usporiadané od najmenšej po najväčšiu. (Keďže už vieme, že nemáme cifru 0, nemôže nám pri usporadúvaní cifier vzniknúť problém s nulou na začiatku čísla.)

- Správna odpoveď následne nemôže obsahovať ani cifru 1. Takéto číslo musí byť aspoň trojciferné (dvojciferné začínajúce 1 sme už pozerali) a keď mu úvodnú cifru 1 zmažeme, tak sa samotné číslo zmenší a jeho ciferný súčin sa nezmení.

## Už sme vyhrali?

Áno. Totiž po úvahe, ktorú sme práve spravili, nám ostane tak malé množstvo kandidátov na správnu odpoveď, že si môžeme dovoliť všetkých vygenerovať a skontrolovať. Dokopy je medzi nanajvýš 18-cifernými číslami len pribiližne 1.5 milióna takých, ktorých cifry sú 2-9 a sú usporiadané od najmenšej po najväčšiu.

## Implementácia

Samotná implementácia je už pomerne priamočiara. Všetkých $k$-ciferných kandidátov na riešenie vieme vygenerovať tak, že vygenerujeme všetkých $(k-1)$-ciferných a každému na koniec pridáme všetky možnosti pre ďalšiu cifru. Takýmto postupom vieme dokonca všetkých kandidátov generovať v usporiadanom poradí, takže akonáhle narazíme na nejakého so správnym skóre, môžeme si byť istí, že sme práve našli riešenie.

## Efektívnejšie hľadanie

Množinu kandidátov, ktorých treba prezrieť, vieme ešte ďalej celkom výrazne prečistiť. Napríklad takto:

- Číslo $n$ nebude obsahovať cifry 22 (lepšie je mať jednu štvorku), 23 (šestku), 24 (osmičku) ani 33 (deviatku).

- Číslo $n$ nebude obsahovať cifry 34, lebo lepšie je mať cifry 26 -- číslo bude menšie a ciferný súčin rovnaký. Podobne vieme, že $n$ nebude obsahovať cifry 36 (lepšie je 29), 44 (lepšie je 28), 46 (lepšie je 38) ani 66 (lepšie je 49).

- Ak máme v $n$ cifru 5 tak nemôžeme mať žiadnu párnu cifru -- lebo $s(n)$ bude končiť nulou a potom $s(s(n))$ bude nula. Medzi zakázané dvojice cifier teda môžeme pridať aj 25, 45, 56 a 58.

Ak do generovania kandidátov pridáme tieto obmedzenia, zredukujeme ich počet z vyššie spomínaného približne 1.5 milióna na iba približne $9,000$.

## Checkpoint

Niekde tu by sa dalo vzorové riešenie tejto úlohy ukončiť. My v ňom však ešte nejakú tú chvíľu budeme pokračovať a doplníme ešte nejaké detaily a zaujímavostí navyše.

## Počítanie kandidátov

Vyššie sme uvádzali nejaké číselné odhady počtov kandidátov. Tie samozrejme vieme získať tak, že ich naozaj vygenerujeme a spočítame. Vieme ich ale veľmi ľahko spočítať aj pomocou kombinatoriky.

Pozrime sa napríklad na všetky $d$-ciferné čísla, ktorých cifry sú od 2 po 9 a sú usporiadané od najmenšej po najväčšiu. Koľko ich je?

Predstavme si, že máme premennú, v ktorej je na začiatku cifra 2, a dve rôzne inštrukcie: inštrukcia `+` zväčší hodnotu v premennej a inštrukcia `p` ju vypíše.

Pomocou takýchto inštrukcií vieme vyrábať čísla, ktorých cifry sú usporiadané. Napr. postupnosť inštrukcií `++p+pp+++p+` vyrobí číslo 4558.

Pozrime sa na postupnosti inštrukcií, ktoré obsahujú práve sedem inštrukcií `+` a práve $d$ inštrukcií `p`. Každá takáto postupnosť vyrobí nejaké $d$-ciferné číslo, ktorého cifry sú od 2 do 9 a postupne rastú. A naopak, keď zoberieme ľubovoľné takéto číslo, vieme nájsť práve jednu takúto postupnosť inštrukcií, ktorá ho vyrobí: ideme zľava doprava a pri každej cifre najskôr stlačíme správne veľa `+` aby sme premennú nastavili na jej hodnotu a potom stlačíme `p`. (Po poslednej cifre ešte doplníme prípadné chýbajúce `+`.)

Hľadaných čísel je teda presne toľko isto ako reťazcov dĺžky $d+7$, ktoré obsahujú $d$ péčok a 7 plusov. No a takýchto reťazcov je zjavne ${d+7\\choose 7}$: vyberieme, na ktorých siedmich pozíciách sú plusy a tým je jednoznačne určené, kde sú péčka.

## Asymptotické odhady

Môžeme rozpísať, že ${d+7\\choose 7} = \\frac{(d+7)(d+6)\\cdots(d+1)}{7!}$. Z toho je zjavné, že počet čísel, ktoré majú usporiadané cifry od 2 po 9, závisí od ich dĺžky $d$ len polynomiálne: je ich $\\Theta(d^7)$.

Keď sme prečistili množinu kandidátov, ostali nám v nej len čísla, ktoré mali nanajvýš po jednej z cifier 2, 3, 4, 6. Navyše buď mali len nepárne cifry (vtedy sú premenlivé len počty cifier 5, 7 a 9) alebo neobsahovali cifru 5 (a vtedy sú premenlivé zase len počty cifier 7, 8 a 9). Podobnou kombinatorickou úvahou dostávame, že čísel dĺžky $d$ jedného aj druhého typu je len $\\Theta(d^2)$.

## Otvorený problém na záver

Najjednoduchšou možnou formou zadania našej úlohy je verzia v ktorej všetky jednociferné čísla majú skóre nula. Pre takýto vstup platí, že skóre čísla udáva jednoducho počet opakovaní operácie ""nahraď číslo jeho ciferným súčinom"" po ktorom dostaneme jednociferné číslo. Matematici v teórii čísel toto občas nazývajú nie skóre, ale _multiplikatívna perzistentnosť_ čísla.

Ak ste si skúšali svoj program spustiť pre najväčšie platné vstupy, určite ste v jeho výstupoch často narazili na číslo $277,777,788,888,899$. Toto je najmenšie číslo, ktoré má multiplikatívnu perzistentnosť 11.

Prečo sme ako najväčšie povolené $c$ v zadaní zvolili práve 11? O koľko väčšia je vlastne správna odpoveď pre $c=12$? Nevieme podobným postupom nájsť aj tú?

Nuž... nielen že nevieme, my vlastne dodnes ani nevieme, či vôbec nejaké takéto číslo existuje. Jeho existencia je otvoreným problémom, ktorý už nejaký ten rok odoláva snahám matematikov. Zatiaľ vieme dokázať, že _ak_ takéto číslo existuje, _tak_ určite musí mať výrazne viac ako $20,000$ cifier. Ale skôr si myslíme, že neexistuje. A dokonca _pravdepodobne_ platí ešte podivuhodnejšie tvrdenie: je možné, že už poznáme _úplne všetkých_ kandidátov, ktorí majú multiplikatívnu perzistentnosť väčšiu ako 2. Vyzerá to totiž tak, že keď budeme postupne prezerať väčších a väčších kandidátov, tak nielen že nenájdeme žiadneho s multiplikatívnou perzistentnosťou 12, ale naopak sa veľmi rýchlo minú všetci s multiplikatívnou perzistentnosťou väčšou ako 2.

Prečo je to tak? Intuitívne sa to dá priblížiť nasledovne. Majme nejakého kandidáta s veľmi veľkým počtom cifier. Toto je nejaké pekné systematické číslo, ktorého cifry sú od 2 od 9. Jeho ciferným súčinom je nejaké iné, tiež ešte obrovské číslo. Toho cifry sú však už všelijaké chaotické a skoro vždy niekde medzi nimi vybehne nejaká tá nula. Takže to vyzerá tak, že pre ľubovoľného veľkého kandidáta $n$ skoro určite platí $s(s(n)) = 0$.

Posledná známa výnimka má 140 cifier. Presnejšie, 140-ciferné číslo $v = 2^{25} \\times 3^{227} \\times 7^{28}$ neobsahuje žiadnu nulu a jeho multiplikatívna perzistentnosť je presne 2. Toto číslo $v$ je rovné $s(n)$ pre niekoľko podobne veľkých kandidátov $n$ ktorí potom majú multiplikatívnu perzistentnosť až 3. Ale od 140 cifier ďalej až po vyše $20,000$ cifier už sme prezreli všetky možnosti a sme si úplne istí, že úplne všetky možné $s(n)$ obsahujú v sebe aspoň jednu nulu.

Zrejme to bude platiť aj ďalej pre ešte väčšie čísla. Hja, ale ako takéto niečo exaktne dokázať?
",6
59e4ca3c1690beca,ksp,"# Osamelý a jednobunkový

Bol raz jeden jednobunkový organizmus menom Cecil^[Možno ste už počuli o jeho pradedovi Bacilovi.]. Bolo mu smutno, lebo nebolo nikoho, s kým by sa mohol porozprávať pri jedle, a tak sa Cecil začal deliť, aby mal koho pozvať na svoje párty.

Časom mal Cecil dosť potomkov, a tak sa rozhodol zorganizovať párty. Pozval na ňu všetkých svojich $k$-potomkov. ($1$-potomok Cecila je každé jeho dieťa, $2$-potomok je každé jeho vnúča, atď.)

Postupom času začali aj potomkovia Cecila organizovať párty podobným spôsobom. Každému svojmu $k$-potomkovi pošlú pozvánku na svoju párty. Tá má nasledovnú formu: ""Na jeho veľkú párty ťa pozýva tvoj $k$-ty predok, sám magnificentný...""

Cecilovi potomkovia sú ale inteligentní, lebo to bolo v Cecilovych génoch. Je im jasné, že množstvo jedla a kofoly, ktoré sa im na párty ujde, je určené počtom účastníkov párty. Nie vždy sa teda oplatí ísť na párty. Pomôžte im pri rozhodovaní -- pre každú pozvánku určite, koľko účastníkov bude na párty ak sa jej všetci pozvaní zúčastnia.

## Úloha

Zadaný je zakorenený strom s $n$ vrcholmi. Prichádza vám postupne $m$ otázok. Každá otázka je určená vrcholom $v$ a poradovým číslom predka $k$. Pre každú otázku zistite, koľko $k$-potomkov má $k$-predok vrchola $v$. Ak $k$-predok vrcholu $v$ neexistuje, tak je odpoveď $0$.

$1$-potomok vrcholu $v$ je ľubovoľné jeho dieťa. Pre $k > 1$ je $k$-potomok vrcholu $v$ ľubovoľné dieťa niektorého $(k-1)$-potomka $v$. $1$-predok vrcholu $v$ je otec $v$ ak existuje. Pre $k > 1$ je $k$-predok vrcholu $v$ otec $(k-1)$-predka $v$.

Úlohu je nutné riešiť online -- váš program sa nedozvie ďalšiu otázku, kým neodpovie na tú aktuálnu. Za každou odpoveďou preto použite `fflush(stdio)` alebo `cout << flush`, aby sa výstup vášho programu hneď odoslal testovaču.

## Formát vstupu

Na prvom riadku vstupu je celé číslo $t$ ($1 \\leq t \\leq 1,000$) -- počet testov. Každý z testov má nasledovný formát:

Prvý riadok testu obsahuje jedno celé číslo $n$ ($1 \\leq n \\leq 100,000$) -- počet vrcholov stromu. Druhý riadok testu obsahuje $n$ čísel $p_1, p_2, \\ldots, p_n$ -- $i$-te z nich je číslo priameho predka vrcholu $i$. Ak je vrchol $i$ koreňom stromu, tak $p_i = 0$. (Pre $i$ také, že vrchol $i$ nie je koreňom stromu platí $1 \\leq p_i \\leq n$.) Môžete predpokladať, že zadaný graf je naozaj strom.

Tretí riadok testu obsahuje jedno celé číslo $m$ ($1 \\leq m \\leq 100,000$) -- počet otázok. Nasleduje $m$ riadkov, $i$-ty z nich obsahuje dve celé čísla $v_i, k_i$ ($1 \\leq v_i, k_i \\leq n$) popisujúce otázku.

Súčet $n$ zo všetkých testov nepresiahne $100,000$, a súčet $m$ zo všetkých testov nepresiahne $150,000$.

## Formát výstupu

Pre každú otázku vypíšte na samostatný riadok jedno celé číslo -- počet $k$-potomkov $k$-predka vrcholu $v$.

## Príklad

```vstup
2
8
4 4 2 0 4 5 5 5
6
1 1 // 1-predok 1 je 4.
    // Jeho 1-potomkovia su 5, 2 a 1.
1 2 // 2-predok 1 neexistuje.
3 1 // 1-predok 3 je 2.
    // Jeho 1-potomok je len 3.
3 2 // 2-predok 3 je 4.
    // Jeho 2-potomkovia su 8, 7, 6 a 3.
3 3 // 3-predok 3 neexistuje.
5 1 // 1-predok 5 je 4.
    // Jeho 1-potomkovia su 5, 2 a 1.
5
3 0 2 5 1
5
4 5
4 1
1 2
1 3
2 1
```

```vystup
3
0
1
4
0
3
0
1
1
0
0
```

*Text uvedený za `//` je komentár -- v skutočných vstupoch sa žiadne komentáre samozrejme nachádzať nebudú. Druhý test má správny formát. Strom v prvom teste vyzerá nasledovne:*
","# Osamelý a jednobunkový

Povedzme, že chceme zodpovedať otázku určenú vrcholom $v$ a číslom $k$ -- teda chceme nájsť počet $k$-potomkov $k$-predka vrcholu $v$. To možno rozdeliť na dve podotázky:

- Zadaný je vrchol $v_1$ a číslo $k_1$. Existuje $k_1$-predok vrcholu $v_1$? Ak áno, ktorý vrchol to je?

- Zadaný je vrchol $v_2$ a číslo $k_2$. Koľko $k_2$-potomkov má vrchol $v_2$?

## Pomalé riešenie

Na zodpovedanie prvej podotázky môžeme postupovať nasledovne:

- Ak $k = 0$, tak $k$-predok vrcholu $v$ je samotný vrchol $v$.

- V opačnom prípade je to ten istý vrchol, ako $(k-1)$-predok otca $v$ -- a toho vieme nájsť rekurzívne.

Zistiť odpoveď pre druhú podotázku vieme takto:

- Ak $k = 0$, tak je odpoveď zrejme $1$ -- jediný $0$-potomok vrcholu $v$ je samotný vrchol $v$.

- V opačnom prípade nech $d_1, d_2, \\ldots, d_i$ sú všetky deti vrcholu $v$. Označme $r_1, r_2, \\ldots, r_i$ postupne počty $(k-1)$-potomkov týchto vrcholov. Ľahko si možno rozmyslieť, že $v$ má práve $r_1 + r_2 + \\ldots + r_i$ $k$-potomkov. No a hodnoty $r_1, r_2, \\ldots, r_i$ vieme vypočítať rekurzívne.

Prvá fáza algoritmu môže mať až toľko krokov, koľko je hĺbka vrcholu $v$, keďže postupne zisťujeme jeho $1$-predka, $2$-predka, ... A to môže byť až lineárne od $n$.

Druhá fáza algoritmu môže mať až toľko krokov, koľko je počet vrcholov v podstrome vrcholu $v$ -- a tých môže byť až lineárne veľa od $n$.

Časová zložitosť na zodpovedanie jednej otázky je teda $O(n)$, celkovo máme preto časovú zložitosť $O(nq)$. Pamäťová zložitosť je $O(n)$ -- pamätáme si iba reprezentáciu stromu.

## Rýchlejšie zodpovedanie prvej podotázky

Predstavme si, že by sme si nepamätali pre každý vrchol iba jeho $1$-predka, ale aj jeho $2$-predka. Potom by sme $k$-predka vrcholu $v$ vedeli nájsť zhruba dvakrát rýchlejšie:

- Ak $k \\geq 2$, tak sa rekurzívne zavoláme -- zrejme hľadáme $(k - 2)$-predka vrcholu $x$, ktorý je $2$-predkom vrcholu $v$.

- Ak $k = 1$, tak odpoveďou je $1$-predok vrcholu $v$.

- V poslednom prípade $k = 0$, a odpoveďou je samotný vrchol $v$.

Ďalej si predstavme, že si nepamätáme iba $2$-predkov, ale aj ďalších predkov s takými číslami, ktoré sú mocninami dvojky -- $4, 8, 16, \\ldots$. Takto si pre každý vrchol pamätáme rádovo $\\log{n}$ čísel. Žiadny vrchol totiž nemá viac ako $n$ predkov, a nemá preto zmysel počítať jeho $(2^i)$-predka pre $2^i > n$.

Zodpovedanie otázky má veľmi podobnú formu.

- Ak $k > 0$, nájdeme najväčšie číslo tvaru $2^i$, ktoré je menšie ako $k$. Ak vrchol $v$ nemá $(2^i)$-predka, tak nemôže mať ani $k$-predka. V opačnom prípade vieme v konštantnom čase pozrieť, ktorý vrchol je $(2^i)$-predok $v$. Rekurzívne nájdeme $(k - 2^i)$-predka tohto vrcholu.

- Ak $k = 0$, tak odpoveď je zrejme $v$.

Navyše si všimnime, že ak v rekurzívnom volaní skočíme z $v$ na jeho $(2^i)$-predka, potom v nasledujúcom rekurzívnom volaní určite môžeme skočiť najviac na $(2^{i - 1})$-predka.

Ak by sme totiž znovu skočili hore aspoň o $2^i$, skončili by sme vo vrchole, ktorý je aspoň $(2^i + 2^i)$-predkom $v$ -- potom určite $2^{i + 1} \\leq k$. Ale to by sme vedeli skočiť o $2^{i + 1}$ už v prvom volaní.

Takže, ak označíme $i$ najväčšie číslo také, že $v$ má $(2^i)$-predka, stačí nám pri hľadaní $k$-predka skúšať $2^i, 2^{i-1}, 2^{i-2}, \\ldots, 1$. Každé raz a v tomto poradí. Dostávame tak algoritmus, ktorý má časovú zložitosť $O(\\log{n})$.

Ešte sme ale vôbec neriešili, ako rýchlo vypočítať týchto mocninových predkov. Predstavme si, že chceme nájsť $(2^i)$-predka vrcholu $v$. To ale nie je nič iné, ako jeho $(2^{i - 1} + 2^{i - 1})$-predok. Takže môžeme postupovať tak, že najprv nájdeme jeho $(2^{i - 1})$-predka -- nech to je $x$. Potom nájdeme $(2^{i - 1})$-predka vrcholu $x$ -- výsledný vrchol je práve $(2^i)$-predok vrcholu $v$.

Na začiatku pre každý vrchol vypočítame jeho $1$-predka (napríklad prehľadávaním do hĺbky). Potom vieme pre každý vrchol vypočítať jeho $2$-predka, potom pre každý vrchol jeho $4$-predka, potom pre každý vrchol jeho $8$-predka, a tak ďalej.

Časová zložitosť tohto predpočítania je teda $O(n\\log{n})$, a pamäťová takisto, keďže si všetkých týchto predkov musíme pamätať.

## Rýchlejšie zodpovedanie druhej podotázky

Rozdeľme si všetky vrcholy do vrstiev podľa toho, akú majú vzdialenosť od koreňa stromu. Na prvej vrstve sa nachádza iba koreň, na druhej sú jeho deti, na tretej sú zas ich deti, ... Pre každý vrchol $v$ označme $h(v)$ číslo vrstvy, na ktorej sa nachádza.

Zrejme $k$-potomkov vrcholu $v$ stačí hľadať medzi vrcholmi na vrstve $h(v) + k$. Tých ale stále môže byť rádovo $n$.

Po chvíli kreslenia stromov a pozorovania rôznych $k$-potomkov rôznych vrcholov $v$ odpozorujeme, že tí potomkovia akosi vždy tvoria vo vrstve súvislý úsek. V nasledujúcom obrázku sú napríklad zobrazení $2$-potomkovia vrcholu $5$:

Ten istý strom môže ale vyzerať úplne inak:

Uvedomíme si, čo určuje poradie vrcholov vo vrstve -- pre každý vrchol máme totiž zoznam jeho synov, ale týchto synov môžeme zľava doprava nakresliť v ľubovoľnom poradí. Zvoľme si teda pre každý vrchol $v$ nejaké poradie jeho synov.

Nahliadneme, že ak $a, b$ sú synovia vrcholu $v$ a $a$ je pred $b$, tak v rámci každej vrstvy je každý potomok $a$ v tej vrstve pred každým potomkom $b$.

Na základe týchto pozorovaní vieme poradie vo vrstvách zostrojiť jednoduchým prehľadávaním do hĺbky. Keď **prvýkrát navštívime** (ďalej *objavíme*) vrchol $v$, tak si pre neho zapamätáme, koľký v poradí objavený vrchol to je. Potom postupne navštívime jeho synov v poradí, ktoré sme si zvolili. V rámci každej vrstvy sú potom vrcholy usporiadané podľa toho, kedy sme ich objavili.

A keď už vieme, že vo vrstve budú vrcholy usporiadané podľa času ich objavenia, tak ich do vrstvy vieme pridať hneď keď ich objavíme.

Teraz už máme vrcholy v každej vrstve usporiadané tak, že keď hľadáme $k$-potomkov niektorého vrcholu $v$, tvoria vo vrstve súvislý úsek. Ako ale zistíme, kde ten úsek začína a kde končí?

Zoberme si ľubovoľnú vrstvu, a nech $x$ je niektorý vrchol na nej. Rozmyslite si, že ak $x$ je potomkom $v$, tak sme ho určite objavili neskôr ako sme objavili $v$.

Pozrime sa na úsek potomkov $v$ na tejto vrstve. Prvý vrchol $x_1$ v tomto úseku sme objavili neskôr, ako $v$ -- a spomedzi všetkých takých vrcholov sme ho objavili najskôr. Vieme ho teda vo vrstve binárne vyhľadať, nakoľko vrcholy na nej sú usporiadané podľa času ich objavenia.

Takto sme našli začiatok úseku, ako ale nájdeme jeho koniec? Podobne -- pre každý vrchol si tiež zistíme, kedy sme ho **naposledy navštívili** (ďalej *opustili*).

Opäť si zoberme ľubovoľnú vrstvu, a nech $x$ je niektorý vrchol na nej. Potom ak $x$ je potomkom $v$, tak sme ho určite opustili skôr, ako sme opustili $v$.

Rozmyslite si, že v každej vrstve je usporiadanie vrcholov podľa času prvej návštevy rovnaké, ako usporiadanie podľa času poslednej návštevy.

Pozrime sa teda na úsek potomkov $v$ na tejto vrstve. Posledný vrchol $x_2$ v tomto úseku bol opustený skôr, ako sme opustili $v$ -- a spomedzi všetkých takých vrcholov sme ho opustili najneskôr. Vieme ho teda vo vrstve binárne vyhľadať.

No a ak prvý vrchol v úseku je $i$-ty, a posledný vrchol v úseku je $j$-ty, počet vrcholov vo vnútri úseku je $j - i + 1$.

## Rekapitulácia

Zrekapitulujme si naše riešenie. Najprv v čase $O(n\\log{n})$ predpočítame pre každý vrchol jeho $1, 2, 4, 8, \\ldots$ predkov. V čase $O(n)$ prehľadáme graf do hĺbky, a pre každý vrchol zistíme čas jeho prvej návštevy a čas poslednej návštevy. Pritom zostrojujeme zoznamy vrcholov v každej vrstve. Celkovo máme čas $O(n\\log{n})$ na predpočítanie.

Keď odpovedáme na otázku určenú vrcholom $v$ a číslom $k$, v čase $O(\\log{n})$ nájdeme $k$-predka vrcholu $v$. Potom vo vrstve $h(v)$ binárne vyhľadáme začiatok úseku potomkov $k$-predka $v$, a tiež koniec tohto úseku -- to nám tiež zaberie čas $O(\\log{n})$. Na otázkach teda minieme $O(q\\log{n})$ času.

Celková časová zložitosť je potom $O((n + q) \\log{n})$. Pamäťová zložitosť je $O(n\\log{n})$.

## Rýchlejšie a úspornejšie

Vráťme sa späť k prvej podotázke. V nej sme dostali zadaný vrchol $v$ a číslo $k$, a chceli sme vedieť, či existuje $k$-predok vrcholu $v$ a ak áno, ktorý vrchol to je. Označme ho $x$.

Teraz už ale pre každý vrchol vieme, kedy sme ho prvýkrát navštívili, a kedy sme ho naposledy navštívili. A tiež vieme povedať, v ktorej vrstve sa nachádza. To využijeme na vytvorenie lepšieho riešenia.

Vieme totiž, že $x$ musí spĺňať nasledovné:

- Musí ležať na vrstve s číslom $h(v) - k$.

- Objavili sme ho skôr, ako vrchol $v$.

- Opustili sme ho neskôr, ako $v$.

Potom vieme $x$ vo vrstve binárne vyhľadať.

Týmto sme si ušetrili $n\\log{n}$ operácii potrebných na predpočítanie, a s tým spojených $n\\log{n}$ pamäte. Dostávame tak celkovú časovú zložitosť $O(n + q\\log{n})$, a pamäťovú zložitosť $O(n)$.
",9
ae55dfcc006b61f0,ksp,"# Ohromná estetickosť

Odjakživa to tak bolo... V kadiach pred Tesclandom kapre, na cestách čľapkanica, v izbe predčasne vybrakovaný adventný kalendár. V obývačke stromček, na ňom obaly od salóniek, z toho polovica prázdna. Prázdniny sa už nezadržateľne blížia, no Matúš ešte musí dokončiť ten projekt z dejepisu o prínose Etruskov pre Staroveký Rím.

Dejepis je super, ale v tomto predvianočnom čase naň už niet dostatok síl. Na druhej strane, v Tesclande sa momentálne chystá zaujímavá akcia. Každých $15$ minút, dostanú všetci zákazníci prítomní v predajni vianočnú guľu. Vianočné gule sú dostupné v $20$ farbách, no zákazník si farbu nevyberá. Našťastie, je dopredu známe, kedy sa budú rozdávať ktoré farby.

Matúš sa tak rozhodol, že nudu plynúcu z písania domácich úloh nahradí niečim užitočnejším a pôjde do Tesclandu nazbierať nejaké gule. Nechce ale ľubovoľné farby... Rád by vyzbieral čo najviac gúľ takých, že ak ich potom __všetky__ zavesí nad svoj písací stôl, postupnosť ich farieb bude rovnaká z ľavej aj z pravej strany.

Samozrejme, nepôjde tam len-tak hocikedy, keďže tie domáce úlohy naozaj musí niekedy dokončiť a nemôže teraz všetko svoj čas stráviť v obchode (aj keď rád by). Chcel by tam stráviť čo najmenej času a nechce tam ísť viac ako raz. Inými slovami, pôjde tam raz, strávi tam určitý čas, počas ktorého dostane nejaké vianočné gule (a žiadnu neodmietne), a potom sa vráti domov.

Matúš tam naozaj chce ísť. Pomôžte mu vopred zistiť, koľko najviac gúľ si domov prinesie, aby neporušil dané pravidlá.

## Úloha

Poznáte postupnosť farieb vianočných gúľ v poradí, v akom sa budú rozdávať. Zistite, koľko najviac si ich Matúš môže priniesť domov, ak chce v obchode stráviť iba jeden súvislý časový úsek a chce, aby množina týchto gúľ spĺňala zaujímavú __ohromne estetickú__ podmienku: Všetky získané gule musí byť možné zavesiť vedľa seba tak, aby vzniknutá postupnosť ich farieb bola rovnaká z ľavej aj z pravej strany. (Vianočné gule môžu byť zavesené v inom poradí, v akom boli rozdávané v obchode)

## Formát vstupu

Na prvom riadku vstupu sa nachádza $1 \\leq n \\leq 300,000$ udávajúce počet rozdávaní vianočných gúľ v obchode (Pri jednom rozdávaní, získa každý človek v supermarkete vianočnú guľu).

Na druhom riadku vstupu sa nachádza $n$ farieb gúľ v poradí, v akom budú rozdávané, pričom farba gule je vyjadrená malým písmenom anglickej abecedy od `a` po `t`.

## Formát výstupu

Na výstup vypíšte jedno číslo, dĺžku najdlhšej súvislej podpostupnosti získaných gúľ, ktorej preusporiadaním (alebo aj ponechaním v pôvodnom poradí) môže vzniknuť postupnosť spĺňajúca podmienku o ohromnej estetickosti.

## Príklady

```vstup
12
aabbccddabcd
```

```vystup
9
```

_Ak bude Matúš v obchode od prvej po deviatu (vrátane) štvrťhodinu, vyzbiera vianočné gule týchto farieb: `aabbccdda`. Tieto vieme zavesiť nad písací stôl, napríklad, v takomto poradí: `dcbaaabcd`, čo je palindróm, a teda táto súvislá podpostupnosť vianočných gúľ spĺňa Matúšove nekompromisné podmienky. Z pohľadu voľným okom je jasné, že táto podpostupnosť má dĺžku 9 a je najdlhšia možná._

```vstup
20
ghjahjghsajdjhlfslja
```

```vystup
7
```
","# Ohromná estetickosť

V prvom rade si uvedomme, čo je našou úlohou.

_Zistite, koľko najviac si ich Matúš môže priniesť domov, ak chce v obchode stráviť iba jeden súvislý časový úsek a chce, aby množina týchto gúľ spĺňala zaujímavú ohromne estetickú podmienku: Všetky získané gule musí byť možné zavesiť vedľa seba tak, aby vzniknutá postupnosť ich farieb bola rovnaká z ľavej aj z pravej strany._

V preklade toto znamená, že chceme nájsť najdlhší súvislý podreťazec, z ktorého vieme spraviť palindróm. _Spraviť palindróm_ znamená, že môžeme meniť poradie písmen v tomto podreťazci tak, aby výsledný reťazec bol palindróm.

## Čo vieme o palidróme?

Palindróm je reťazec, ktorý je rovnaký z jednej aj z druhej strany. Existuje v ňom teda nejaký stred, od ktorého sa vľavo a vpravo nachádzajú rovnaké znaky v rovnakom poradí.

Keďže všetky znaky, nachádzajúce sa vľavo od stredu, sa nachádzajú aj vpravo od stredu, vieme, že sa v palindróme každý znak, nachádzajúci v jednej polovici, nachádza celkovo dvakrát.

Samozrejme, to platí, ak má palindróm párnu dĺžku a jeho stred je tak presne medzi dvoma písmenami. Ak má palindróm nepárny počet znakov, jeden znak je presne v strede. Tento stredný znak sa nenachádza vľavo ani vpravo od stredu, preto nemá svoju ""dvojičku"" v druhej polovici palindrómu a je nám jasné, že sa v palindróme nachádza práve raz.

Z takejto úvahy sa dozvedáme, že v palindróme párnej dĺžky sa musí každý znak vyskytovať párny-počet-krát a v palindróme nepárnej dĺžky sa musia všetky znaky okrem práve jedného vyskytovať párny-počet-krát.

__Zjednodušene:__ V palindróme sa musí žiadny alebo jeden znak vyskytovať párny-počet-krát.

## Všetky podreťazce

Okay. Chceme asi zistiť početnosti znakov v jednotlivých podreťazcoch vstupného reťazca gúľ a nájsť taký najdlhší podreťazec, že žiadny alebo práve jeden znak má v ňom nepárnu početnosť.

Ak má reťazec dĺžku $n$, existuje $\\frac{(n+1)\\cdot n}{2}$ jeho podreťazcov (1 dlžky $n$, 2 dĺžky $n-1$, 3 dĺžky $n-2$, \\dots $n$ dĺžky 1), čo je asymptoticky $n^2$. Ak by sme pre chceli každý jeden podreťazec rátať početnosti jeho znakov osobitne, museli by sme spracovať vštky znaky vo všetkých podreťazcoch. Počet znakov vo všetkých podreťazcoch je asymptoticky $n^3$.

Okrem toho by sme pre každý podreťazec museli skontrolovať $k$ početností znakov, aby sme zistili, či spĺňa podmienky. $k$ je veľkosť abecedy, no v zadaní sme sa dozvedeli, že je to najviac 20, preto môžeme toto číslo brať ako konštantu. Z toho vidíme časovú zložitosť $\\mathcal{O}(n^3)$.

## Niečo lepšie

Predchádzajúce riešenie vieme značne vylepšiť jednoduchou myšlienkou. Nepotrebujeme pre každý jeden podreťazec rátať početnosť odznova, vieme využiť informáciu z o jedno menšieho podreťazca.

Ak nebudeme rátať početnosti znakov v každom podreťazci osobitne, ale využijeme to, že početnosť v reťazci o dĺžke $x$ sa len pre jeden znak líši od početnosti jeho podreťazca o dĺžke $x-1$. To znamená, že počas výpočtu početností pre nejaký podreťazec so znakmi $C_i$ až $C_j$ sme už vyrátali aj početnosti pre podreťazce so znakmi $C_i\\rightarrow C\_{i+1}, C_i\\rightarrow C\_{i+2},\\dots C_i\\rightarrow C\_{j-1}$. To znamená, že nám vlastne stačí spracovať len $n$ podreťazcov ($C_0\\rightarrow C_n, C_1\\rightarrow C_n,\\dots C_n\\rightarrow C_n$). Priemerná dĺžka týchto podreťazcov je $\\frac{n}{2}$ znakov.

Vidíme, že takýmto prístupom nám časová zložitosť klesne na $\\mathcal{O}(n^2)$. Pamäťová zložitosť je tu $\\mathcal{O}(n)$. Potrebujeme si pamätať len celý vstupný reťazec.

## Zjednodušenie a prefixy

Položme si otázku: Naozaj potrebujeme vedieť konkrétne početnosti znakov? Hm\\dots Povedal by som, že nás aj tak vo výsledku zaujímajú iba parity týchto početností (či sú párne alebo nepárne). To by ale predchádzajúce riešenie aj tak nezlepšilo, aj tak by sme museli spracovať $n$ podreťazcov.

Navyše, prečo musíme spracovať osobitne $n$ podreťazcov? Teraz si uvedomme, ak máme informácie o paritách v podreťazcoch $C_i\\rightarrow C_j$ a $C_i\\rightarrow C_k$ pre $j < k$, vieme z toho zistiť aj paritu podreťazcu $C_j\\rightarrow C_k$. V podstate prefixové súčty.

Ak je medzi indexami $i$ a $j$ početnosť nejakého písmena $a\_{ij}$ a medzi indexami $i$ a $k$ $a\_{ik}$, početnosť mezi indexami $j$ a $k$ je potom $a\_{jk} = a\_{ik} - a\_{ij}$. To isté platí aj pre paritu tejto početnosti. Ak, napríklad, $a\_{ij} = parne$ a $a\_{ij} = neparne$, tak $a\_{jk} = neparne$.

Zo spracúvania $n$ podreťazcov, začínajúcich na indexoch $0\\dots n-1$, sa dostávame k tomu, že nám stačí spracovať celý reťazec len raz. Počas jeho spracúvania, spracúvame postupne všetky podreťazce začínajpce na indexe 0. V predchádzajúcom odesku sme si ukázali, že ak poznáme parity reťazcov, začínajúcich na rovnakom indexe, poznáme aj parity medzi ich koncami. Ak poznáme parity všetkých podreťazcov, začínajúcich na indexe 0, poznáme aj parity všetkých podreťazcov medzi všetkými ich koncami, čo sú vlastne všetky podreťazce celého reťazcu. Čo s nimi?

## Xor a zapamätanie najľavejšej

$a\_{jk} = neparne$, ak $a\_{ij} \\neq a\_{ij}$. To vyzerá ako xor.

V zadaní sa spomína, že v reťazci je najviac $20$ rôznych znakov. Každý z týchto 20 znakov môže mať párnu alebo nepárnu paritu. To je dokopy $2^{20}$ kombinácií parít jednotlivých znakov.

Hm\\dots Informáciu o parite nejakého podreťazcu si môžeme reprezentovať, napríklad, nejakým binárnym číslom s 20 bitmi. Ak máme dva takéto podreťazce, začínajúce na rovnakom indexe, xorom ich parít dostaneme paritu podreťazcu medzi ich koncami.

Ku každej parite existuje 20 takých, ktoré sa líšia práve v jednom znaku. Ak spracúvame vstupný reťazec z ľava do prava a sme na nejakom _i_-tom znaku reťazca, zaujíma nás, či a kde vľavo od neho sa nachádza znak, na ktorom sa parita nelíši od aktuálnej alebo sa líši v práve jednom znaku. To znamená, že podreťazec medzi nimi má vyhovujúcu paritu (0 alebo 1 nepárnych).

Dokonca, môžeme povedať, že má zmysel hľadať len tú najľavejšiu z takých parít. Hľadáme _najdlhší_ podreťazec, preto pre nás nemá zmysel nie-najľavejšia parita, pretože tá by určite nepatrila najdlhšiemu takému podreťazcu, ak by existovala nejaká ľavejšia, čiže vzdialenejšia od aktuálne spracúvaného znaku.

## Zhrnutie vzorového riešenia

Pamätáme si pre každú paritu, kde najskôr sa v reťazci vyskytuje. Pre každý aktuálne spracúvaný index reťazcu si nájdeme najľavejšiu vyhovujúcu paritu (ak existuje), lebo tá začína najdlhší podreťazec končiaci v aktuálnom znaku. Keď takto spracujeme celý reťazec, je nám známa dĺžka najdlhšieho podreťazcu, z ktorého je možné vytvoriť palindróm.

Časová zložitosť. Pre každý znak v reťazci potrbujeme len nájsť najľavejší s vyhovujúcou paritou, ktorých je $k+1$. To nám dáva krásne $\\mathcal{O}(n\\cdot k)$, kde $n$ je dĺžka reťazcu a $k$ je počet farieb. Ak si ale povieme, že 20 (najviac farieb) je konštanta, ostane nám $\\mathcal{O}(n)$.

S pamäťou je to tu trošičku smutnejšie. Okrem vstupu si ešte potrebujeme pamätať najľavejšiu pozíciu pre každú možnú paritu. Tých je až $2^{20}$, takže pamäťová zložitosť nám tu vychádza na $\\mathcal{O}(n + 2^{20})$.
",5
152469ece381b531,ksp,"# Dijkstra inak

Danovi sa začal nový semester a to preňho znamená jediné. Blíži sa skúškové. Z knižnice si už požičal všetky skriptá a cvičebnice. Keďže si po ne bol už o šiestej ráno v prvý výpožičný deň, ušli sa mu dokonca tie najlepšie kusy. Čo sa jeho spolužiakov týka, tí už také šťastie nemali a knižky sa im neušli. Aby znova polovica ročníka nevyletela, rozhodol sa dobrotivo požičať svoje vzdelávacie materiály na naskenovanie.

Vieme si však predstaviť, že naskenovať tie tisíce strán chvíľu potrvá a Dano každú sekundu čo v ruke nemá svoje skriptá pociťuje fyzickú bolesť. Krtkovi obzvlášť nebolo príjemné pozerať sa ako sa zvíja na zemi a tak spravil náčrty PCBčiek potrebných na zostavenie robota, ktorý skenovanie zautomatizuje, urýchli a spraralelizuje. Náčrty však vôbec nie sú pekné, vodiče idú krížom krážom, masívne sa križujú a nikto sa v tom nevyzná. Aby nedošlo ku skratom, bude treba viacvrstvové dosky.

Na odhad ceny robota (a teda finálne rozhodutie či radšej nenecháme Dana trpieť) budeme potrebovať vedieť, koľko najmenej vrstiev môžu mať dosky bez toho aby sa vodiče križovali. Keďže toto je úloha v KSP, je na vás aby ste to zistili.

## Úloha

Náčrt má $N$ vodičov. Každý vodič má 2 konce a všetky konce vodičov sú rozdelné do 2 stĺpcov (ľavého a pravého) po $N$ koncoch. Konce v oboch stĺpcoch sú očíslované zhora nadol od 1 po $N$. Dva vodiče sa križujú ak sú na tej istej vrstve a ak jeden vodič má číslo ľavého konca menšie ako číslo ľavého konca druhého vodiča a číslo pravého konca väčšie ako číslo pravého konca druhého vodiča. Každý vodič sa môže nachádzať na práve jednej vrstve.

Na prvom riadku je celé číslo $N$ ($0 \\leq N \\leq 10^6$) - počet vodičov. Na druhom riadku je $N$ rôznych celých čísel. Nech $i$-te z nich je $v_i$, potom $i$-ty vodič spája $i$-ty koniec v ľavom stĺpci s $v_i$-tým koncom v pravom stĺpci.

Na výstup vypíšte jeden riadok s jedným celým číslom - najmenším počtom vrstiev postačujúcich na zostavenie dosky bez križovaní.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- | ---: | -------: | --------: | ------------: | | $0 \\leq N \\leq$ | $10$ | $2,000$ | $50,000$ | $1,000,000$ |

## Príklady

```vstup
3
1 2 3
```

```vystup
1
```

```vstup
5
5 4 3 2 1
```

```vystup
5
```

```vstup
6
4 5 2 3 1 6
```

```vystup
3
```
","# Dijkstra inak

Našou úlohou je rozdeliť $N$ čísel do čo najmenej rastúcich podpostupností tak, aby bolo každé číslo v práve jednej z nich. Vstup si teda predstavme ako pole $V$ dĺžky $N$, pričom hodnota $V[i]$ znamená, že vodič spája $i$-ty koniec v ľavom stĺpci s $V[i]$-tým koncom v pravom stĺpci.

## Riešenie

Úlohu riešme postupne, tak ako ju dostávame na vstupe - ak sa aktuálne snažíme zaradiť číslo $V[i]$, majme už všetky čísla s indexom menším ako $i$ roztriedené. Vďaka tomuto si stav riešenia vieme reprezentovať ako niekoľko rastúcich postupností, pričom nové číslo pridávame vždy iba na koniec daných postupností. Keďže číslo pridávame vždy iba na koniec a jediná podmienka ktorú musíme spĺňať je aby boli postupnosti rastúce, stačí si nám pamätať iba posledné číslo z každej postupnosti. Navyše sa s údajmi omnoho ľahšie pracuje ak sú utriedené, preto si tieto konce postupností budeme pamätať v utriedenom poli $P$.

Intuitívne dáva zmysel, že ak pridávame číslo $X$, oplatí sa ho umiestniť do postupnosti, ktorej koniec má oproti $X$ čo najmenší rozdiel (a zároveň sa do nej $X$ dá umiestniť). Ak máme konce postupnosti utriedené zostupne, znamená to, že $X$ chceme pridať do postupnosti s čo najmenším indexom pre ktorý je $P[i]\<X$. Kedze toto cislo pridame na koniec tejto postupnosti, $P[i]$ sa bude po pridani rovnat $X$. Dolezite pozorovanie je, ze takato uprava pola nam nenarusi jeho utriedenost. Totiz kedze sme cislo umiestnili na $i$-ty index pola $P$, znamena to ze $P[i+1]\<P[i]\<X\<P[i-1]$ (ak $i>0$, inak je jednoducho $X$ začiatkom pola). Posledným detailom je, čo spraviť ak je $X$ menšie ako ktorékoľvek číslo v $P$. Vtedy jednoducho pridáme $X$ na koniec pola $P$, a zaradíme ho teda do novej postupnosti.

## Dôkaz

Je tento postup optimálny? Konkrétna implementácia bude ovplyvňovať časovú zložitosť, poďme sa však teraz pozrieť skôr na optimalitu výsledku a jej dôkaz. Povedzme že budeme dodržiavať tento postup a skončíme s riešením ktoré potrebuje $R$ vrstiev. Pozrime sa na posledné číslo v tejto poslednej vrstve. Keďže sme ho tam umiestnili, znamená to, že v momente keď sme ho tam umiestňovali mali všetky predchádzajúce vrstvy na konci väčšie číslo. Takúto úvahu vieme uplatniť aj na predposlednú vrstvu a postupne na všetky vrstvy, čím zistíme, že na vstupe sa musela nachádzať klesajúca podpostupnosť dĺžky $R$. Vieme si však uvedomiť, že klesajúcu postupnosť nevieme rozdeliť lepšie ako na rovnako veľa jednoprvkových rastúcich postupností. Teda vieme, že pre daný vstup určite neexistuje lepšie riešenie a teda toto riešenie je optimálne.

## Riešenie druhej sady

Teraz keď už vieme čo chceme robiť stačí to iba spraviť! Vlastne jediný problém ktorý máme, je hľadanie najmenšieho indexu s hodnotou menšou ako $X$. Na to aby sme vyriešili druhú sadu, teda $N\<2000$, nám stačí vyhľadávanie s časovou zložitosťou $O(N)$. Teda jednoducho prejdeme polom zľava doprava, pri prvom valídnom čísle sa zastavíme a pole upravíme. Nakoniec vypíšeme veľkosť pola. Celková časová zložitosť bude $O(N^2)$, pamäťová zložitosť bude závislá od veľkosti výsledku, teda v najhoršom prípade $O(N)$.

## Vzorové riešenie

Vzorové riešenie si vyžaduje vyhľadávanie s časovou zložitosťou $O(\\log N)$ a keďže si pole udržiavame utriedené, môžeme na ňom [binárne vyhľadávať][1]. Jediný rozdiel oproti predchádzajúcemu riešeniu je teda jeden riadok, keďže väčšina jazykov má binárne vyhľadávanie ako súčasť štandardnej knižnice.

Vzorových riešení je však viacero. Jedným z nich je použitie [intervalového stromu][2]. Totiž postupnosti si nemusíme reprezentovať ako hodnoty koncov v postupnosti, Vieme sa na to pozrieť z opačného uhla. Budeme mať pole $S$ o $N$ prvkoch, pričom ak sa v predchádzajúcom riešení končila $i$-ta postupnosť číslom $P[i]$, tentoraz bude v poli $S$ na pozícii $P[i]$ hodnota $i$ (teda $S\[P[i]\]=i$). Index najskoršej postupnosti, ktorej koniec je menší ako $X$ nájdeme tak, že v prefixe dĺžky $X$ poľa $S$ nájdeme najväčšiu hodnotu (rovnako ako keď sme hladali najväčšie menšie číslo). Keď ju nájdeme, vymažeme ju a uložíme na index $X$ pola $S$. Keďže potrebujeme tieto operácie vykonávať v $O(\\log N)$, použijeme maximový intervalový strom.

## Časová a pamäťová zložitosť

V oboch prípadoch bude časová zložitosť $O(N \\log N)$ a pamäťová zložitosť bude v najhoršom prípade $O(N)$.

[1]: https://sk.wikipedia.org/wiki/Bin%C3%A1rne_vyh%C4%BEad%C3%A1vanie
[2]: https://www.ksp.sk/kucharka/intervalovy_strom/
",8
94f6819b95d37530,ksp,"# Masaker v Kratarii

Kedysi dávno, v časoch, keď vo svete ešte vládla mágia a po vonku si voľne behali zázračné bytosti, v jednej ďalekej krajine s názvom Krataria, žilo $N$ čarodejov. A ako iste viete, každý poriadny čarodej potrebuje svoju vlastnú vežu, v ktorej bude vykonávať svoje experimenty, vymýšľať nové kúzla, variť lektvary a inak čarovať... Taktiež je celkom logické, že keď budú mať dvaja čarodejovia vežu s rovnakou výškou, nebudú sa mať radi a nedopadne to dobre. Preto sa rozhodli, že spolu budú priateľsky súperiť o to, kto bude mať akú výšku veže. Po dlhoročnom súperení boli nakoniec zoradení a každý z nich vedel, ktorá z veží vysokých od $1$ po $N$ mu patrí. Keď si už obyvatelia konečne mysleli, že budú mať pokoj, čarodejovia začali s výstavbou svojich veží a rozruch pokračoval. Každý čarodej si vybral nejaké miesto na hranici Kratarie, kde si svoju vežu postavil. Tieto veže boli však také obrovské a drahé na výstavbu, že sa Krataria ocitla v kríze a ich výstavba trvala dlhé roky. Už to vyzeralo tak, že sa výstavba bude musieť zrušiť, avšak stálo to za to. Krataria sa od momentu dokončenia výstavby stala najmocnejšiou krajinou na celom svete. Nikto sa nikdy neodvážil na ňu zaútočit. Tak to aspoň hovorí legenda o Kratarii.\\

Existuje ešte jedna legenda, z ktorej sa síce zachovali iba útržky, ale spomína sa v nej $N$ veží:\\

V legende sa spomína pustatina, v ktorej žijú draky a celá táto pustatina je obklopená $N$ vežami. Drakom sa tieto veže nepáčia a preto možno niekoľkokrát zničili niektoré najvyššie poschodia niektorých veží. Tiež sa spomína presný popis toho, ako draky ničia poschodia, ale nie to, či sa to aj naozaj stalo alebo koľkokrát sa to stalo. Draky ničia poschodia tak, že každú vežu znížia na minimum jej výšky a výšky predošlej veže.\\

Dnes sa nám podarilo odkryť pozostatky poslednej veže. Som presvedčený, že tieto pozostatky patria vežiam z legiend. Teraz už len zostáva zistiť, ako vyzerali veže pôvodne, teda koľko možností spĺňa to, čo sa píše v legendách.\\

*denník archeologickej jednotky 0471*

## Úloha

Na vstupe dostanete postupnosť $N$ čísel ($1 \\le P_i \\le N$).

Nájdite počet permutácií čísel $1$ až $N$, z ktorých je možné dosiahnuť postupnosť $P$ opakovaním (možno aj 0-krát) nasledovnej operácie:

Pre každé $1 \\le i \\le N$, $b_i = \\min(a\_{i-1}, a_i)$, pričom $n = 0$, kde $a$ je postupnosť pred operáciou a $b$ postupnosť po operácii.

Na štandardný výstup vypíšte hľadaný počet modulo `1000000007`.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $N$ ($1 \\le N \\le 1000000$). Na druhom riadku je výsledná postupnosť čísel $P$, zapísaná ako $N$ medzerami oddelených čísel. ($1 \\le P_i \\le N$)

## Formát výstupu

Vypíšte jedno číslo - počet permutácií, z ktorých vieme dostať postupnosť $P$ opakovaním vyššie uvedenej operácie. Keďže tento počet môže byť veľmi veľký, vypisujte ho modulo $10^9+7$.

## Príklady

```vstup
4
2 1 1 2
```

```vystup
2
```

*Postupnosti $(3, 1, 4, 2)$ a $(4, 1, 3, 2)$ spĺňajú podmienky.*

```vstup
6
6 3 1 1 2 2
```

```vystup
0
```

*Neexistuje žiadna permutácia, ktorá spĺňa podmienky.*

```vstup
7
4 3 3 1 1 1 2
```

```vystup
18
```
","# Masaker v Kratarii

## Počet operácii

Konštanta $K$ nech predstavuje počet jednotiek na vstupe. Ak je vstup validný, respektíve ak existuje aspoň jedna permutácia, ktorá sa po konečnom počte operácií zmení na postupnosť na vstupe, tak počet vykonaných operácií je rovno $K-1$, pretože po každej operácií sa úsek jednotiek zväčši o jedna.

## Úseky

Na základe počtu operácií sa pre každé číslo na vstupe dá určiť úsek pozícií, kde sa v pôvodnej permutácií toto číslo mohlo nachádzať. Treba si však všimnúť, že číslo sa nemohlo nachádzať na pozícii, kde do $K$ pozícií od neho sa na vstupe nachádza väčšie číslo. Na základe tohto sa nemôžu dva úseky prekrývať, pretože by to znamenalo, že na rovnakej pozícii môžu byť dve rôzne čísla, ktoré sa v postupnosti zo vstupu nachádzajú. To by znamenalo, že do $K$ pozícií od tejto spoločnej sa na vstupe nachádzajú obe čísla, ale pritom platí, že jedno z týchto čísel je menšie a nemôže sa teda na tejto pozícii nachádzať.

```
        vstup: 1 1 1 2 2 4
        úseky: 1   2 4 4 4
               1 · 1 · 3
```

Tieto úseky vieme nájsť jedným prechodom vstupu: Ak narazíme na prechod z väčšieho čísla na menšie, znamená to, že úsek väčšieho čísla môže začínať najskôr $K$ pozícií pred ním a končiť najneskôr na jeho pozícii, a že úsek menšieho čísla môže začínať najskôr a končiť najneskôr na svojej pozícii. A podobne naopak, ak narazíme na prechod z menšieho na väčšie, úsek menšieho môže začínať najskôr a končiť najneskôr $K$ pozícií pred jeho pozíciou a úsek väčšieho môže začať najskôr $K$ pozícií pred svojou pozíciou a končiť najneskôr na svojej pozícii.

## Dolné hranice

Spomínané úseky však nijako neurčujú kde sa môžu nachádzať zvyšné čísla, ktoré sa na vstupe nevyskytujú. Pre tieto čísla vieme určiť dolné hranice, teda pre každú pozíciu najmenšie číslo ktoré sa tam mohlo nachádzať v pôvodnej permutácií. Teda dolná hranica pre nejakú pozíciu je určená maximom na intervale dĺžky $K$ začínajúcom na tejto pozícii. Toto sa dá nájsť pomocou okienkového minima.

```
        vstup: 1 1 1 2 2 4
        úseky: 1   2 4 4 4
dolné hranice: 1 2 2 4 4 4
```

Všimnime si, že pre každú pozíciu v úseku je rovnaká dolná hranica. Je to tak, pretože dolná hranica nemôže byť menšia ako číslo, ktorého je to úsek, a zároveň na týchto pozíciach môže byť aspoň to číslo. Z tohto dôvodu, keď si zvolíme niektorú možnú pozíciu pre číslo z jeho úseku, dolné hranice sa nezmenia a teda môžme voliť pozície a čísla ktoré sa na vstupe nenachádzajúcu podľa dolných hraníc nezávislo na sebe.

Potrebujeme si však ešte rozmyslieť, ako vyberať čísla, ktoré na vstupe nie sú. Môžu byť kdekoľvek, kde nie je žiaden úsek a ak tam úsek je, tak jednu (ľubovoľnú) pozíciu vynecháme, pričom musia vyhovovať dolným hraniciam. Ak by sme tieto čísla vyberali akokoľvek, mohlo by sa stať, že by pre pozície s vyššou dolnou hranicou nezostalo číslo. Keďže platí, že pre pozíciu s vyššou dolnou hranicou je na výber podmnožina čísel ako pre pozíciu s nižšou, tak môžme vyberať náhodne od pozícií s väčšou. Na to však treba tieto dolné hranice zoradiť podľa veľkosti, pričom si stačí uvedomiť, že na ne vieme použiť counting sort.

```
        vstup: 1 1 1 2 2 4
        úseky: 1   2 4 4 4
               1 · 1 · 3
dolné hranice: 1 2 2 4 4 4
                 3
 zvyšné čísla:   5   5 5
                 6   6 6
```

Výsledok je tým pádom $1 \\cdot 1 \\cdot 3$ (úseky) krát $2 \\cdot 1 \\cdot 1$ (zvyšné čísla), teda dokopy $3 \\cdot 2 = 6$

Možné postupnosti:

```
1 3 2 4 5 6
1 3 2 4 6 5
1 3 2 5 4 6
1 3 2 6 4 5
1 3 2 5 6 4
1 3 2 6 5 4
```

## Neplatné vstupy

Na vstupe musí byť aspoň jedna jednotka. Všetky rovnaké čísla na vstupe musia tvoriť jeden súvislý interval. Pri hľadaní úsekov, nemusí existovať neprázdny úsek alebo pri vyberaní zvyšných čísel nemusí byť možné čísla rozdeliť. V týchto prípadoch neexistuje žiadna permutácia ktorá sa po $K-1$ operáciach zmení na zadanú postupnosť, teda výsledok je $0$.
",10
95949de5a6aa8978,ksp,"# Riadny strach

Krtko a Jerry sa idú zapísať na ústnu skúšku z analýzy. Keďže analýza je najväčší strašiak matfyzákov, chceli by sa na skúške navzájom podporovať svojou prítomnosťou. Vedia, že profesor vždy volá študentov na ústnu skúšku po skupinkách. Najväčšia šanca, že budú v jednej skupinke je, ak sa zapíšu hneď po sebe. Na skúšku sa však musia poctivo pripravovať, preto nemajú čas zisťovať, na ktoré miesto sa majú zapísať aby išli s čo najväčšou pravdepodobnosťou spolu. Pomôžete im?

## Úloha

Na skúšku je voľných $n$ miest. Zistite, aká je pravdepodobnosť, že Krtko a Jerry pôjdu spolu na skúšku ak sa Jerry zapíše na $r$-tú pozíciu a Krtko hneď pred ňu. Profesor si vždy pred skúškou náhodne zvolí $x$ -- veľkosť skupiniek po ktorých bude študentov volať dnu, pričom platí, že $1 \\leq x \\leq n$. Každá veľkosť skupinky od $1$ po $n$ je rovnako pravdepodobná.

## Formát vstupu

Na vstupe sa nachádza jeden riadok a v ňom dve čísla: $n$ - počet ľudí zapísaných na danú skúšku a $r$ - poradie Jerry, pričom platí $(2 \\leq r \\leq n \\leq 10^{12})$. Pozor, v jazykoch podobných C++ vám nemusí na uloženie $n$ a $r$ stačiť klasický typ `int`. Riešením(v C++) je napr. použiť typ `long long`.

V testovacích sadách platia pre $n$ a $r$ nasledovné obmedzenia zhora:

| Sada | 1 a 2 | 3 | 4 | 5 | 6 až 8 | |:------------------- | :-----:| :-----:| :-----:| :--------:| :-----:| | $n,r \\leq$ | $10,000$ | $100,000$ | $150,000,000$ | $250,000,000$ | $10^{12}$ |

## Formát výstupu

Vypíšte dve medzerou oddelené čísla $p$ a $q$ kde $p$ je čitateľ a $q$ menovateľ zlomku, ktorý vyjadruje pravdepodobnosť s akou pôjdu Krtko s Jerry odpovedať v jednej skupinke. Zlomok naviac vypíšte v ***základnom tvare***.

## Príklad

```vstup
20 15
```

```vystup
4 5
```

Na skúšku je zapísaných 20 ľudí pričom Krtko je v poradí 14. a Jerry 15. Krtko a Jerry budú spolu v skupinke ak bude profesor volať študentov po skupinkách veľkosti 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19 alebo 20. Celkovo profesor môže vymyslieť 20 rôznych veľkostí skupiniek (1-20), preto je pravdepodobnosť, že pôjdu spolu 16/20, teda v základnom tvare 4/5.
","# Riadny strach

## Čo vlastne hľadáme

Chceli by sme zistiť pre aké veľkosti skupiniek od $1$ po $n$ budú Krtko a Jerry zavolaní spolu. To vieme však vypočítať ako $n$ mínus počet veľkostí skupiniek, pre ktoré budú Krtko a Jerry zavolaní oddelene, teda keď budú patriť do dvoch rôznych po sebe idúcich skupiniek.

\\medskip

A čo musí veľkosť skupinky spĺňať, aby Krtka a Jerry rozdelila? No čísla $r-1$ a $r$ musia patriť do dvoch rôznych skupiniek, teda ak $r-1$ patrí do skupinky číslo $k$, tak $r$ patrí do skupinky číslo $k+1$. Ak tieto skupinky majú veľkosť $x$, tak potom bolo v prvých $k$ skupinkách dokopy $kx = r-1$ študentov. Aby toto nastalo, musí byť $r-1$ násobkom veľkosti skupinky $x$, inými slovami $x$ musí byť deliteľom $r-1$. Keďže každý deliteľ $r-1$ označujúci veľkost skupinky dosiahne rozdelenie Krta a Jerry, celá úloha je vlastne len 'vypíš ($n$ mínus počet deliteľov $r-1$) deleno $n$ v základnom tvare'.

## Všetky možnosti

Každý celočíselný deliteľ $r-1$ leží medzi $1$ a $r-1$, vrátane -- môžeme teda všetky vyskúšať.

Prejdeme for cyklom čísla od $1$ po $r-1$, a ak je zvyšok po delení^\[Vo viacerých jazykoch je operátor na zvyšok po delení `%`\] rovný nule, pripočítame k odpovedi jedna.

Nakoniec chceme vypísať zlomok $\\frac{n-odpoved}{n}$ v základnom tvare, teda tak aby $n-odpoved$ a $n$ nemali spoločné delitele okrem $1$. Môžeme jednoducho prejsť všetky čísla od $1$ po $n-odpoved$, a všetkými ktoré delia aj $n-odpoved$ aj $n$ ich predelíme dokým ich nedelia.

\\medskip

Keďže v cykle prechádzame čísla od $1$ po $r-1$, čo je najviac $n$, a vždy vykonáme niekoľko konštantných operácií, toto nám zaberie $O(n)$ času. V druhom cykle tiež určite neprejdeme viac ako $n$ čísel, čiže celková časová zložitosť je $O(n)$.

Stačí si nám pritom pamätať len konštantne veľa premenných, čiže pamäťová zložitosť je $O(1)$.

## Vzorové riešenie

Ako vieme nájsť počet deliteľov efektívnejšie?

Použijeme pozorovanie ktoré sa často v úlohách o deliteľoch a prvočíslach používajú: ak $a \\cdot b = x$, tak aspoň jedno z $a,\\ b \\leq \\sqrt{n}$.

Každý deliteľ väčší-rovný $\\sqrt{n}$ má svojho spoločníka ktorý je menší-rovný ako $\\sqrt{n}$. Stačí nám teda hľadať delitele po odmocninu z $r-1$, a za každý nájdený pripočítať dva, ledaže by práve platilo $x^2 = r-1$, kde sa deliteľ opakuje a my ho chceme zarátať len raz.

Skrátime teda náš for cyklus a trochu ho prepíšeme, a máme riešenie v $O(\\sqrt{n})$.

\\medskip

Na nájdenie zlomku v základnom tvare použijeme [Euklidov algoritmus](https://sk.wikipedia.org/wiki/Euklidov_algoritmus) na nájdenie najväčšieho spoločného deliteľa čitateľa a menovateľa, a predelíme ich ním. Euklidov algoritmus zbehne v $O(logn)$, číže celé riešenie nám pobeží v $O(\\sqrt{n})$.

Pamäťová zložitosť sa nezmenila -- $O(1)$.
",2
ce3c1dbab0b742d3,ksp,"# Oštara s huncútmi malými

Ako tak študent Dávid cestou domov začal konzumovať čokoládu, jej úlomky dopadali na chodník. Na druhý deň išiel Dávid po tom istom chodníku, znova konzumujúc čokoládu a opäť mu zopár malých kúskov spadlo na zem. Táto situácia sa opakuje každý deň, lebo Dávid je svedomitý študent a zároveň veľký milovník čokolády.

Na začiatku tohto chodníka prebývajú mravce -- bažiace po čokoláde, a mimochodom, mimoriadne expanzívne. Ak sa niekde v okolí mraveniska vyskytne kúsok čokolády, mravce neváhajú a rozšíria svoje mravenisko až po tento kúsok. Ak teda Dávid bude pokračovať vo svojom zvyku konzumovať čokoládu cestou zo školy, mravce časom skolonizujú celý chodník.

Dávid by ale nerád (nevedomky) predal našu krajinu mravcom. Keď od vás dostane každý deň údaj o tom, kde sa nachádza hranica mravčej ríše, uvedomí si vážnosť celej situácie a podnikne rázne protiopatrenia.

## Úloha

Chodník má dĺžku $n+1$ metrov. Môžeme si ho teda predstaviť ako časť číselnej osi od bodu $0$ po bod $n+1$. Zo začiatku je celé mravenisko v bode $0$. Neskôr sa bude rozširovať na čoraz dlhší interval na chodníku.

Rozpínavosť mravcov sa dá charakterizovať kladným číslom $v$ s nasledovným významom: ak sa niekedy vo vzdialenosti $v$ alebo menej metrov od mraveniska nachádza kúsok čokolády, mravce ho pohltia a tak rozšíra svoje impérium až po tento kúsok. Ako pracovité tvory sú toto schopné urobiť v rámci jedného dňa **ľubovoľne veľa ráz** -- posunutím hranice sa totiž môže stať, že mravce už ,,dočiahnu'' aj na ďalšie kúsky čokolády, na ktoré predtým nedočiahli. Navyše, ak sa niekedy dostanú do vzdialenosti $v$ alebo menej metrov od konca chodníka, rozšíria sa až po koniec chodníka (teda akoby na konci chodníka bola čokoláda).

Dávid má zvláštny talent na trúsenie čokolády. Po prvé, čokoládové omrvinky mu padajú iba na miesta, ktoré sú celočíselný počet metrov od začiatku chodníka. Okrem toho Dávidovi nikdy nepadne omrvinka dvakrát na to isté miesto. Zároveň však platí, že na všetky body $1, 2, \\dots, n$ mu časom nejaká omrvinka padne.

Kým sa mravce dostanú po koniec chodníka v bode $n+1$, zopár dní im to potrvá. Vašou úlohou bude zistiť, kde sa bude nachádzať hranica mravčieho impéria po jednotlivých dňoch expanzie, až kým neskolonizujú celý chodník.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve celé čísla $n$ ($2 \\leq n \\leq 100,000$) a $v$ ($1 \\leq v \\leq 100,000$) -- počet omrviniek, ktoré Dávid vytrúsi, a expanzívnosť mravcov. Nasleduje $n$ riadkov popisujúcich jednotlivé kúsky čokolády, ktoré Dávid vytrúsil. Každý z týchto riadkov obsahuje dve celé čísla $m_i$ ($1 \\leq m_i \\leq n$) a $d_i$ ($0 \\leq d_i \\leq 100,000$) -- pozíciu danej omrvinky a číslo dňa, keď táto omrvinka spadne. **Dni číslujeme od nuly.**

Môžete predpokladať nasledovné:

1. Kúsky čokolády budú na vstupe zoradené **vzostupne** podľa dňa, kedy padli. Viacero kúskov mohlo padnúť v rovnaký deň -- na vstupe sa vtedy objaví skôr ten, ktorý padol na skorší meter chodníka.

1. Na každý meter chodníka medzi $1$ a $n$ (vrátane) padne **práve jeden** kúsok čokolády.

Keďže expanzívnosť mravcov je aspoň $1$, určite sa časom dostanú až na koniec chodníka.

**Riešenia, ktoré zvládnu riešiť iba prípady kde $\\boldsymbol{v = 1}$, získajú v praktickom testovaní približne polovicu bodov a môžu získať až polovicu bodov za popis.**

## Formát výstupu

Deň, počas ktorého sa mravce dostanú na koniec chodníka, označme $c$. Vypíšte $c+1$ čísel -- na koľkom metri sa nachádzala hranica mraveniska na konci dňa $0, 1, 2, 3, ..., c$. Každé číslo nech je na samostatnom riadku.

## Príklady

```vstup
6 1
1 2
3 2
5 2
2 3
4 4
6 4
```

```vystup
0
0
1
3
7
```

_V dňoch $0$ a $1$ nepadla žiadna čokoláda, mravce teda tieto dva dni ostanú na začiatku chodníka. Počas dňa $2$ padne na meter $1$ čokoláda, ktorú mravce pohltia. Hoci v ten istý deň padla omrvinka aj na metre $3$ a $5$, mravce ich nepohltia, pretože ich expanzívnosť je len $1$. Počas dňa $3$ padne čokoláda na meter $2$ a vtedy mravce pohltia ďalšie $2$ metre. Po ďalšom dni už budú schopné ovládnuť celý chodník._

```vstup
6 3
1 0
2 1
3 1
6 1
5 6
4 8
```

```vystup
1
7
```

_Na prvý meter padla čokoláda hneď, preto už od začiatku bude ríša hraničiť na prvom metri. Ďalší deň padne jedlo na metre $2$, $3$, $6$. Kedže tieto body sú dostatočne blízko seba (aj bodu $7$), mravce rovno ovládnu všetko._
","# Oštara s huncútmi malými

Povieme si najprv niečo o riešení za polovicu bodov (kde $v = 1$) a od neho sa dostaneme k vzorovému riešeniu.

Odporúčame vám si dôsledne preštudovať uvedené zdrojové kódy (keď budú zverejnené). Najmä riešitelia, ktorí ešte nie sú úplne zbehlí v programovaní, sa tak dozvedia veľa užitočných trikov. Každé riešenie obsahuje komentáre o tom, čo sa presne deje a prečo, netreba sa teda kódov báť.

## Riešenie za polovicu bodov

Zo zadania sme museli najprv pochopiť, akým spôsobom sa mravčia ríša pohybuje pozdĺž chodníka. Toto správanie potom vieme jednoducho nasimulovať pomocou cyklov.

Do pamäte si uložíme pole reprezentujúce chodník, ktoré si nazveme `chodnik[]`. Na $x$--tej pozícii poľa bude uložené číslo dňa, v ktorom na $x$-tý meter chodníka dopadla omrvinka. Okrem poľa `chodnik[]` si budeme v našej simulácii pamätať aj číslo aktuálneho dňa (premenná `den`) a pozíciu, na ktorej končí mravčia ríša (premenná `kde_som`). Tieto premenné budú mať na začiatku hodnotu 0.

Algoritmus bude prebiehať nasledovne:

1. Posúvame koniec mraveniska po chodníku ďalej pokiaľ platia obe nasledujúce podmienky:

   - ešte sme nedosiahli koniec chodníka: `kde_som < n+1`
   - na ďalšom metri chodníka už je omrvinka: `chodnik[kde_som + 1] <= den`

   Pre posun na ďalší meter chodníka zväčšíme `kde_som` o 1.

1. Keď sme sa dostali najďalej, ako to v daný deň išlo, inými slovami jedna z podmienok z kroku 1 prestala platiť, vypíšeme aktuálnu hodnotu `kde_som` a zvýšime číslo dňa o 1. Po zvýšení hodnoty `den` sa už možno budeme vedieť dostať po chodníku ďalej, kedže nám na chodníku možno pribudli ďalšie omrvinky. Ak sme sa ešte nedostali na koniec chodníka, znova pokračujeme krokom 1 a skúšame sa posunúť ďalej.

Ak sme chceli získať na testovači aspoň 6 bodov, bolo sa treba popasovať aj so situáciami, kde je expanzívnosť mravcov väčšia než 1.

Ako sa takéto riešenie líši od toho predošlého? V kroku 1 našej simulácie sme schopnosť posunúť sa ďalej overovali podľa toho, či na nasledujúce políčko už dopadla omrvinka. Avšak mravce dokážu od svojej hranice dosiahnuť na $v$ ďalších políčok, musíme preto urobiť takýchto kontrol $v$ -- jednu pre každé políčko, na ktoré dočiahnu. Všimnite si, že aj predtým sme ich potrebovali $v$, akurát $v$ bolo $1$, a preto nám stačil jednoduchý `if`.

Na overenie druhej podmienky kroku 1 použijeme `for` cyklus, ktorý bude kontrolovať, či `chodnik[kde_som + i] <= den` pre všetky $i$ od $1$ po $v$. Samozrejme, treba si dať pozor, aby sme sa takýmto skúšaním nepozerali za koniec chodníka.

## Prečo sme za toto riešenie nedostali všetky body?

Samozrejme, takéto riešenie je pomalé. Zaujímavá otázka však je, prečo? Uvedomme si, čo sa v algoritme deje. Každý deň sa pozeráme na $v$ nasledujúcich políčok a zisťujeme, či na niektoré z nich nepadla omrvinka. Hodnota $v$ však môže byť veľká a mohlo sa nám stať, že všetky omrvinky padli v posledný možný deň. Poprípade omrvinky, ktoré padli ako prvé, padli na koniec chodníka.

Z toho vyplýva, že v najhoršom možnom prípade budeme musieť pre každý deň (počet dní označme $max\_{den}$) naozaj skontrolovať $v$ políčok a pri tom sa ani vôbec neposunúť. To vedie k zložitosti $O(max\_{den} \\cdot v + N)$, čo je pre najväčšie možné hodnoty zo zadania priveľa.

## Iný prístup

Namiesto toho, aby sme simulovali jednotlivé dni, poďme simulovať dopady jednotlivých omrviniek. Pomôže nám, že omrvikny sú na vstupe zoradené podľa času dopadu **vzostupne** -- od prvej padnutej po poslednú.

Predstavme si, že stojíme na $x$-tom metri a na chodník dopadla ďalšia omrvinka. V závislosti od miesta jej dopadu vykonáme jednu z nasledovných akcií:

a) Ak dopadla do už obsadeného územia, čiže na meter menší alebo rovný $x$, nemá zmysel niečo robiť. Mravce majú záujem expandovať len vpred, nie vzad.

b) Ak dopadla tak ďaleko, že na ňu práve nedočiahneme, nemá zmysel sa momentálne pokúšať expandovať. Do budúcna by sa nám ale táto informácia mohla zísť, preto si ju musíme niekam zapísať. Vytvoríme si pole `uz_padla[]`, do ktorého si na $i$-tu pozíciu zaznačíme, či už na $i$-ty meter chodníka padla omrvinka (`uz_padla[i] = true`). Pole `uz_padla[]` bude obsahovať hodnoty typu `boolean`, na začiatku sú všetky `false`.

c) Ak omrvinka dopadla pred nás, ale ešte stále v našom dosahu, budeme sa posúvať dopredu. Na rozdiel od predošlých riešení by sme však chceli každý meter chodníka skontrolovať najviac raz.

## Ako sa múdro posúvať ?

Keď omrvinka padla niekam v rámci nášho dosahu, chceme sa k nej hneď posunúť. Ako však potom rýchlo nájsť ďalšiu omrvinku v dosahu? A ako to spraviť bez toho, aby sme zakaždým pýtali na tie isté políčka?

Na úplnom začiatku stojíme na metri 0 a vieme, že na chodník ešte nepadla žiadna omrvinka. Začneme omrvinky spracovávať v poradí, v akom sa objavili na vstupe, teda podľa času ich dopadu. Kým padajú ďalej ako je vzdialenosť $v$, nevieme sa posunúť ďalej a iba si tieto omrvinky značíme do poľa `uz_padla[]`.

Zmena nastane pri prvej omrvinke, ktorá dopadne na miesto $x$, kde $x \\leq v$. V tom momente sa môžeme posunúť na pozíciu $x$. Z novej pozície však možno dosiahneme na omrvinky, ktoré padli skôr. Mohli by sme sa preto začať pozerať na nasledujúcich $v$ políčok a s pomocou poľa `uz_padla[]` zisťovať, či sa na nich nenachádza nejaká omrvinka. Pričom vždy keď nájdeme ďalšiu omrvinku v dosahu, tak sa posunieme na jej miesto

Uvedomme si však jednu dôležitú vec. **Až po meter $\\boldsymbol{v}$ sa žiadna ďalšia omrvinka nenachádza**. Na začiatku bol totiž chodník prázdny a omrvinka, ktorá padla na pozíciu $x$ bola prvá omrvinka, ktorá padla do nášho dosahu. Nemusíme teda kontrolovať políčka $x$ až $v$, **stačí nám skontrolovať pozície od $\\boldsymbol{v+1}$ po $\\boldsymbol{x+v}$**.

Táto vlastnosť naviac platí aj vo všeobecnosti. Ak sme zastavili na metri $y$, pričom sme sa nevedeli posunúť ďalej, bolo to preto, lebo sme skontrolovali všetky políčka po $y+v$ a na žiadnom z nich sa omrvinka nenachádzala. Keď teda do nášho dosahu padne prvá omrvinka, stačí kontrolovať políčka začínajúc od pozície $y+v+1$.

Toto zlepšenie spôsobí, že každý meter chodníka skontrolujeme najviac raz. Zakaždým totiž kontrolovanie začneme od poslednej skontrolovanej pozície. A keďže chodník má dĺžku $n$, budeme potrebovať $O(n)$ času.

Samozrejme, zadanie po nás chcelo, aby sme vypísali pozície, na ktorých stoja mravce v každý možný deň. To však vieme do nášho programu ľahko pridať. Ak totiž stojíme na metri $x$, naposledy sme úspešne spracovali omrvinku, ktorá padla v deň $d_1$ a ďalšia omrvinka padne až v deň $d_2$ tak vieme, že odpoveď pre dni $d_1$ až $d_2-1$ bude $x$.

Je si však treba uvedomiť, že veľkosť výstupu nesúvisí s hodnotou $n$ a jeho vypísanie nám tiež zaberie čas úmerný počtu vypísaných čísel. Ak si teda posledný deň, keď padne nejaká omrvinka označíme $max\_{den}$, tak môžeme povedať, že časová zložitosť našeho algoritmu je $O(n + max\_{den})$. Pamäťová zložitosť bude $O(n)$, keďže na naprogramovanie nám stačí jedno pole dĺžky $n$.
",2
d69a21dff7b3e124,ksp,"# Ideme robiť kampaň

Voľby v Krajine Samých Politikov sú už za rohom.

Treba byť akční! Však ak s tým nič neurobíme, tí politici z opozície - Fakt Kool Strana - nebodaj získajú demokratickú väčšinu, postavia vládu, a začnú plniť svoje predvolebné sľuby! Koalícia Mnohých Strán tomu musí nejako zabrániť.

KMS sa teda rozhodla zorganizovať predvolebnú kampaň, na ktorej vycestujú z hlavného mesta a navštívia všetky okresné mestá, po čom sa slávnostne vrátia do hlavného mesta v deň volieb.

Mohli síce vyrátať najkratšiu cestu ktorú by museli prejsť, bol by to však problém. Ak by totiž navštívili okresné mestá v tak špecifickom poradí, žurnalisti z časopisu Zuby a Vlasy by si to určite vysvetlili tak, že na okresoch ktoré KMS navštívi posledné im nezáleží, a stratili by v nich voličov.

Keďže KMS nemá hlavného vedúceho ktorý by vedel takéto obvinenia verejne poprieť, rozhodlo sa KMS pre inú stratégiu - spravia okruhovú cestu krajinou. Začnú v hlavnom meste, ktoré je najzápadnejšie okresové mesto. Potom sa vydajú na východ, pričom ponavštivujú niektoré mestá, až kým neprídu do najvýchodnejšieho z nich. Vtedy spravia otočku a vydajú sa na západ, pričom navštívia všetky mestá ktoré vynechali v opačnom smere, až kým nakoniec neprídu naspäť do hlavného mesta.

Pomôžte KMSákom zrátať, koľko najmenej kilometrov musia prejsť, aby mohli takto zorganizovať svoju predvolebnú kampaň a poraziť FKS!

## Úloha

Každé mesto si vieme predstaviť ako bod v rovine.

KMS začína v najzápadnejšom meste, a potom sa vydá na východ k najvýchodnejšiemu mestu. Po ceste môže navštíviť niektoré mestá, tie však musia mať rastúcu zemepisnú dĺžku ($x$-ovú súradnicu).

Po príchode do najvýchodnejšieho mesta sa KMS otočí a vydá na západ, pričom v klesajúcom poradí zemepisnej dĺžky navštívi všetky mestá, ktoré KMSáci nenavštívili počas kampaňovania na východ.

Akú najmenšiu vzdialenosť musia prejsť?

## Formát vstupu

V prvom riadku vstupu je číslo $n$ -- počet miest v KSP. Každý z nasledovných $n$ riadkov obsahuje dve čísla $x_i y_i$: súradnice jedného mesta. Tie sú kladné a nepresahujú milión. Body budú udávané v rastúcom poradí zemepisnej dĺžky (teda žiadne mestá nemajú rovnakú zemepisnú dĺžku, a prvé mesto na vstupe je hlavné mesto).

## Formát výstupu

Vypíšte najmenšiu vzdialenosť ktorú KMSáci musia prejsť aby zvládli svoju okruhovú predvolebnú kampaň. Dĺžku ich cesty meriame Euklidovsky.

Vypíšte dostatočne veľa desatinných miest. Vaša odpoveď bude uznaná, ak sa bude od našej líšiť v absolutnéj alebo relatívnej hodnote najviac $10^{-6}$.

## Hodnotenie

Čím väčšia sada, tým väčšie $n$, zhora ohraničené postupne:

1. Počtom prstov na mojich rukách a nohách

1. Počtom dní v letných prázdninách

1. Počtom dní v orbite Venuše

1. Rokom v ktorom Krištof Kolumbus objavil Ameriku

$n$ nikdy nie je menšie ako počet trpaslíkov v rozprávke o Snehulienke mínus päť.

## Príklady

```vstup
5
1 3
2 1
3 4
4 4
5 2
```

```vystup
10.870481593
```

```vstup
10
4 1
13 4
21 3
25 9
28 10
42 1
43 2
50 4
67 10
68 9
```

```vystup
131.651455225
```
","# Ideme robiť kampaň

## Hrubá sila

Ako vždy, na prvú sadu tejto úlohy nám postačí hrubá sila a málo rozmýšľania.

Chceme nájsť najkratšiu okruhovú cestu po mestách? No tak vyskúšajme všetky možné okruhové cesty, a zapamätajme si najlepší výsledok.

Každá okruhová cesta je jednoznačne určená tým, ktoré mestá navštívime cestou na východ (keďže všetky zvyšné mestá potom musíme jednoducho navštíviť počas cesty na západ). Toto si teda môžeme reprezentovať napríklad $n-2$ bitmi v čísle; ak je $i$-ty bit čísla 1, navštívime ho cestou na východ, inak cestou na západ. Všetky možné cesty sú teda reprezentované číslami $0$ až $2^{n-2}-1$. Pre každé z nich si spravíme zoznam miest ktoré chceme navštíviť v jednom smere a ktoré v druhom, sčítame vzdialenosti medzi susednými mestami v oboch zoznamoch (nezabudnime zarátať hlavné a najvýchodnejšie mesto v oboch prípadoch), a zo všetkých takýchto súčtov si zapamätáme ten najmenší.

Časová zložitosť tohto riešenia je $O(n2^n)$, keďže pre každú z $O(2^n)$ okruhových ciest vyrátame jej dĺžku v $O(n)$.

Pamäťová zložitosť nášho riešenie ja $O(n)$, keďže si nepotrebujeme pamätať nič väčšie ako vstup.

## Dynamické programovanie

Všetky rýchlejšie riešenia sú založené na rovnakom princípe -- určíme si nejaké stavy, ktoré jednoznačne popisujú nejaký stav v ktorom sa nachádzame (ktoré mestá sme spracovali), a dynamickým programovaním so stavu 'stojím v hlavnom meste a ešte som nič nenavštívil' postupne nájdeme najmenšie vzdialenosti v stavoch s viac a viac spracovanými mestami, až nájdeme odpoveď pre všetky mestá. Riešenia sa potom len líšia tým, koľko stavov nakoniec budeme potrebovať, a ako rýchlo vieme vyskúšať všetky potrebné možnosti na zistenie vzdialeností susedných stavov. Tu si popíšeme rovno vzorové, ktoré zvláda všetky sady.

Okruhovú cestu si budeme predstavovať nie tak, že ideme najprv na východ a potom na západ, ale že máme dve skupiny ktoré idú zo západu na východ a medzi sebou navštívia všetky mestá. Ak naše skupiny navštívili všetky mestá od $1$ až po $k$, jediné čo potrebujeme vedieť na presunutie sa na ďalšie mesto je pre obe skupiny ich posledné navštívené mesto. Stačí nám na to teda tabuľka $dp[n][n]$, pričom $dp[i][k]$ obsahuje najmenšiu vzdialenosť čo dokopy naše dve skupiny prešli tak, aby najvýchodnejšie mesto navštívené prvou skupinou bolo $i$, a druhou skupinou $k$. Na začiatku teda nevieme žiadnu hodnotu okrem $dp[1][1] = 0$, čo označuje obe skupiny vyrážajúce z hlavného mesta. Poznamenáme, že si nemusíme pamätať koľko miest sme už spracovali, keďže to už v stave implicitne je -- spracovali sme $max(i,k)$ miest.

Teraz pôjdeme po mestách zľava doprava. Povedzme že už vieme všetky optimálne prejdené vzdialenosti, aby naše dve skupinky navštívili všetky mestá od $1$ po $x$, a skúsme naše riešenia rozšíriť o mesto $x+1$. Kľúčové pozorovanie je, že ak naše skupiny navštívili všetky mestá až po $x$, pre jednu z nich je posledné navštívené mesto práve $x$. Druhá skupina pritom môže byť v ľubovoľnom západnejšom meste (alebo v ňom práve v prípade $x = 1$). Vyskúšame teda všetky možnosti -- ktorá z dvoch skupín je v meste $x$, ktoré mesto naposledny navštívila druhá skupina, a ktorá z nich má navštíviť mesto $x+1$. Dostaneme sa tak do nového stavu kde jedna zo skupín je v meste $x+1$ a druhá ostala tam kde bola predtým. K vzdialenosti pripočítame cestu medzi dvoma mestami, ktoré zvolená skupina práve prešla a ak je menšia ako tá, ktorú sme doposiaľ objavili pre tento stav, zapamätáme si ju.

Postupne takto pozisťujeme najkratšiu potrebnú vzdialenosť ktorú skupiny musia prejsť tak, aby jedna z nich bola v meste $n$, a druhá v nejakom predošlom meste $m$, pre všetky $1 \\leq m < n$. Aby naša cesta bola ozaj okruhová, musíme k týmto vzdialenostiam ešte pripočítať vzdialenosť medzi mestom $m$ a $n$, aby sa obe skupiny nakoniec stretli v najvýchodnejšom meste. Zo všetkých týchto vzdialeností zoberieme najmenšiu, a to je naša odpoveď.

## Časová a pamäťová zložitosť

Postupne zisťujeme najkratšie cesty pre každé ďalšie mesto, ktorých je $n$. Pre každé z nich musíme skúsiť všetky predošlé mestá, ktoré mohla ako posledné navštíviť jedna zo skupín, a týchto možností je $O(n)$. To že pre každé z nich skúšame ktorá zo skupín pricestuje do spracovávaného mesta, a ktorá zo skupín je tá vzdialená, je už len konštantne krát viac prípadov; časová zložitosť je teda $O(n^2)$.

Pamätáme si pozície miest, čo nám zaberie $O(n)$, a tabuľku $dp$ o rozmeroch $n$ krát $n$, čiže naša pamäťová zložitosť je $O(n^2)$. Ak by sme si udržiavali len posledné dva stĺpce našej dynamiky (poslednú a tú, ktorú práve rátame), môžeme to zlepšiť na $O(n)$.
",9
a51873f33a1c26a3,ksp,"# Nové PINy pre trezor

Bola jar. Sniežik sa topil, kvietky kvitli, rástli listy. Ale najmä, hovnivále kládli vajíčka. Ale to nie je len tak, naklásť vajíčka a bezstarostne sa zabávať. Treba ich schovať, ukryť pred beštiami. Náš Lajniak Lajko to mal tentokrát obzvlášť obtiažne. Jeho partnerka ho požiadala, aby zohnal trus, v ktorom pod zemou schovajú vajíčka. Tento materiál je nevyhnutný, aby sa larvy mali čím živiť.

Lajko je ale veľmi zábudlivý lajniak, a minulé leto zabudol svoje zásoby trusu vo Firme Korporátnych Slimákov, kde v tom čase brigádoval. Aby ich dostal naspäť, musel by otvoriť svoj starý firemný trezor. Bohužiaľ, zabudol aj svoj PIN. Našťastie, FKS ponúka zmenu PINu, ak si ho niekto zabudol. Tento proces funguje nasledovne:

Firma Korporátnych Slimákov Lajkovi zaradom navrhne $p$ rôznych PINov, každý o rovnakej dĺžke $n$. Užívateľ ide zaradom, a keď je na PINe, ktorý sa mu páči, môže si ho zvoliť. Systém ale ponúka aj ďalšiu zmenu, ak si užívateľ chce výber rozmyslieť. Má to ale háčik. Môže si ďalší PIN zvoliť iba ak sa líši v len jednej cifre od toho, ktorý si zvolil naposledy. Takto si užívateľ môže PIN zmeniť koľkokrát len chce, pokiaľ sa každý ďaľší PIN líši v len jednej cifre. Keďže tento systém naprogramovali slimáci, zmena PINu prebieha pomocou operácie, ktorá zmení jednu cifru v PINe o $1$, buď sa cifra zväčší, alebo zmenší. Keby si Lajko chcel zmeniť PIN $0000$ na PIN $0700$, systému by to trvalo $7$ operácii.

Lajko ako minulý brigádnik vo firme o tomto systéme vie. Je zároveň veľmi citlivý, čo sa týka problémov jeho pamäte. Chce sa teda vyhnúť zmene PINu. Čiže samozrejme sa namiesto toho pokúsi preťažiť slimačí systém menenia PINu tým, že ho donúti vykonať čo najviac operácií pre každú sadu navrhnutých PINov. Keď systém preťaží, určite sa mu trezor otvorí, a dostane sa k svojmu vysnívanému trusu. Pomôžte Lajkovi zistiť, koľko najviac operácií vie od systému v danej sade vynútiť.

## Úloha

Dostanete $p$ rôznych PINov, každý o rovnakej dĺžke $n$. V PINe môžu byť aj nuly. Jeden PIN si zvolíte ako začiatočný. Následne si môžete vždy PIN zmeniť na ľubovoľný v zozname nasledujúci PIN, pokiaľ sa od toho, čo máte teraz, líši len v jednej cifre. Ak sa líši vo viacerých cifrách, zobrať si ho nemôžete a idete na ďalší navrhnutý PIN. Keď si takto zmeníte PIN, tak podľa toho, o koľko sa dve rozdielne cifry líšia, toľko sa vykoná operácií. Keď sa dostanete na posledný PIN, po ňom si už ďalej PIN meniť nemôžete.

Vašou úlohou bude zistiť, koľko najviac operácií sa dá vykonať pre daný zoznam navrhnutých PINov.

## Formát vstupu

Na prvom riadku dostanete číslo $n$ ($1 \\leq n \\leq 6$) -- počet cifier v každom PINe. Na druhom riadku bude číslo $p$ ($1 \\leq p \\leq 100,000$) -- počet PINov.

Nasleduje $p$ riadkov, na $i$-tom sa nachádza PIN $p_i$, pričom PIN je ľubovoľná kombinácia cifier $0$ až $9$ o dĺžke $n$.

## Formát výstupu

Vypíšte jedno číslo -- najväčší možný počet operácií, ktoré sa dajú vykonať.

## Príklad

```vstup
4
6
8823
2145
2185
3385
4145
4445
```

```vystup
5
```

_Lajko si zvolí $2145$ ako začiatočný PIN. Od neho sa môže dostať na $2185$, čo by vykonalo $4$ operácie, alebo na $4145$, čo by vykonalo iba $2$. Lenže sa mu oplatí zvoliť si $4145$ aj tak, pretože z neho sa vie dostať na $4445$, čo by dokopy vykonalo $5$ operácií. Neexistuje iná stratégia, pomocou ktorej by systém vykonal viac, ako $5$ operácií._

```vstup
5
11
00000
60000
00100
10100
60100
10190
10390
61100
20100
10380
20190
```

```vystup
20
```
","# Nové PINy pre trezor

## Pomalé riešenie

Jeden spôsob je cez brute-force. Držíme si v pamäti PINy ako idú zaradom. Iterujeme cez pole PINov od začiatku. Pre každý PIN si budeme v pamäti držať najlepší výsledok pre ten PIN. Čiže pre prvý PIN v poli by to bola 0. Pre každý ďalší PIN porovnáme najlepšie výsledky s PINmi ktoré sme už prešli, ktoré sa zároveň od terajšieho PINu líšia len v jednej cifre. Pridáme najlepší výsledok PINu, ktorý porovnávame, a pridáme k nemu rozdiel cifier, v ktorých sa dva PINy líšia. Na konci iterovania sa pozrieme, aké najväčšie číslo sme týmto dosiahli, a to bude naša odpoveď. Takýto algoritmus by mal časovú zložitosť $O(p^2)$, pretože by sme pre každý PIN vykonali minimálne toľko operácii, koľko PINov je už za nami, a máme dokopy $p$ pinov.

## Vzorové riešenie

Vieme sa dostať k lepšiemu riešeniu pomocou dynamického programovania. Vieme, že $n \\leq 6$, a tým pádom počet rôznych PINov určite nepresiahne $10^6$. Inicializujeme pole $L$ o veľkosti $10^n$, kde každý index reprezentuje jeden možný PIN. Napr. PIN $00002$ by sa nachádzal na indexe $2$ v poli $L$, a na tomto indexe by sme našli najlepšiu odpoveď pre tento PIN.

Budeme si pamätať najlepšiu možnú odpoveď pre každý možný PIN, čo na začiatku bude $-1$. $-1$ preto, lebo chceme vedieť, či sa daný PIN vôbec nachádza v našom poli PINov, a bolo by dobré túto skutočnosť nejak označiť. Pre každý PIN, ktorý pri iterovaní stretneme, nastavíme v poli $L$ na jeho indexe najlepšiu odpoveď na aspoň $0$. Týmto označíme, že sa tento PIN v poli PINov nachádza.

Trik v tomto riešení je, že keď iterujeme PINmi, tak namiesto toho, aby sme kontrolovali všetky predošlé PINy, tak skontrolujeme všetky PINy, ktoré sú tomuto PINu ""susedné"". Dva piny sú susedné vtedy, keď sa líšia v jednej cifre. Každý PIN má teda $10n-1$ susedných PINov, pretože každý PIN má $n$ cifier, kde cifra môže byť ľubovoľné číslo od $0$ po $9$. Pre každý takýto susedný PIN sa pozrieme na pole $L$, a ak sme tento PIN stretli (čiže hodnota na tom indexe nie je $-1$), tak zoberieme rozdiel cifier týchto dvoch PINov, a sčítame ho s hodnotou v poli $L$. Takto dostaneme potenciálnu najlepšiu odpoveď pre tento PIN. Ak v ďaľšom susednom PINe vypočítame vyššiu hodnotu, tak v poli $L$ prepíšeme na tú vyššiu. Takúto kontrolu všetkých susedných PINov spravíme pre každý PIN vo vstupe a na konci algoritmu vypíšeme najvyššiu možnú odpoveď, ktorú sme kedy vypočítali. Časová zložitosť tohto algoritmu je $O(10np)$ = $O(np)$, čo je v našom prípade lepšie ako $O(n^2)$, pretože u nás platí $1 \\leq n \\leq 6$ a $1 \\leq p \\leq 100,000$. Pamäťová zložitosť $O(10^n)$, kvôli dĺžke poľa $L$.
",5
ef4b151b39e4eb22,ksp,"# Otravné farmárčenie

Predstavte si post- a zároveň pred- apokalyptický svet, v ktorom ľudstvo skoro vymrelo od hladu (preto post-) a čoskoro pravdepodobne aj vymrie (preto pred-). Hoci ste špičkoví programátori, musíte proti svojej vôli pracovať v poľnohospodárstve, aby ste mali čo jesť vy, vaše deti a iní príbuzní, nehovoriac o zvyšku ľudstva.

Keďže ľudstvo zanevrelo na vedu, a tak odsúdilo Zem k úplnej záhube, jedinou nádejou na prežitie (okrem pestovania kukurice) je opustenie našej zničenej planéty. Aby sme Zem mohli opustiť, musíme najprv nájsť nejakú inú prívetivú planétu a chceme si byť istí, že bude skutočne obývateľná.

Problémom je, že všetky takéto planéty sú veľmi ďaleko a tak nám naše sondy vedia posielať len veľmi malé množstvo informácií. Mohli by sme sa uchýliť k tomu, že nám sondy budú posielať len akési čísla a písmenká o prívetivosti planét, ale ako sa hovorí: ,,Lepšie raz vidieť, ako stokrát počuť.''

Čo ak na jednej planéte rastú kokosové palmy, šumí more a príjemne hreje neSlniečko a na druhej rastú kaktusy, šumí piesok a nepríjemne páli obrovská ohnivá guľa a my z oboch planét dostaneme rovnakú správu? To teda nie! Ak raz niekto bude posielať takéto sondy, nedajbože aj s ľudskou posádkou, určite im treba dať aj foťáky a nejak vymyslieť, aby sa dali fotky posielať.

Keďže vás úplne prestalo baviť pestovanie kukurice a zatúžili ste po troške dobrodružstva, na večernej prechádzke lesom ste sa snažili vlámať na oplotený súkromný pozemok. Za trest vás okamžite najali majitelia pozemku a za úlohu vám dali vyriešiť problém vesmírnej komunikácie: Ako posielať čo najkvalitnejšie fotografie v malom množstve dát?

Musíte to vymyslieť rýchlo. Majú vaše deti. A predsa len, je to zábavnejšie ako jazdenie na kombajne.

## Úloha

Dostanete čiernobiely obrázok v textovom formáte veľkosti $w\\times h$. Vašou úlohou je skomprimovať obrázok pomocou pár referenčných bodov tak, aby sa čo najviac podobal originálu.

Komprimovaný obrázok pozostáva z najviac $w+h$ bodov, pričom každý bod je popísaný súradnicami $x, y$ a intenzitou $I$.

Pôvodný obrázok sa dekompresiou získa tak, že intenzita referenčných bodov zostane rovnaká a intenzita každého zvyšného pixelu sa vypočíta ako [vážený priemer](http://sk.wikipedia.org/wiki/Aritmetick%C3%BD_priemer#V.C3.A1.C5.BEen.C3.BD_aritmetick.C3.BD_priemer) intenzít referenčných bodov, váhovaných prevrátenou hodnotou druhej mocniny vzdialenosti. Teda intenzitu pixela $x,y$ z referenčnýxh bodov $(x_1,y_1,I_1),\\dots,(x_n,y_n,I_n)$ určíme ako: $$I = \\frac{\\frac{I_1}{dx_1^2 + dy_1^2} + \\frac{I_2}{dx_2^2 + dy_2^2} + \\dots +\\frac{I_n}{dx_n^2 + dy_n^2}} {\\frac{1}{dx_1^2 + dy_1^2} + \\frac{1}{dx_2^2 + dy_2^2} + \\dots +\\frac{1}{dx_n^2 + dy_n^2}} $$ kde $dx_i = (x-x_i)$ a $dy_i = (y-y_i)$.

## Obrázky

Stiahni si [zip archív](https://media.ksp.sk/ulohy/32rocnik/prikl5-vsetky.zip) z našej stránky. V ňom sa nachádzajú tri cvičné obrázky a 15 súťažných obrázkov. Každý obrázok sa nachádza vo formáte `.jpg` (klasický JPEG formát) a v takomto formáte `.in`:

Prvý riadok `.in` súboru obsahuje dve čísla $w, h$ ($1 \\leq w,h \\leq 500$) oddelené medzerou -- šírku a výšku obrázku.

Nasleduje $w\\times h$ čísel $p\_{i}$, ktoré môžu byť oddelené medzerou, alebo znakom nového riadku. Každé číslo $0 \\leq p\_{i} \\leq 255$ vyjadruje intenzitu/odtieň sivej pixelu obrázku. Pixely sú zapísané v poradí zľava doprava, zhora dole, teda tak, ako by ste ich normálne čítali.^\[$p_i$ označuje intenzitu pixelu $[(i:\\mathrm{mod}: w)+1,(i: \\mathrm{div}: w)+1]$, kde mod je zvyšok po delení, div je celočíselné delenie a $0 \\leq i \\leq w\\times h -1$\]

0 je čierna, 255 je biela, čísla medzi určujú svetlejšie a tmavšie odtiene sivej.

## Odovzdávanie

Odovzdáva sa zip archív, ktorý obsahuje súbory `01.out`, `02.out`, atď až po `15.out`. Nemusíte odovzdať všetky súbory, body dostanete za tie súbory, ktoré sa v archíve nachádzajú. (Ako obyčajne, do výsledkovky sa počíta len posledný odovzdaný zip archív, takže v ňom je odporúčané mať všetkých 15 súborov). Môžete do archívu pribaliť aj `00.sample.*.out` súbory, ale tieto sú len cvičné a nedostanete za ne body.

Každý z odovzdaných súborov musí mať nasledovný formát:

Na prvom riadku sa nachádza číslo $n \\leq w+h$ -- počet bodov, ktorými chcete obrázok popísať.

Následne na $n$ riadkoch sú po 3 čísla oddelené medzerami: $x, y, I$ -- súradnice a intenzity referenčných bodov. Zadané body musia ležať v obrázku, teda $1 \\leq x \\leq w, 1 \\leq y \\leq h$. Intenzity musia byť v rozmedzí od $0$ po $255$ vrátane.

## Hodnotenie

Každý obrázok sa hodnotí samostatne. Na základe referenčných bodov obrázok dekomprimujeme a porovnáme ho s originálom pixel po pixeli.\
Pre obrázok vypočítame [strednú kvadratickú odchýlku](http://sk.wikipedia.org/wiki/Smerodajn%C3%A1_odch%C3%BDlka) na základe rozdielov intenzít pixelov, teda sčítame druhé mocniny rozdielov intenzít a na záver výsledok predelíme počtom pixelov obrázku a odmocníme.

Za každý obrázok dostanete nejaký počet bodov od 0 po 1, podľa toho ako malá je vaša kvadratická odchýlka v porovnaní s referenčnou. Ak je vaša odchýlka $o$ a referenčná odchýlka je $r$, tak počet bodov, ktoré dostanete bude $\\max(0, min(1, \\frac{50+r-o}{50}))^2$, čo v praxi znamená, že plný počet bodov máte ak ste aspoň takí dobrí ako referenčná odchýlka a 0 bodov máte ak ste aspoň o 50 horší. Body, ktoré takto dostanete vám ešte nemusia ostať, zmenia sa, keď sa zmení referenčná odchýlka.

V tejto úlohe budete súťažiť proti sebe, takže referenčná odchýlka sa vypočíta na základe najlepšieho odovzdaného riešenia. Počas behu série budeme odchýlku aktualizovať približne raz za týždeň a po skončení série ju aktualizujeme znova a vypočítame finálne body.

Keďže neodovzdávate programy a nás zaujíma, ako úlohu riešite, môžete k úlohe odovzdať aj popis, kde stručne popíšete, ako ste úlohu riešili a priložíte zdrojové kódy programov, ktoré ste pri riešení použili. Za popis môžete získať 3 body. (Nemusíte odhadovať časovú zložitosť ani dokazovať správnosť riešenia, jednoducho napíšte, čo ste robili.)

## Príklady s cvičnými obrázkami

```vstup
7 7
255 255 255 255 255 255 255
255 255 0 255 0 255 255
255 255 255 255 255 255 255
255 0 255 255 255 0 255
255 255 0 255 0 255 255
255 255 0 0 0 255 255
255 255 255 255 255 255 255
```

```vystup
9
1 1 255
7 1 255
3 2 0
5 2 0
4 3 255
3 5 0
5 5 0
1 7 255
7 7 255
```

*Stredná kvadratická odchýlka tejto kompresie je 120,597746.*

```vstup
3 3
255 255 255
255 255 255
255 255 255
```

```vystup
1
2 2 0
```

*Úplne zlá kompresia má kvadratickú odchýlku 255. Ak by sme zmenili zadanú intenzitu na 255, kompresia by bola dokonalá a mala by odchýlku 0.*

Na prvom obrázku je originálna [fotografia](http://gambar.co/wp-content/uploads/2013/11/Foto-Gurun-Mojave-Amerika-Serikat.jpg), na druhom môžete vidieť referenčné body, ktorými sa obrázok komprimuje. Na posledom obrázku vidíte, ako by vyzeral obrázok po rekonštrukcii z referenčných bodov. Kvadratická odchýlka tejto kompresie je 49.131287. Vstupný súbor tohto obrázku si viete stiahnuť [tu](http://media.ksp.sk/ulohy/32rocnik/prikl5-vstup.txt), a výstup našej nedokonalej kompresie [tu](http://media.ksp.sk/ulohy/32rocnik/prikl5-vystup.txt).
","# Otravné farmárčenie

Už z prvého pohľadu na túto úlohu by malo byť jasné, že si môžeme nechať zájsť chuť na akékoľvek exaktné optimálne riešenie. Spôsob, akým vyrobíme výsledný obrázok z jeho komprimovanej podoby, nemá žiadne dobré vlastnosti, ktoré by sme vedeli využiť.

Čo nám teda ostáva? Prezerať nejaké možné riešenia a vybrať si najlepšie, ktoré sa nám podarí nájsť.

Hm, ale ani to nevyzerá veľmi nádejne. Keď máme obrázok rozmerov $500\\times 500$ a v ňom môžeme zvoliť $1000$ referenčných bodov, existuje približne $1000^{250,000}$ možností ako obrázok skomprimovať. Skúšanie všetkých možností hrubou silou teda tiež nevyzerá reálne. Vyzerá to, že predsa len budeme musieť aj trochu myslieť.

Jedna z vecí, ktoré si môžeme všimnúť, je samotný vzorec zo zadania. Keď si rozmyslíme, ako funguje, prídeme na to, že síce každý referenčný bod ovplyvňuje celý obrázok, ale najväčší vplyv má vo svojom bezprostrednom okolí -- a naopak, ďaleko od neho je už jeho vplyv pomerne malý. Asi teda príliš nepokazíme, keď si to predstavíme tak, že každý referenčný bod ofarbí len svoje okolie, v každom smere po najbližšie iné referenčné body.

Takéto pozorovanie nám už umožní vyrobiť nejaké prvé jednoduché riešenia. Napríklad keď máme obrázok rozmerov $n\\times n$, tak môžeme referenčné body rozmiestniť pravidelne do mriežky rozmerov $\\sqrt{2n}\\times\\sqrt{2n}$. Ich intenzity určíme napríklad tak, že pre každý referenčný bod zoberieme priemer jeho okolia. Výsledný obrázok síce nebude žiadna výhra, ale programuje sa to rozumne ľahko a nejaké body za to budú.

O čosi lepšie riešenie zrejme vieme dosiahnuť tak, že referenčné body nebudeme rozmiestňovať rovnomerne, ale budeme ich dávať *pažravo* vždy tam, kde ich je najviac treba. Ako na to? Budeme referenčné body pridávať postupne po jednom. Vždy, keď pridávame nový, vyskúšame všetkých $256n^2$ možností, kam ho dať. Zakaždým si prepočítame, akú chybu bude mať výsledné riešenie. No a následne zoberieme tú polohu, ktorá viedla k najmenšej chybe.

Takéto riešenie má síce polynomiálnu časovú zložitosť, je však stále dosť pomalé. Na to, aby bolo aspoň trochu použiteľné aj pre obrázky väčšie ako $10\\times 10$, ho treba implementovať šikovne. Urobíme preto jeden trik, ktorý odteraz budú používať aj všetky ďalšie riešenia: Keď už máme nejaké referenčné body, budeme si pamätať pre každý pixel obrázka aj súčet hodnôt (intenzita referenčného bodu krát jeho váha), aj súčet samotných váh. Z nich vieme aktuálnu intenzitu pixelu vypočítať v konštantnom čase. Čo je však dôležitejšie, keď pridáme (alebo odoberieme alebo presunieme) jeden nový referenčný bod, vieme každý pixel v konštantnom čase prepočítať. Nemusíme už teda strácať čas tým, že po každej zmene našej komprimovanej reprezentácie budeme vyhodnocovať celé riešenie od začiatku.

S týmto trikom potrebujeme na vyššie popísané riešenie zhruba $512n^5$ krokov výpočtu. To je OK pre menšie obrázky, ale pre $500\\times 500$ by takéto riešenie bežalo rádovo roky. Niekde teda treba ušetriť. Kde? Môžeme napríklad prezerať menej možných polôh nového referenčného bodu, z intenzít pixelov v jeho okolí môžeme odhadnúť malý interval intenzít, ktoré má zmysel skúšať pre referenčný bod... fantázii sa medze nekladú.

## Lezenie na kopec

My by sme ale chceli nejaký šikovnejší postup, ktorý bude výstupy dávať rýchlejšie a navyše budú mať lepšiu kvalitu. Ako na to? Jednou zo základných techník číselnej optimalizácie je tzv. *hill climbing*, v preklade teda lezenie na kopec.

Komprimovaný obrázok je tvorený $6n$ číslami: pre každý z $2n$ referenčných bodov potrebujeme povedať jeho súradnice a jeho intenzitu. Predstavme si teraz týchto $6n$ čísel ako akési ""GPS súradnice"" nejakého ""bodu"" vo ""svete"". Samozrejme, tento svet nie je dvojrozmerný (ako u klasických GPS súradníc) ale je až $6n$-rozmerný -- to však v našich predstavách spokojne odignorujeme.

Každému ""bodu"" teraz ešte priradíme ""nadmorskú výšku"". Tá bude zodpovedať kvalite príslušného riešenia: čím lepšie riešenie je tvorené súradnicami daného bodu, tým vyššia bude nadmorská výška v ňom.

V našej úlohe môžeme urobiť jedno dôležité pozorovanie: **keď spravíme malú zmenu** ""súradníc bodu"" (teda keď buď trošku posunieme jeden referenčný bod alebo trošku zmeníme jeho intenzitu), **spôsobíme tým len malú zmenu** kvality riešenia. Celá naša krajina, ktorú si predstavujeme, je teda v podstate pekná spojitá.

To, čo by sme v ideálnom prípade chceli, je nájsť najvyšší bod celej krajiny -- globálne maximum výšok, teda optimálne riešenie. Toto môže byť veľmi ťažké, a tak sa uspokojíme s o čosi horším výsledkom: nájdeme aspoň nejaké kopce, nájdeme vrchol každého z nich (lokálne maximum) a spomedzi nich si vyberieme ten najlepší.

Ako na to? Začneme vždy v náhodnom bode našej krajiny. (Zvolíme si teda náhodne súradnice referenčných bodov aj ich intenzity.) Tento bod zrejme leží na úbočí nejakého kopca. Teda existujú nejaké smery, ktorými keď sa po krajine pohneme, pôjdeme hore kopcom. Dobrý spôsob, ako liezť hore kopcom, je taký, že v každom kroku si vyberieme ten smer, ktorý vedie najstrmšie dohora. Čo to znamená v našej úlohe? Vyskúšame nejaké malé zmeny (trochu posunúť alebo prefarbiť niektorý referenčný bod). Ak žiadna z nich riešenie nezlepší, sme už na vrchole kopca. A ak ho nejaké zmeny zlepšia, tak si vyberieme tú z nich, ktorá ho zlepší najviac. Tú aplikujeme a postup lezenia na kopec opakujeme z nového bodu.

## Simulované žíhanie

Naše výstupy sme generovali ešte o čosi šikovnejším postupom. V angličtine je známy pod názvom *simulated annealing*. Ide o podobnú *heuristiku* ako lezenie na kopec, len o čosi zložitejšiu, ale zato často o čosi účinnejšiu. (Mimochodom, ide o postup, ktorý bol spoluvynájdený u nás -- v roku 1985 ho vymyslel Vlado Černý a aplikoval ho na riešenie problému obchodného cestujúceho.)

Na rozdiel od lezenia na kopec, ktoré sa po krajine pohybovalo ""spojito"", pri simulovanom žíhaní po krajine viac ""skáčeme"". Na začiatku je povolená veľkosť skoku veľká (teda v našom prípade môžeme napr. zobrať jeden referenčný bod a ľubovoľne mu zmeniť všetky parametre). Po každom skoku vyhodnotíme, či je nové riešenie lepšie alebo horšie ako to staré. Lepšie riešenie si necháme s veľkou pravdepodobnosťou, horšie s malou. Teda ak je napr. nové riešenie horšie od toho čo práve máme, s pravdepodobnosťou 90 percent ostaneme kde sme, ale s pravdepodobnosťou 10 percent aj tak prejdeme do nového bodu. (Toto je dôležité aby sme mali šancu dostať sa preč z nejakého ""malého miestneho pohoria"". Pravdepodobnosti samozrejme nemusia byť 10-90, môžu napr. závisieť aj od rozdielu kvality oboch riešení.)

Ako proces hľadania riešenia pokračuje, postupne zmenšujeme povolenú veľkosť skoku. Keďže preferujeme lepšie riešenia pred horšími, časom sa s veľkou pravdepodobnosťou dostaneme do ""hornatej oblasti"" a zároveň veľkosť skoku klesne natoľko, že už z nej neodídeme -- ak by sme aj skočili mimo, ďalší skok nás zase skoro určite vráti späť. A tam sa vlastne stále deje to isté: v rámci oblasti nájdeme nejaké miesto, kde sú kopce ešte vyššie, a keď časom veľkosť skoku ešte viac klesne, už tam ostaneme.

Ak to príliš nedáva zmysel, pozrite si [animovaný gif na Wikipédii](https://en.wikipedia.org/wiki/Simulated_annealing#Overview).

No a celý tento proces môžeme samozrejme veľakrát nezávisle na sebe spustiť a vybrať najlepšie z takto zostrojených riešení. Samozrejme, ani táto technika nie je všemocná a nemáme žiadnu záruku, že nájde globálne optimum, ani záruku, ako ďaleko bude nami nájdené riešenie od globálneho optima.

## Hodnotenie

Bodovanie praktickej časti úlohy je nasledovné. Každý vstup sa hodnotí samostatne a dá sa zaň získať 1 bod. Referenčná odchýlka $r$ (počet bodov potrebný na plný počet) sa vypočíta ako aritmetický priemer najlepšej účastníckej a najlepšej vedúcovskej odchýlky. Keď vaša odchýlka v konkrétnom vstupe bola $o$, tak ste dostali $(\\max(0, \\min(50, r-o+50))\\cdot 0.02)^2$ bodov.
",6
7676e66558821c95,ksp,"# Iregulérna strava

Janko sa na internáte delí o chladničku s ďalšími troma ľuďmi. Často sa mu stáva, že jedlo, ktoré si do nej odloží, mu odtiaľ záhadným spôsobom zmizne. Napríklad, v minulú nedeľu si z domu doniesol lahodné grilované kuracie stehno s ryžou a nivovou omáčkou. Odložil ho na svoju poličku v chladničke s tým, že ho zje v pondelok večer.

V pondelok večer o 19.00 sa po celom dni na fakulte, hladný ako vlk, vrátil na internát. Otvoril chladničku a čo tu vidí? Nič! Stehno a jeho predstavy o lahodnej večeri sú preč.

Povedal si, že to už takto ďalej nemôže pokračovať, a prišiel s nápadom: Uloží si do chladničky okrem jedlých vecí aj veci nejedlé. Všetky veci zabalí do alobalu tak, aby spolubývajúci nevedeli, čo je dnu.

Problém je, že takto ani on nebude vedieť, čo môže bezpečne zjesť. Našťastie, Janko sa nedávno v škole učil o šifrách a tak pozná spôsob, ako si označí balíčky tak, aby ich obsah poznal iba on.

Vytvoril si teda tabuľku, v ktorej každému malému písmenu anglickej abecedy priradil práve jedno veľké písmeno anglickej abecedy. Balíčky si označil dvoma slovami. Prvé sa skladá z malých písmen anglickej abecedy a druhé z veľkých písmen anglickej abecedy. Ak je v balíku jedlo, tak druhé slovo je vytvorené z prvého podľa tejto tabuľky.

Jankoví spolubývajúci, ktorí nepoznajú túto šifru, si tak dosť pravdepodobne pochutia na nejedlých balíčkoch, ktoré môžu obsahovať napríklad drevo alebo kapsuly s pracím práškom.

Napíšte Jankovi program, ktorý mu pomôže zistiť, či je daný balíček jedlý.

## Úloha

Na vstupe je zoznam balíčkov v chladničke. Na každom z nich sa nachádzajú práve dve slová. Zistite podľa slov na každom balíčku, či je v ňom jedlo. V balíčku sa nachádza jedlo práve vtedy, keď platí:

- Každému písmenu v prvom slove je pridelené práve jedno veľké písmeno (obraz) v druhom slove.
- Rovnaké písmená majú rovnaký obraz.
- Rozdielne písmená majú rozdielny obraz.
- Poradie obrazov v druhom slove zodpovedá poradiu písmen v prvom slove.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $1 \\leq t \\leq 10^4$, počet balíčkov v chladničke. Nasleduje $t$ popisov balíčkov -- dva riadky obsahujúce slová na jednotlivom balíčku. Prvé slovo je tvorené malými, a druhé veľkými písmenami anglickej abecedy. Každé slovo obsahuje aspoň jeden znak. Platí, že súčet dĺžok všetkých slov nepresahuje $4,000,000$.

## Formát výstupu

Pre každý balíček na výstup vypíšte ""ano"", ak je v ňom jedlo, inak vypíšte ""nie"".

## Príklady

```vstup
4
anna
ABBA
anna
ABB
lopta
HOKEJ
banany
ANANAS
```

```vystup
ano
nie
ano
nie
```

*Zo slova ""anna"" sa 'a' zobrazilo do 'A' a 'n' do 'B'*

*Slovo ""ABB"" je kratšie než ""anna"", takže neplatí, že každé písmeno z prvého slova sa __práve__ __raz__ zobrazí do druhého.*

*V slove ""lopta"" sa žiadne písmeno neopakuje, takže päť písmen sa zobrazilo do piatich rôznych obrazov.*

*Slovo ""banany"" sa nezobrazilo správne do slova ""ANANAS"", keďže až dvom písmenám 'b' a 'n' je priradené 'A'.*
","# Iregulárna strava

Zadanie úlohy hovorí, že na vstupe máme dva reťazce a našou úlohou je zistiť, či spĺňajú zadané podmienky. Podmienky vieme zhrnúť tak, že každým rovnakým (malým) znakom prvého slova majú zodpovedať rovnaké (veľké) znaky -- obrazy -- v druhom slove. Odlišné znaky prvého slova majú mať odlišné obrazy v druhom.

## Funkčné riešenie

V najjednoduchšom riešení stačí, ak prejdeme cez všetky dvojice znakov pôvodného slova a overíme, či sú splnené podmienky zo zadania.

V prvom rade skontrolujeme, či sú slová rovnakej dĺžky. Ak nie sú, vieme, že nejaký znak prvého slova nemá žiaden obraz v druhom slove, alebo naopak, a tak vieme hneď povedať, že odpoveď je ""nie"".

Teraz prichádza na rad hlavná časť riešenia. Povedzme, že oba reťazce $A$ a $B$ dĺžky $n$ máme načítané v pamäti a prechádzame obe slová po znakoch. Cieľom je overiť, či všetky znaky spĺňajú určené podmienky zo zadania. Pre každú $i$-tu dvojicu znakov $A_i$ a $B_i$ prechádzame ďalších $n - i$ dvojíc $A_j$, $B_j$. Pri tomto prechádzaní môžu nastať 4 situácie:

- $A_j$, $B_j$ sa zhodujú s $A_i$, $B_i$ -- vtedy je všetko v poriadku. $A_i = A_j$ a preto sú rovnaké aj ich obrazy $B_i = B_j$.

- $A_i \\neq A_j$ a $B_i \\neq B_j$ -- vtedy je tiež všetko v poriadku. Pôvodné písmená sú rozdielne a tak aj ich obrazy sú rozdielne.

- $A_i = A_j$ a $B_i \\neq B_j$ (alebo opačne $A_i \\neq A_j$ a $B_i = B_j$) znamená, že, buď máme dve rovnaké písmena v pôvodnom slove, ktoré majú odlišné obrazy, alebo, v druhom prípade, sú to rôzne písmena v pôvodnom slove a majú rovnaké obrazy. Oba tieto prípady znamenajú, že sme našli znak, ktorý nespĺňa podmienku zo zadania a odpoveď je tým pádom ""nie"".

Ak týmto spôsobom prejdeme celé slovo a nenájdeme žiadnu chybu, podmienky sú splnené pre všetky znaky a teda odpoveď je ""áno"".

Časová zložitosť tohto riešenia je __$O(n^2)$__, keďže pre každú z $n$ pozícií $i$ musíme ešte prejsť rádovo $n$ pozícií $j$.

Pamäťová zložitosť je __$O(n)$__, lebo si pamätáme dve slová s $n$ písmenami.

Na vstupe ale možeme dostať slovo dĺžky až $2,000,000$, čo znamená, že pri vyššie spomenutej časovej zložitosti by riešenie bežalo pomerne dlho...

## Substitučná šifra

Podmienky zo zadania vieme ale zjednodušiť a preformulovať tak, že chceme, aby sa každé písmeno malej abecedy (z prvého slova) zašifrovalo na písmeno veľkej abecedy (z druhého slova). Tiež musí platiť, že žiadne dve malé písmená sa nemôžu zašifrovať na to isté veľké.

Uvedomme si, že takéto šifrovanie sa dá celé definovať pomocou __šifrovacej abecedy__, čo je reťazec, v ktorom sa na $i$-tom mieste nachádza šifrovaný znak (obraz) $i$-teho písmena klasickej abecedy. Napríklad, použitím šifrovacej abecedy `ANCDEFGHIJKLMBOPQRSTUVWXYZ` vznikne zo slova ""abba"" slovo ""ANNA"". Písmeno `a` sa pri tom mení na `A`, `b` na `N`.

Takéto šifrovanie sa bežne nazýva __substitučná šifra__. Našou úlohou je teda zistiť, či šifrovaný text mohol vzniknúť z pôvodného pomocou takejto šifry.

## Lepšie riešenie

A práve pomocou šifrovacej abecedy vieme navrhnúť rýchlejšie riešenie! Ak si budeme pamätať šifrovaciu abecedu, tak nemusíme pre každý znak prechádzať celý zvyšok slova, ale stačí nám len overiť, či sú všetky nové znaky zašifrované podľa tej istej abecedy ako predošlé znaky.

Budeme si pamätať dve šifrovacie abecedy, vďaka ktorým budeme vedieť realizovať šifrovanie a dešifrovanie. Jedna abeceda bude šifrovať znaky z pôvodného slova do šifry, a druhá bude inverzná k nej -- ak sa podľa šifrovacej abecedy mení `a` na `B`, tak podľa dešifrovacej abecedy sa mení `B` na `a`.

Pre každý $i$-ty znak z pôvodného slova zistíme, či už máme k nemu priradený nejaký obraz v abecede pre šifrovanie. Ak tam žiaden obraz nie je, znamená to, že takéto písmeno sme objavili prvýkrát. V takomto prípade znaku pridelíme obraz podľa jeho šifry, čiže $i$-ty znak v druhom slove.

To isté zisťujeme aj pre znaky v druhom, šifrovanom, slove, a vytvárame si dešifrovaciu abecedu.

Ak už $i$-ty znak má v šifrovacej abecede priradený obraz, overíme, či sa tento obraz zhoduje s $i$-tym znakom v druhom slove. Ak sa nezhodujú, našli sme chybu v šifrovaní -- dva rovnaké znaky sú zašifrované na odlišné obrazy. Tiež musíme overiť, či sa už náhodou nejaký odlišný znak nezašifruje na obraz $i$-teho. To overíme pomocou doteraz vybudovanej dešifrovacej abecedy.

Pamäťová zložitosť je v podstate rovnaká ako predtým, aj keď si teraz musíme pamätať aj dve abecedy -- $2\\times 26$ znakov. To znamená __$O(2\\times n + 2\\times 26)$__, no konštanty môžeme pri odhade zložitostí zanedbať, keďže nás zaujíma iba rádový odhad množstva použitej pamäte. Tým pádom vieme určiť výslednú pamäťovú zložitosť na __$O(n)$__.

Pri časovej zložitosti získaváme výrazné zlepšenie a dostávame sa na lineárnu zložitosť, keďže pre každé písmeno vykonáme iba konštantný počet operácií. Takže __$O(n)$__.
",2
bfc1366de4cbb76e,ksp,"# Ohavný čin

Kleofáš sa vlúpal do základne KSP, aby z organizátorských serverov ukradol zadania ďalšej série (ktoré už sú samozrejme dávno pripravené). Ale spustil sa alarm a do T2 už mieria vytočení rooti, takže Kleofáš si musí pohnúť a všetky príklady ukradnúť čo najrýchlejšie.

## Úloha

Na serveri je $n$ príkladov. Kleofáš chce všetky stiahnuť na svoj notebook. Stiahnuť príklad číslo $i$ trvá $d\_{i,i}$ sekúnd. Ale ak sa podobá na nejaký už stiahnutý príklad $j$, netreba ho sťahovať celý -- stačí za $d\_{i,j}$ sekúnd stiahnuť rozdiely medzi nimi.

Príklady je možné sťahovať v ľubovoľnom poradí. Zistite, za koľko sekúnd dokáže Kleofáš stiahnuť všetky príklady.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($1\\leq n \\leq 1,000$) udávajúce počet príkladov. Nasleduje $n$ riadkov s $n$ číslami, z čoho $j$-te číslo $i$-teho riadku je hodnota $d\_{i,j}$ ($1\\leq d\_{i,j} \\leq 10^9$). Pre $i=j$ je to čas prenosu celého príkladu, zatiaľčo pre $i\\neq j$ je to čas prenosu rozdielov medzi príkladmi $i$ a $j$. Platí, že pre každé $i,j$ je $d\_{i,j}=d\_{j,i}$.

## Formát výstupu

Vypíšte, koľko sekúnd treba na stiahnutie všetkých príkladov.

## Príklad

```vstup
5
4 7 7 6 7
7 11 4 3 4
7 4 8 7 6
6 3 7 1 5
7 4 6 5 5
```

```vystup
16
```

_Najprv stiahneme celý štvrtý príklad, potom jeho rozdiely od druhého, a keď už máme druhý, stiahneme jeho rozdiely od tretieho a piateho príkladu. Prvý príklad tiež stiahneme celý, lebo sa veľmi nepodobá na žiaden iný._
","# Ohavný čin

Chceme stiahnuť $n$ súborov, pričom každý súbor môžeme buď stiahnuť celý, alebo si ušetriť čas a stiahnuť iba jeho rozdiely oproti nejakému inému súboru, ktorý už máme stiahnutý. O všetkom z toho vieme, koľko by to trvalo.

Základná myšlienka riešenia je previesť naše zadanie na problém najlacnejšej kostry. To je štandardná úloha, v ktorej dostaneme neorientovaný ohodnotený graf, a máme vybrať takú podmnožinu hrán, že má minimálnu cenu a graf obsahujúci len tieto hrany bude súvislý. Takže keď v grafe nájdeme najlacnejšiu kostru, stále sa po nej zvládneme dostať odvšadiaľ všade, ale celkový súčet váh hrán bude minimálny.

Tak to skúsme. Povedzme, že každý vrchol bude reprezentovať jeden stiahnutý súbor, a medzi každými dvoma vrcholmi bude hrana s takou váhou, koľko trvá stiahnuť rozdiely medzi tými súbormi. Keby sme v tomto grafe našli najlacnejšiu kostru, zistili by sme, ako by sa dalo stiahnuť všetky súbory, keď už jeden máme.

Ale zatiaľ sme obmedzení len na sťahovanie rozdielov. Stále sme sa nedozvedeli, ktoré súbory máme stiahnuť celé. Našťastie už nechýba veľa: Stačí do grafu pridať nový vrchol, ktorý predstavuje situáciu ""zatiaľ žiadne súbory nemám"". Medzi každým súborom a týmto novým vrcholom bude hrana s takou váhou, koľko trvá stiahnuť celý ten súbor.

Veľkosť najlacnejšej kostry pre tento graf je naša odpoveď. Najlacnejšia kostra vlastne hovorí návod, ako všetko najrýchlejšie stiahnuť. Súbory, čo susedia s vrcholom ""ešte nič nemám"", stiahneme celé, a potom podľa kostrových hrán postupne stiahneme všetko ostatné (tam už stačí sťahovať rozdiely).

## Hľadanie najlacnejšej kostry

Na naše konkrétne zadanie už môžme zabudnúť. Pozrime sa, ako sa hľadá najlacnejšia kostra vo všeobecnom grafe s $v$ vrcholmi a $e$ hranami. Jeden z algoritmov, čo túto úlohu vedia riešiť, sa volá Primov algoritmus.

Primov algoritmus buduje výslednú kostru vrchol po vrchole. Na začiatku bude kostra mať jediný vrchol (je jedno, ktorý). Potom v každom ťahu našu kostru o niečo zväčšíme -- nájdeme najlacnejšiu hranu, ktorá prepája nejaký kostrový a nejaký nekostrový vrchol, a pridáme ju do našej kostry. To opakujeme, až kým nie je v kostre každý vrchol (čiže $v-1$ ráz). Kostra, ktorú týmto postupom nájdeme, je zaručene najlacnejšia.

Ako nájdeme tú najlacnejšiu hranu? Väčšinou sa na to používa binárna halda, ale teraz si ukážeme, ako to spraviť lineárnym prehľadávaním. Budeme mať pole, v ktorom si pre každý vrchol $p$ uložíme cenu pridania $p$ do kostry -- čiže najlacnejšiu hranu z ľubovoľného kostrového vrchola do $p$. Keď vyberáme, ktorý vrchol pridať, proste zaradom prejdeme celé toto pole a vyberieme najlacnejší. Z tohto vrchola sa tým pádom stáva kostrový vrchol, takže sa pozrieme na všetkých jeho nekostrových susedov a zapíšeme do poľa, či sme pre nich nenašli lepšiu cenu. A to je celé.

Tento algoritmus má časovú zložitosť $O(v^2)$. To je zvyčajne dosť veľa -- keby sme použili Primov algoritmus s binárnou haldou, mali by sme zložitosť iba $O(e \\log v)$, a Kruskalov algoritmus by nám tiež dal $O(e \\log v)$. Lenže my máme kompletný graf, kde $v=O(n)$ a $e=O(n^2)$. V ňom majú Kruskal aj haldový Prim časovú zložitosť $O(n^2 \\log n)$, zatiaľ čo trápnemu lineárnemu prehľadávaniu stačí $O(n^2)$. V praxi to síce nie je veľký rozdiel, takže asi budú fungovať aj programy s pomalšími algoritmami, ale v popise ste za to mohli stratiť jeden bod.
",9
ca30eda90e0fe8ad,ksp,"# Obmenené zátvorky

Malý Marcelko je introvert, a tak si v škôlke spestruje dni tým, že len veľmi z diaľky pozoruje svojich spolužiakov, keď si kreslia voskovkami. Keďže sa zatiaľ naučil počítať iba do $4$, pozoruje, čo sa deje počas kreslenia s týmito $4$ druhmi voskoviek -- guľatou, kučeravou, špicatou a hranatou (voskovky si môžeme predstaviť ako príslušné zátvorky). Jeho novou zábavkou je písať si na papier záznamy o tom, čo sa deje s ktorou voskovkou. Na papier napíše otváraciu -- ľavú zátvorku (príslušného typu), keď si nejaký spolužiak danú voskovku vezme zo stolíka. Naopak, keď ju položí na stolík, zapíše si zatváraciu -- pravú zátvorku (príslušného typu). Na začiatku a na konci dňa sa všetky voskovky nachádzajú na stole. Občas sa ale Marcel zadíva na Sabinku a zabudne zapisovať niektoré zobratia alebo položenia voskoviek, alebo zapíše nejaké zobratia a položenia zle. Potom mu vznikajú všelijaké čudné zápisy a je smutný, lebo si nie je istý, či niečo nezmeškal. Pomôžte mu overiť, či jeho zápis mohol vzniknúť zapisovaním pohybov voskoviek, alebo nie.

## Úloha

Na vstupe dostanete počet jednotlivých druhov voskoviek a postupnosť zátvoriek. Vašou úlohou je zistiť, či pri danom počte druhov voskoviek mohol na konci dňa, keď všetky deti vrátili svoje voskovky, tento zápis nastať alebo nie.

## Formát vstupu

Na prvom riadku vstupu dostanete 4 čísla: $g$, $k$, $s$, $h$, kde $g$ je počet guľatých, $k$ je počet kučeravých, $s$ je počet špicatých a $h$ je počet hranatých voskoviek, ktoré majú v škôlke. Platí, že $0 \\leq g,k,s,h \\leq 5000$.

Nasleduje $1$ riadok obsahujúci neprázdnu postupnosť zátvoriek. Dĺžka tejto postupnosti je najviac $200,000$.

## Formát výstupu

Vypíšte jediný riadok obsahujúci buď reťazec `ANO` ak je záznam korektný, alebo reťazec `NIE` ak záznam nie je korektný a teda Marcel musel pri obzeraní Sabinky zmeškať nejaké položenie, zobratie voskovky, alebo nejaké zapísal zle. Nezabudnite na koniec vypísať znak konca riadku.

## Príklad

```vstup
1 1 1 1
([{<)]}>
```

```vystup
ANO
```

*V škôlke majú z každého druhu voskoviek jeden kus a takýto zápis mohol nastať tak, že zo stola postupne zobrali guľatú, hranatú, kučeravú a špicatú voskovku a následne ich v rovnakom poradí vrátili.*

```vstup
1 0 0 0
[()]
```

```vystup
NIE
```

*V škôlke majú iba guľatú voskovku a tu hneď na začiatku podľa zápisu niekto zobral hranatú, ktorú ale v škôlke nemajú.*

```vstup
1 0 0 0
(())
```

```vystup
NIE
```

*V škôlke majú iba jednu guľatú voskovku, ale podľa tohto zápisu sa zo stola najprv zobrali dve guľaté bez toho, aby sa medzi nimi nejaká položila.*

```vstup
2 0 0 0
(()
```

```vystup
NIE
```

*V škôlke majú dve guľaté voskovky ale v tomto zápise nám chýba položenie jednej voskovky.*
","# Obmenené zátvorky {bodypopis=12 bodyprogram=8}

Skúsme si najprv povedať, v akých situáciách budeme vedieť zo zápisu zátvoriek povedať, že táto postupnosť nemohla nastať. Sú to tieto situácie:

- v zápise je, že by sme mali zo stola zobrať nejakú voskovku, ktorá už nie je na stole, alebo ani nikdy na stole nebola

- v zápise je, že by sme mali vrátiť na stôl nejakú voskovku, ktorú sme si nikdy nezobrali

Ako takéto veci kontrolovať? Jednoducho postupne prechádzame postupnosť zátvoriek a pamätáme si počet voskoviek jednotlivých druhov, ktoré aktuálne sú na stole. Vždy, keď nájdeme nejakú zátvorku, tak si správnym spôsobom zmeníme aktuálny počet voskoviek na stole. Ak sa hocikedy v priebehu stane, že by počet nejakých voskoviek klesol pod $0$ alebo stúpol nad počet, koľko voskoviek toho druhu máme v škôlke, tak vypíšeme `NIE`. Netreba zabudnúť skontrolovať, že na konci dňa (na konci vstupu) musia byť na stole všetky voskovky. V prípade ak nie sú, tak tiež vypíšeme `NIE`. V ostatných prípadoch vypíšeme `ANO`.

Časová aj pamäťová zložitosť je lineárna, priamo úmerná dĺžke postupnosti zátvoriek.
",2
d11b95bab7ee0270,ksp,"# Zabezpečenie

V centrále Kryptografickej Spravodajskej Pobočky berú bezpečnosť veľmi vážne. Nedávno zistili, že niektoré semináre (napríklad Korešpondenčný Seminár z Programovania) nezabezpečujú svoju komunikáciu dostatočne. Preto navrhujú použiť nový Kryptografický Šifrovací Protokol. Je založený na technológii, ktorú používali už v starovekom Ríme.

Text sa zašifruje tak, že každé písmeno textu sa nahradí písmenom, ktoré je v abecede o $k$ pozícií ďalej. Napríklad, ak by sme mali $k=3$, tak všetky *A* sa nahradia písmenom *D*, *B* sa nahradí *E*, *C* sa nahradí *F*... No a v prípade, že by sme potrebovali použiť písmeno, ktoré sa nachádza v abecede za písmenom *Z*, pokračujeme opäť od začiatku abecedy. Písmeno *X* sa preto pri posunutí $k=3$ nahradí za *A*, *Y* za *B* a *Z* za *C*. Medzery medzi slovami zostávajú nezmenené.

No a keďže toto šifrovanie bolo dobré pre Rímske impérium, musí byť dobré aj pre KSP. Avšak doba o pár (tísíc) rokov pokročila, preto skôr než KSP začne používať KŠP odporúčané KSP, musí byť jeho bezpečnosť otestovaná. Práve spúšťame najväčšie testovanie KŠP v histórií KSP^[Ktorého?]. A na to potrebujeme práve teba.

## Úloha

Tvojou úlohou je napísať program, ktorý bude dešifrovať text zašifrovaný pomocou KŠP.

## Formát vstupu

V prvom riadku vstupu je celé číslo $n$, pričom platí $1\\leq n \\leq 20,000$. Nasleduje $n$ riadkov, každý obsahuje text pozostávajúci z veľkých písmen anglickej abecedy a medzier, ktorý je určený na dešifrovanie. Dĺžka riadku nepresiahne $100$ znakov. Je známe, že každý text, pred tým ako bol zašifrovaný, začínal *V MENE KSP*.

## Formát výstupu

Pre každý riadok textu na vstupe vypíšte do samostatného riadku dešifrovaný text (taktiež tvorený veľkými písmenami anglickej abecedy a medzerami).

## Príklad

```vstup
3
W NFOF LTQ WTFUDJ NVTJB OPTJU SVAPWF TVLOF
V MENE KSP NEZABUDAJTE POUZIVAT SIFROVANIE
L CUDU AIF FHEWHQCELQDYU ZU IKFUH
```

```vystup
V MENE KSP VSETCI MUSIA NOSIT RUZOVE SUKNE
V MENE KSP NEZABUDAJTE POUZIVAT SIFROVANIE
V MENE KSP PROGRAMOVANIE JE SUPER
```

*V prvom riadku je posun $k=1$, v druhom sa text vôbec nedešifroval, teda $k=0$ a v treťom je $k=16$.*

## Nápoveda

V prípade, že nevieš, ako spracovávať text, nasledujúce odstavce sú určené práve pre teba.

V programovacích jazykoch máme okrem číselných premenných typu `int`, `integer` aj premenné na ukladanie znakov, ktoré zvyknú byť označované `char`. Premenná typu `char` má v podstate uložené číslo od $0$ po $256$ v Pascale (od $-128$ po $127$ v C++), pričom každému číslu zodpovedá nejaký znak: napríklad kde napríklad číslu $65$ zodpovedá písmeno `'A'`, číslu $66$ zodpovedá písmeno `'B'` atď. -- pozri si ASCII tabuľku na odkaze [www.asciitable.com](http://www.asciitable.com/).

## Nápoveda -- PASCAL

Na načítanie jedného znaku zo vstupu do premennej typu `char` môžeme použiť funkciu `read(c)`. Pole znakov dĺžky 255 (`var s : array[0..255] of char`) sa nazýva `string` (na nultej pozícii uložená je dĺžka `string`u, `s[1]` je prvý znak, `s[n]` je $n$-tý znak). Na načítanie celého riadku do premennej `s` typu `string` sa používa `readln(s)`. Dĺžku tohto stringu zistíme príkazom `length(s)`. Znaky konca riadku sa nenačítajú. ASCII hodnotu daného znaku (jeho číselný kód) vieme zistiť pomocou `ord(c)`. Ak chceme získať znak z jeho kódu (opačný smer ako `ord`) použijeme `chr(cislo_znaku)`. Napríklad `writeln(ord('A'))` vypíše 65. Ak by sme napísali `writeln(chr(ord('A')))`, tak program vypíše `A`, pretože `chr` zoberie hodnotu znaku `A` vrátenú `ord` a vráti daný znak.

## Nápoveda -- C++, iostream

Premennú typu `char` môžeme považovať za jednobajtové číslo alebo za jeden znak. V prípade, že používame knižnicu iostream (`#include <iostream>`) môžeme jeden znak načítať nasledovne: `cin >> c`, kde `c` je typu `char`. Ak chceme znak vypísať: `cout << c`. Ak chceme vypísať jeho číslo: `cout << int(c)` -- takto už program vie, že ten kus pamäte, čo považoval za `char`, má považovať za `int`. Na prácu s reťazcami znakov sa dá využiť typ *string*. Prístup k $n$-tému znaku stringu `s` je podobný ako v Pascale (**ale nie rovnaký**): `s[n-1]`. V C++ a podobných jazykoch sa totiž indexuje od nuly (takže prvý znak je `s[0]`). ^\[`string` v C++ je v skutočnosti `vector<char>` s nejakými dodatočnými funkciami.\]

Keď chceme číslo vypísať ako znak, môžeme to spraviť nejako takto: `cout << char(66);` vypíše `B`, keďže práve `B` má hodnotu 66. Funkcia `s.size()` vráti dĺžku `s`. Vtipnou záležitosťou sú ""biele znaky"" (*whitespace characters*) -- to sú tie, ktoré nevidíme (medzera, tabulátor, enter). `cin >> s` štandardne načíta text iba po prvý biely znak. Na načítanie celého riadku do `string`u `s` môžeme použiť `getline(cin,s)`.

V C++ vieme s `char` pracovať aj ako s číslom, napríklad `'B'+1` je `'C'`.

## Nápoveda -- C++, cstdio

Ukážeme si jednoduchý program, ktorý najprv načíta jedno číslo, potom načítava znaky až po koniec riadku (znak `'\n'`) a tento riadok vypíše. Následne načíta dve slová (slová sú oddelené bielymi znakmi) a vypíše ich na samostatné riadky.

```
#include <cstdio>
int main(){
    int cislo;
    char znak;
    char slovo[256];
    scanf(""%d"", &cislo);
    while(scanf(""%c"", &znak)>0 && znak!='\n') printf(""%c"", znak);
    printf(""\n"");
    scanf(""%s"", slovo);
    printf(""%s\n"", slovo);
    scanf(""%s"", slovo);
    printf(""%s\n"", slovo);
}
```

Odporúčame spustiť si tento program na ukážkovom vstupe zo zadania.
","# Zabezpečenie

Vo všeobecných šifrách potrebujeme na dešifrovanie poznať šifrovací algoritmus a kľúč na dešifrovanie. Šifrovací algoritmus už poznáme -- je popísaný v zadaní. Pravdepodobne nebude problém celý proces obrátiť a dešifrovať text. Avšak na to potrebujeme kľúč -- v našom prípade číslo udávajúce posun v abecede. Tento kľúč zatiaľ nepoznáme, preto ho musíme zistiť z jednotlivých správ.

Na začiatok, keď nevieme prísť na nejaký prefíkaný spôsob, ako odhaliť kľúč, môžeme skúšať všetky možné kľúče, kým použitie jedného nevráti zmysluplný dešifrovaný text. V našom jednoduchom príklade spoznáme ""zmysluplný"" text tak, že na jeho začiatku sa nachádza *V MENE KSP*. Môžeme teda v cykle postupne prechádzať všetky možné posuny. Pre každý posun ""zmenšíme"" každé písmeno o 1, a v prípade, že by sme sa mali dostať pod *A*, tak pokračujeme od *Z*. Po takomto pokuse o dešifrovanie overíme, či text začína v *V MENE KSP*.

Predošlé riešenie má časovú zložitosť $O(n \\cdot k)$, kde $n$ je maximálna dĺžka textu a $k$ je počet možných kľúčov. V našom prípade riešenie nie je až také zlé, keďže texty sú pomerne krátke a písmen v abecede je len 26.

Keby však správa mohla pozostávať zo všetkých ASCII znakov, alebo nebodaj z UTF-8 znakov a bola by veľká niekoľko gigabajtov, bol by to už trochu problém. Existuje však aj rýchlejšie a jednoduchšie riešenie.

Vieme, že prvý znak textu (označme ho $e$) musel vzniknúť zašifrovaním *V* (lebo to je prvé písmeno *V MENE KSP*). Kľúč môžeme jednoducho vypočítať ako hodnotu $e-V$.

V niektorých programovacích jazykoch ako napríklad C++ môžeme pracovať so znakmi priamo ako s číslami, napríklad `'D'-'A'` bude číslo $3$. V iných jazykoch musíme najprv konvertovať znaky na čísla. `ord('D')-ord('A')` bude mať hodnotu $3$.

Tiež ak nám vadí, keď vyjde záporná hodnota ($F-V$ je $-16$), môžeme k tomuto číslu pričítať hodnotu $26$.

Akonáhle vypočítame $k$, stačí dešifrovať text podobne ako v predošlom riešení, a keďže už vieme správny kľúč, stačí odčítavať od každého znaku iba raz. Takto dostaneme časovú zložitosť $O(n)$. Pamäťovú zložitosť vieme mať dokonca $O(1)$, keby sme vstup načítavali postupne znak po znaku a rovno vypisovali výsledok, ale pre jednoduchosť budeme načítavať celý riadok do pamäte naraz.
",2
0a768014c8173388,ksp,"# Opäť sa hady hadiť budú

Blíži sa jar, kvety začnú pučať, hady sa začnú hadiť. Každý čo i len trochu decentný hadonoš si teraz plánuje rozloženie svojej zbierky na hadisko. Počet možných rozložení je častokrát obrovský, avšak mnoho začínajúcich hadonošov si to vôbec neuvedomuje a príprave nevenujú dostatok času. Navyše sa potom čudujú, keď dosiahnu malý hadiaci kvocient a v lete slabú úrodu! Pre mnohých z vás je toto tiež iba prvá hadonošská jar, a povedzme si to na rovinu, vieme, že nie všetci ste z tých najzodpovednejších. Možno by ste to brali serióznejšie, keby ste presne vedeli ako *hrozne* veľa kombinácii treba zvážiť? Dokonca to možno poslúži ako dobrá rozcvička vašich mozgov pred tým, ako sa začnete trápiť s hľadaním toho optimálneho rozloženia.

## Úloha

Hadisko má tvar mriežky s rozmermi $N \\times M$. Vo vašej zbierke je $K$ hadov a radi by ste ich rozložili na hadisko. Na každé políčko môžete položiť najviac jedného hada, a aby sa príliš nepohadili, do každého stĺpca a riadku nanajvýš dvoch. Pre účely hadenia môžeme všetkých hadov aj napriek ich náramne odlišným osobnostiam považovať za identických. Koľko existuje rôznych rozložení? Keďže ich môže byť ale že *naozaj veľa*, ako odpoveď uvádzajte výsledok modulo $10^9+7$.

## Formát vstupu

Na jedinom riadku su tri celé čísla $N$, $M$, $K$ -- rozmery hadiska a počet hadov.

## Formát výstupu

Na výstup vypíšte koľko existuje rôznych rozložení modulo $10^9+7$.

## Obmedzenia

Vstupy budú rozdelené do 4 sád. Každá sada bude hodnotená 2 bodmi. Platia v nich nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------- | --: | ---: | ----: | ----: | | $1 \\leq N,M \\leq$ | $5$ | $20$ | $50$ | $100$ | | $0 \\leq K \\leq$ | $5$ | $10$ | $100$ | $200$ |

## Príklady

```vstup
1 1 1
```

```vystup
1
```

```vstup
2 2 2
```

```vystup
6
```

```vstup
3 3 3
```

```vystup
78
```

```vstup
4 4 4
```

```vystup
1428
```

```vstup
5 5 5
```

```vystup
34020
```
","# Opäť sa hady hadiť budú

## Hlavná myšlienka

Ak by sme s úlohou nevedeli nijako pohnúť, mohli by sme naprogramovať nejakú rekurziu, čo by skúšala všetky permutácie ukladania hadov do mriežky a mala by otrasnú časovú zložitosť. Skúsenejšiemu riešiteľovi by sa však mala táto úloha rýchlo odhaliť ako úloha na dynamické programovanie.

Teda namiesto toho, aby sme navštívili každé možné rozloženie hadov a zväčšili počítadlo riešení o jedna, budeme veľa rozložení charakterizovať určitým stavom, navštevovať iba tieto menej početné stavy a počítadlo tak zväčšovať o veľké množstva naraz.

Teraz by sme boli radi, keby sme vedeli všetky rozloženia mriežky nejako rozumne reprezentovať do čo najmenej stavov, aby sme mali čo najlepšiu časovú zložitosť.

Poďme do mriežky umiestňovať hadov. Robiť to len tak náhodne asi nie je veľmi rozumné, a teda sa rozhodnime, že ich budeme umiestňovať napríklad po riadkoch zdola nahor -- teda pre každý riadok sa rozhodneme koľko a kam chceme hadov položiť a potom prejdeme na ďalší riadok. Vďaka tomuto sa vždy nachádzame v stave, kde všetky riadky, na ktoré sme sa doteraz pozreli, už nemusíme uvažovať a všetky, na ktoré sme sa ešte nepozreli, sú prázdne. Namiesto toho aby sme si teda pamätali celú tabuľku s pozíciami hadov, nám bude stačiť si pamätať, koľko hadov sme už umiestnili, koľko riadkov sme už naplnili (počet neumiestnených hadov a prázdnych riadkov je triviálne dopočítatelný) a počet hadov pre každý stĺpec.

Čo sa týka stĺpcov, môžeme si povšimnúť, že ak máme nejaké rozloženie hadov, na poradí stĺpcov veľmi nezáleží a ľubovoľné ich premiešanie je tiež valídne rozloženie. Preto je lepšia reprezentácia, kde si namiesto pamätania počtu hadov pre každý stĺpec pamätáme iba počet stĺpcov čo majú 0, 1 a 2 hady.

V tomto momente vieme teda stav reprezentovať piatimi číslami (počet umiestnených hadov, naplnených riadkov a stĺpcov s 0, 1 a 2 hadmi), čím by sme získali približne $O(K N M^3)$ stavov. Toto je však stále omnoho viac, ako je potrebné na získanie 8 bodov. Našťastie by malo byť ľahké tento počet zredukovať. Totiž, počet stĺpcov s 0 a 1 hadmi sa dá ľahko vypočítať z ostatných hodnôt. Ak $U$ je počet hadov, ktoré sme už umiestnili, a $S_i$ je počet stĺpcov s $i$ hadmi, tak $S_1=U - 2S_2$ a $S_0=M-(S_1+S_2)$. Zostáva nám teda iba $O(K N M)$ stavov. Keďže $K$ môže byť nanajvýš $2 \\cdot \\min(N, M)$ (inak neexistuje valídne rozloženie), tak počet stavov je $O(\\min(N,M)^2 \\cdot \\max(N,M))$.

Samozrejme, existujú aj iné reprezentácie stavov, bolo by však zbytočné ich tu uvádzať.

Teraz treba nájsť spôsob, ako z aktuálneho stavu odvodiť ostatné, alebo naopak, ako z ostatných stavov odvodiť aktuálny. Ľahšie sa vysvetľuje tá druhá možnosť, takže spravme to. Povedzme, že chceme vyjadriť stav $D[n][u][s_2]$, teda stav, kde sme už naplnili $n$ riadkov, umiestnili $u$ hadov a máme $s_2$ stĺpcov s dvoma hadmi. Pripomínam, že z týchto troch informácií vieme dopočítať $s_1$ a $s_0$. Do tohoto stavu sme prišli z nejakého iného, v ktorom sme mali o jeden menej naplnených riadkov, tak, že sme do jedného riadku pridali nula až dvoch hadov. Každú z týchto troch možností vyriešime samostatne.

Ak sme sa v predchádzajúcom stave rozhodli uložiť $0$ hadov, počet uložených hadov ani počet $s_2$ sa nezmenil, teda sme do aktuálneho stavu iba pripočítali počet rozložení predchádzajúceho stavu. Teda $D[n][u][s_2] \\mathrel{{+}{=}} D[n-1][u][s_2]$.

Ak sme sa v predchádzajúcom stave rozhodli uložiť $1$ hada, počet uložených hadov sa zvýšil o jedna a počet $s_2$ sa buď zmenil alebo nezmenil, podľa toho, do ktorého stĺpca sme daného hada vložili. Ak sme ho vložili do stĺpca s $0$ hadmi (ktorých je $s_0$) tak sa $s_2$ nezmenilo. Ak sme ho vložili do stĺpca s jedným hadom (ktorých je $s_1$) tak sa $s_2$ zvýšilo o $1$. Teda $D[n][u][s_2] \\mathrel{{+}{=}} s_0 \\cdot D[n-1][u-1][s_2] + s1 \\cdot D[n-1][u-1][s_2-1]$.

Ak sme sa v predchádzajúcom stave rozhodli uložiť $2$ hadov, počet uložených hadov sa zvýšil o dva a počet $s_2$ sa znova mohol, ale nemusel, zmeniť. Tentoraz máme až $3$ možnosti ako sme ich mohli uložiť:

1. oboch do nulového stĺpca -- to môžeme spraviť $s_0 (s_0-1) / 2$ spôsobmi
1. jedného do nulového a jedného do jednotkového stĺpca -- to môžeme spraviť $s_0 \\cdot s_1$ spôsobmi
1. oboch do jednotkového stĺpca -- to môžeme spraviť $s1(s1-1) / 2$ spôsobmi

To, ako sa zmenilo $s_2$ je ľahké odvodiť. Dostávame teda $D[n][u][s_2] \\mathrel{{+}{=}} (s_0 (s_0-1) / 2) \\cdot D[n-1][u-2][s_2] + (s_0 \\cdot s_1) \\cdot D[n-1][u-2][s_2-1] \\

- (s_1 (s_1-1) / 2) \\cdot D[n-1][u-2][s_2-2]$.

Zostáva nám iba pridať modulovanie a ošetriť, aby sme nepoužívali záporné indexy do polí. Začíname s informáciou $D[0][0][0] = 1$ a zvyšok tabuľky už vieme potom dopočítať. Vypočítanie ľubovoľného indexu trvá $O(1)$ a teda časová aj pamäťová zložitosť je $O(\\min(N,M)^2 \\cdot \\max(N,M))$.

Posledná vec, ktorú si môžeme všimnúť, je, že výpočet $D[n]$ závisí iba od $D[n-1]$. Teda ak budeme tabuľku počítať v rozumnom poradí (najprv všetky hodnoty pre určité $n$, až potom pre $n+1$), môžeme na $D[n-2]$ vždy zabudnúť a znížiť tak pamäťovú zložitosť na $O(M \\cdot \\min(N,M))$. A keďže vieme, že počet riešení je rovnaký pre tabuľky rozmerov $N \\times M$ a $M \\times N$, tak môžeme $N$ a $M$ vymeniť tak, aby nám to vyhovovalo a získať pamäťovú zložitosť $O(min(N,M)^2)$.

Riešenie tejto úlohy obsahovalo veľa pozorovaní a trikov. Veľa z nich však nebolo nutných (napríklad zníženie pamäťovej zložitosti), alebo sa dali získať čiastkové body ak ste ich nenašli.
",8
ed26764377bae27e,ksp,"# Otoč sa!

Popri čakaní v rade profesionálne deformovanému grafovému teoretikovi niekedy napadne modelovať aj to čakanie v rade grafom. A takto vznikla táto úloha.

$n$ ľudí stojí v rade na záchod. Teda, v rade ako rade[^1]. Tento rad má viac grafovej štruktúry ako by graf mal mať. Ľudia v rade sa na seba môžu pozerať. Ale pozerať sa na ľudí v ""rade"" nie je len tak! Menovite, pozeranie sa je *tranzitívne*: ak sa človek A pozerá na človeka B, a človek B sa pozerá na človeka C, potom sa aj človek A pozerá na človeka C. Navyše, žiadni dvaja ľudia sa na seba vzájomne nepozerajú, prípadný očný kontakt by bol príliš zahanbujúci!

Chceli by sme vedieť, či sa pri danej konfigurácií ľudí na seba ľudia vedia podľa hore uvedených pravidiel pozerať.

\[^1\]: zoradiť sa prirodzene do radu sa pre niektorých ľudí ukazuje ako veľmi ťažká úloha. Ale o tom táto úloha nie je.

## Úloha

Cyklus v (neorientovanom) grafe je postupnosť aspoň troch rôznych vrcholov, $v_1$, $v_2$, $\\dots$, $v_k$ takých že medzi každými $v_i$ a $v\_{i+1}$ je hrana a navyše $v_1$ a $v_k$ sú tiež spojené hranou. *Kaktus* je neorientovaný graf, v ktorom žiadna hrana neleží na viac ako jednom cykle.

Na obrázkoch vidíme tri grafy, prvé dva z nich sú kaktusy. Posledný z nich nie je kaktus, pretože červená hrana leží na dvoch cykloch.

Na vstupe dostanete súvislý neorientovaný kaktus. Vrcholy predstavujú ľudí. Chceli by sme vedieť či vieme *orientovať hrany* - hrana z vrchola $i$ do vrchola $j$ hovorí, že človek $i$ sa pozerá na človeka $j$ - tak aby sa zachovala tranzitívnosť a acyklickosť.

Inak povedané, chceme dať každej hrane šípku tak, že:

- každá hrana je orientovaná presne jedným smerom
- výsledný orientovaný graf neobsahuje cyklus
- ak z $i$ ide orientovaná hrana do $j$, z $j$ hrana do $l$, potom ide aj z $i$ orientovaná hrana do $l$. Menovite to znamená, že potom hrana medzi $i$ a $l$ existuje v zadanom neorientovanom grafe.

Dá sa to? Ak áno, vypíšte ako.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve medzerou oddelené čísla $n$ a $m$ -- počet vrcholov zadaného kaktusu a počet jeho hrán.

Na ďalších $m$ riadkoch sa nachádza popis hrán: na $i$-tom z nich sú dve _rôzne_ čísla $1 \\leq a_i, b_i \\leq n$ oddelené medzerou - vrcholy ktoré spája $i$-tá hrana.

Žiadna hrana sa na vstupe nevyskytuje viackrát.

## Formát výstupu

Pokiaľ sa hrany orientovať nedajú vypíšte ""nie"" (bez úvodzoviek).

Pokiaľ sa hrany orientovať dajú, vypíste $m+1$ riadkov: na prvom z nich vypíšte ""ano"" (bez úvodzoviek) a na ďalších $m$ riadkoch vypíšte orientované hrany. Nemusia ísť v poradí akom boli na vstupe, ale všetky hrany zo vstupu musia byť takto zorientované. $a b$ znamená že z vrcholu $a$ ide hrana do vrcholu $b$.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- | --: | --: | --: | --: | | $2 \\leq n, m \\leq$ | $20$ | $1000$ | $10^5$ | $10^5$ |

Navyše, v tretej sade platí, že $m = n - 1$, teda zadaný kaktus je strom (neobsahuje žiadne cykly).

## Príklady

```vstup
5 5
1 2
3 2
2 4
5 4
3 5
```

```vystup
ano
1 2
3 2
4 2
3 5
4 5
```

_Ľudia vo vrcholoch $2$ a $5$ sa na nikoho pozerajú, naopak, všetci ich susedia hľadia na nich_

```vstup
8 9
7 8
8 1
7 1
1 5
1 2
2 3
3 4
4 5
4 6
```

```vystup
nie
```

_Nech robíme, čo robíme, nevieme otočiť hrany tak, aby všetky tri podmienky platili_
","# Otoč sa!

## Keď je kaktus stromom

Pozrime sa najskôr na to, ako vyriešiť tretiu sadu: keď zadaný graf je strom.

Ukáže sa, že stromy vieme orientovať vždy nasledovným algoritmom:

- Zakoreňme strom a pre každý vrchol spočítame jeho hĺbku (vzdialenosť od vrchola).
- Všetky hrany orientujeme tak, aby išli z nepárnej hĺbky do párnej hĺbky

Každý vrchol po tomto orientovaní má buď všetky hrany idúce do neho, alebo z neho. Takto neexistuje cesta (po orientovaných hranách) s dĺžkou dva (alebo viac). Taktiež sa nevyskutuje cyklus, keďže stromy žiadne cykly nemajú.

Tento algoritumus vieme implementovať v čase aj pamäti $O(n)$ , napríklad pomocou prehľadávania do hĺbky.

## Čo s cyklami?

Najskôr sa zamyslime, čo sa deje, ak je zadaný kaktus cyklom.

Všimnime si, že akonáhle máme cyklus veľkosti viac ako $3$, nemôžeme mať cestu dĺžky dva, teda hranu z $a$ to $b$ a zároveň hrany z $b$ do $c$. Je to preto, že potom by sme museli mať aj hranu z $a$ do $c$. Lenže, ak už hrana z $a$ do $b$ leží na väčšom cykle, nemôže ležať na ďalšom cykle ($a-b-c$), keďže zadaný graf je kaktus. Takže, každý vrchol ležiaci v cykle dĺžky väčšej než $3$ má buď všetky hrany idúce z neho, alebo do neho.

Keď je dĺžka cyklu párna, potom vieme orientovať hrany na striedačku: každý druhý vrchol má všetky jeho hrany idúce z neho, a ostatné vrcholy v cykle majú všetky hrany idúce z nich, ako môžme vidieť na obrázku.

Čo ak je cyklus nepárnej dĺžky? Potom tento istý postup nemôžeme spraviť. Všimnime si navyše, že akonáhle orientujeme jednu hranu v cykle, orientácia ostatných hrán v cykle je daná - tak, aby sme nespravili cyklus. Problém je, že orientácia hrán ""na striedačku"" v nepárnom cykle nefunguje (skúste si to). Takže akonáhle máme nepárny cyklus dĺžky väčšej ako tri, nevieme ho orientovať.

Z toho vyplýva, že keď graf obsahuje nepárny cyklus dlhší než tri, nejde ho zorientovať.

Čo s cyklami dĺžky tri? Všimnime si, že ich hrany vieme orientovať hocijako. Bez ohľadu na ich orientovanie, vždy ostane jeden vrchol do ktorého hrany prichádzajú, jeden z ktorého odchádzajú a jeden, do ktorého jedna hrana pricháda a druhá odchádza. Rozmyslite si, prečo sú tak všetky podmienky zo zadania splnené.

## Všetko dokopy

Vyššie v texte sme si všimli, že ak graf obsahuje nepárny cyklus veľkosti $5$ alebo viac, potom hrany orientovať nejde. Ide to inak vždy? Nie, ukáže sa, že je ešte jeden prípad, v ktorom to nejde. Predstavme si, že graf obsahuje cyklus dĺžky tri, taký, že z každého vrchola tohto cyklu ide aspoň jedna ďalšia hrana. Lenže, ako sme pozorovali vyššie, akokoľvek orientujeme hrany v trojcykle, bude mať presne jeden vrchol, ktorý je v strede cesty dĺžky dva (teda jedna hrana troj-cyklu ide doňho, a ďalšia z neho). Problém je s hranami v tomto vrchole, ktoré nie sú hrany trojcyklu. Keďže zadaný graf je kaktus, hrany trojcyklu neležia na žiadnom ďalšom cykle. Z toho nám vyjde, že tieto ďalšie hrny orientovať nevieme (rozmyslite si to).

Ukáže sa, že toto je naozaj posledný prípad kedy to nejde. Na algoritmus nám ďalej poslúži nasledovné pozorovanie: keď zoberieme dobre-orientovaný graf (spĺňajúci podmienky v zadaní), a otočíme *všetky* hrany, dostaneme taktiež dobre-orientovaný graf. Teda nezáleží na tom, ako zorientujeme prvú hranu.

Algoritmus bude podobný ako pre stromy: zvolíme si ľubovoľne orientáciu prvej hrany, a takto sa nám jednoznačne zadá orientácia (takmer) všetkých ostatných hrán. Jediné, kde môžeme mať voľbu sú troj-cykly. V nich treba vybrať ktorý vrchol bude mať jednu príchodziu a jednu odchádzajúcu hranu, a tento vrchol musí mať stupeň presne $2$. Jediné, na čo si treba dávať pozor sú trojuholníky - tam treba vybrať orientáciu hrán, (teda aby z neho išli len grafy trojcyklu).

- Najskôr skontrolujme (napríklad prehľadávaním do hĺbky), či v grafe neexistuje nepárny cyklus dĺžky aspoň $5$, alebo troj-cyklus, ktorý neobsahuje vrchol stupňa dva.

- Prehľadávame do hĺbky: pre vrcholy vo vrstvách dfs-stromu alternujeme, či idú hrany z nich, či do nich. Treba si dávať pozor na trojuholníky, tie ošetríme špeciálne: vyberieme jeden -- ak ich je viac, z jeho vrcholov ktorý má stupeň dva, jednu hranu orientujeme doňho, a druhú z neho.

Všetko sa dá spraviť napríklad dvoma prehľadávaniami do hĺbky, v časovej aj pamäťovej zložitosti $O(n)$.
",9
dff861c253929b36,ksp,"# Zápolenie o cukríky

Jedno pomalé štvrtkové popoludnie Kuko zase raz dostal chuť na cukríky. V tú ranu vošiel do miestnosti Mišo s jeho obľubeným balením všetkých chutí. Kukovi v hlave vzkrsol nápad -- stavil sa s Mišom o cukrík, že proti nemu vyhrá partiu hry [Go](<https://en.wikipedia.org/wiki/Go_(game)>). Tak hrali jednu hru, dve hry, až napokon za svitu posledných lúčov zapadajúceho slnka vyprázdnili celý sáčok.

Kukovi sa podarilo vyhrať každú jednu hru. Teraz, keď už nemá žiadne ďalšie cukríky na zjedenie, začal uvažovať, či by mu celé balenie nechutilo viac, ak by niektoré hry nechal vyhrať Miša.

Kukove chuťové poháriky totiž fungujú prazvláštne. Ak si dá len jeden cukrík, je mu jedno aký bude, všetky mu budú chutiť rovnako. Ak ale zje dva rovnaké po sebe, situácia je trochu zložitejšia. Niektorých chutí by sa nevedel nabažiť ani keby ste mu doviezli plný kamión, pri iných by druhý rovnaký cukrík zjedol len pri použití násilia.

Teraz by od vás chcel vedieť, ako najviac mu mohlo Mišove balenie chutiť, ak by niektoré hry nevyhral.

## Úloha

Na vstupe máte postupnosť cukríkov dĺžky $n$, o ktoré postupne Kuko s Mišom bojovali. Pre každý typ cukríka $i$, tiež viete, akú má chutnosť, ak je zjedený po cukríku rovnakého typu -- túto chutnosť nazveme $b_i$. Tiež viete, akú má chutnosť cukrík, ak je zjedený po cukríku iného typu -- chutnosť $c$. Táto chutnosť je rovnaká pre všetky typy cukríkov.

Prvý cukrík má chutnosť rovnakú, ako keby bol zjedený po cukríku iného typu (teda $c$), chutnosť každého ďalšieho cukríka závisí na type posledného zjedeného cukríka.

Nájdite chutnosť najchutnejšej podpostupnosti cukríkov (nie nutne súvislej). Chutnosť podpostupnosti je rovná súčtu chutností jednotlivých zjedených cukríkov.

## Formát vstupu

V prvom riadku vstupu sú kladné, medzerou oddelené čísla $n$, udávajúce počet cukríkov, a $m$, udávajúce počet typov cukríkov. Platí, že $1 \\leq m \\leq n \\leq 1,000,000$

V nasledujúcom riadku sa nachádza $n$ medzerou oddelených čísel $a_i$ ($1 \\leq a_i \\leq m$) -- typ $i$-teho cukríka.

V ďalšom riadku nasleduje $m$ medzerou oddelených čísel $b_i$ ($0 \\leq b_i \\leq 10^9$) -- chutnosť cukríka typu $i$, ak bol zjedený hneď po cukríku rovnakého typu.

V poslednom riadku je jedno kladné číslo $c$ ($0 \\leq c \\leq 10^9$) -- chutnosť cukríka, ak bol zjedený hneď po cukríku iného typu, alebo je to prvý zjedený cukrík.

Všimnite si, že súčet chutností cukríkov ľahko presiahne $2^{31} - 1 \\approx 2 \\cdot 10^9$, čo je najväčšie číslo, ktoré sa dá uložiť v $32$-bitovej premennej so znamienkom. Použite preto $64$-bitové premenné typu `long long` v C++ a `Int64` v Pascale.

## Formát výstupu

Na jediný riadok vypíšte chutnosť najchutnejšej podpostupnosti cukríkov, akú vie Kuko dosiahnuť.

## Príklad

```vstup
5 3
1 2 3 3 2
3 7 1
2
```

```vystup
11
```

_Najchutnejšia podpostupnosť je $1, 2, 2$, pričom jednotlivé chutnosti curíkov sú $2, 2, 7$. Prvý a druhý cukrík majú obidva chutnosť $c = 2$, keďže pred nimi nebol zjedený cukrík rovnakého typu. Všimnite si tiež, že ak by Kuko zjedol všetky cukríky, celková chutnosť by bola menšia, konkrétne $2+2+2+1+2 = 9$._
","# Zápolenie o cukríky

## Riešenie hrubou silou

Ako pri väčšine úloh, aj pri tejto sa dá vcelku ľahko vymyslieť riešenie, ktoré vyskúša všetky možnosti zjedenia cukríkov, vypočíta chutnosť každej podpostupnosti a vypíše najväčšiu z nich.

Vezmime si prvý cukrík. Ten v našej výslednej postupnosti buď bude, alebo nebude. Zrátame teda akú najväčšiu chutnosť môže dosiahnuť zvyšok postupnosti ak tento prvý cukrík vezmeme a ak ho nevezmeme, a vyberieme z nich tú lepšiu možnosť. Spravíme si teda rekurzívnu funkciu `rek`, ktorá dostane ako parametre pozíciu momentálne spracovávaného cukríka v postupnosti a typ posledného zjedeného cukríka. Funkcia pomocou samej seba (rekurzívne) spočíta dve hodnoty -- chutnosť zvyšku postupnosti podľa toho či momentálne spracovávaný cukrík v postupnosti bude alebo nie -- a vyberie možnosť s najväčšou chutnosťou. Maximálnu chutnosť vráti ako výstup. Na výpočet celej úlohy potom stačí zavolať `rek` na prvý cukrík s tým, že predtým nebol zjedený žiaden iný a vypísať hodnotu, ktorú vráti.

Už len odhadneme časovú zložitosť takéhoto riešenia. Pre každý cukrík máme dve možnosti, čo s ním spraviť, zjeme ho alebo ho nezjeme. Všetkých možností, ako vybrať niekoľko cukríkov je preto $2^n$, čo bude aj časová zložitosť nášho riešenia -- $O(2^n)$.

Za takéto riešenie bolo možné získať 1 bod.

## Dynamické programovanie

Poďme teda vymyslieť niečo rýchlejšie. Takéto rekurzívne riešenie totiž zbytočne veľakrát počíta stále tie isté hodnoty: Vezmime si postupnosť cukríkov `1 1 1 1`. Už pri takto malom vstupe trikrát počítame hodnotu funkcie `rek` pre tretí cukrík, ak predchádzajúci bol typu $1$ -- raz pre možnosť, kedy zoberieme iba prvý cukrík, raz keď zoberieme iba druhý a raz keď zoberieme oba.

Hodnota, ktorú vráti funkcia `rek(2, 1)` (2 prislúcha tretiemu cukríku, lebo indexujeme od 0) sa však nezmení bez ohľadu na to, ktorú z týchto možností sme zvolili. Ak by sme sa dokázali vyhnúť tomu, aby sme počítali tú istú vec duplicitne, naše riešenie by sa určite zrýchlilo.

Pri rekurzívnych funkciách existuje spôsob ako niečo takéto docieliť -- volá sa memoizácia. V podstate spočíva v tom, že po vypočítaní nejakej hodnoty si zapamätáme tento výsledok a nabudúce, keď náš program bude potrebovať spočítať túto hodnotu, iba si ju nájde v pamäti. Viac sa o memoizácii môžete dozvedieť napríklad v tomto vzorovom riešení: [https://www.ksp.sk/ulohy/riesenia/1098/](https://www.ksp.sk/ulohy/riesenia/1098/)

Použitím memoizácie na vyššie ukázanú rekurziu by sme dostali riešenie s časovou zložitosťou $O(nm)$, za ktoré by sme dostali 4 body. Toto riešenie však následne už nevieme zlepšiť, preto sa na náš problém musíme pozrieť z inej strany.

Pokúsme sa vyriešiť takúto úlohu: Akú najväčšiu chutnosť vie mať postupnosť končiaca cukríkom na $i$-tej pozícii? Túto najväčšiu možnú chutnosť si označme $D[i]$.

Keďže vieme, ktorý cukrík zjeme ako posledný ($i$-ty), možno má zmysel pozrieť sa na to, ktorý sme zjedli ako predposledný. Ten totiž ovplyvní, ako nám bude chutiť ten na pozícii $i$. Nech je predposledný zjedený cukrík na pozícii $j$. Potom na základe toho, či sú $i$-ty a $j$-ty cukrík rovnakého typu vieme povedať, ako veľmi nám chutil ten na pozícii $i$.

Všimnime si však, že $i$-ty cukrík, keďže je posledný, nám neovplyvní ako nám chutili predošlé cukríky v postupnosti. Preto ak chceme mať čo najväčšiu chutnosť a vieme, že na predposlednej pozícii je $j$-ty cukrík, najväčšia chutnosť postupnosti končiacej $j$-tym cukríkom je $D[j]$.

Preto platí, že:

- Ak je $i$-ty cukrík rovnakého typu ako $j$-ty, najväčšia možná chutnosť postupnosti, ktorá končí týmito dvoma cukríkmi je $D[i] = D[j] + chutnost\[typ[i]\]$

- Ak sú dva posledné cukríky rôznych typov, chutnosť postupnosti je $D[i] = D[j] + c$ (kde $c$ je chutnosť cukríka ak nasleduje po cukríku iného typu)

My síce nevieme, ktorý cukrík bol predposledný, teda čo je tá pozícia $j$, nič nám však nebráni, aby sme vyskúšali všetky možnosti medzi 0 až $i-1$ a z nich si vybrali tú najlepšiu. Zapísané ako vzorec:

$$ rovnaky predosly = chutnost\[typ[i]\] + \\max \\lbrace D[j] ~|~ j \\leftarrow 0, 2, \\dots, i-1; typ[i] = typ[j] \\rbrace$$ $$ iny predosly = c +\\max \\lbrace D[j] ~|~ j \\leftarrow 0, 2, \\dots, i-1; typ[i] \\neq typ[j] \\rbrace$$ $$D[i] = \\max \\lbrace rovnaky predosly, iny predosly\\rbrace$$

Vyrobíme si teda pole `D[]`, v ktorom budeme mať pre každý cukrík uloženú **najväčšiu chutnosť postupnosti, akú vieme dosiahnuť, ak ho vezmeme ako posledný**. Keďže pri výpočte hodnoty $D[i]$ potrebujeme poznať všetky hodnoty $D[j]$ pre $j < i$, budeme hodnoty tohto poľa vypĺňať zaradom od prvej pozície. Takýto prístup, kde z menších hodnôt postupne počítame čím ďalej väčšie hodnoty, sa nazýva _dynamické programovanie_.

Keď vyplníme celé pole, tak výsledok bude maximálna hodnota v ňom, a tú vypíšeme.

Pre spočítanie jednej hodnoty $D[i]$ sa potrebujeme pozrieť na predošlých $i-1$ políčok. Celkovo sa preto pozrieme na $0 + 1 + 2 + ... + (n-1) = \\frac{(n-1)n}{2}$ políčok, a časová zložitosť tohto algoritmu bude $O(n^2)$. Za takéto riešenie ste na testovacích vstupoch mohli získať $3$ body.

## Jemné vylepšenie

V predchádzajúcom riešení si môžeme všimnúť, že pri počítaní $D[i]$ prechádzame všetkých $i-1$ políčok poľa $D$ len preto, aby sme spomedzi nich vybrali buď najväčšie $D[j]$, kde cukrík $j$ má rovnaký typ ako cukrík $i$ alebo najväčšie $D[j]$ zo všetkých ostatných.

Predstavme si, že dva cukríky na pozícii $a$ a $b$ sú rovnakého typu a máme pre ne vypočítané hodnoty $D[a]$ a $D[b]$, pričom platí $D[a] < D[b]$. Uvedomme si, že pri počítaní ďalších hodnôt $D[i]$ sa budeme vždy pozerať na obe tieto pozície, budú patriť do tej istej skupiny (rovnaký alebo rôzny ako $i$-ty cukrík) a vždy z nich budeme vyberať maximum. Hodnotu $D[a]$ teda už **nikdy** viac nebudeme potrebovať, lebo hodnota $D[b]$ je proste lepšia.

Bude nám preto stačiť, ak si pre každý typ cukríka zapamätáme len tú najväčšiu hodnotu $D[i]$, ktorú sme dovtedy videli ak $i$-ty cukrík bol príslušného typu.

Budeme mať teda pole `T[]` veľkosti $m$, kde na $k$-tej pozícii bude uložená **najväčšia doteraz videná chutnosť postupnosti, ktorá končí cukríkom typu $k$**. Hodnotu $D[i]$ potom budeme počítať tak, že buď zoberiem hodnotu postupnosti končiacej rovnakým typom cukríka, teda hodnotu $T\[typ[i]\]$ alebo maximum zo všetkých ostatných.

V našom programe dokonca vynechávame samotné pole `D[]`, namiesto hodnoty `D[i]` používame iba lokálnu premennú `najlepsie`. Všimnite si tiež, že na záver nezabudneme hodnotu `najlepsie` vložiť do poľa `T[typ[i]]` -- samozrejme, ak je väčšia ako doterajšia hodnota.

Takéto riešenie má zložitosť $O(nm)$ a na testovacích vstupoch dostalo $4$ body.

## Ešte o rád rýchlejšie

Označme si najväčšiu chutnosť spomedzi cukríkov iných typov než typu $k = typ[i]$ ako: $$M_k = \\max\\lbrace T[1], T[2], \\dots T[k-1], T[k+1], \\dots T[m]\\rbrace$$

Hodnotu $D[i]$ sme teda v predošlom riešení počítali ako $\\max\\lbrace T[k] + chutnost[k], M_k + c\\rbrace$.

Strácali sme ale veľa času tým, že sme $M_k$ vždy hľadali v čase $O(m)$ -- prezeraním všetkých ostatných typov. Takmer vždy nám ale stačí pamätať si len najväčšiu chutnosť zo všetkých, $M = \\max\\lbrace T[1], T[2], \\dots T[m]\\rbrace$. Chutnosť postupnosti, ktorá končí $i$-tym cukríkom, ktorý má typ $k$ vieme teda spočítať ako $T[k] = \\max\\lbrace T[k] + chutnost[k], M + c\\rbrace$.

Hodnota $M$ však patrí niektorému typu cukríkov. A ak je $i$-ty cukrík rovnakého typu, tak neplatí, že $M\_{typ[i]} = M$ ($M\_{typ[i]}$ je maximum z typov *iných* ako $typ[i]$). V takomto prípade by sme museli spočítať hodnotu $M\_{typ[i]}$ a použiť tú.

V skutočnosti ju ale nemusíme počítať, stačí si zapamätať **typ cukríka, ktorým končí druhá doteraz najchutnejšia postupnosť** a použiť ju namiesto $M\_{typ[i]}$.

V našom riešení si teda budeme pamätať pole pre chutnosti jednotlivých typov, `T[]`, a dva typy s najväčšími chutnosťami $a$ a $b$, pričom $T[a] \\geq T[b]$.

- Pri výpočte chutnosti postupnosti, ktorá končí $i$-tym cukríkom sa pozrieme na postupnosť, ktorá končila *rovnakým typom*, a jedna možnosť výsledku bude $T\[typ[i]\] + chutnost\[typ[i]\]$.

- Druhá možnosť výsledku je taká, že zoberieme najchutnejšiu postupnosť, ktorá končí *iným typom* cukríka ako $typ[i]$ a potom je možnosť výsledku $M + c$, pričom $M$ bude $T[a]$ ak $typ[i] \\neq a$ a $T[b]$ v opačnom prípade.

Z týchto dvoch možností vyberieme ako výsledok tú chutnejšiu.

Časová zložitosť riešenia je teda $O(n)$, lebo pre každý cukrík overíme len pár podmienok a upravíme dva najvýhodnejšie typy.
",5
9bcadf539f04e4ca,ksp,"# Zlacnené disky

Matúš už vďaka vám našiel disk, ktorý má najlepší pomer ceny ku kapacite, ale stále nie je celkom spokojný. Momentálne je totiž spomenutý disk veľmi drahý. Po krátkej úvahe si Matúš uvedomil, že sa disky nevyrábajú v Európe, ale na Taiwane, a preto ich cena závisí od kurzu eura k taiwanskému doláru. Pohrabal sa v ekonomických zákutiach internetu a stiahol si vývoj kurzu na nasledujúcich $n$ dní. Keďže potreboval disk ihneď, kúpil si ho na splátky priamo u taiwanskej spoločnosti.

Matúš každý deň spláca $s$ eur, avšak ktorýkoľvek deň sa sa môže rozhodnúť doplatiť zvyšok sumy. Teraz už len potrebuje zistiť, ako dlho by mal platiť splátky a čakať so zaplatením zvyšku tak, aby dokopy zaplatil čo najmenej.

No a v súlade s jeho žgrlošským zmýšľaním prenechal Matúš túto úlohu lacnejšej pracovnej sile: vám!

## Úloha

Na vstupe dostanete vývoj kurzu taiwanského doláru na najbližších $n$ dní, cenu disku $c$ v taiwanských dolároch a výšku splátky $s$ v eurách. Matúš spláca každý deň $s$ eur začínajúc prvým dňom, ktorý je na vstupe. Skutočnú sumu, ktorú dostane taiwanská spoločnosť vypočítame tak, že sumu, ktorú zaplatí Matúš v eurách vynásobíme kurzom na daný deň. Ak je kurz $47$ a Matúš zaplatí $2$ eurá, tak sa z celkovej sumy $c$ odráta $47\\cdot 2=94$ taiwanských dolárov. Celková suma, ktorú dostane spoločnosť v taiwanských dolároch, môže byť aj vyššia, ako cena disku, keďže Matúš vie platiť iba celočíselné sumy.

Vašou úlohou je zistiť, v ktorý deň má Matúš zaplatiť zvyšok dlhu, aby dokopy zaplatil čo najmenej eur. Ak je takých dní viac, vypíšte ten najskorší, aby Matúš splácal čo najkratšie. V prípade, že sa mu oplatí čakať až do $n$-tého dňa, musí Matúš vyplatiť zvyšok sumy v tento deň. **Matúš musí aj v posledný deň splácania zaplatiť aspoň $s$ eur**.

## Formát vstupu

V prvom riadku vstupu sú tri kladné celé čísla $n$, $c$ a $s$ ($1 \\leq n \\leq 200,000, 1 \\leq c,s \\leq 10^9$) udávajúce počet dní pre ktoré poznáme kurz, cenu disku a výšku splátky. V nasledujúcom riadku je $n$ celých čísel oddelených medzerou, kde číslo na pozícií $i$ udáva kurz v $i$-tom dni.

## Formát výstupu

Vypíšte jedno číslo -- taký deň, v ktorom má Matúš doplatiť zvyšok sumy, aby dokopy zaplatil čo najmenej. Nezabudnite za ním vypísať koniec riadku.

## Príklad

```vstup
5 1000 2
3 47 190 50 30
```

```vystup
3
```

*V prvý deň zaplatí $2\\cdot 3=6$ dolárov, druhý deň $2\\cdot 47=94$ a tretí deň doplatí zvyšok $5\\cdot 190=950$.*

```vstup
4 200 10
3 2 10 20
```

```vystup
3
```

*V tretí deň zaplatí $15$ eur, takže dokopy zaplatí 35 eur v hodnote $10\\cdot 3+10\\cdot 2+15\\cdot 10=200$ dolárov. Ak by čakal na najvyšší kurz vo štvrtý deň, zaplatil by dokopy $40$ eur, pretože aj v posledný deň splácania musí Matúš zaplatiť aspoň $10$ eur.*

```vstup
3 1000 1
100 10 1
```

```vystup
1
```

*Matúš sa môže rozhodnúť, že zaplatí celú sumu aj v prvý deň.*
","# Zlacnené disky

Úlohou bolo zistiť, v ktorý deň je najvýhodnejšie zaplatiť zvyšok dlhu.

Potrebujeme teda pre každý deň zistiť, koľko eur by Matúš celkovo zaplatil, ak by vyplatil zvyšok dlhu v tento deň. Potom nám stačí vybrať najskorší deň kedy je táto suma najnižšia.

Otázkou ostáva, ako počítať sumu v eurách, ktorú by zaplatil, ak by ukončil splácanie v $i$-ty deň. Táto suma sa skladá z dvoch častí:

Prvá časť je to, čo musel zaplatiť každý deň splácania -- $i$-krát výška splátky, teda $i \\cdot s$.

Druhá časť musí pokrývať nesplatený zvyšok ceny v taiwanských dolároch. Tento zvyšok vypočítame ako rozdiel ceny disku a súčtu hodnôt všetkých doterajších splátok. Ak si teda označíme kurz $i$-teho dňa ako $k_i$, zvyšok je $c - s \\cdot (k_1 + k_2 + ... + k_i)$.

Môžeme si všimnúť, že ak poznáme zvyšok v $i$-ty deň, ľahko vieme vypočítať zvyšok v $i+1$ deň, a to tak že od zvyšku v $i$-ty deň odrátame hodnotu splátky v $i+1$ deň -- $s \\cdot k\_{i+1}$^[Ak by sme pre každý deň zvlášť počítali súčet $(k_1 + k_2 + ... + k_i)$, potebovali by sme si kurzy pamätať v poli, no čo je horšie, výpočet by mohol trvať dlho. Pre $n$ dní by sme postupne sčítavali $1, 2, 3, \\dots n$ čísel, teda celkovo by sme sčítali $1 + 2 + 3 + \\dots + n = \\frac{n(n-1)}{2} = O(n^2)$ čísel. Takýto program by úspešne stihol vyriešiť vstupy s $n$ nanajvýš $10,000$.].

Keď už poznáme zvyšok, ktorý treba pokryť, vydelíme ho kurzom na tento deň a získame sumu v eurách ktorú treba doplatiť. Nakoľko chceme platiť celočíselne, túto sumu ešte zaokrúhlime nahor.

Celkovú sumu, ktorú Matúš zaplatí, ak sa rozhodne doplatiť dlh v $i$-ty deň vieme teda vypočítať ako $$ i \\cdot s + \\left\\lceil \\frac{c - s \\cdot (k_1 + k_2 + ... + k_i)}{k_i} \\right\\rceil$$

Keď poznáme celkovú sumu, stačí ju porovnať s doteraz najnižšou sumou ktorú sme vyrátali, a ak je lepšia, tak si uložíme číslo tohto dňa. Treba si dať pozor, aby sme výpočet zastavili potom, ako sa zvyšok stane záporným, lebo vtedy je už disk splatený.

## Zložitosť

Ak postupujeme tak, ako sme popisovali vyššie, stačí nám v každom z $n$ krokov prečítať hodnotu kurzu na tento deň a spraviť konštantne veľa jednoduchých výpočtov a porovnaní, ktoré majú konštantnú časovú zložitosť. Preto celková časová zložitosť bude $O(n)$.

Lepšie sa to dokonca ani nedá, keďže na vstupe máme kurzy na $n$ dní, ktoré musíme načítať^[ Odhad zložitosti robíme všeobecne, teda uvažujeme najhorší možný prípad -- ak je najvýhodnejšie doplatiť splátku v posledný deň, musíme načítať všetky kurzy.].

Pamäťová zložitosť je $O(1)$, pretože si stačí pamätať len zvyšok, ktorý treba zaplatiť z predošlého dňa a kurz v daný deň.
",1
b553a29e0e5933e5,ksp,"# Ako sa časy menia

Píše sa 31. jún 2019. Prešlo už viac ako 20 rokov odkedy ste nezískali tender na napísanie programu pre jadrovú elektráreň na matfyze. Ale časy sa menia a tentoraz je šťastie na vašej strane. Ministerstvo Krajne Serióznych Projektov sa rozhodlo vykonať rutinnú 20 ročnú kontrolu bezpečnostných systémov kritických zariadení republiky a vy ste vyhrali tento tender! Hlava sa vám točí nad predstavou koľko korniet si budete vedieť kúpiť. Ale najprv práca, potom kornetá, hor sa do roboty!

Bezpečnostný systém funguje na báze Masívneho hesla, teda číselnej kombinácie, ktoré má uložené v pamäti a ktoré porovnáva s pokusmi od užívateľa. Vám však netrvalo dlho zistiť, že to kódil naozaj iba nejaký skoro-programátor. Pokus sa vyhodnotí ako nesprávny nie keď sa zadané heslo nezhoduje s Masívnym heslom, ale keď obsahuje nejaké znaky navyše! To znamená, že na poradí znakov v hesle vôbec nezáleží a že napríklad prázdne heslo bude vždy správne.

Ministerstvo nebolo veľmi nadšené vaším zistením, ale odľahlo im, lebo vraj potenciálny útočník túto chybu nevedel použiť na zistenie Masívneho hesla. To totižto používajú úplne všade a ak by ho zistiť vedel, bola by šanca, že ho niekedy v minulosti získal alebo možno v blízkej budúcnosti získa. Toto by nemohli riskovať, museli by Masívne heslo všade zmeniť a komu sa to chce.

Dokážte, že sa mýlia a že sa táto chyba dá použiť na zistenie Masívneho hesla. Navrhnite program, ktorý toto Masívne heslo nájde.

## Úloha

Táto úloha je interaktívna. Namiesto kompletného vstupu budete dostávať odpovede na vaše otázky. Heslo je podmnožina, teda niekoľko **rôznych** celých čísel od $1$ po $N$, pričom Masívne heslo má dĺžku najviac $M$ čísel.

Vaša otázka je tip na Masívne heslo. Odpoveď na vašu otázku bude kladná, pokiaľ je každý jeden prvok tejto otázky súčasťou Masívneho hesla. Teda otázka bude vyhodnotená záporne, pokiaľ obsahuje aspoň jeden prvok, ktorý nie je súčasťou Masívneho hesla. Vašou úlohou je zistiť Masívne heslo.

Môžete sa opýtať nanajvýš $111,111$ otázok.

## Formát vstupu

Na prvom riadku dostanete čísla $N$ -- najväčšie možné číslo v hesle a $M$ -- maximálnu dĺžku Masívneho hesla, pri čom vždy platí $(0 \\leq M \\leq N \\leq 10^5)$.

Následne dostanete odpoveď na každú vašu otázku jedným riadkom obsahujúcim `JOP` v prípade kladného vyhodnotenia a `NOP` v prípade záporného.

## Formát výstupu

Každá otázka, ktorú položíte, by mala byť vypísaná na jednom novom riadku. Riadok sa začína číslom $K$ - dĺžkou hesla. Za ním nasleduje medzera a $K$ medzerou oddelených čísel -- vaša otázka. V prípade, že si myslíte, že poznáte Masívne heslo, vypíšte `-1` a na nový riadok vypíšte toto heslo v rovnakom formáte, ako otázky (teda číslo $K$ a za ním $K$ medzerou oddelených čísel).

Pokiaľ sa opýtate viac ako $111,111$ otázok, váš program bude nemilosrdne ukončený a v testovači sa to prejaví verdiktom `""WA - Zlá odpoveď""` alebo dokonca `""EXC - Chyba počas behu programu""`.

## Flushovanie

Programovacie jazyky štandardne používajú výstupný buffer, a až po jeho zaplnení program vypíše jeho obsah. Flushovanie vlastne znamená vypísanie (vyprázdnenie) tohto buffera. Vždy, keď vypíšete svoju otázku, musíte ešte flushnúť výstupný buffer. Inak sa váš ťah v skutočnosti nevypíše a nedostane sa k nášmu programu. V konečnom dôsledku potom dostanete hlášku `""TLE - Prekročený časový limit""`.

### Ako flushovať?

Ak programujete v C/C++ a používate `printf()`, na to aby ste flushli jeho buffer, použite `fflush(stdout)`. Ak používate `cout`, buffer sa flushuje automaticky po vypísaní konca riadku pomocou `cout<<endl`. Ak programujete v Pythone, používajte `print(vystup, flush=True)`. Ak programujete v Pascale použite `flush(output)`.

## Hodnotenie

Sú 4 testovacie sady, každá za 2 body. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-------------- | ----:| -----:| --------:| ----------:| | Maximálne N | $15$ | $200$ | $3,000$ | $100,001$ |

Navyše v druhej sade platí, že počet platných tajných hesiel je malý, teda hesiel ktoré neporušujú obmedzenie na maximálnu veľkosť Masívneho hesla.

V hodnotení popisu sa bude samozrejme klásť veľký dôraz na časovú zložitosť, ale tento krát ešte väčší na počet položených otázok. Odhad počtu položených otázok a časovej zložitosti programu nezabudnite zdôvodniť a dokázať.

## Príklad

```iobox
>>>3 2
0
>>>JOP
2 1 2
>>>NOP
2 1 3
>>>NOP
2 2 3
>>>JOP
-1
2 2 3
```

*Pre lepšiu čitateľnosť sme pred riadky obsahujúce výstup testovača dopísali prompt `"">>>""`. Tento sa v skutočnosti nikde nezjaví: ani náš program ho nevypíše, ani vy ho nemáte vypisovať.*
","# Ako sa časy menia

### Skúšame všetky heslá

Priamočiare riešenie ktoré vyrieši prvú sadu je jednoducho vyskúšať všetky Masívne heslá. Tých je $2^N$, keďže každé číslo v Masívnom hesle buď je, alebo nie je, a teda za každé možné číslo sa počet možností zdvojnásobí.

Vyskúšať všetky možnosti môžeme napríklad jednoduchou rekurzívnou funkciou, v ktorej si udržiavame zoznam čísel na ktorý sa chceme opýtať (najprv prázdny), a číslo o ktorom sa práve rozhodujeme či ho do zoznamu pridáme, alebo nie. Zakaždým vyskúšame obe možnosti -- pridať toto číslo do zoznamu a rekurzívne rozhodnút nad ďalším, alebo ho nepridať a rekurzívne rozhodnúť nad ďalším. Keď už sme sa rozhodli nad všetkými $N$ číslami, opýtame sa testovača, a keď nám dá kladnú odpoveď, uložíme si tento zoznam ako kandidáta na Masívne heslo práve vtedy, keď pozostáva z viac čísel ako globálny zoznam v ktorom si udržiavame momentálnu odpoveď. Masívne heslo je totiž práve taká sada čísel na ktorú dostaneme JOP, ktorá má v sebe čísel najviac.

Po vyskúšaní všetkých odpovedí oznámime testovaču najdlhšie heslo na ktoré sme dostali JOP.

Hesiel musíme vyskúšať $O(2^N)$, pričom zakaždým musíme vypísať až $O(N)$ čísel v otázke. Časovú zložitosť teda máme $O(2^N)$. Pamätáme si pritom jeden globálny zoznam a jeden zoznam v rekurzií o dĺžke najviac $N$, a konštantne veľa premenných, čiže pamäťe zaberieme $O(N)$.

### Vylepšenie pre druhú sadu

Malou úpravou horeuvedeného riešenie vieme vyriešiť aj vstupy druhej sady, kde máme zaručené že počet platných Masívnych hesiel je malý. Ak teda v rekurzií nebudeme skúšať pridať do zoznamu ďaľšie čísla, ak už by presiahol dĺžku $M$, vyskúšame len týchto zopár platných hesiel a získame nejaké body navyše.

Časová zložitosť je vo všeobecnom pripade rovnaká, ale pre $M$ o dosť menšie ako $N$ bude tesnejší odhad na opýtané otázky $N$ nad $M$.

### Optimálne riešenie

Optimálnym riešením, ktoré sa dokonca programuje ľahšie ako už spomínaná rekurzia, je všimnúť si že sa môžeme opýtať na všetky heslá o dĺžke $1$. Odpoveď na otázku so samotným číslom $i$ nám potom priamo povie, či sa v Masívnom hesle $i$ nachádza. Keď sa teda spýtame na všetky čísla od $1$ po $N$, teda $N$ otázok a zároveň $N$ čísel, budeme o každom vedieť či sa v hesle nachádza alebo nie, a tie ktoré sme zistili že v ňom sú môžeme všetky vypísať.

Pamäťová zložitosť tohoto riešenia je $O(N)$, keďže si musíme o každom čísle pamätať či v hesle je, alebo nie (prípadne si robíme zoznam s číslami ktoré v ňom naozaj sú, ale aj tých môže byť až $N$). Časová zložitosť je $O(N)$, keďže sa pýtame $N$ otázok na konštantne veľa čísel, a nakoniec vypíšeme odpoveď v ktorej je tiež $O(N)$ čísel.

### Dôkaz správnosti

Teraz si poďme dokázať, že úlohu naozaj nevieme vyriešiť na menej otázok, alebo s lepšou časovou zložitosťou.

Čo keby bolo Masívne heslo práve jedno číslo? Potom ľubovoľná otázka s viac ako jedným číslom nám neposkytne žiadnu informáciu -- odpoveď je vždy NOP, a my nevieme či je v tejto otázke to správne číslo. Jediný spôsob ako to zistiť je naozaj sa spýtať na každé číslo zvlášť. Musíme sa teda opýtať aspoň $N$ otázok.

Keďže sa musíme opýtať aspoň $N$ otázok, a teda aspoň toľko čísel musíme vypísať, určite úlohu nevyriešime rýchlejšie ako na $O(N)$ operácií. Iný môžný dôkaz je to, že v heslo môžu byť všetky čísla, a bezohľadu na to ako to uhádneme, budeme ich musieť všetky vypísať.
",2
7dd3340b5ae824c2,ksp,"# Zúfalo málo miesta

Matúš má problém s nedostatkom miesta na svojom počítači. Jeho uši sú ochotné počúvať len najkvalitnejšiu hudbu v bezstratovom formáte, oči mu krvácajú, ak uzrú video v kvalite horšej od Blu-ray a so svojim fotoaparátom spravil obrovské množstvo fotiek vo vysokom rozlíšení, ktoré odmieta zmazať. Zábavný priemysel je neúprosný a chudák Matúš už nemá svoje dáta kam uložiť.

Nezostáva mu teda nič iné, len sa opäť raz ponoriť do divokých vôd e-shopov a rozšíriť pamäťovú kapacitu svojho počítača. Stiahol si preto celú ponuku diskov z najväčších internetových obchodov do jediného prehľadného súboru a teraz rozmýšľa, ktorý disk kúpiť.

Matúš je ekonomicky cítiaci človek a tak by rád zistil, ktorý z diskov má najlepší pomer ceny ku kapacite. Pomôžete mu v tom? Najlepšie bude, ak pri tom použijete len celé čísla, pretože ostatným Matúš veľmi neverí.

## Úloha

Na vstupe máte zoznam dostupných diskov v obchodoch. Vašou úlohou je nájsť disk, ktorý je najvýhodnejší -- teda taký, ktorý má najnižšiu jednotkovú cenu za gigabajt (teda spomínaný pomer ceny a kapacity). Ak je najlepších diskov viacero, vypíšte ľubovoľný z nich. Snažte sa vymyslieť taký algoritmus, ktorý pri výpočtoch používa len celé čísla. Najlepšie bude, ak nebudete vôbec nikde deliť.

## Formát vstupu

V prvom riadku vstupu je kladné číslo $n$ udávajúce počet diskov. V každom znasledujúcich $n$ riadkov sú celé čísla $c$ a $k$ udávajúce cenu (v eurách) a kapacitu (v gigabajtoch) daného disku.

## Formát výstupu

Vypíšte dve medzerami oddelené čísla -- cenu a kapacitu hociktorého najvýhodnejšieho disku v zozname. Nezabudnite za nimi vypísať koniec riadku.

## Hodnotenie

Za popis riešenia, ktoré používa aj iné ako celé čísla sa dajú získať najviac 3 body zo 7. Počet bodov za program závisí len od toho, ktoré vstupy váš program vyrieši správne. Vstupy sú rozdelené do sád podľa obtiažnosti, za každú sadu sa dá získať pol boda, ale celkový počet bodov za program sa zaokrúhľuje nadol.

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | |---| ---:| ---:| ---:| ---:| ---:| ---:| ---:| | Maximálny počet | $2$ | $3$ | $10$ | $1,000$ | $10,000$ | $100,000$ | | Maximálna cena | $100$ | $100$ | $1,000$ | $1,000$ | $10,000$ | $10,000$ | | Maximálna kapacita | $100$ | $100$ | $1,000$ | $1,000$ | $10,000$ | $10,000$ |

## Príklad

```vstup
5
500 100
750 130
1500 200
250 60
1000 147
```

```vystup
250 60
```
","# Zúfalo málo miesta

Základná myšlienka algoritmu pre hľadanie najlepšieho disku je veľmi jednoduchá. Budeme si pamätať najlepší disk, aký sme doteraz našli (na začiatku si zoberieme nejaký fiktívny, naozaj zlý disk), postupne prejdeme všetky disky a každý porovnáme s tým, ktorý bol doteraz najlepší. Vždy, keď je nejaký disk výhodnejší ako ten, čo vyhrával doteraz, stane sa najlepším on.

To, čo ostáva vymyslieť, je, ako porovnať dva disky, bez toho, aby sme spočítali samotnú cenu za gigabajt. Ak by sme mohli používať reálne čísla, cenu za gigabajt by sme porovnávali nasledovne:

$$\\frac{cena_aktualny}{kapacita_aktualny} \\gtreqqless \\frac{cena_najlepsi}{kapacita_najlepsi}$$

Delenie je však operácia, pri ktorej vznikajú desatinné čísla, preto sa chceme tejto operácii vyhnúť. Obe strany môžeme prenásobiť kapacitami diskov. Dostaneme:

$$cena_aktualny \\cdot kapacita_najlepsi \\gtreqqless cena_najlepsi \\cdot kapacita_aktualny$$

Výsledok tohto porovnania bude rovnaký, ako výsledok toho predošlého. Ak v pôvodnej nerovnosti platilo ""\<"", "">"" alebo ""="", bude rovnaký vzťah platiť aj v druhej nerovnosti. Avšak, pri použití tohto porovnania sa nemusíme obávať vzniku desatinných čísel, lebo nepoužívame delenie.

\\medskip

Aká je zložitosť tohto algoritmu? Keďže na vstupe máme $n$ diskov, ktoré musíme načítať, zložitosť bude aspoň $O(n)$. Pri porovnávaní diskov sa na každý pozrieme iba raz, keď ho porovnávame so zatiaľ najvýhodnejším. Každé porovnanie používa iba násobenie čísel s konštantnou zložitosťou a teda celková časová zložitosť bude $O(n)$. Pamäťová zložitosť je $O(1)$, pretože si stačí pamätať len doteraz najlepší disk. Na ostatné môžeme zabudnúť.

\\medskip

Niektorí z vás si zbytočne sťažovali život hľadaním najmenšieho spoločného násobku kapacít alebo cien diskov. To však algoritmu nepomôže a akurát ho to môže spomaliť, pretože hľadanie $nsn(a,b)$ trvá $O(\\log b)$.
",1
62981039b2073874,ksp,"# Párty

Kika pečie tortu. Narodeninová párty jej sestry je už čoskoro a ona ešte len dopiekla cesto, resp. veľa ciest, keďže jej sestra je ešte malá a chce vysokú tortu. Dokonca nie len tak nejakú, ale viacfarebnú. Kika teda napiekla niekoľko čokoládových a vanilkových ciest. Teraz stojí pred neľahkou úlohou a to poukladať ich na seba tak, aby to bolo dostatočne pestrofarebné a rozmanité, ale nie veľmi prehnané. Všimla si, že najvýraznejšie sú miesta, kde prechádza farba jedného cesta na druhú farbu. Zadefinovala si teda prechod ako miesto, kde sa stretávajú cestá dvoch rôznych farieb. Chcela by vidieť, ako vyzerá torta pre rôzne počty prechodov. Pomôžte jej.

## Úloha

Kika by chcela program, ktorý pre zadaný počet čokoládových ciest, vanilkových ciest a počet prechodov vytvorí jeden konkrétny vzhľad torty.

## Formát vstupu

Na jedinom riadku vstupu sú tri medzerou oddelené čísla $1\\leq c \\leq 500,000$, $1\\leq v \\leq 500,000$ a $1\\leq p \\leq 1,000,000$ pričom $c$ označuje počet čokoládových ciest, $v$ počet vanilkových ciest a $p$ počet prechodov, ktoré má mať výsledná torta.

## Formát výstupu

Na jediný riadok výstupu vypíšte jeden reťazec dĺžky $c+v$ znakov, pričom práve $c$ z nich bude `c` a $v$ z nich `v`. Okrem toho má platiť, že počet prechodov, teda dvojíc `cv` a `vc`, má byť dokopy presne $p$. Za týmto reťazcom má už nasledovať iba znak konca riadka. Je garantované, že riešenie **vždy existuje**. Pokiaľ existuje viac korektných riešení, vypíšte ľubovolné z nich.

## Príklad

```vstup
5 1 2
```

```vystup
cccvcc
```

*Výsledná torta má mať $5$ čokoládových ciest a $1$ vanilkové. Počet prechodov v tejto torte je $2$ a to z 3. vrsty na 4. vrstvu a tiež zo 4. na 5. Existujú, samozrejme, aj iné korektné výstupy ako `cvcccc` či `ccccvc`. Príkladom zlého riešenia je `vccccc`, pretože počet prechodov je iba $1$ a to z 1. na 2. vrstvu.*
","# Párty

Našou úlohou je z daného počtu znakov `c` a `v` poskladať reťazec znakov, ktorý bude mať určitý počet prechodov(miesto, kde sú vedľa seba dva rozdielne znaky). Kedže máme počty `c` a `v` zadané, tak našou úlohou je tieto znaky len vhodne preusporiadať.

## Riešenie hrubou silou

Kedže hľadáme iba preusporiadanie, ktoré spĺňa určité podmienky, môžeme samozrejme vyskúšať všetky preusporiadania. Pri každom preusporiadaní skontrolujeme, či má požadovaný počet prechodov. V prípade, že áno, ho vypíšeme a skončíme. Pokiaľ chceme skúšať všetky možnosti, zväčša sú na výber dve možné cesty.

Prvá, implementačne možno jednoduchšia, je založená na metóde `next_permutation`. Táto funkcia v `C++` vie vyrábať permutácie. Ako? Ako už názov napovedá, pokiaľ ju zavoláme na nejakú množinu prvkov vo vektore, vráti ďalšiu permutáciu. Ďalšiu v tomto prípade znamená v lexikografickom poradí. Ak teda túto funkciu zavoláme na ***vektor*** obsahujúci `0007`, funkcia vráti `true` a obsah sa zmení na `0070`. Pokiaľ však zavoláme túto funkciu na pole či vektor obsahujúci `7000`, čo je zjavne lexikograficky posledná permutácia, vráti nám `false` a nič nespraví. To znamená, že pokiaľ jej na začiatku dáme utriedený vektor a budeme túto funkciu volať, pokým nevráti `false`, vygeneruje nám každú permutáciu. Užitočný je fakt, že permutácie, ktoré sa líšia iba v preusporiadaní rovnakých prvkov nám vráti iba raz. Kód by mohol vyzerať takto: (Upozorňujeme na celkom neštandardnú konštrukciu `do-while`, ktorá sa často s `next_permutation` používa. Tá zapríčiní, že pred prvým volaním `next_permutation` sa ešte preverí úplne prvá permutácia.)

Aká je časová zložitosť tohto riešenia? Mohlo by sa zdať, že permutácií je $n!$. My však vieme, že niektoré permutácie sú totožné, pretože jednotlivé znaky `c` a `v` nerozlišujeme. Preto platí, že permutácií je $\\frac{(a+b)!}{a!b!}$. Vďaka použitu funkcie `next_permutation` platí, že časová zložitosť je totožná počtu permutácií, teda $O(\\frac{(a+b)!}{a!b!})$. Jedno volanie `next_permutation` síce môže trvať rádovo až $O(n)$, potom však bude nasledovať viac rýchlych volaní. Toto sa volá amortizovaná časová zložitosť. Pamäťová zložitosť je $O(a+b)$, pretože si musíme pamätať preverovaný reťazec dĺžky práve $a+b$.

\\medskip

Druhá cesta, ktorou sa môžeme vydať, sú triky s bitmi. Pokiaľ chcete, môžete túto časť vzorového riešenia preskočiť, ide skôr o pekný bonus. Mohli by sme povedať, že je zbytočné hrať sa s bitmi, pokiaľ máme na permutovanie funkciu, ktorá je jednoduchá a funkčná. Fakt ale je, že bitové operácie sú na počítači rýchle a tento spôsob sa často dá použiť na výrazné urýchlenie bruteforcu. Predstavme si, že ideme riešiť túto úlohu znova generovaním všetkých preusporiadaní. Ukázali sme si, že máme nejakých $n$ znakov. Čo je dôležité, tie sú iba dvoch typov, znak je teda buď `c`, alebo `v`. To je pri tejto technike veľmi dôležité. Veci, ktoré chceme odlíšiť, musia byť iba dvoch kategórií - to z dôvodu aby ich bolo možné reprezentovať ako `0` a `1`. Ako teraz prísť na všetky preusporiadania? Pokiaľ je vecí $n$, môžeme si túto situáciu predstaviť ako $n$-bitové číslo. Situáciu `10001` vieme teraz interpretovať ako `cvvvc`. Čo sme touto reprezentáciou získali? Odpoveď je, že teraz vieme jednoducho generovať všetky možnosti. Pokiaľ prejdeme čísla od $0$ po $2^n-1$, získame všetky možné $n$-tice `c` a `v` v každom možnom preusporiadaní, stačí sa nám teda len pozrieť na zápis týchto čísel v dvojkovej sústave. Vyskúšajme si to pre $n=3$, $c=2$, $v=1$. Pomocou troch bitov vieme získať čísla `000`, `001`, `010`, `011`, `100`, `101`, `110`, `111`. Iste, niektoré čísla neodpovedajú počtami bitov rozumnému počtu `c` a `v`. To nám však nevadí, pretože tento spôsob bude veľmi rýchly, nakoľko nám stačí iba inkrementovať jednú premennú. Otázka ešte je, ako z čísla $x$, vieme dostať hodnotu $i$-teho bitu... To už je miesto, kde prichádza k spomínanému triku. Na zistenie bitu nám stačí operácia `shift`, ktorá posunie bitovú reprezentáciu čísla doľava a nové miesto doplní nulou. Teda `1 << 2 = 4` pretože bitová reprezentácia 1 posunutá doľava a doplnená nulami nám dá `100`, čo je v desiatkovej sústave 4. Teraz už len potrebujeme operáciu `and`, ktorá vezme dve bitové reprezentácie čísel a urobí po bitoch logický `and`. Teda `121 and 55 = 1111001 and 0110111 = 0110001`. Teraz využijeme trik, ktorý spočíva v tom, že keď spravíme `x and (1<<i)`, dostaneme kladné číslo práve vtedy, keď $i$-ty bit $x$ sprava bol 1 a nulu ak bol 0. Pýtaním sa na jednotlivé bity vieme zistiť ich jednotlivé hodnoty. Napriek tomu, že to môže vyzerať ako zdĺhavý proces. Pre $n=7$, teda $2^n$ možností urobíme pri pýtaní sa na jednotlivé bity iba 14 operácií, ktoré sú pre procesor zo súdka najjednoduchších a najrýchlejších. Program by mohol vyzerať nejak takto:

Ak si nie ste istý, či ste porozmueli tomuto triku, môžete si ho vyskúšať napr. na úlohe [vojaci](https://testovac.ksp.sk/tasks/ls14-vojaci1/).

Aká je časová zložitosť tohto riešenia? Všetkých vyskúšaných možností je zjavne $2^{a+b}$. Overenie každého preusporadania trvá $O(a+b)$. Dokopy to teda celé trvá $O(2^{a+b}\\cdot (a+b))$.

Obidve doterajšie riešenia fungujú na princípe, že si najprv vyberieme nejaké poradie a potom ho kontrolujeme. Nebolo by lepšie nájsť spôsob, akým vieme určiť správne usporiadanie bez toho, aby sme ho museli overovať?

## Vzorové riešenie

Pokaždé budeme predpokladať, že počet `v` je väčší nanajvýš rovný počtu `c`. To samozrejme nemusí platiť. V tom prípade si na všetkých miestach, kde použijeme znak `c` môžeme predstaviť znak `v` a naopak. Predstavme si nachvíľu, že sme už všetky znaky `v` uložili, kedže na konci aj tak všetky skončia v koláči a všetky znaky `c` chceme nejako poukladať medzi nich. Na úlohu sa teraz môžeme teraz pozrieť ako na vkladanie `c` do niečoho tvaru `XvXvX...XvXvX`. Na každé miesto označené `X`(chlievik) môžeme dať nejaký, možno aj nulový počet `c`.

Prvá zaujímavá vec, ktorú by sme mohli zistiť je, aký najmenší a najväčší počet prechodov vieme dosiahnuť. Najmenší počet prechodov vieme zrejme dosiahnuť tak, že poukladáme jeden typ cesta za seba a potom ďalší. Dostaneme postupnosť tvaru `c...cv...v` s jedným prechodom. Rozoberme si ešte najväčší dosiahnuteľný počet prechodov. Uložením prvého `c` do chlievika, získame nejaký počet prechodov. Uložením ďalšieho `c` do chlievika, v ktorom sa už jedno `c` nachádza nové prechody nezískame. V krajných chlievikoch vložením získame 1 prechod. Uložením na ostatné `X` získame 2 prechody. Maximálny počet prechodov získame tak, že najskôr ukladáme `c` do vnútorných chlievikov a na koniec do dvoch krajných. Uvedomme si, že obidva krajné chlieviky nikdy nevyužijeme, nakoľko by to znamenalo, že počet `c` je väčší ako počet `v`(`cvcvc`). Rozlíšime teraz dva prípady. Pokiaľ je počet `c` rovný počtu `v` vieme získať $c+v-1$ prechodov s tým, že využijeme práve jeden okrajový chlievik. Pokiaľ je počet $c$ menší, vieme získať práve $2c$ prechodov. Kedže máme garantované, že riešenie existuje, vieme skonštruovať vzorové riešenie.

Najprv si označíme znak, ktorého je menej $m$ a toho, ktorého je viac $v$. To, čo namiesto nich budeme vypisovať na výstup teda záleží na jednotlivých počtoch cesta. Uvedomme si, že pokiaľ je počet prechodov nepárny, vieme, že musíme využiť jeden z dvoch krajných chlievikov. Všetky ostatné nám totiž dajú párny počet prechodov. Dohodneme sa, že pokiaľ takéto niečo nastane, vždy umiestnime cesto farby m do prvého chlievika. Riešenie je teraz celkom priamočiare. Postupne plníme chlieviky zľava doprava, pokiaľ dosiahneme želaný počet prechodov, všetky ostávajúce cestá farby m vložíme do posledného použitého chlievika.

Časová zložitosť tohto riešenia je $O(a+b)$, kedže pri každej našej operácii trvajúcej konštantný čas sa zníži počet `a` alebo `b`, ktoré zároveň aj vypisujeme. Pamäťová zložitosť je $O(1)$, keďže si výsledné poradie ciest nemusíme pamätať, lebo hneď vieme povedať, v akom poradí budú na torte.
",1
cc07ce4856d6bc32,ksp,"# Odstrihnuté útvary

Dano prišiel zo školy a už sa teší ako sa pôjde učiť na zajtrajšiu písomku z matematiky. Práve preberajú geometriu a tá ho veľmi baví. Zajtrajšia písomka bude z názvov rovinných a priestorových geometrických útvarov. Dano už vybehol po schodoch, otvoril dvere do izby... Ale nie! Jeho malý brat Jožko sedí uprostred jeho izby, v ruke drží nožničky a raduje sa. Dano sa však až tak neraduje. Jožko povystrihoval zo zošitu z matematiky všetky slovíčka! Ako sa teraz naučí na písomku z geometrie? Pomôžete Danovi zistiť, ktoré geometrické útvary sú rovinné a ktoré sú priestorové?

## Úloha

Napíšte program, ktorý pomôže Danovi roztriediť geometrické útvary na rovinné a priestorové.

## Formát vstupu

Na vstupe dostanete jedno slovo, názov geometrického útvaru. Názvy sú písané bez diakritiky malými písmenami.

## Formát výstupu

Vypíšte jeden riadok, ktorý obsahuje text `rovinny` ak je daný útvar rovinný alebo `priestorovy` ak je daný útvar priestorový.

## Hodnotenie

Z celkových 20 bodov budú 4 body udelené za stručnosť^\[V rámci možností zvoleného programovacieho jazyka. Teda program ktorý je v `C++`, ale nedá sa skrátiť môže dostať $4$ body, aj keď program ktorý je kratší a `Pythone` dostane iba $3$ body lebo sa skrátiť ešte dá.\]. Dĺžku svojho programu vypočítate ako počet znakov s ASCII hodnotou väčšou ako 32 vo vašom zdrojovom kóde (teda viditeľné znaky, nie medzery a konce riadkov). Body za stručnosť budú môcť získať iba plne funkčné programy (teda tie, ktoré na testovači dostanú 16 bodov a teda budú pracovať korektne).

Bonusový 1 bod bude udelený najkratšiemu programu z pomedzi všetkých jazykov. Takže autor (resp. v prípade rovnosti autori) najkratších z programov má šancu mať za túto úlohu 21 bodov. Všetky tieto body za stručnosť budú udelené až po uplynutí termínu na odovzdávanie riešení.

## Príklad

```vstup
sestuholnik
```

```vystup
rovinny
```

```vstup
stvorsten
```

```vystup
priestorovy
```
","# Odstrihnuté útvary

Ako ste si mohli všimnúť, v tejto úlohe boli viditeľné vstupy a výstupy. Teda na správne riešenie za 16 bodov stačilo zistiť všetky priestorové a všetky rovinné útvary, ktoré boli na vstupe a následne napísať program, ktorý si ich všetky zapamätá.

Toto riešenie sa dá jednooducho skrátiť ak si všimneme pár zákonitostí. Až na pár výnimiek sa rovinné útvary končia príponou `""uholnik""` a priestorové sa končia `""sten""`. Programu už teda stačí zapamätať si len niekoľko výnimiek. V prvej sade neboli žiadne výnimky a teda na 4 body za prvú sadu stačilo rozoznať útvary končiace na `""uholnik""` a útvary končiace na `""sten""`.

Aby sme program ešte skrátili bude najlepšie ak sa pohráme len s písmenkami. Môžeme si všimnúť, že všetky útvary končiace na `""n""` okrem `""oktagon""` a `""hexagon""` sú priestorové. Žiadny rovinný útvar ale nemá piate písmeno `""g""`. Vieme teda použiť, že všetky končiace na `""n""`, ktoré nemajú piate písmeno `""g""` sú priestorové. Všetky útvary končiace na písmeno `""k""` sú rovinné. Teraz nám stačí sa pozrieť len na výnimky. Z výnimiek, `""gula""` a všetky slová začínajúce na `""k""`, okrem slova `""kruznica""` sú priestorové. Zvyšné sú rovinné.

Niektorí z vás našli ďalšie pravidlá, ktoré sa dajú využiť. Stačí sa napríklad pozrieť iba na tretie a piate písmenko odzadu.

Veľmi krátke riešenie, sa dalo získať aj pomocou regulárnych výrazov, ktorými vieme na pomerne málo znakov popísať text, ktorý potom možeme vo vstupnom reťazci vyhľadávať. Napríklad regulárny výraz `sten$|uholnik|..ica` popisuje výraz, ktorý končí (symbol `$`) na `sten` alebo (symbol `|`) obsahuje `uholnik` alebo obsahuje text s ľubovolnými dvoma písmenami (symbol `.`) nasledujúc textom `ica`. _(Knižnice pre regulárne výrazy obsahuje každý slušný jazyk, vrátane Pythonu a C++11 a dokážu toho omnoho viacej. Podrobný popis regulárnych výrazov nájdete na internete)_.

Ďalšie nápady už necháme na vás.
",2
d2d63bab26c45c13,ksp,"# Obytná štvrť

Kráľovstvo Slnka a Paliem sa rozhodlo, že postaví mesto uprostred púšte. Obytná štvrť bude pozostávať z $n\\times n$ domov usporiadaných do štvorca. Každá budova bude mať nejaký počet podlaží a všetky podlažia budú rovnako vysoké.

Na prízemí každého domu bude bývať služobníctvo a na poschodiach vyššia šľachta\\footnote{čím vyššia šľachta, tým vyššie poschodie}. Interiér budovy je však pre vyššiu šľachtu nepostačujúci, stiesnené priestory veru nie sú nič pre nich. Aby si mohli užívať čerstvý vzduch, chceli by mať šľachtici možnosť prejsť sa po streche vedľajšej budovy. Na to však musí vedľa stáť budova so strechou v správnej výške. Napríklad vedľa každej štvorpodlažnej budovy musí byť jednopodlažná, dvojpodlažná aj trojpodlažná budova.

Kráľ by chcel, aby celkový počet podlaží v obytnej štvrti bol čo najväčší a preto vyhlásil súťaž o najlepší územný plán.

## Úloha

Vašou úlohou je pre dané $n$ vytvoriť plán mesta. Plán mesta je matica $n\\times n$ čísel predstavujúcich výšky budov. Každé číslo musí susediť so všetkými menšími kladnými celými číslami, ako je ono samé. Keďže číslo má najviac štyroch susedov, tak najväčšie možné číslo v matici je 5.

Počet bodov, ktoré za úlohu dostanete bude závisieť od celkového súčtu čísel v matici.

## Odovzdávanie príkladu

V tejto úlohe namiesto toho, aby ste odovzdali program, odovzdávate hotové plány mesta. Zaujímajú nás plány mesta pre nasledovné $n$: 3, 5, 8, 13, 21, 34, 55, 89 a 144.

Pre každé takéto $n$ vyrobte jeden súbor, ktorý má presne $n$ riadkov a v každom riadku presne $n$ cifier (za ktorými nasleduje znak konca riadku, čiže `\n`). Cifry vyjadrujú počet podlaží veže. Tento súbor nazvite `n.txt`, teda napríklad `13.txt` pre $n=13$. Následne tieto súbory všetky zabaľte do jedného zipu a odovzdajte.

Okrem toho odovzdajte stručný popis toho, ako ste úlohu riešili.

## Hodnotenie

Každý z 9 odovzdaných plánov sa hodnotí samostatne a za každý môžete získať $0$ až $\\frac{4}{3}$ bodu. Keď váš odovzdaný plán má celkovo o $d$ podlaží menej ako náš, dostanete ${4}\\cdot{3^{-1-d/n}}$ bodov.

Napríklad, ak pre $n=3$ odovzdáte plán s $20$ podlažiami, dostanete plný počet, približne $1.333$ bodu. Ak odovzdáte plán s $17$ podlažiami, dostanete $0.444$ bodu a za plán s $19$ podlažiami približne $0.924$ bodu.

Za popis môžete dostať 0 až 3 body. Nemusíte písať dlhé eseje, stačí stručne popísať, ako ste úlohu riešili, alebo ako by ste ju chceli riešiť.

## Príklady

```vstup
2
```

```vystup
11
23
```

```vstup
6
```

```vystup
112111
234521
111321
112311
121311
111211
```

_Prvý ukážkový vstup má optimálny počet podlaží, druhý sa dá ešte dosť zlepšiť._
","# Obytná štvrť

Úloha sa dala riešiť nasledujúcimi troma nástrojmi (prípadne kombináciou týchto nástrojov). Počty bodov, ktoré sa dali získať, sú len odhadované a dosť záviseli od šikovnosti a množstva času venovaného tejto úlohe.

1. Použitím ceruzky a papiera sa dalo získať 7 až 9 bodov z 12.
1. Využitím počítača na prechádzanie všetkých možností a automatizovanie manuálnej roboty sa dalo získať 9 až 11 bodov.
1. Využitím počítača a programov špecializovaných na rýchle riešenie optimalizačných úloh, sa dalo získať 10 až 12 bodov.

Bez ohľadu na to, ktorý nástroj použijeme, ak chceme získať veľa bodov, tak postup riešenia bude vyzerať približne takto:

1. Malé plány (s rozmermi do 8) vyriešime samostatne.
1. Následne vymyslíme čo najlepší spôsob, ako vyrobiť nekonečne veľký plán mesta. Teda odmyslíme si okraje a skúsime nájsť nejaký plán -- nejakú ""kachličku"" -- ktorú môžeme ľubovoľne veľa krát ukladať veľa seba a pod seba, a stále bude spĺňať podmienky zo zadania. Budeme sa snažiť dosiahnuť čo najvyššiu priemernú výšku kachličky.
1. Veľké plány mesta vyrobíme tak, že naukladáme vedľa seba niekoľko kópií kachličiek a pridáme okraje plánu.

## Malé plány

Takto vyzerajú optimálne riešenia pre $n \\in {3,5,8}$ aj so súčtom výšok budov.

```
20          170
241         12413231
132         14324152
241         25135241
            43251432
63          11342514
23131       24515323
14523       13234131
42314       24142142
31452
21231
```

Prvé dva sa dajú nájsť ručne alebo inteligentným skúšaním všetkých možností na počítači. Pre $n=8$ vieme bezbolestne ručne/pomocou počítača nájsť riešenie s počtom poschodí medzi $160$ a $166$, ale na optimum treba trocha väčšie kladivo.

Väčšie kladivo môže byť napríklad nejaký heuristický algoritmus -- to je taký, ktorý síce nemusí vždy dosiahnuť najlepší výsledok, ale väčšinou sa mu to podarí a navyše je veľmi rýchly. Ako príklady uvedieme simulované žíhanie, genetické programovanie alebo hillclimbing, viac si o nich môžete nájsť na internete, ale konkrétne v tejto úlohe pravdepodobne nebudú veľmi úspešné.

Lepšie je použiť ILP, Integer Linear Programing, čiže celočíselné lineárne programovanie, o ktorom si podrobnejšie môžete prečítať v zadaní 5. príkladu 4. série, 31. ročníka ([old.ksp.sk/wiki/uploads/Zadania/ps314.pdf](http://old.ksp.sk/wiki/uploads/Zadania/ps314.pdf)). Pointa je v tom, že úlohu zapíšeme ako skupinu podmienok a výraz, čo chceme maximalizovať, v špecifickom formáte. Táto skupina podmienok a výraz sa nazýva celočíselný lineárny program. Potom na internete dokážeme nájsť nástroje, ktoré vedia hľadať optimálne riešenia pre takéto programy. Ako dobré cvičenie si môžete naštudovať ILP z vyššie uvedeného odkazu alebo inú heuristickú metódu a pomocou nej vytvoriť čo najlepší plán mesta. V tomto vzorovom riešení sa však uspokojíme s 10 bodmi za program a ďalej sa týmto sofistikovaným nástrojom nebudeme venovať.

## Inteligentné skúšanie všetkých možností.

Zlé skúšanie možností je nasledovné: Pre každé políčko máme $5$ možností aká budova tam môže byť, takže vygenerujeme všetkých $5^{n^2}$ rôznych miest. Overíme, ktoré z miest vyhovujú podmienkam zo zadania, a vyberieme z nich najlepšie (podľa počtu poschodí).

Riešenie by sa najjednoduchšie implementovalo tak, že plochu budeme generovať po jednotlivých políčkach rekurzívne. Teda si spravíme funkciu `vygeneruj(x,y)`, ktorá vyskúša všetkých $5$ možností čo môže byť na políčku `x,y` a pre každú možnosť zavolá `vygeneruj(nasledujúce políčko po x,y)`. Nech `x` je číslo riadku a `y` číslo stĺpca. Riadky aj stĺpce číslujeme od `1` po `n`. Keď chceme políčka prechádzať po riadkoch, tak nasledujúce políčko po `x,y` má súradnice `x + y/n, y mod n + 1`. Keď sa takto dostaneme na riadok `n+1`, tak sme vygenerovali celú plochu a ostáva nám overiť, či vyhovuje zadaniu. Keďže pre každé políčko sme skúsili všetky možné výšky, nestane sa nám, že by sme na nejaký plán zabudli.

```
vygeneruj(x, y):
    pokiaľ y>n:
        pokiaľ Plocha vyhovuje zadaniu a má zatiaľ najväčší počet poschodí:
            aktualizuj najlepšie riešenie
        koniec
    pre i od 1 do 5:
        Plocha[x][y] = i
        vygeneruj(x + y/n, y%n + 1)

vygeneruj(1,1)
vypíš najlepšie riešenie
```

Prečo je toto zlé? Lebo je to pomalé a veľa roboty sa robí zbytočne. Už pre $n = 4$ by výpočet trval asi hodinu. A pre $n = 5$ by sme sa nedočkali výsledku ani do konca roka. Skúsime to teda zlepšiť.

Pri inteligentnom skúšaní všetkých možností musíme priebežne kontrolovať, či vôbec má zmysel pokračovať ďalej. Pokiaľ napríklad prvé dve budovy budú $5$ a $5$, tak už nemá zmysel skúšať, ako by vyzeral zvyšok mesta, pretože určite nebude vyhovovať zadaniu.

```
vygeneruj(x, y):
    pokiaľ y>n:
        skontroluj Plochu a prípadne aktualizuj najlepšie riešenie
        koniec
    skontroluj Plochu, či ma zmysel pokračovať
    ak nemá zmysel pokračovať:
        koniec
    pre i od 1 do 5:
        Plocha[x][y] = i
        vygeneruj(x + y/n, y%n + 1)
        Plocha[x][y] = 0
```

Čím lepšie naprogramujeme funkciu na kontrolu, tým menej možností bude program skúšať. Jednoduchá kontrola, ktorá veľmi pomôže, je prejsť všetky nenulové políčka v poli `Plocha` a pre každé z nich overiť, či by sa dali doplniť okolité nuly tak, aby malo políčko okolo seba všetky menšie čísla (tak ako to káže zadanie). Celá kontrola sa dá implementovať v čase $O(n^2)$. Konkrétnu implementáciu si môžete pozrieť na spodku tohoto vzorového riešenia.

Trocha času sa dá ušetriť aj zvolením si vhodného programovacieho jazyka, napríklad C++ je asi desaťnásobne rýchlejšie než Python.

## Nekonečne veľký plán mesta

Chceli by sme mať čo najvyššie budovy, ale celé nám to kazia okraje, lebo budovy na okraji majú málo susedov. Keby sme povedali, že budovy úplne vľavo susedia s tými úplne v pravo a budovy v prvom riadku susedia s budovami v spodnom riadku, mohli by sme dosahovať plány s oveľa lepším skóre.

Napríklad plán

```
1323
2414
1525
```

má priemernú výšku budovy $2.75$. (Pre porovnanie, optimálny plán pre $5\\times 5$ podľa pôvodných pravidiel, mal priemernú výšku $2.52$). Keď sa potrápime trocha viac, nájdeme optimálny plán s rozmermi $5\\times 5$ (s tým, že protiľahlé okraje susedia):

```
12345
45123
23451
51234
34512
```

Tento plán má priemernú výšku $3$. Ukladaním takejto ""kachličky"" ľubovoľne veľakrát pod seba a vedľa seba vieme vytvoriť nekonečnú plochu s priemernou výškou $3$. Aby sme nemuseli hľadať ďalšie plány, ukážeme si, že lepšia priemerná výška sa nedá dosiahnuť.

## Horné ohraničenie

Každá budova, ktorá nemá $1$ podlažie, musí susediť s jednopodlažnou budovou. Jedna jednopodlažná budova môže susediť s najviac $4$ ďalšími budovami, inými slovami, jedna jednopodlažná budova dovolí najviac štyrom budovám mať viac poschodí. Z toho vyplýva, že **aspoň jedna pätina všetkých budov je jednopodlažná**.

Podobne dvojpodlažná budova môže mať okolo seba najviac $3$ vyššie budovy (lebo musí mať vedľa aspoň jednu jednopodlažnú). Preto aspoň **štvrtina z budov, ktoré nie sú jednopodlažné, sú dvojpodlažné**. Analogicky ukážeme, že **aspoň tretina zo zvyšných budov sú trojpodlažné** a **aspoň polovica zo zvyšku je štvorpodlažná**.

Jednoduchou matematikou môžeme spočítať, že priemerná výška budov potom nemôže byť viac ako tri.

## Skladanie veľkých konečných plôch

Po tom, ako sme našli ""kachličku"" $5\\times 5$, môžeme nadobudnúť presvedčenie, že najlepší plán mesta pre veľké $n$ bude vyzerať zhruba takto:

```
????????????????...?
?123451234512345   ?
?451234512345123   ?
?234512345123451...?
?512345123451234   ?
?345123451234512   ?
.       .          .
.       .          .
.       .          .
????????????????...?
```

Avšak rýchlo zistíme, že v druhom stĺpci a piatom riadku nemôže byť päťposchodová budova, pretože v prvom stĺpci by musela byť štvorka, ktorá by nevedela mať okolo seba $1$, $2$ aj $3$. Preto skutočný plán mesta by vyzeral takto (rozdiel je len v druhom stĺpci):

```
????????????????...?
?123451234512345   ?
?451234512345123   ?
?234512345123451...?
?412345123451234   ?
?345123451234512   ?
.       .          .
.       .          .
.       .          .
????????????????...?
```

Alebo sa nám možno oplatí nezačať číslom $1$ ale spraviť druhý riadok `234512345...`, `345123451...`, `451234512...` či `512345123...`

A program by už len mal uhádnuť, aké výšky budov sú schované pod otáznikmi. Pre veľké $n$ to môže byť stále veľa možností, tak sa môžme obmedziť len na okraje, ktoré sa periodicky opakujú. Teda $10$-te číslo v prvom riadku musí byť rovnaké ako $5$-te číslo v prvom riadku.

Za týchto podmienok je možností dostatočne málo na to, aby náš program, ktorý skúša všetky možnosti, bežal len chvíľu.

Tento program vstupy s $n$ do $5$ rieši optimálne, pri $n = 8$ a $n = 13$ sa mu veľmi nedarí, ale pri vyšších $n$ je veľmi blízky najlepšiemu vedúcovskemu riešeniu. (V najhoršom prípade dosahuje o $3$ poschodia menej ako najlepšie riešenie.) Nie je úplne najrýchlejší takže na výsledok si budeme musieť počkať asi pol hodinu.

No a ako dostať viac bodov? Naše riešenia skúšalo doplniť len okraj veľkosti jedna a ten okraj navyše musel byť periodický. Keď skúsime okraj veľkosti dva alebo tri a dovolíme robiť aj neperiodické okraje, dosiahneme lepšie výsledky. Aby sme sa dočkali výsledku do konca série, musíme použiť nejaké z väčších kladív, ktoré sme spomínali v prvej časti vzoráku.

My sme použili ILP, pre $n$ do $13$ sa stíhal okraj veľkosti $3$, pre vyššie $n$ okraj veľkosti $2$. Počty poschodí najlepších plánov boli postupne $7$, $20$, $63$, $170$, $467$, $1249$, $3342$, $8863$, $23416$ a $61640$.
",6
9d822daf1d619159,ksp,"#Okázalá svadba

Usáma a Maru sa rozhodli, že spravia tú najokázalejšiu svadbu, akú kedy Trojsten videl. Rozhodli sa preto, že každý hosť dostane ručne šitého motýlika alebo mašľu do vlasov. Výhodou je, že pri objednávaní to netreba rozlišovať, lebo je to vlastne to isté, len inak nazvané. V krajčírskej firme J&P^[Jano a podšívky.] si teda objednali zákazku na $n$ motýlikov.

Jano je veľký motýlikový umelec a na tejto zákazke sa vybláznil, preto je každý motýlik iný a originálny. Ako však vieme, nie každý originálny nápad dopadne úspešne a teda nie všetky motýliky vyzerajú rovnako dobre. Každému motýliku preto Usáma a Maru priradili číslo zodpovedajúce jeho kráse.

Situácia sa však skomplikovala. Nie sú si totiž istí, koľko pozvaných hostí naozaj príde. Chceli sa preto s Janom dohodnúť, že keď zistia počet hostí $k$, ktorí prídu na svadbu, zoberú si $k$ najkrajších motýlikov. To im však Jano zakázal, zoradil motýliky podľa poradia ušitia a povedal, že si budú môcť vybrať iba súvislý úsek dĺžky $k$.

V tom okamihu sa rozpútala hádka^[V skutočnosti to tak nebolo. Maru rozhodla, ktorý úsek zoberú a Usáma nemal na výber. Takýto scenár by však nevytvoril zaujímavé zadanie.]. Usáma chcel, ako správny egoista, získať najkrajší motýlik pre seba a chcel preto úsek s čo najväčším maximom krásy. Maru je ale štedrá osoba a páči sa jej rozmanitosť, preto chcela maximalizovať bitový OR krás všetkých motýlikov, ktoré budú vo vybranom úseku.

Nakoniec sa dohodli sa dohodli na kompromise^[Čo je v manželstve veľmi dôležité.] a rozhodli sa maximalizovať súčet maximálneho prvku a bitového ORu všetkých krás v úseku. Stále však nevedia, koľko hostí príde na svadbu, preto by chceli vedieť dopredu, ktorý úsek vybrať pre všetky možné $k$.

## Úloha

Na vstupe dostanete postupnosť kladných celých čísiel dĺžky $n$. Vašou úlohou bude pre každé $k$ od $1$ po $n$ nájsť taký súvislý úsek dĺžky $k$ v tejto postupnosti, že súčet maxima v tomto úseku a bitového ORu prvkov tohoto úseku je najväčší možný.

## Formát vstupu

Na prvom riadku sa nachádza číslo $n$ ($1 \\leq n \\leq 100,000$), ktoré označuje počet vyrobených motýlikov. Nasleduje $n$ čísel, ktoré predstavujú krásy jednotlivých motýlikov v poradí, v akom boli vytvorené. Krásy motýlikov sú kladné celé čísla neprevyššujúce $10^9$.

## Formát výstupu

Vypíšte $n$ čísel na samostatné riadky, kde $k$-te z nich predstavuje najväčší možný súčet požadovaných vlastností pre úseky dĺžky $k$.

## Príklad

```vstup
3
1 0 2
```

```vystup
4
4
5
```
","# Okázalá svadba

Osobne sa musím priznať, že sa mi táto úloha veľmi páčila. Jej riešenie je totiž také skladačkové, treba spraviť zopár správnych aj nesprávnych pozorovaní, ale výsledok je o to krajší. A ako ste mali začať? No predsa tak, že ste naprogramovali jednoduché $n^2$ riešenie, ktoré postupne skúšalo všetky možné úseky a zisťovalo ich maximum a bitový or. A aj keď to vyzerá ako riešenie so zložitosťou $O(n^3)$, určite ho dokážete ľahko zredukovať, keď si uvedomíte, že z výsledku pre jeden úsek viete jednoducho vypočítať výsledok pre úsek o jedno dlhší.

Samozrejme, takéto jednoduché riešenie nie je až také zaujímavé. Potrebujeme vymyslieť niečo rádovo rýchlejšie. Dobrým postupom je hľadať, čoho môže byť v zadaní málo, a poprípade si fixovať nejaké prvky napevno. Začnime druhým prípadom, skúsime si dopredu určiť maximum úseku. Prečo práve maximum? Lebo to sa aj naozaj nachádza v poli. Pre ľubovoľný úsek bude jeho maximum len jeden z prvkov poľa, zatiaľčo bitový or môže byť takmer ľubovoľné číslo.

Vyberieme si teda nejaký prvok na $m$-tej pozícii a budeme sa pozerať na všetky úseky, ktoré ho obsahujú. Naviac budeme predpokladať, že tento prvok je maximum pre všetky tieto úseky. Samozrejme, niečo také platí iba pre najväčší prvok poľa. Ak si ako náš prvok zvolíme inú hodnotu, pravdepodobne niektoré úseky budú obsahovať väčšie číslo. To budeme ale potichu ignorovať a budeme sa tváriť, že nech je na $m$-tej pozícii hocijaké číslo, je maximom pre všetky úseky, ktoré ho obsahujú. Naším cieľom bude pre tieto úseky rátať or čísel v nich a pomocou toho zisťovať výslednú hodnotu.

A hoci naše vybrané číslo nemusí byť skutočné maximum každého podúseku, hodnota, ktorú vďaka tomu vypočítame, nebude väčšia ako naozajstné maximum súčtu maxima a bitového or-u v tomto úseku. A tú správnu hodnotu zarátame, keď si ako $m$-tý prvok zvolíme to správne číslo^[Možno sa pokúste trochu rozdýchať to, čo som sa tu snažil naznačiť a uvedomte si, že naozaj je to v pohode.].

Maximum máme určené, pozerajme sa teraz na bitový or. Ten má tú peknú vlastnosť, že toto číslo neklesá, keď sa k úseku pridávajú ďalšie prvky, pretože sa môže len zväčšiť priorovaním nového bitu, ktorý sa v ňom dovtedy nevyskytoval.

Zoberme si napríklad všetky úseky, kde je $m$-tý prvok najľavším v tomto úseku a pozrime sa na bitové ory ich čísel. Hodnota tohoto oru sa zmení vždy len vtedy, keď sa pridá prvok, ktorý obsahuje nejaký ""nový"" bit, taký, ktorý doposiaľ nebol v našom ore. Ale toto sa môže stať najviac $31$ krát, lebo práve toľko bitov má najväčšie možné číslo $10^9$.

Je len $31$ zaujímavých úsekov, čo sú také úseky, kde sa zmení hodnota oru. To platilo pre úseky zľava zarovnané na $m$-tý prvok. Ale to isté sa dá povedať aj opačným smerom a dokopy nám to dá najviac $31^2$ zaujímavých úsekov, čo dostaneme ako všetky možnosti začiatkov a koncov zarovnaných zaujímavých úsekov. A to je pomerne málo.

Otázka ale je, že čo s úsekmi, ktoré nie sú zaujímavé. A čo s ostatnými dĺžkami postupností? Všimnime si, že naše zaujímavé úseky sú naviac najkratšie možné, lebo zaujímavé sú práve tým, že sa niečo zmenilo. A druhá dôležitá vlastnosť je, že ak máme úsek dĺžky $d$ so súčtom maxima a oru rovným $l$, tak všetky úseky dĺžky viac ako $d$ majú súčet maxima a oru rovný aspoň $l$. Prečo? Lebo zoberieme ten úsek dĺžky $d$, pridáme nejaké prvky a je jasné, že ani maximum ani or prvkov sa nám zmenšiť nemohol.

Zhrnieme si teraz riešenie. Pre každý prvok $m$ poľa vyrátame dve pomocné polia (v programe označené ako $Ml$ a $Mr$). Tie hovoria o každom možnom bite, kde naľavo (poprípade napravo) sa nachádza najbližšie číslo obsahujúce tento bit. Pričom prvok je sám sebe naľavo (aj napravo). Toto vieme spraviť jedným prechodom. Tieto dve polia si utriedime podľa vzdialenosti. Každá dvojica, kde jeden prvok je zľava a druhý sprava, nám určuje jeden zaujímavý úsek obsahujúci daný prvok $m$. O prvku $m$ predpokladáme, že je maximom svojich zaujímavých úsekov, a or čísel zaujímavého úseku vyrátame ľahko, lebo presne vieme, ktoré bity boli pridané dovtedy (predchádzajúce prvky v $Ml$ a $Mr$). Do poľa výsledkov si preto zaznačíme, že úsek tejto dĺžky má aspoň takýto súčet maxima a oru, pričom si pamätáme zatiaľ videné maximum.

Niektoré prvky poľa výsledkov sú nevyplnené, lebo neexistuje zaujímavý úsek danej dĺžky. V takom prípade bude odpoveď maximum súčtu pre nejaký menší zaujímavý úsek. Môže sa dokonca stať, že máme dlhý zaujímavý úsek, ktorý má menší súčet ako nejaký iný menší zaujímavý úsek. Aby sme toto všetko napravili, toto pole výsledkov upravíme tak, že na $i$-tom políčku je maximum z úsekov dlhých najviac $i$. Toto pole určuje výsledok.

Čo sa týka zložitosti, označme si $M$ maximálny prvok postupnosti zo vstupu. Pamäťová zložitosť je potom $O(n\\log M)$, lebo pre každý prvok si pamätáme informáciu o $\\log M$ bitoch. A časová zložiťosť je $O(n \\log^2 M)$, lebo musíme vyskúšať všetky zaujímavé úseky.
",10
8d03174f13848e13,ksp,"# Obnova bytového parku

Nie je tomu tak dávno, čo sa lokálny magnát (volajme ho M) rozhodol odkúpiť od mesta nejaké paneláky a zrekonštruovať byty v nich. Samozrejme, najlepší spôsob, ako s takýmto biznisom začať, je podať si grant. Ako to už však chodí, na získanie grantu potrebujete splniť absurdné požiadavky. Ani tentoraz nedošlo k výnimke a magnát M sa musel popasovať hneď s niekoľkými:

- Počet kúpených panelákov musí byť práve $k$.

- Paneláky sa musia nachádzať v štvrti, kde sú budovy usporiadané do štvorčekovej siete, teda všetky majú rovnako veľký, štvorcový pôdorys.

- Všetky kúpené paneláky spolu musia susediť stenami.

- Čím je stavba nižšia, tým viac je ekologická a teda vhodnejšie vyvažuje charakter mesta.

- Mačka musí mať štyri nohy a nestrká sa do mikrovlnky.

Aj magnátovi M chvíľu trvalo, kým pochopil, o čo sa tu jedná. Zistil, že úradníci si od neho vyúčtujú ekologický poplatok, na základe toho, akú najvyššiu budovu bude rekonštruovať.

Jeho cieľom je teda splniť všetky podmienky a zároveň spraviť čo najvýhodnejší biznis -- vybrať si takých $k$ bytoviek, že vytvoria súvislú oblasť a najvyššia budova medzi nimi je čo najnižšia (medzi všetkými takýmito oblasťami).

## Úloha

Dostanete číslo $k$ a mriežku čísel s $r$ riadkami a $s$ stĺpcami.

Hovoríme, že oblasť mriežky je súvislá, ak sa vieme z každého jej políčka dostať na každé iné políčko oblasti len prechodmi smermi hore, dole, vpravo, vľavo, bez opustenia danej oblasti.

Nájdite takú súvislú oblasť, ktorá obsahuje $k$ čísel a najväčšie číslo, ktoré obsahuje, je najmenšie možné.

## Formát vstupu

Na prvom riadku sa nachádza číslo $k$. Na druhom riadku sú medzerou oddelené čísla $r, s$. Pre všetky vstupy platí $1 \\le k \\le r \\cdot s \\le 10^6$.

Na každom z nasledujúcich $r$ riadkov sa nachádza $s$ medzerou oddelených kladných celých čísel, ktoré udávajú výšky jednotlivých budov v meste. Výška žiadnej budovy nepresiahne $10^9$.

## Formát výstupu

Na prvý riadok výstupu vypíšte celé číslo určujúce najmenšiu možnú výšku najvyššej odkúpenej budovy. Následne vypíšte $r$ riadkov a na každom z nich $s$ znakov. Každý znak musí byť bodka (`"".""`), alebo hviezdička (`""*""`), pričom hviezdičkami označené políčka musia vyznačovať ľubovoľné zo správnych riešení.

## Príklady

```vstup
6
4 3
2 3 4
2 3 2
5 1 1
3 2 1
```

```vystup
3
...
..*
.**
***
```

```vstup
4
3 3
1 1 2
1 2 1
2 1 1
```

```vystup
2
***
.*.
...
```
","# Obnova bytového parku

V úlohe hľadáme dva výsledky, ktoré aj vypisujeme -- súvislú oblasť veľkosti $k$ a najmenšiu možnú výšku najvyššej budovy v takejto oblasti -- označme ju $H$. Ak ale poznáme jeden z týchto dvoch výsledkov, tak ten druhý sa k nemu dá dopočítať celkom ľahko.

Ak poznáme ""ideálnu výšku"", stačí postupne skúšať prehľadávať mesto do šírky alebo do hĺbky^\[Ak sú vám tieto pojmy cudzie, na internete nájdete množstvo materiálov na témy *breadth-first-search* a *depth-first-search*. V češtine/slovenčine si môžete pozrieť napríklad [časť kuchárky českého KSP](https://ksp.mff.cuni.cz/tasks/25/cook4.html) alebo [poznámky k prednáške zo sústredenia Prask (od str. 20)](https://people.ksp.sk/~baklazan/UFO-Prask_2016_jar/zbornik_Prask.pdf).\]. Zo všetkých (ešte nenavštívených) políčok postupne spúšťame prehľadávania, kým nenájdeme oblasť veľkosti aspoň $k$. Prehľadávanie navyše navštevuje len také susedné políčka, ktorých budovy sú nanajvýš tak vysoké ako ""ideálna výška"" $H$.

Naopak, keď poznáme tú správnu oblasť, poľahky vyrátame, aká je v nej tá najväčšia výška. Stačí prejsť všetky políčka danej oblasti a zapamätať si výšku toho najvyššieho z nich.

Toto umožňuje dva prístupy k príkladu: prvý, v ktorom sa snažíme nájsť tú ""ideálnu"" výšku a druhý, kedy sa pokúšame skonštruovať nejakú správnu oblasť. V tomto vzoráku sa budeme zaoberať tým prvým prístupom a na konci si len krátko spomenieme, ako by sa dalo na riešenie prísť z druhej strany.

## Jednoduché hľadanie najmenšej výšky

Postupne budeme skúšať pre všetky možné výšky $h$ (od najmenšej po najväčšiu) nasledovný postup:

1. Vieme nájsť oblasť veľkosti aspoň $k$, kde je najvyššia budova vysoká nanajvýš $h$? (Toto vieme zistiť práve spomínanými prehľadávaniami.)

1. Ak nie, skúsme to isté, pre výšku o jedna väčšiu.

Takýmto spôsobom po chvíli prídeme k tej najmenšej vyhovujúcej výške -- k výške $H$. Na záver len vypíšeme jej prislúchajúcu oblasť a máme vyhrané.

Akú má toto riešenie časovú zložitosť? Robíme prehľadávanie na mriežke rozmerov $r \\times s$ pre výšky, až kým nenájdeme tú správnu. V najhoršom prípade bude riešenie potrebovať $O(r \\cdot s \\cdot h\_{max})$ operácií, čo je podľa zadania najviac $10^6 \\cdot 10^9 = 10^{15}$. Je to síce oveľa viac, než si v bežnom programe môžeme dovoliť, no riešenie zvládne vyriešiť menšie vstupy a aj vstupy, kde je $h\_{max}$ malé.

Pamäťová zložitosť algoritmu je $O(r \\cdot s)$, keďže si musíme pamätať výšku každej budovy a aj to, ktoré políčka sme pri prehľadávaní navštívili.

Ako toto riešenie zlepšiť? Naša úloha má príjemnú vlastnosť, ktorú sme zatiaľ nepoužili: Pre všetky výšky menšie ako ideálna výška $H$ dostatočne veľkú oblasť nájsť nevieme, a naopak, pre všetky výšky väčšie ako $H$ takú oblasť určite nájsť vieme.

Toto nám tvorí ideálne podmienky pre použitie binárneho vyhľadávania.

## Binárne hľadanie najmenšej výšky $H$

Myšlienka binárneho vyhľadávania je veľmi jednoduchá. Pre nejakú hodnotu výšky $h$ sa pýtame otázku: Vieme nájsť súvislú oblasť veľkosti aspoň $k$, kde je najväčšia budova vysoká nanajvýš $h$?

- Ak áno, hľadaná výška je $\\leq h$.

- Ak nie, hľadaná výška je $> h$.

Na začiatku si teda zvolíme interval, v ktorom budeme vyhľadávať: `(left, right] = (-1, max_h]`. Jeho *ľavá hranica* bude označovať najväčšiu výšku, o ktorej vieme, že sa pre ňu *nedá* nájsť dostatočne veľká oblasť. Opačne, *pravá hranica* intervalu bude označovať najnižšiu výšku, o ktorej vieme, že sa pre ňu *dá* nájsť dostatočne veľká oblasť. Následne sa opakovane pýtame danú otázku pre výšku $h = (right + left) / 2$ -- výšku presne uprostred intervalu.

- Ak sa dá nájsť dostatočne veľká oblasť, posunieme pravú hranicu intervalu na $h$.

- Ak sa nedá nájsť dostatočne veľká oblasť, posunieme ľavú hranicu intervalu na $h$.

Prehľadávanie skončíme, ak zostane v intervale len jediná hodnota -- jeho pravá hranica -- výška $H$.

To, že sme si zvolili práve polootvorený interval (jeden z jeho hraničných prvkov v ňom nie je) nie je náhoda. Vďaka takejto voľbe sa vieme ľahko rozhodnúť, kedy kam posunúť ktorú hranicu -- predsa tak aby zostali zachované definície `left` a `right`. Tiež sa vyhneme rôznym chybám, keďže pivot (prostredný prvok -- $h$) nám rozdelí interval opäť na dva polootvorené -- `(left, h]` a `(h, right]` -- také, že ich prienik je prázdny a ich zjednotením dostaneme práve `(left, right]`. Vďaka tomu žiadnu možnosť nikdy nebudeme uvažovať dvakrát a žiadnu tiež nikdy nevynecháme. Ako bonus dostávame, že dĺžka intervalu `(left, right]` je práve `right-left`.

Časová zložitosť nám klesla na $O(r \\cdot s \\cdot \\log(h\_{max}))$, lebo pri vyhľadávaní sa vždy spýtame najviac $\\log_2(dlzka~intervalu)$ otázok. Pamäťová zložitosť ostáva $O(r \\cdot s)$, lebo si pamätáme tie isté údaje ako v jednoduchšom riešení.

## Pohľad z opačnej strany

Bez väčších omáčok si vysvetlime, ako sa na to dalo dívať inak. Predstavíme si, že v meste ešte nie je postavená žiadna budova. Preto ich tam začneme postupne pridávať od najmenšej budovy po najvyššiu. Popri tom budeme sledovať, či po pridaní budovy nevznikla súvislá oblasť budov veľkosti aspoň $k$. Ak vznikla, tvrdíme, že táto oblasť je samotným riešením problému.

Dokážme si to sporom. Ak by existovala nejaká iná dostatočne veľká súvislá oblasť, ale najvyššia budova v nej by bola nižšia, tak to znamená, že túto oblasť sme museli nájsť už skôr. Keďže sme ale pridávali budovy od najnižšej, tak sme museli pridať už všetky budovy tvoriace túto oblasť. Takúto oblasť by sme teda už objavili skôr, čo je v spor s tvrdením, že pridaním poslednej budovy vznikla dostatočne veľká oblasť prvýkrát.

Potrebujeme ešte vyriešiť, ako zisťovať, či už existuje súvislá oblasť veľkosti aspoň $k$. Na také niečo je ako stavaný algoritmus Union-find, pri ktorom si udržujeme súvislé oblasti budov. Vždy keď pridávame novú budovu, zistíme, do ktorej oblasti ju máme pridať a či prípadne nespojila nejaké skupiny dokopy. Pre jednotlivé oblasti si pamätáme ich veľkosti a ak má nejaká z nich veľkosť aspoň $k$, môžeme náš algoritmus zastaviť.

Takéto riešenie je rovnako dobré ako binárne vyhľadávanie najmenšej výšky, keďže musíme usporiadať všetkých $r\\cdot s$ budov podľa veľkosti. Samotný algoritmus union-find už nespotrebuje viac času ako toto triedenie a preto je výsledná časová zložitosť $O(r\\cdot s \\cdot log(r\\cdot s))$ a pamäťová zložitosť ostáva $O(r \\cdot s)$.
",8
f73f08f47ae95c6e,ksp,"# Pozíciechtivý vedúci

__Rok 2018 (rekonštruované podľa dobových záznamov):__

""Tak, vítam Vás všetkých na Rade Trojstenu. Máme dnes celkom veľa vecí na práci. Takmer polovica pozícií v Trojstene je neobsadených... Hľadáme napríklad hlavného vedúceho KMS, vedúcich FKS, dievčatá do KSP,...""

""Muhahahahaa"" pomyslel si Krtko. ""Konečne sa zmocním všetkých pozícií v Trojstene. Teda, nie všetkých, ale len tých cool. Napríklad hlavný vedúci KMS naozaj nie je cool pozícia...""

""Takže, chce si niekto zobrať pozíciu dievčaťa v KSP?""

""Ja by som si to zobral"", ozval sa Krtko.

""Hlavného vedúceho KMS?""

""Nie, toto nechcem..."", povedal Krtko.

""Ale takto to nefunguje, Krtko... Ak si zoberieš nejakú pozíciu, tak si musíš zobrať všetky pozície od nej, až po poslednú.""

""No dobre, ako myslíte...""

...

Už dlhé roky sa v Trojstene traduje táto legenda, ale nikto doteraz nevie ako veľmi cool boli pozície, ktoré si Krtko zobral. Z dobových záznamov sa zachoval len počet pozícií, ktoré boli v ponuke, a cool-ovosť týchto pozícií. Vedeli by ste z týchto údajov vypočítať najväčšiu možnú coolovosť pozícií, ktoré si mohol Krtko zobrať?

## Úloha:

Pre zadané coolovosti pozícií na vstupe, vypíšte maximálnu možnú coolovosť, ktoré je rovná súčtu coolovosti pozícií na neprázdnom intervale, ktorý končí na poslednom prvku poľa.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n \\leq 100000$ - počet pozícií, ktoré boli ponúknuté Krtkovi. Na druhom riadku sa nachádza $n$ medzerou oddelených čísel, $c_i$: $-100000 \\leq c_i \\leq 100000$.

## Formát výstupu

Vypíšte jedno číslo, maximálnu možnú coolovosť pozícií, ktore mohol Krtko získať.

## Príklad

```vstup
5
1 2 -5 10 2
```

```vystup
12
```

```vstup
3
10 -8 10
```

```vystup
12
```
","# Dvojičky

Je niekoľko spôsobov, ako sa na túto úlohu pozerať. Líšia sa časovou a pamäťovou zložitosťou.

## Priamočiare riešenie

Pre každý možný začiatok intervalu potrebujeme zistiť, aký je súčet prvkov po posledný a následne z nich vybrať maximálny. Toto riešenie zaberie $O(n)$ pamäte, lebo si pamätáme celé pole, a $O(n^2)$ času, lebo pre každý prvok musíme sčítať všetky ďalšie. Dokopy, za celý beh programu počet prvkov, ktoré potrebujeme sčítať vieme vyjadriť ako $\\frac{n \\cdot \\left(n-1\\right)}{2}$, čo je asymptoticky $n^2$.

## Ako zlepšiť časovou zložitosť

To, na čom náš kód trávi priveľa času, je to, že každý interval počíta odznovu. Na to, aby sme nemuseli vždy počítať súčet celého nového intervalu, si stačí uvedomiť, že ako prechádzame intervaly od najdlhšieho, tak nový interval je vždy len o jeden prvok kratší ako ten starý, resp., ten starý je o jeden prvok dlhší. To znamená, že ak sa budeme pozerať na intervaly od najkratšieho, (ako prvý sa pozrieme na ten, ktorý má len jeden prvok), tak súčty všetkých intervalov, ktoré končia na poslednom prvku poľa zistíme na $n$ krokov, kde v každom kroku pripočítame k aktuálnemu súčtu ďalší prvok. Pamäťová zložitosť bude $O(n)$, lebo stále si musíme pamätať celé pole, ale časová zložitosť bude už iba $O(n)$.

## Ako to robiť bez nutnosti pamätania všetkých súčtov

Toto riešenie samozrejme môže mať veľa variácií, napríklad namiesto hľadania intervalu s čo najväčším súčtom, ktorý končí na poslednom prvku poľa, môžeme hľadať interval od začiatku, ktorého suma je čo najmenšia. V takomto prípade je výsledok súčet celého poľa mínus súčet intervalu s najmenším súčtom.

Toto dokonca dokážeme urobiť v pamäti $O(1)$, a čase $O(n)$, ak načítavame prvky postupne, po jednom.
",1
adab91a3246d9e2d,ksp,"# Zrýchlenie parkoviska

Niektorí riešitelia KSP sa po maturite rozutekajú do sveta. Napríklad do Dánska. Nechcú si ale so sebou brať svoje autá a keďže sú dobré duše, požičajú ich Trojstenu.

Toto má ale nežiadúce vedľajšie efekty: matfyzácke parkovisko sa rýchlo plní a bezradní šoféri sa hádajú o prázdne miesta. Preto sa vedenie rozhodlo zaviesť nový systém prideľovania parkovacích miest, ktorý bude férový ku všetkým.

## Úloha

Máme parkovisko, kde je $m$ parkovacích miest, očíslovaných číslami od $0$ po $m-1$.

Na parkovisko prichádzajú a odchádzajú autá s unikátnou ŠPZ (teda na parkovisku nebudú naraz dve autá s rovnakou ŠPZ, ale jedno auto môže prísť a odísť aj viackrát).

Vašou úlohou je prideľovať autám parkovacie miesta. Každému autu, ktoré príde, prideľte ľubovoľné voľné parkovacie miesto. Ak sú všetky miesta plné, miesto prideľovať nemusíte a auto neobslúžite (ide parkovať inam).

## Formát vstupu

V prvom riadku vstupu sú čísla $m$ ($1 \\leq m \\leq 10^5$) a $n$ ($1 \\leq n \\leq 10^6$). Číslo $m$ je počet miest na parkovisku a $n$ je počet príchodov a odchodov áut dokopy.

V každom z ďalších $n$ riadkov je číslo ŠPZ ($1 \\leq SPZ \\leq 10^6$) auta, ktoré prišlo alebo odišlo. Ak sa auto s touto ŠPZ nachádza na parkovisku, práve odišlo. V opačnom prípade práve prichádza.

## Formát výstupu

Pre každé auto, ktoré prišlo alebo odišlo, vypíšte jeden riadok a na ňom číslo parkovacieho miesta, ktoré obsadilo alebo uvoľnilo (číslované od $0$ po $m-1$). Ak príde auto na plné parkovisko, vypíšte jeden riadok a na ňom reťazec `""plne""`.

Správny výstup je ľubovoľné prideľovanie miest, pri ktorom žiadnemu autu nebude pridelené už obsadené miesto a každé auto pri odchode uvoľnilo miesto, ktoré mu bolo pridelené.

## Príklad

```vstup
3 7
4
9039
103
19
4
103
47
```

```vystup
0
1
2
plne
0
2
2
```
","# Zrýchlenie parkoviska

Pre každý riadok vstupu (ŠPZ auta) riešime jednu z dvoch úloh: parkovanie (nájdi voľné miesto) alebo vyparkovanie (nájdi miesto, na ktorom auto bolo).

Obe sa dajú jednoducho vyriešiť napríklad takto: parkovisko si budeme pamätať ako pole, kde `parkovisko[i]` bude obsahovať buď ŠPZ auta, ktoré stojí na mieste $i$, alebo špeciálnu hodnotu, ak je miesto prázdne. Na zodpovedanie otázky prezeráme parkovisko miesto po mieste, kým nenájdeme dané auto a potom ho vyparkujeme. Ak auto nenájdeme, vyhľadáme mu voľné miesto. Toto riešenie je ale zjavne veľmi pomalé, pretože pre každé auto musíme prehľadať prinajhoršom celé parkovisko. Časová zložitosť takéhoto riešenia je potom $O(mn)$.

Malým, ale v niektorých prípadoch významným, zlepšením jednoduchého riešenia je nezačínať hľadanie prázdneho miesta vždy odznova. Budeme ho hľadať od miesta, kam zaparkovalo posledné auto. Týmto zrýchlime hľadanie miesta, samozrejme, len pokiaľ sa nezaplní posledné miesto parkoviska. Zvyšok výpočtu sa nespomalí, a preto je toto riešenie lepšie, hlavne ak prichádzajúcich áut je málo a parkovisko veľké.

Toto ale nestačí. Ak by po zaplnení parkoviska stále prichádzali autá na miesta s číslami $m$ a $m/2$, pre každú otázku zo vstupu prehľadávame stále $O(m)$ miest. Chceme teda nájsť buď voľné miesto, alebo miesto, kde je auto zaparkované bez nutnosti prehľadať parkovisko. Na to si ukážeme dva zlepšováky:

Keď auto zaparkuje, jeho miesto sa už meniť nebude. Preto môžeme vyparkovanie zrýchliť na konštantný počet operácií tým, že pre každé zaparkované auto si budeme pamätať miesto, na ktorom stojí a pri vyparkovaní ho uvoľníme. Toto dosiahneme napríklad tým, že budeme mať pole a v ňom políčko pre každú možnú ŠPZ. Keď auto nie je zaparkované, pamätáme si v tomto políčku hodnotu $-1$ (alebo inú, ktorá nie je platné číslo parkovacieho miesta). Ak príde auto zaparkovať a nájdeme mu miesto, do tohto políčka uložíme číslo miesta, kam zaparkovalo. Keď bude odchádzať, stačí sa pozrieť na toto políčko a hneď vieme, ktoré miesto treba uvoľniť.

Druhým zlepšovákom chceme zrýchliť hľadanie voľného miesta. Uvedomte si, že je nám jedno, na ktoré voľné miesto prichádzajúce auto zaparkujeme. Dôležité je len, aby sme to robili rýchlo. Pamätajme si preto všetky voľné miesta v jednom poli. Na začiatku toto pole obsahuje všetky čísla od 1 po $m$.

Ak príde auto a chceme mu priradiť voľné miesto, pozrieme sa jednoducho na posledné miesto tohto poľa. Tam sa nachádza nejaké voľné miesto, ktoré mu priradíme. V tomto momente však toto miesto už nie je voľné -- potrebovali by sme ho z tohto poľa vyškrtnúť a pole skrátiť. To vieme robiť rýchlo buď pomocou dynamických polí^\[`vector::pop_back()` v C++, `list::pop()` v Pythone\] alebo len použijeme jednu premennú `posledneVolne`, ktorá nám hovorí, koľko voľných parkovacích miest máme. Namiesto skracovania poľa nám preto bude stačiť zmenšiť túto premennú o 1.

Ak auto odchádza, vyššie uvedeným spôsobom zistíme, ktoré miesto uvoľnilo. Toto voľné miesto si zapíšeme do nášho poľa voľných miest, a to tak, že zväčšíme premennú `posledneVolne` a do poľa si na toto miesto zapíšeme uvoľnené parkovacie miesto.

Takto máme celý čas k dispozícii zoznam voľných miest a nemusíme sa preto pozerať na všetky ostatné (aj obsadené) parkovacie miesta. Dátová štruktúra, do ktorej vieme na koniec vkladať a z jej konca vyberať prvky sa často používa a tak dostala aj názov -- zásobník, po anglicky `stack`. V predošlých odsekoch sme si vlastne popísali, ako taký zásobník naprogramovať.

Keď použijeme oba zlepšováky, na parkovanie alebo vyparkovanie jedného auta potrebujeme iba konštantný počet operácií. Obslúžiť $n$ príchodov alebo odchodov bude teda trvať $O(n)$ operácií.

V pamäti si musíme držať voľné miesta, ktorých je nanajvýš $m$ a parkovacie miesta pre všetky ŠPZky^[Ak by sme použili hashovaciu tabuľku, stačilo by nám pamätať si v nej pre každé auto jeho miesto a zmestili by sme sa do pamäte $O(m+n)$. V tejto úlohe to však nebolo potrebné.]. Napriek tomu, že v našej úlohe sú tieto hodnoty len do $1,000,000$, nie je slušné povedať, že pamäťová zložitosť je konštantná. Omnoho viac prezradíme, ak si označíme maximálnu hodnotu ŠPZ ako napríklad $S$ a potom môžeme povedať, že pamäťová zložitosť algoritmu je $O(m + S)$.
",2
6557e79ac09b241b,ksp,"# Zajovo umenie

Mišo ukázal Zajovi, aká rýchla je jeho grafická knižnica napísaná v jazyku Go:

""Pozri, ako rýchlo vygenerujem veľa náhodných čiernych a bielych štvorcov!"", povedal Mišo a hneď sa mu na obrazovke zjavili čierne a biele štvorčeky.

""Hmm, to bolo rýchle. Ale bolo to naozaj náhodné?"" začudoval sa Zajo.

""Pozri, spustím to ešte raz a bude to vyzerať inak."", povedal Mišo a tak aj spravil. Nový obrázok vyzeral naozaj inak.

""No, niečo sa zmenilo, ale čo tie dva veľké štvorce, jeden čierny a jeden biely? Také tam boli aj minule."" poznamenal Zajo.

""No dobre, ono to nie je celkom náhodné. Najprv si rozdelím celý štvorec na štvrtiny, náhodne jednu vyfarbím na bielo, jednu na čierno a ostatné dve rekurzívne rovnako."" priznal sa Mišo.

Zajo sa na chvíľu zamyslel a opýtal sa Miša: ""Ak by som ti dal čiernobiely obrázok, aký najpodobnejší obrázok by k nemu dokázal tvoj postup vygenerovať?"".

Mišo pohotovo odvetil: ""Tak to teda neviem, ale myslím si, že riešitelia KSP by nám s tým vedeli pomôcť."".

""To je pravda. Zaujímalo by ma, či to zvládnu rýchlejšie ako my postavíme snehuliaka. Pozri, koľko snehu napadlo!"", povedal Zajo a išli spolu stavať snehuliaka.

## Úloha

Mišov program dokáže generovať štvorcové obrázky, ktorých šírka (a tým pádom aj výška) je mocnina dvojky. Program postupuje takto:

1. Ak je strana štvorca $1$, vyfarbi ho náhodne, buď celý na bielo, alebo celý na čierno
1. Inak:\
   2.1. Rozdeľ štvorec na 4 menšie štvorce\
   2.2. Náhodnú zo 4 štvrtín vyfarbi na bielo\
   2.3. Náhodnú zo zvyšných troch štvrtín vyfarbi na čierno\
   2.4. Pre zvyšné dve štvrtiny opakuj od kroku 1.

Podobnosť dvoch obrázkov definujeme ako veľkosť plochy, na ktorej majú oba obrázky rovnakú farbu. Napríklad nasledujúce dva obrázky majú podobnosť 8 (zhodujú sa v červeno orámovaných políčkach).

Na vstupe dostanete čierno-biely štvorcový obrázok. Zistite, aký najpodobnejší obrázok by dokázal Mišov postup vygenerovať (spomedzi všetkých takých, ktoré má šancu vygenerovať).

## Formát vstupu

Na prvom riadku je čílo $n$, $(1 \\leq n \\leq 512)$ -- dĺžka strany štvorca. Číslo $n$ je vždy mocnina čisla $2$.

Nasleduje $n$ riadkov po $n$ čísel `0` alebo `1` (nie sú oddelené medzerami). Číslo `0` znamená bielu, `1` znamená čiernu farbu.

## Formát výstupu

Na prvý riadok vypíšte, na koľkých miestach sa bude Mišov najpodobnejší obrázok odlišovať od toho na vstupe. Ďalej vypíšte najpodobnejší obrázok v rovnakom formáte ako obrázok na vstupe. Ak je viac možností, vypíšte ľubovolnú z nich.

## Hodnotenie

Pre jednotlivé sady testovacích vstupov platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:-----:| | $n \\leq$ | $8$ | $64$ | $256$ | $512$ |

## Príklady

```vstup
4
1001
0011
0111
1111
```

```vystup
1
0001
0011
0111
1111
```

```vstup
4
1010
0101
1010
0101
```

```vystup
4
0011
0011
1010
0101
```

*Tento vstup má viacero riešení.*
","# Zajovo umenie

Mišov program si náhodne vyberá, ktorá štvrtina obrázku bude biela a ktorá čierna. Našou úlohou je zistiť, ako si má program vyberať tak, aby bol vygenerovaný obrázok čo najviac podobný obrázku na vstupe.

Môžeme si to predstaviť tak, že necháme bežať program a vždy, keď si má náhodne vybrať, podstrčíme mu to ""správne"" umiestnenie čierneho a bieleho štvorca. Takýmto spôsobom vieme jednoducho vytvoriť výsledný obrázok, ktorý potrebujeme vypísať na výstup. Ostáva nám zistiť, ktoré je to ""správne"" rozloženie štvorcov.

## Ako nájsť najlepšie rozloženie?

Aby sme našli najlepšie rozloženie štvorca so stranou $n$, potrebujeme zistiť, kam umiestniť biely a čierny štvorec. Koľko na to máme možností? Vyberáme zo štyroch štvrtín štvorca. Jedna má byť biela, jedna čierna, a ostatné dve budú vyfarbené rekurzívne, ako keby to boli samostatné obrázky so stranou $\\frac{n}{2}$ (ak sú väčšie ako 1 štvorček). Znamená to, že vyfarbíme jeden zo štyroch štvorcov na bielu a potom jeden zo zvyšných troch na čiernu, čo je spolu $4 \\cdot 3 = 12$ možností. Zvyšné dva štvorce sa vyfarbia rekurzívne.

Pre každú možnosť potrebujeme zistiť, ako veľmi by sa líšil výsledný obrázok od zadaného (ďalej skóre). Aby sme vedeli rýchlo zistiť skóre jednotlivých štvrtín, použijeme niekoľko trikov.

Pre skóre bieleho štvorca potrebujeme vedieť, koľko jednotiek sa nachádza v príslušnom štvorci na zadanom obrázku. V našom obrázku sú len nuly a jednotky, čiže počet jednotiek vo štvorci je vlastne súčet všetkých čísel vo štvorci. S tým nám pomôžu [dvojrozmerné prefixové súčty](https://www.ksp.sk/kucharka/2d_prefixove_sumy). Ich výpočet nám trvá čas lineárny od veľkosti obrázku, a potom sme schopní v konštantnom čase zodpovedať otázky tvaru: ""Aký je súčet čísel v tomto obdĺžniku?""

Pre čierny štvorec potrebujeme vedieť, koľko núl sa nachádza v príslušnom štvorci. Počet núl vo štvorci je počet jeho políčok mínus počet jednotiek v ňom, a obe z týchto hodnôt už vieme vypočítať.

Ostáva nám zistiť, aké skóre majú štvorce, ktoré vyplníme rekurzívne. Ak sú tieto štvorce $1 \\times 1$, skóre je vždy $0$, lebo si môžeme zvoliť farbu. Ak sú väčšie, zistíme to rekurzívne. Použijeme teda rovnaký postup, ako keď zisťujeme skóre veľkého štvorca (vyskúšame všetkých $12$ možností).

Toto riešenie je ale pomalé, dostali by sme za neho $2$ body.

## Prečo je to pomalé?

V prvom kroku máme $12$ možností ktoré skúšame. Z týchto $12$ možností je každý menší štvorec $3$-krát čierny, $3$-krát biely a $6$-krát určovaný rekurzívne. Rekurzívnych volaní je teda spolu $24$.

V každom z týchto rekurzívnych volaní sa deje to isté. Na druhej úrovni už máme $24 \\cdot 24 = 576$ volaní na $4 \\cdot 4 = 16$ štvorcov, pre ktoré chceme zistiť skóre. Očividne robíme niečo zbytočne viac krát. Predídeme tomu jednoducho tak, že vždy, keď poprvýkrát zrátame skóre niektorého štvorca, si jeho skóre zapamätáme. Neskôr, keď budeme chcieť zistiť jeho skóre, sa iba pozrieme na zapamätanú hodnotu. Aký dopad bude mať táto malá zmena? Pozrime sa napríklad opäť na druhú úroveň. Budeme na nej mať už len $16$ rekurzívnych volaní, a zvyšných $576 - 16 = 560$ volaní už vyhodnotíme v konstantnom čase tak, že sa pozrieme na zapamätanú hodnotu.

Tento postup sa volá memoizácia. Ďalšiu ukážku použitia memoizácie nájdete napríklad v úlohe [Optimálna šifrovačka](https://www.ksp.sk/ulohy/riesenia/1098/).

## Časová zložitosť

Pri úlohách, v ktorých je vstup dvojrozmerný (tabuľka, mriežka), máme dve možnosti, ako zapísať časovú zložitosť. Buď ju môžeme uvádzať zložitosť od skutočného počtu čísel na vstupe (veľkosti vstupu) alebo od dĺžky strany štvorca. My budeme uvádzať zložitosť v závislosti od čísla $N = n \\cdot n$, teda od veľkosti vstupu.

Na začiatku si predrátame prefixové súčty obrázku na vstupe, pomocou ktorých neskôr budeme zisťovať skóre bielych a čiernych štvorcov v konštantnom čase. Na to potrebujeme $O(N)$ času. Zaujímavejšie je to s našou rekurzívnou funkciou.

Vďaka memoizácii sa rekurzívne volanie pre každý štvorec vykoná iba raz. Pri každom ďalšom volaní len vráti už uložené riešenie. Počet volaní tejto funkcie je teda rovnaký, ako počet rôznych štvorcov, na ktoré sa funkcia zavolá.

Na začiatku máme štvorec veľkosti $N$. V ďalšom kroku máme $4$ štvorce veľkosti $\\frac{N}{4}$, potom $16$ štvorcov veľkosti $\\frac{N}{16}$, a tak ďalej až po $N$ štvorcov s veľkosťou $1$. Dostávame postupnosť $1 + 4 + 16 + 64 + ... + N$ štvorcov všetkých veľkostí.

Aby sme ukázali, že súčet tejto postupnosti je $O(N)$, porovnáme ju s postupnosťou $1+2+4+8+...+N = 2N-1$. Vidíme, že naša postupnosť obsahuje len niektoré jej členy a teda náš súčet bude určite menší. Z toho vyplýva, že celkový počet štvorcov, a teda aj počet volaní funkcie, je $O(N)$.

Teraz potrebujeme ešte zistiť, ako dlho trvá výpočet jedného volania. Potom to vynásobíme počtom volaní a dostaneme zložitosť celého výpočtu. Aby sme zistili zložitosť iba jedného volania, budeme predpokladať, že všetky volania, ktoré bude potrebovať, sú už vyrátané.

Čo robí jedno volanie? Zisťujeme v ňom skóre menších štvorcov a podľa nich vyberieme najlepšie z $12$ možných rozložení. Zisťovanie skóre pre biely a čierny štvorec je vďaka prefixovým súčtom v $O(1)$, skóre ostatných štvorcov zistíme opätovným volaním našej funkcie, čo môžeme kvôli rekurzii považovať za $O(1)$.

Spolu bude teda výpočet celého rozloženia trvať $O(N) \\cdot O(1) = O(N)$.

Na koniec nám ostáva len skonštruovať obrázok na výstup. Na to stačí priamočiara simulácia Mišovho programu (keď už vieme, ktoré štvorce majú byť biele a ktoré čierne). Pri takejto simulácii iba vypĺňame tabuľku veľkosti $N$, na čo potrebujeme opäť $O(N)$ času.

Celková časová zložitosť je teda $O(N)$. Pamäťová tiež, lebo si pamätáme obrázok veľkosti $O(N)$ a skóre už vyrátaných štvorcov, ktorých je $O(N)$.
",6
47ba3d085938c887,ksp,"# Éra krátkych skratiek

Janko sa začal učiť pracovať s Unixovým terminálom. Ako prvý sa naučil príkaz `echo` s veľmi príznačným menom, ktorý ako ozvena vypíše svoje parametre na štandardný výstup.

Potom však došiel k príkazom, ktoré začali mať príliš krátke a nezrozumiteľné mená. Začínalo to úplne nebadane, príkazmi `cp`, `mv` a `rm` na kopírovanie, presúvanie a mazanie súborov, ktorých mená vznikli jednoducho z CoPy, MoVe a ReMove. Neskôr sa to začalo zhoršovať. Janko sa dozvedel napríklad o príkazoch `chmod` (change mode), `tar` (tape archiver), `tr` (transform) či `chgrp` (change group). Janko si príkazy nedokázal zapamätať a v skriptoch, ktoré napísal, sa už chvíľu nato nedokázal vyznať. Ale malo to aj svoje výhody: menej búchania do klávesnice, menej prenesených mobilných dát^[Znižovanie množstva prenesených dát je naozaj dôvodom, prečo majú príkazy tak veľmi skrátené názvy. Kedysi, v časoch terminálov a telefónnych liniek, to naozaj malo význam.] , ..., a tu to aj skončilo.

Kto si má všetky tie skratky pamätať, pomyslel si Janko a začal sa radšej učiť programovať v jazyku `C`. Vôbec si však nepomohol, práve naopak. Tu mená funkcií boli nielen prikrátke, ale priam až kryptické. Napríklad `strrchr`. Po dlhých minútach zamyslenia zistil, že to `str` znamená `string`, `r` znamená `reverse` a `chr` znamená `character` a funkcia teda hľadá výskyt znaku v reťazci odzadu.

Keďže ho však premýšľanie začalo bolieť, rozhodol sa už druhýkrát zmeniť predmet svojho záujmu. Vybral si jazyk SNOBOL. Ale toto už Jankovi nedalo. Prečo práve SNOBOL? Ako k tomu došli? Vraj StriNg Oriented symBOlic Language. To nijak nedáva zmysel.

Napokon došiel k tomu, že vo všeobecnosti skratka vzniká tak, že len jednoducho vyberieme niektoré znaky názvu, pričom zachováme ich poradie a zapíšeme ich za seba. Z každého slova musíme vybrať aspoň jedno písmeno. A žiadne ďalšie pravidlá zrejme neplatia.

Janko by chcel vedieť overovať, či je daná skratka platná. Ale rozmýšľanie ho už po lúštení `strrchr` a SNOBOLu veľmi bolí, rád by to teda nechal na vás.

## Úloha

Vašou úlohou je spočítať počet možností, ako mohla vzniknúť skratka $S$ z názvu $T$.

Aby skratka $S$ mohla vzniknúť z textu $T$, musí platiť, že písmenám v $S$ vieme priradiť písmená v $T$, pričom musíme zachovať poradie (teda ak priradíme písmenko z $S$ nejakému písmenku z $T$, ďalšiemu môžeme priradiť len nejaké napravo v $T$) a z každého slova $T$ musíme použiť aspoň jedno písmeno.

Keďže počet možností je v niektorých prípadoch naozaj veľký, vypíšte len jeho zvyšok po delení $10^9+7$.

## Formát vstupu

Na prvom riadku sa nachádza číslo $w$ -- počet slov textu, z ktorého má byť utvorená skratka.

Na druhom riadku sa nachádza skratka - reťazec $S$ a na treťom riadku sa nachádza text $T$, ktorého skratka to má byť. Oba reťazce na vstupe pozostávajú len z malých písmen anglickej abecedy a medzier. Jednotlivé slová $T$ sú oddelené práve jednou medzerou (medzier je teda $w-1$). Skratka žiadne medzery neobsahuje.

## Formát výstupu

Vypíšte jedno číslo -- počet možností, ako možno priradiť písmenám skratky $S$ písmená textu $T$ tak, aby tvorili platnú skratku, modulo $10^9+7$. Ak to nie je možné, vypíšte $0$.

## Hodnotenie

Nech $M$ je dĺžka skratky a $N$ dĺžka textu. Sú $4$ sady vstupov. V jednotlivých sadách platia nasledovné obmedzenia:

1. $M \\leq 5$, $N \\leq 12$
1. $M \\leq 12$, $N \\leq 50$
1. $M \\leq 120$, $N \\leq 200$
1. $M \\leq 200$, $N \\leq 10000$

## Príklady

```vstup
2
tar
tape archiver
```

```vystup
4
```

_Možnosti sú TApe aRchiver, TApe archiveR, Tape ARchiver a Tape ArchiveR._

```vstup
4
snobol
string oriented symbolic language
```

```vystup
1
```

```vstup
3
strrchr
string reverse char
```

```vystup
3
```

```vstup
4
radar
radio detection and ranging
```

```vystup
1
```

_Jediná možnosť je RAdio Detection And Ranging. RADio detection And Ranging nie je platná možnosť, pretože zo slova detection sme nepoužili žiadne písmeno._

```vstup
4
acm
academy of computer makers
```

```vystup
0
```

_Skratka je jednak prikrátka, a jednak neobsahuje žiadne z písmen slova of._
","# Éra krátkych skratiek

Zabudnime zatiaľ na obmedzujúcu podmienku v zadaní, že z každého slova musíme do skratky vybrať aspoň jedno písmeno. Keďže medzery sa v skratke nenachádzajú, bez tohto obmedzenia sa nás úloha pýta, koľkými spôsobmi možno dostať skratku -- reťazec $S$ ako podreťazec reťazca $T$. Táto úloha sa dá riešiť jednoducho dynamickým programovaním.

Dynamické programovanie označuje techniku, kedy si problém vieme rozdeliť na menšie, výsledky pre menšie problémy si zapamätať a potom ich rovno používať, nepočítať ich znova. Naše podproblémy budú zodpovedať tú istú otázku, ale len pre menšie prefixy $S$ a $T$. Konkrétne: označíme si $dp[i][j]$ počet spôsobov, ako vybrať z prvých $i$ znakov $T$ podpostupnosť zhodnú s prvými $j$ znakmi $S$. Tieto hodnoty budeme počítať od menších hodnôt $i$ a $j$ k väčším.

Ako vypočítať hodnotu $dp[i][j]$, ak poznáme hodnoty pre menšie $i$ a $j$ Chceme teda získať prefix $S$ dĺžky $j$ ako podpostupnosť prefixu $T$ dĺžky $i$.

Ak je $j=0$, potom zrejme existuje práve jedna možnosť, ako vybrať prázdnu podpostupnosť z niečoho, a to práve tá, že nevyberiem žiadny znak.

Ak je $i=0$ a $j \\neq 0$, potom nie je možné z prázdneho prefixu $T$ neprázdnu podpostupnosť.

Ak sa $j$-ty znak $S$ zhoduje s $i$-tym znakom $T$ \\footnote{Znaky indexujeme od 1, pretože napr. prefix dĺžky 2 končí druhým znakom, ale ten je na indexe 1 v zero-based stringu.}, potom tento znak mohol byť z $T$ vybraný a ostáva nám vybrať prvých $j-1$ znakov $S$ z o 1 kratšieho prefixu $T$. Už vieme, koľkými spôsobmi to ide: $dp[i-1][j-1]$. Inou možnosťou je, že sme tento znak z $T$ nevybrali (nejaký rovnaký sme v $T$ vybrať museli, ale skôr). To znamená, že sa pokúšame vybrať prvých $j$ znakov $S$ ako podpostupnosť z o 1 kratšieho prefixu $T$, čo ide $dp[i-1][j]$ spôsobmi. Každá možnosť konštrukcie podpostupnosti spadá do práve jedného z týchto prípadov, a teda bude započítaná práve raz.

Ak sa $j$-ty znak $S$ nezhoduje s $i$-tym znakom $T$, musia všetky spôsoby, ako vyrobiť žiadaný prefix, vyzerať tak, že používajú iba prvých $i-1$ znakov $T$.

Vďaka pamätaniu si predchádzajúcich hodnôt $dp$ vieme každú ďalšiu hodnotu $dp$ spočítať v konštantnom čase, teda celková časová zložitosť je úmerná počtu dvojíc $i$ a $j$, teda $O(|S| \\cdot |T|)$.

Ako by sme vedeli upraviť tento algoritmus, aby počítal len možnosti, kedy z každého slova zoberieme aspoň jedno písmeno?

Parametre $i$, $j$ dynamického programovania vlastne zodpovedajú akýmsi stavom. Stav je napríklad, že mám prefix $S$ dĺžky $j$ a prefix $T$ dĺžky $i$. V našej pôvodnej úlohe tiež môžeme nájsť nejaké stavy. Konkrétne je stavom to, že máme prefix $S$ dĺžky $j$, prefix $T$ dĺžky $i$ a buď sme už z aktuálneho slova (z toho, ktorému patrí $i$-ty znak $T$) vybrali nejaké písmeno, alebo nie. Týmto sa stavový priestor zväčší iba dvojnásobne, takže to časovú zložitosť nepokazí.

Nech teda $dp[i][j][N]$ značí stav, kedy máme prefix $S$ dĺžky $j$ a prefix $T$ dĺžky $i$, pričom z aktuálneho slova sme ešte nepoužili žiaden znak a $dp[i][j][P]$ značí, že sme už nejaký znak slova použili. $N$ a $P$ sú len symboly pre lepšie pochopenie. V implementácii môžeme použiť hodnoty $0$ a $1$ alebo mať dve polia, $dp_N$ a $dp_P$.

Ak je $i$-ty znak $T$ písmeno, do stavu $dp[i][j][N]$ sa dá dostať jedine zo stavu $dp[i-1][j][N]$. Ak by sme totiž použili daný znak, dostali by sme sa do stavu s $P$. To však nenastalo, a teda máme o 1 kratší prefix.

Do stavu $dp[i][j][P]$ sme sa mohli dostať viacerými spôsobmi:

- $i$-ty znak $T$ sme nevybrali, museli sme vybrať nejaký znak predtým, čiže sme prišli zo stavu $dp[i-1][j][P]$,
- $i$-ty znak $T$ sme vybrali (samozrejme, len ak je zhodný s $j$-tym znakom $S$) a už predtým sme vybrali nejaký iný znak slova, teda sme prišli zo stavu $dp[i-1][j-1][P]$,
- $i$-ty znak $T$ sme vybrali a bol to prvý vybraný znak slova, žiaden predošlý sme nevybrali, prišli sme zo stavu $dp[i-1][j-1][N]$.

Ostáva poriešiť hranice medzi slovami. Tie sa jednoducho riešia vtedy, ak je aktuálny ($i$-ty) znak $T$ medzera. Vtedy začína nové slovo, takže počet spôsobov, ako mať vybraný nejaký znak nového (aktuálneho) slova ($dp[i][j][P]$) je nula. Počet spôsobov, ako nemať vybraný znak nového slova ($dp[i][j][N]$) je rovný $dp[i-1][j][P]$, teda hodnota pre o 1 kratší prefix $T$ s použitím nejakého znaku posledného slova. Všimnime si, že nezapočítavame $dp[i-1][j][N]$, pretože to zodpovedá situácii, kedy sme z predošlého slova nič nevybrali.

Počet možností pre skúmaný stav získame ako súčet počtov možností pre stavy, z ktorých sa do aktuálneho vieme dostať.

Odpoveďou je potom odpoveď pre celý reťazec $S$ a celý reťazec $T$, pričom aj z posledného slova sme museli nejaké písmeno vybrať. Je to teda hodnota $dp[|T|][|S|][P]$.

Časová zložitosť riešenia je stále $O(|S| \\cdot |T|)$, pretože máme len dvakrát viac hodnôt ako v zjednodušenom prípade a každú hodnotu vieme vypočítať v konštantnom čase.

Pamäťová zložitosť je rovnaká, ale vieme dosiahnuť aj zložitosť $O(|S|)$, pretože pri výpočte hodnôt $dp[i]$ nám stačí poznať hodnoty $dp[i-1]$, teda stačí si pamätať dva stĺpce, predošlý a aktuálny, tabuľky $dp$.
",6
bb3eb93986665717,ksp,"# O sústredkových pozvánkach

Jarné sústredenie KSP^[Nie až také jarné, keďže bude 4. až 11. marca.] sa pomaly blíži a vedúci začali s prípravami. Prvou, vcelku dôležitou úlohou je pozvať účastníkov. Zobrali sa preto výsledkové listiny oboch kategorií a spojili sa do jednej, čím vznikol dlhý zoznam, podľa ktorého sa bude pozývať na sústredenie. Postupne sa budú oslovovať účastníci od prvého miesta po posledné, až kým prvých 32 účastníkov nepovie, že ide na sústredenie. Je preto jasné, že čím skôr je niekto v tomto zozname, tým má väčšiu šancu, že sa na sústredenie dostane.

To všetko by bolo pekné, vedúci však začali vyjadrovať svoje súkromné preferencie. Napríklad Mišo povedal, že Paulínka musí byť pozvaná skôr ako prvý človek v zozname, aby sa určite dostala na sústredenie. Žaba tiež vyjadril názor, že dievčatá by sa mali uprednostňovať a pozývať protekčne skorej. A Hopko nástojil^[Prostredníctvom svojho spolubývajúceho Vlejda, ktorý je zhodou okolností priateľ Bašky, ktorá účastníkov pozýva na sústredenie.], aby bol jeho brat Slavo pozvaný na sústredenie skôr ako Andrej.

Aby v tom mala Baška prehľad, spísala si $m$ požiadaviek vedúcich. Môže sa stať, že sa jedna požiadavka niekoľkokrát opakuje. Každá požiadavka je tvaru `""x y""` a vyjadruje, že človek, ktorý je v zozname na $x$-tej pozícii má byť na sústredenie pozvaný skôr ako človek na $y$-tej pozícii. Baška sa teraz zamýšľa, v akom poradí má vlastne pozývať účastníkov z pôvodného zoznamu. Určite chce splniť všetky požiadavky, ktoré majú vedúci. Zároveň ale chce pozvať účastníka, ktorý je na prvom mieste čo najskôr. Z možných poradí, ktoré spĺňajú túto podmienku, chce potom vybrať také, kde pozve účastníka na druhom mieste čo najskôr atď...

## Úloha

Máme $n$ účastníkov očíslovaných $1$ až $n$ v poradí, v akom by sa mali pozývať na sústredenie. Ďalej máme $m$ požiadaviek -- dvojíc $x_i$ a $y_i$. Nájdite takú permutáciu čísel $1$ až $n$, že pre všetky $i$ je číslo $x_i$ pred číslom $y_i$. Spomedzi takýchto permutácií vyberte tú, v ktorej je číslo $1$ najskôr ako sa (za splnenia všetkých požiadaviek) dá, číslo $2$ je najskôr ako sa (za splnenia všetkých predošlých podmienok) dá, a tak ďalej až po $n$.

## Formát vstupu

Na prvom riadku sa nachádzajú dve čísla $n$ a $m$ ($1 \\leq n \\leq 200,000$, $1 \\leq m \\leq 400,000$) -- počet účastníkov a počet požiadaviek. Nasleduje $m$ riadkov, každý obsahuje dvojicu čísel $x_i$ a $y_i$ ($1 \\leq x_i, y_i \\leq n$).

Vstupné súbory sú pomerne veľké. Odporúčame preto používať C++ (keďže Python nemusí stíhať ani pri optimálnej časovej zložitosti) a na načítavanie odporúčame použiť knižnicu `cstdio`.

## Formát výstupu

Na jeden riadok vypíšte $n$ medzerami oddelených čísel -- permutáciu spĺňajúcu podmienky zo zadania. Je zaručené, že aspoň jedna takáto permutácia existuje.

## Príklad

```vstup
4 1
3 1
```

```vystup
3 1 2 4
```

_Účastníka 1 nevieme pozvať ako prvého, ale ak najskôr pozveme účastníka 3, tak ho môžeme pozvať už ako druhého. Následne chceme najskôr pozvať účastníka 2 a až potom 4._

```vstup
5 6
3 1
5 1
5 2
1 4
5 4
3 1
```

```vystup
3 5 1 2 4
```
","# O sústredkových pozvánkach

Keďže zadanie je trochu komplikovanejšie, začnime tým, že si ho zopakujeme. Máme čísla 1 až $n$ a $m$ podmienok, ktoré musíme splniť. Každá podmienka nám o nejakom čísle hovorí, že sa vo výslednej permutácii musí objaviť pred ktorýmsi iným číslom. Naviac, nechceme nájsť ľubovoľnú permutáciu, ktorá spĺňa všetky podmienky, ale takú, kde sa číslo 1 nachádza čo najskôr, potom číslo 2 čo najskôr atď. Uvedomme si, že toto nie je to isté ako hľadať lexikograficky najmenšiu takúto permutáciu, lebo permutácia $(3,1,2)$ je síce lexikograficky väčšia ako $(2,3,1)$, ale číslo 1 sa v nej nachádza skôr.

Pri riešení takýchto úloh je dobré si vstup zakresliť, aby sa nám nad ním lepšie rozmýšľalo -- napríklad formou orientovaného grafu. Každé číslo bude mať priradený jeden vrchol a hrana povedie z vrchola $x$ do vrchola $y$, ak má byť $x$ v permutácii pred $y$. Keďže zadanie nám zaručuje, že existuje aspoň jedna vhodná permutácia, v takomto grafe sa nemôžu nachádzať orientované cykly (rozmyslite si prečo by sme ich nevedeli celé splniť) a takýto graf sa preto volá orientovaný acyklický graf, alebo tiež DAG^[Z anglického Directed Acyclic Graph].

Poďme sa teraz pozrieť na to, ako by sme vedeli vytvoriť vhodnú permutáciu, ktorá by spĺňala všetky podmienky. Ktoré číslo sa môže nachádzať na prvom mieste? Každé, ktoré nemá byť predbehnuté iným číslom. Keď sa teda pozrieme na náš graf, zistíme, že sú to tie vrcholy, do ktorých nevedie žiadna hrana -- hrana vedie z vrchola, ktorý má byť skôr, do takého, ktorý má byť neskôr. Ak do vrchola vedie hrana, musíme najskôr do permutácie vložiť prvok na začiatku tejto hrany.

Ak teda vyberieme nejaké číslo a vložíme ho do permutácie, z nášho grafu si môžeme príslušný vrchol odstrániť. A rovnako všetky hrany, ktoré z neho viedli von, lebo tieto hrany už určite budú splnené. Ich začiatok sa v permutácii nachádza skôr ako ich koniec. Na druhom mieste permutácie môže byť opäť ľubovoľný vrchol, do ktorého nevchádza žiadna hrana.

Postupne by sme teda vedeli vytvoriť permutáciu, ktorá spĺňa všetky podmienky. Ako však vyberieme takú, kde bude 1 čo najskôr? Nemôžeme sa rozhodovať podľa veľkosti čísel, lebo nejaké väčšie číslo nám možno odkryje lepšie menšie a vie nastať pomerne veľa komplikovaných prípadov.

Keď to teda nevyšlo pre začiatok, skúsme vytvárať permutáciu od konca. Ktoré čísla môžu byť na poslednej pozícii? No predsa všetky, po ktorých už nemusí ísť žiadne číslo. V grafe sú to teda vrcholy, z ktorých nevychádza žiadna hrana. A opäť, ak si niektorý z nich vyberieme a odstránime ho z grafu, dostaneme graf, z ktorého môžeme vyberať číslo na pozíciu, ktorá je druhá od konca. Robíme v podstate to isté, len opačným smerom. Vieme však teraz zaručiť aj zvyšné požiadavky, teda aby sa 1 nachádzala vo výslednej permutácií čo najskôr?

Čo keby sme vždy z čísel, ktoré máme k dispozícii na poslednú pozíciu vybrali to, ktoré je najväčšie? Znie to ako nápad, ktorý nič nepokazí. Predsalen, umožníme všetkým menším číslam, aby sa nachádzali skôr. A síce je fajn, že nám intuícia napovedá, že tento postup je správny, musíme si ho aj dokázať.

Predstavme si, že máme optimálnu permutáciu, ktorá na posledné miesto umiestnila číslo $x$, ale na posledné miesto môže ísť aj číslo $y$, ktoré je väčšie ako $x$. Čo sa stane, ak z tejto permutácie vyberieme číslo $y$ a dáme ho na koniec, pričom všetky čísla, čo boli pôvodne za ním posunieme o jedno dopredu? Vo výslednej permutácii sa dozadu posunulo iba číslo $y$. Všetky ostatné buď zostali na svojom mieste, alebo sa posunuli dopredu. A hlavne sa dopredu posunulo číslo $x$. A keďže je menšie ako $y$, tak táto permutácia je lepšie ako pôvodná, s ktorou sme začínali. To je ale spor s tým, že tá permutácia mala byť optimálna. Dokázali sme teda, že náš postup je správny.

Otázkou zostáva už len to, ako takéto riešenie naprogramovať. Musíme vedieť odstrániť ľubovoľný vrchol z grafu a tiež všetky hrany, ktoré z neho viedli. Takisto si musíme udržiavať množinu čísel, z ktorých nevedie žiadna hrana a z tejto množiny rýchlo vybrať číslo, ktoré je najväčšie. Na druhú časť použijeme dátovú štruktúru halda, do ktorej vieme vkladať prvok v čase $O(\\log n)$ a vyberať najväčší prvok v čase $O(\\log n)$, kde $n$ je počet prvkov v halde.

Na začiatku načítame vstup a pre každý vrchol vytvoríme zoznam hrán, ktoré doň vchádzajú. Takisto si v poli $P[]$ budeme pamätať, koľko hrán z neho vychádza. Všetky čísla $x$, pre ktoré je $P[x]$ rovné 0 vložíme do haldy, keďže sú to vrcholy, z ktorých nevychádza žiadna hrana. Z haldy vyberieme najväčšie číslo, označme si ho ako $x$. Vrchol $x$ chceme odstrániť z grafu. Preto prejdeme všetky hrany vychádzajúce z tohto vrchola a každému koncovému vrcholu zmenšíme hodnotu v $P[]$, lebo už z neho vychádza o jednu hranu menej. Ak počas týchto úprav klesne niektoré $P[y]$ na nulu, tak $y$ vložíme do haldy. Na konci vypíšeme čísla v obrátenom poradí ako sme ich vyberali z haldy.

Každý vrchol vložíme aj vyberieme z haldy najviac raz. Takisto raz odstránime každú hranu. Preto je výsledná časová zložitosť tohto riešenia $O(n\\log n + m)$. Pamäťová zložitosť je $O(n+m)$.
",8
fe526701d8e066f0,ksp,"# Svinstvo na koberci

Krtko si na oslavu svojho novo zrekonštruovaného bytu pozval všetkých vedúcich. Kubíkovi sa byt tak páčil, že sa rozhodol kúpiť nový nábytok do Klubovne Spokojných Programátorov. Zohnal nové staré stoly, kolieskové stoličky bez koliesok aj pekné preplnené skrine. Nákup zavŕšil novým viacdielnym kobercom. Ten sa skladá z viacerých kúskov uložených tak, že na podlahe tvoria mapu.

Netrvalo dlho a na čistučkom koberci sa začali každý deň objavovať zablatené stopy, zadupaná čokoláda či škrny od kofoly. Tie treba rýchlo odstrániť, inak sa do koberca zažerú nastálo.

Kubík dostal briliantný nápad. Na strop pripevnil kameru namierenú na koberec, takže vie presnú polohu každej škvrny v momente, keď sa objaví. Od vás chce program, ktorý mu povie veľkosť zašpineného kusu koberca, aby mohol objednať správne množstvo čistiacich prostriedkov.

## Úloha

Na vstupe dostanete zadanú mapu koberca v podobe **súvislého** *planárneho grafu* (vrcholy so súradnicami a hrany medzi nimi) a niekoľko bodov. Vašou úlohou je pre každý bod nájsť veľkosť uzavretej oblasti, v ktorej leží (tj. jej obsah). Ak sa bod nenachádza v žiadnej uzavretej oblasti, vypíšte $-1$. **Body ležiace na niektorej hrane grafu (vrátane jej okrajov) považujeme, že nie sú vo vnútri žiadnej uzavretej oblasti.**

Pozor! Túto úlohu je treba riešiť online, čiže testovač vášmu programu posiela otázky postupne. Každú nasledujúcu otázku dostanete až po tom, čo zodpoviete aktuálnu. Nezabudnite flushovat, aby sa vaša odpoveď skutočne testovaču odoslala a netrávila prázdniny v nejakom buffri. (C++ `cout.flush()`, Python `sys.stdout.flush()`, pre iné jazyky si vyhľadajte.)

## Formát vstupu

Na prvom riadku vstupu je číslo $n$---počet vrcholov, $m$---počet hrán a $q$---počet otázok.

Potom prázdny riadok, a nasleduje $n$ riadkov ($n \\geq 1$) obsahujúcich $2$ čísla---súradnice daného vrchola. Môžete predpokladať, že žiadne dve vrcholy nie sú ten istý bod v rovine. Všetky súradnice sú celé čísla, ktoré v absolútnej hodnote neprevýšia $10^9$.

Potom prázdny riadok, a na ďalších $m$ riadkoch ($m \\geq 0$) sú vždy $2$ čísla---čísla vrcholov, medzi ktorými vedú hrany. Vrcholy číslujeme $1, 2, \\ldots, n$. Môžete predpokladať, že ak niektoré tri vrcholy $a, b, c$ ležia na jednej priamke v tomto poradí, tak na vstupe nebude hrana $ac$. Takisto sa žiadna hrana na vstupe nevyskytne viackrát, a žiadne dve hrany sa nekrižujú. Koncové vrcholy každej hrany sú rôzne. Zadaný graf je súvislý.

Potom prázdny riadok, a na každom z posledných $q$ riadkov ($q \\geq 0$) sú $2$ čísla---súradnice bodu z otázky.

Súradnice všetkých bodov sú nezáporné a neprevyšujú $10^9$.

## Formát výstupu

Pre každý bod vypíšte riadok obsahujúci jedno číslo---veľkosť oblasti, v ktorej sa nachádza. Ak bod neleží v žiadnej uzavretej oblasti, vypíšte $-1$. **Pokiaľ je výsledok celočíselný, nevypisujte žiadne desatinné miesta, v opačnom prípade vypíšte jedno desatinné miesto.** (Rozmyslite si, že obsah každej z oblastí je nutne celočíselným násobkom $\\frac{1}{2}$.)

## Hodnotenie

Obmedzenia v jednotlivých sadách sú nasledovné:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:------- | ----------:| ----------:| -----------:| -------------:| -----------:| -----------:| -------------:| -------------:| | $n \\leq$ | $300$ | | $2,500$ | | | $50,000$ | | | | $m \\leq$ | $300$ | | $4,000$ | | | $70,000$ | | | | $q \\leq$ | $10,000$ | | | | | $20,000$ | | |

## Príklady

```vstup
5 7 5

10 6
7 10
9 1
0 6
2 0

2 4
5 3
1 3
3 4
5 4
4 1
2 1

8 6
0 3
2 5
7 0
8 1
```

```vystup
-1
-1
25
-1
22
```

Obrázok prvého vstupu:

```vstup
7 10 5

7 3
0 4
0 8
3 2
10 0
7 6
0 10

6 2
6 7
5 4
3 7
5 1
6 5
6 4
2 4
3 2
6 3

5 4
5 2
8 1
2 5
4 4
```

```vystup
-1
18
18
14
10
```

Obrázok druhého vstupu:

```vstup
9 12 5

3 1
4 5
7 0
10 5
8 0
0 6
1 10
5 5
6 5

9 7
8 7
8 2
2 6
4 5
7 2
6 7
3 1
8 9
3 5
3 4
1 8

7 1
3 2
3 7
5 2
9 4
```

```vystup
-1
-1
2.5
-1
-1
```

Obrázok tretieho vstupu:

```vstup
5 5 5

0 0
0 4
4 4
4 0
1 1

1 2
2 3
3 4
4 1
4 5

1 1
0 4
3 3
0 2
2 4
```

```vystup
-1
-1
16
-1
-1
```

Obrázok štvrtého vstupu:
","# Svinstvo na koberci

Táto úloha bola fakt ťažká. Dĺžka vzoráku to celkom odzrkadľuje. Nebojte sa teda vzorák spracovávať po kúskoch, kľudne aj vo viacerých sedeniach.

Na získanie $5$ bodov z programu si stačilo len uvedomiť, čo v skutočnosti znamenajú niektoré geometrické pojmy a ako ich vyjadriť v programe. V geometrii totiž častokrát ""vidíme"", že niečo platí, ale nevieme to poriadne zdôvodniť/vyjadriť. Napríklad, čo znamená, že bod $A$ je vo vnútri nejakej oblasti? Čo to vlastne je oblasť, ako môže vyzerať? Nielen týmito otázkami sa budeme zaoberať v nasledujúcej časti.

## Geometria

### Základy

Ak ste sa s výpočtovou geometriou ešte nestretli, odporúčame vám najprv prečítať si v našej kuchárke [Úvod do výpočtovej geometrie](https://www.ksp.sk/kucharka/uvod_do_vypoctovej_geometrie/).

Vo vzorovom riešení sa často využívajú skalárny súčin, a obzvlášť vektorový súčin. Ak vám niekde vo vzoráku nebude jasné, ako je niektorý zo súčinov použitý, môžete hľadať odpovede v odpovedajúcom článku v kuchárke: [Skalárny a vektorový súčin](https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin/)

### Čím je určená oblasť?

Najprv si rozmyslime jednu vec. Naľavo od každej hrany je vždy práve jedna oblasť, a napravo od hrany je vždy práve jedna oblasť. Pritom to môže byť tá istá oblasť, ako naľavo, a obe oblasti môžu byť nekonečné. Je zrejmé, že v oboch smeroch hrana susedí s aspoň jednou oblasť; zároveň vieme prejsť ""tesne"" popri hrane od jedného konca hrany k druhému, takže oblasť môže byť len jedna.

Tento prechod je umožnený tým, že sa hrany grafu nekrižujú, a že na žiadnej hrane neleží tretí bod. Ak by jedna z týchto podmienok bola porušená, mohlo by na jednej strane hrany byť viacero oblastí. Ilustrujeme na nasledujúcom obrázku:

Každá oblasť má teda svoju hranicu, ktorá obsahuje celé hrany. Pretože zadaný graf je súvislý, hranica oblasti musí byť súvislá: ak sú teda nejaké dve hrany na hranici oblasti, vieme sa od jednej hrany dostať k druhej tak, že pôjdeme po okraji. Toto v nesúvislých grafoch nemusí platiť, ako vidno na nasledujúcom obrázku:

Predstavme si teraz, že ideme po okraji oblasti proti smeru hodinových ručičiek. To samozrejme neznamená, že vždy zatáčame doľava, nakoľko oblasť nemusí byť konvexná. Ako je potom ale definovaný smer ""proti smeru hodinových ručičiek""? Je to taký smer, v ktorom je vnútro oblasti vždy na ľavej strane hrany. Môžete si to predstaviť tak, že hranám na okraji oblasti priradíme takú orientáciu, aby bolo vnútro oblasti vždy naľavo od hrany. Samozrejme, sú prípady, kedy je vnútro aj na pravej strane hrany:

V takom prípade pôjdeme pri našom prechode raz v jednom smere pozdĺž takejto hrany, a raz v druhom smere. Takže tento sled, ktorý ""obtiahne"" okraj oblasti, môže niektoré hrany obsahovať dvakrát: raz v jednej orientácii a raz v druhej orientácii.

Orientované hrany budeme v ďalšom texte volať *šípky*. Budeme hovoriť, že šípka patrí tej oblasti, ktorá je naľavo od šípky.

### Ktoré šípky sú na okraji?

Predstavme si, že pri obťahovaní okraju sme sa zastavili na nejakej šípke $A \\to B$. Vieme povedať, ktorá šípka bude nasledovať? Zrejme to bude niektorá šípka vychádzajúca z vrcholu $B$. Ak si nakreslíme všetky šípky vychádzajúce z $B$, nie je ťažké vidieť, že hľadaná šípka bude $B \\to C$ taká, pri ktorej zatočíme čo najviac doľava:

Prečo je toto tá správna šípka? Totiž, vždy vieme ísť tesne popri šípke $A \\to B$ a potom popri $B \\to C$. Pri tomto prechode neprekrížime žiadnu inú šípku, a teda určite patria tieto šipky do tej istej oblasti. Ak by sme skúšali prejsť podobným spôsobom popri iných šípkach vychádzajúcich z vrcholu $B$, križovali by sme niektorú inú šípku.

Takýmto spôsobom vieme pre každú šípku zistiť celú hranicu oblasti, do ktorej patrí. Pretože každá oblasť má na okraji aspoň jednu šípku, vieme týmto spôsobom získať hranice všetkých oblastí. A pretože šípka je len hrana s priradenou orientáciou, získame týmto pre každú hranu informáciu o tom, ktorá oblasť je na jednej strane a ktorá na druhej strane hrany.

Na celý tento proces sa ale dá pozerať aj iným, prirodzenejším, spôsobom. Pre každú šípku máme dve premenné: číslo oblasti, ktorá je na ľavej strane hrany a číslo oblasti, ktorá je na pravej strane. Pritom pre dvojicu navzájom opačných šípok sú tieto dve premenné iba vymenené -- to, čo je naľavo od jednej šípky, je napravo od druhej, a naopak.

Zoberme si teraz všetky šípky vychádzajúce z nejakého bodu $A$ a usporiadajme si ich polárne (podľa uhlu), proti smeru hodinových ručičiek. Potom pre každú dvojicu po sebe idúcich šípok vieme povedať, že oblasť naľavo od prvej z nich je tá istá, ako oblasť napravo od druhej z nich -- teda že sa príslušné premenné rovnajú.

Toto vieme spraviť pre všetky vrcholy, a dostaneme tak sadu rovností nad $2m$ premennými. Premenné, ktoré sa rovnajú, potom reprezentujú tú istú oblasť. Premenné, ktoré sa nerovnajú, reprezentujú rôzne oblasti. Ak si premenné predstavíme ako vrcholy nejakého grafu a rovnosti ako hrany grafu, tak oblasti zodpovedajú súvislým komponentom tohto grafu.

Dostávame tak jednoduchý algoritmus na výpočet okrajov oblastí, bežiaci v čase $O(m \\log m)$, logaritmus kvôli polárnemu usporiadaniu. Aby sme vedeli šípky polárne usporiadať, potrebujeme vedieť pre dva vektory povedať, ktorý je naľavo od ktorého. To vieme určiť podľa znamienka vektorového súčinu.

### Ako vypočítať obsah oblasti?

Ak poznáme hranicu oblasti, vieme aj vypočítať obsah oblasti, nasledovne. Zoberme si ľubovoľný bod v rovine $S$, napríklad $S = (0, 0)$. Hranica oblasti zodpovedá nejakému sledu $A_1 \\to A_2 \\to \\ldots \\to A_n \\to A_1$, proti smeru hodinových ručičiek. Jednoducho teraz vezmeme orientované obsahy trojuholníkov určených dvojicami vektorov

$$ (\\overrightarrow{SA_1}, \\overrightarrow{SA_2}), (\\overrightarrow{SA_2}, \\overrightarrow{SA_3}), \\ldots, (\\overrightarrow{SA_n}, \\overrightarrow{SA_1})$$

a sčítame ich. Tieto orientované obsahy vieme dostať pomocou vektorového súčinu.

Prečo to ale funguje? Zamyslime sa nad najjednoduchším prípadom, keď máme trojuholník $ABC$. Potom náš výraz je súčtom orientovaných obsahov troch trojuholníkov, jeden pre každú stranu $\\triangle ABC$. Ak je bod $S$ vo vnútri $\\triangle ABC$, tak jednotlivé podtrojuholníky budú mať všetky kladný obsah, nakoľko $\\overrightarrow{SA\_{i + 1}}$ je vždy naľavo od $\\overrightarrow{SA_i}$. Ich súčtom dostaneme celý trojuholník. Ak je bod $S$ mimo $\\triangle ABC$, tak jeden alebo dva podtrojuholníky budú záporné, a všetko sa to vyruší tak, že zostane iba $\\triangle ABC$.

Čo v prípade, keď nemáme trojuholník? Každý (aj nekonvexný) mnohouholník sa dá rozdeliť na niekoľko dizjunktných trojuholníkov (tzv. *triangulácia*). Na každý z týchto trojuholníkov vieme aplikovať vyššie uvedené tvrdenie, a dostaneme tak obsah nášho mnohouholníka vyjadreného ako súčet niekoľkých orientovaných trojuholníkov. Každý z týchto trojuholníkov má ako jeden z vrcholov $S$, a ostatné dva vrcholy patria mnohouholníku -- teda každý trojuholník zodpovedá buď niektorej hrane v triangulácii (ktorá oddeľuje dva z trojuholníkov), alebo hrane na obvode mnohouholníka.

My chceme ukázať, že v skutočnosti tam budú vystupovať iba hrany z obvodu mnohouholníka. To je ale zrejmé: každá vnútorná hrana susedí s dvomi podtrojuholníkmi: v jednom z nich bude vnútro trojuholníka naľavo od hrany (a zarátame ho s kladným znamienkom), v druhom z nich bude vnútro trojuholníka napravo od hrany (záporné znamienko).

Pozorný čitateľ si isto všimne jeden zvláštny prípad. Čo sa stane, ak tá oblasť, po okraji ktorej ideme, je nekonečná? Zrejme vypočítame obsah útvaru určeného týmto okrajom (tj. obsah toho, čo je ""skutočne vnútri"", nie vonku). Aké znamienko ale bude mať takto vypočítaný obsah? Definovali sme ""proti smeru hodinových ručičiek"" tak, že vnútro oblasti je naľavo od šípky. Nie je ťažké rozmyslieť si, že pre (jedinú) nekonečnú oblasť je takto definovaný sled v skutočnosti **v smere** hodinových ručičiek:

Dostaneme teda záporný alebo nulový obsah. Pomocou znamienka teda vieme určiť, či je bod vo vnútri nekonečnej oblasti, alebo v konečnej.

Časová zložitosť výpočtu obsahu oblasti je $O(k)$, kde $k$ je počet vrcholov/hrán na okraji oblasti. Nakoľko každá šípka patrí iba do jednej oblasti, a všetkých šípok je $2m$, celková časová zložitosť tohto predrátania je $O(m)$.

## Prvé riešenie

Už teda vieme, ako nájsť hranice všetkých oblastí, a tiež ako podľa týchto hraníc vypočítať obsah oblasti. Aby sme ale vedeli odpovedať na otázky, musíme ešte vedieť pre ľubovoľný bod $X$ povedať, v ktorej oblasti leží, prípadne, že leží na niektorej hrane.

Zistiť, či bod leží na hrane, vieme v čase $O(m)$: iba postupne prejdeme všetky hrany, a pre každú hranou overíme, či na nej $X$ leží alebo nie. Ako to ale overíme? Pomocou vektorového súčinu vieme zistiť, či $X$ leží na priamke určenej touto hranou. Pomocou skalárneho súčinu zistíme, či je $X$ ""vo vnútri"" úsečky alebo mimo nej.

Ak neleží na hrane, ako zistíme, do ktorej oblasti patrí? Vieme sa pozrieť na najbližšiu hranu, ktorá je ""pod"" naším bodom. Hľadaná oblasť je tá, ktorá je ""hore"" od tejto hrany. Ak žiadna hrana pod bodom $X$ nie je, tak bod zrejme neleží v žiadnej konečnej oblasti.

Čo to ale znamená hore? Ak každú (nezvislú) hranu orientujeme tak, že ide zľava doprava (tj. od menších $x$-ových súradníc k väčším), tak ""hore"" znamená ""vľavo"". Budeme hovoriť, že ľavý koniec hrany je jej *začiatok* a pravý koniec hrany je jej *koniec*.

Potrebujeme teda zistiť, ktoré hrany majú spoločnú $x$-ovú súradnicu s naším bodom $X$. (Ak by sme nakreslili zvislú čiaru cez $X$, tak sú to tie hrany, ktoré majú s touto čiarou nejaký spoločný bod.) Spomedzi týchto hrán chceme nájsť tú, ktorá pretína zvislú čiaru cez $X$ čo najvyššie, ale stále pod bodom $X$. Čo ale v prípade, že takýchto najvyšších hrán je viac? Takýto prípad môže nastať jedine vtedy, ak je bod $X$ priamo nad niektorým vrcholom. Ako ukazuje nasledujúci obrázok, nie je jedno, ktorú hranu vyhlásime za najvyššiu:

V takom prípade chceme vybrať takú hranu, ktorá v tom vrchole začína (končí) a ktorá ide čo najrýchlejšie hore (dole). Inak povedané, spomedzi všetkých hrán začínajúcich (končiacich) v tomto vrchole chceme vybrať tú najľavejšiu (najpravejšiu). Porovnať dve hrany, že ktorá je vľavo (vpravo) od ktorej, vieme jednoducho pomocou vektorového súčinu.

Máme tak algoritmus s časovou zložitosťou $O(m)$ na jednu otázku, celková časová zložitosť je teda $O(m \\log m + mq)$. Toto riešenie si vyslúžilo $5$ bodov z testovania.

## Cesta k lepšiemu riešeniu

Potrebujeme urýchliť dve veci: vedieť rýchlo zistiť, či náš bod $X$ leží na niektorej hrane; a vedieť rýchlo nájsť najbližšiu hranu pod naším bodom.

Rozdeľme si prácu trochu inak: ak by sme za hrany pod naším bodom považovali aj tie, ktoré cez nehoprechádzajú, stačilo by nám v prvej časti overovať iba zvislé hrany. Ak totiž $X$ leží na nezvislej hrane, bude to najvyššia hrana pod $X$. Nezvislé hrany teda vieme vybaviť tak, že pre najvyššiu hranu pod $X$ overíme, či na nej $X$ leží alebo nie.

Ako zistiť, či náš bod leží na nejakej zvislej hrane? Jednoducho: spomedzi vrcholov s rovnakou $x$-ovou súradnicou nájdeme ten vrchol $A$, ktorý je najvyššie, ale stále nižšie, ako $X$. Ak náš bod leží na zvislej hrane, musí to byť zvislá hrana, ktorá vychádza z $A$ a ide ""hore"". Stačí si teda usporiadať všetky vrcholy primárne podľa $x$-ovej, sekundárne podľa $y$-ovej súradnice, a pre každý vrchol si zapamätať (najviac jednu) šípku hore, ktorá z neho vychádza. V tomto zozname potom binárne vyhľadáme najväčší bod menší rovný $X$ a overíme, či $X$ leží na šípke hore alebo nie.

Ako ale rýchlo nájsť tú hranu, ktorá je pod $X$? Ak by sme mohli riešiť úlohu offline, teda ak by sme vedeli dopredu všetky otázky, vedeli by sme použiť prístup zvaný *zametanie*.

### Offline zametanie

Ak by sme mali k dispozícii všetky otázky dopredu, mohli by sme sa rozhodnúť ich spracovať v nejakom konkrétnom poradí. Napríklad si môžeme všimnúť, že keď bod $X$ iba trochu posunieme doprava alebo doľava, množina hrán, ktoré sú pod alebo nad $X$, sa zmení iba trochu. V probléme je istá *lokálnosť*. Dobré poradie, v ktorom spracovať otázky, je potom napríklad zľava doprava.

Predstavme si teda, že nekonečne vľavo máme zvislú priamku, tzv. *zametaciu čiaru*, ktorá sa posúva doprava. Táto čiara nám postupne bude ""skenovať"" všetky hrany a všetky otázky. Keď čiara narazí na začiatok alebo koniec hrany, upraví svoj stav (tj. ktoré hrany ju pretínajú), a keď čiara narazí na otázku, na základe svojho stavu ju zodpovie.

Konkrétnejšie, keď čiara narazí na ľavý koniec hrany, túto hranu pridá do množiny hrán, s ktorými máme aktuálne priesečník. Keď čiara narazí na pravý koniec hrany, danú hranu z množiny vyhodí. A nakoniec, keď narazí na bod $X$ reprezentujúci otázku, nájde spomedzi všetkých aktuálnych hrán tú, ktorá má na tejto $x$-ovej súradnici priesečník čo najvyššie, ale stále nižšie alebo rovnako vysoko, ako je $X$.

Zametacia čiara nám teda musí byť schopná povedať, ktorá hrana je na aktuálnej $x$-ovej súradnici ""tesne pod"" bodom $X$. Tiež musíme vedieť do nej pridávať a odoberať hrany. Vhodnou dátovou štruktúrou na toto je vyvažovaný vyhľadávací strom, v ktorom budeme mať hrany usporiadané podľa ich aktuálnej $y$-ovej súradnice (tj. v akej výške pretínajú zametaciu čiaru).

Môžeme si ho ale dovoliť použiť? V našom prípade je totiž výsledok porovnania dvoch hrán závislý od toho, aká je $x$-ová pozícia zametacej čiary. Nemôže sa počas posúvania čiary stať, že sa výsledky niektorých porovnaní zmenia, a štruktúra stromu už nebude korektná? Dve hrany zmenia svoje relatívne poradie jedine vtedy, keď sa krížia. To sa ale v našom planárnom grafe nikdy nestane: pred tým, než by k tomu došlo, by jedna alebo obe hrany skončili v niektorom (možno v tom istom) vrchole.

Môže sa ale stať, že dve hrany skončia v jednom a tom istom vrchole; alebo že jedna hrana skončí vo vrchole, v ktorom druhá hrana začne; alebo že obe hrany začnú v tom istom vrchole. V tom momente ich nie sme schopní porovnať, lebo ich priesečníky so zametacou čiarou budú ten istý bod. Pritom ale nie je jedno, ktorú z tých hrán prehlásime za väčšiu a ktorú za menšiu.

Ak totiž dve hrany začínajú v tom istom vrchole, v tom momente ich síce nevieme porovnať, ale hneď v nasledujúcom momente (tj. keď sa zametacia čiara posunie o máličko doprava) ich budeme vedieť porovnať: tá hrana, ktorá rastie rýchlejšie (je viac vľavo), je tá väčšia. Teda pri pridávaní nových hrán ich musíme do stromu dať podľa toho.

Naopak, ak dve hrany končia v tom istom vrchole, v tom momente ich síce nevieme porovnať, ale v predchádzajúcom momente sme ich vedeli porovnať: tá hrana, ktorá klesá rýchlejšie (je viac vpravo), je väčšia. Ak by sme ale toto pri mazaní hrany odignorovali, mohli by sme omylom zmazať tú nesprávnu hranu.

A čo v treťom prípade, keď jedna hrana začína v tom vrchole, v ktorom iná hrana končí? Našťastie sa tomuto prípadu vieme vyhnúť tým, že najprv vybavíme všetky hrany končiace vo vrchole, a až potom všetky hrany začínajúce vo vrchole. Týmto zaručíme, že nikdy nebudeme mať v našom vyhľadávacom strome hranu, ktorá v nejakom vrchole začína spolu s hranou, ktorá v tomto vrchole končí.

Takže naše porovnávanie bude závisieť nielen od toho, aká je momentálna $x$-ová súradnica zametacej čiary, ale aj od toho, či sa k nej blížime zľava (vybavujeme konce hrán) alebo sa od nej vzďaľujeme doprava (vybavujeme začiatky hrán). Týmto sme vybavili všetky možné prípady.

Drobný technický detail: vo vyhľadávacom strome vieme porovnávať iba dve hrany, nevieme porovnať bod a hranu. Nebudeme teda porovnávať priamo s bodom $X$, ale s akousi pomocnou hranou, ktorá bude prechádzať cez $X$. Aký bude jej sklon? Nemôže byť ľubovoľný: chceme totiž, aby všetky hrany prechádzajúce cez $X$ boli menšie, aby sme vedeli detekovať, že $X$ leží na hrane. Takže podľa toho, či sa zľava blížime do $x$, alebo sa od neho sprava vzďaľujeme, nastavíme sklon hrany na ""takmer zvislo hore"" alebo ""takmer zvislo dole"".

Na začiatku musíme všetky začiatky, konce hrán a otázky utriediť, čo trvá $O((m + q) \\log {(m + q)})$. Samotné zametanie trvá rovnako dlho, nakoľko v každom kroku robíme jednu operáciu s vyvažovaným vyhľadávacím stromom (`insert`, `delete` alebo `lower_bound`), ktorá trvá $O(\\log {(m + q)})$. Celková časová zložitosť je teda $O((m + q) \\log {(m + q)})$.

Toto riešenie si samozrejme vyslúžilo $0$ bodov, so správou `TLE` -- čakalo totiž na všetky otázky, ktoré mu testovač nebol ochotný dať...

## Perzistentný stav čiary

Ak by sme sa vedeli pozrieť na stav zametacej čiary v ľubovoľnom momente, nemuseli by sme všetky otázky zodpovedať od najľavejšej po najpravejšiu. Stačilo by sa pre každú otázku $(x, y)$ pozrieť na stav zametacej čiary v momente $x$, a podľa neho odpovedať.

Potrebujeme si teda zapamätať celú históriu zametacej čiary a vedieť v nej vyhľadať posledný stav, ktorý predchádzal otázke $X$. Takýmto ""historickým"" dátovým štruktúram (ktoré si vedia pamätať nielen ich aktuálny stav, ale aj všetky predchádzajúce) sa hovorí *perzistentné dátové štruktúry*.

Jedna možnosť je zakaždým, keď chceme zmeniť stav čiary, celý stav skopírovať a vykonať zmenu v kópii. Tieto stavy si potom uložíme do poľa, a pre každý stav si budeme pamätať, v akom časovom momente začal. V tomto poli potom budeme pri otázke $(x, y)$ vedieť binárne vyhľadať poslednú verziu pred (alebo zarovno s) $x$.

Toto je ale pomalé: pri každej udalosti musíme skopírovať celý strom, čo trvá až $O(m)$. Udalostí je tiež $O(m)$, predpočítanie teda bude trvať až $O(m^2)$, a pamäťová zložitosť bude rovnaká.

My si ukážeme dve prístupy, ktoré dosahujú lepšiu časovú zložitosť: *fat nodes* a *path copying*.

### Fat nodes

Pri programovaní používame rôzne objekty, a každý objekt si vieme predstaviť ako zoskupenie niekoľkých údajov, nie nutne rovnakých typov. Napríklad vrchol vo vyhľadávacom strome môže obsahovať tieto údaje: ukazovateľ na ľavého syna, pravého syna, a čo je vo vrchole.

Štandardne, keď zmeníme jeden z týchto údajov na iný, stratíme pôvodnú hodnotu. Nevieme ale zmeny údajov spracovať iným spôsobom, tak, aby sa nám zachovala aj pôvodná informácia? Vieme. Budeme si pamätať všetky doterajšie verzie údaju, a pre každú verziu aj čas, kedy táto verzia vznikla (tj. kedy nahradila starú verziu). Keď teraz chceme pristúpiť k údaju v (diskrétnom) čase $t$, iba binárne vyhľadáme, akú hodnotu v tom čase mal, a vrátime ju. Toto spôsobí iba mierne spomalenie: konkrétne, všetko bude $O(\\log t)$-krát pomalšie, kde $t$ je počet verzii údaju. Pamäť bude ale až $O(t)$ namiesto $O(1)$.

Ak náš vyhľadávací strom implementujeme týmto spôsobom, dostaneme perzistentný vyhľadávací strom. Samozrejme, potrebujeme vyvažovaný vyhľadávací strom, napríklad [treap](https://www.ksp.sk/kucharka/treap/).

Otázka je, o koľko pomalší bude oproti pôvodnému stromu. Udalostí (začiatok alebo koniec hrany) je $O(m)$. Pri každej udalosti sa zmení nanajvýš $O(\\log m)$ vrcholov stromu, a ""narazíme"" pri binárnom vyhľadávaní nanajvýš na všetky doterajšie zmeny. Pred $i$-tou udalosťou bolo týchto zmien $O(i \\log m)$, na jeden vrchol teda pripadá spomalenie $O(\\log \\frac{i \\log m}{\\log m}) = O(\\log i)$.

Spomalenie jednej operácie je teda $O(\\log m)$ a časová zložitosť predpočítania teda bude $O(m \\log^2 m)$. Podobne, zodpovedanie jednej otázky bude o $O(\\log m)$ pomalšie, a teda dokopy $O(q \\log^2 m)$. Pamäťová zložitosť bude $O(m \\log m)$, nakoľko každá zmena prispeje $1$.

### Path copying

Predstavme si, že objekty, ktoré už existujú, nevieme meniť. Jediné, čo vieme robiť, je vytvárať zo starších objektov nové. Takémuto prístupu k programovaniu sa hovorí aj *funkcionálne programovanie*.

Načo také niečo je? Dá sa takto vôbec programovať? Ako to súvisí s perzistentnými dátovými štruktúrami? Hneď uvidíme.

Predstavme si, že chceme funkciu, ktorá zmení stav nejakého objektu. Napríklad vezme ako vstup zoznam čísel a na jeho koniec pridá číslo $4$. Nevieme to spraviť priamo, nakoľko nevieme zmeniť stav vstupného zoznamu. Vieme ale spraviť funkciu, ktorá nám vráti nový zoznam, ktorý bude reprezentovať nový stav vstupného zoznamu. Napríklad ak vstupom je $a = [1, 2, 3]$, výstupom bude nejaké $b = [1, 2, 3, 4]$. Zoznam $a$ ale stále obsahuje pôvodné údaje.

No a tu si môžeme uvedomiť, že čo sa v podstate stalo je, že sme síce dostali novú verziu objektu, ale máme aj starú verziu objektu. Ak by sme týmto prístupom implementovali náš vyhľadávací strom, dostali by sme perzistentný vyhľadávací strom.

Presnejšie, každý vrchol stromu reprezentuje vyhľadávací storm zodpovedajúci podstromu tohto vrcholu. Každá operácia, ktorá mení stav podstromu (`insert`, `delete` a rotácie) nám strom nezmení, ale vráti nový vrchol reprezentujúci nový stav (pod)stromu. Tieto operácie sú z veľkej časti definované pomocou operácii na synoch.

Ilustrujeme operáciu `insert` na nevyvažovanom vyhľadávacom strome nad číslami. Keď chceme vložiť číslo $5$ do koreňa, chceme ho vložiť do ľavého syna, lebo $5$ je menšie ako číslo v koreni. Takže výsledkom insertu bude niečo ako `strom(lavy_syn->insert(5), hodnota_v_koreni, pravy_syn)`, kde `strom` je konštruktor (vytvorí nový strom s daným ľavým synom, danou hodnotou v koreni, a s daným pravým synom). To isté sa potom udeje aj v ľavom synovi, ..., až kým nedôjdeme do listu. Dostaneme tak $O(h)$ nových vrcholov, kde $h$ je hĺbka stromu.

Prístup sa volá *path copying* podľa toho, že v podstate pri každej zmene skopírujeme celú cestu od listu až ku koreňu, a kópiu upravíme. Samozrejme, pre efektívnosť potrebujeme strom vyvažovať, my sme (opäť) zvolili [treap](https://www.ksp.sk/kucharka/treap/).

Aká je časová a pamäťová zložitosť? Vždy, keď sa v najaktuálnejšej verzii stromu zmení nejaký vrchol, musíme zmeniť (skopírovať) aj všetkých jeho predkov. Pri každej operácii v štandardnom treape sa zmení vždy nanajvýš $O(\\log m)$ vrcholov, z tohto by plynul (časový aj pamäťový) odhad $O(\\log^2 m)$ na jednu operáciu. Avšak ukazuje sa, že všetky tieto zmeny v treape sú ""zarovnané"", tj. že väčšinou sa mení iba jeden vrchol a jeho predkovia. Z toho vyplynie lepší odhad $O(\\log m)$.

Časová zložitosť predpočítania teda bude $O(m \\log m)$, pamäťová zložitosť bude rovnaká. Zodpovedanie otázok bude trvať $O(q \\log m)$. Toto je lepšie, ako v prístupe fat nodes.

### Záverečné poznámky

Dátovým štruktúram, ktorých stav sa nemení (ang. *immutable*) a vedia iba vracať nové objekty, sa hovorí *funkcionálne dátové štruktúry*. Ich výhodou oproti iným implementáciám perzistencie je, že sme schopní ""pokračovať"" nielen v aktuálnej verzii objektu, ale aj v starých verziách. Časová os teda nemusí byť os, môže to byť aj strom.

Naproti tomu ale existuje implementácia perzistentného treapu, ktorá potrebuje menej pamäte: iba $O(1)$ amortizovane na každú zmenu, oproti $O(\\log m)$ v prípade funkcionálneho treapu. Pre záujemcov odporučím [tento článok](http://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf) od legiend Sleatora a Tarjana, strany $93$ až $97$.
",10
c75fbabb55608fa8,ksp,"# Lenivé prasa

V jeden zimný deň si Buj povedal, že bude lenivé prasa. Namiesto toho, aby šiel poctivo do školy, vybral sa do supermarketu, nakúpil neskutočne veľa čokolády, a potom ju zvyšok dňa konzumoval.

V ten deň zadal pán profesor algebry domácu úlohu. Buj sa o nej síce dozvedel z internetovej stránky predmetu, ale keďže na hodine nebol, netuší, ako ju má riešiť. Pomôžte mu!

## Úloha

V tejto úlohe budeme pracovať s *kompletne uzátvorkovanými výrazmi*. Tie si definujeme takto:

- Reťazec $a$ (jedno konkrétne písmeno *a*) je kompletne uzátvorkovaný výraz.
- Ak $A$ a $B$ sú kompletne uzátvorkované výrazy, tak aj $(A + B)$ je kompletne uzátvorkovaný výraz.
- Nič, čo sa nedá vyskladať postupným použitím dvoch predchádzajúcich pravidiel, nie je kompletne uzátvorkovaný výraz.

Podľa tejto definície sú kompletne uzátvorkované výrazy napríklad $a$, $(a+a)$, $((a+a)+a)$ a $(((a + a) + (a + a)) + ((a + a) + (a + a)))$. **Vonkajšie zátvorky** vo výrazoch **vynechávame**. Napríklad, namiesto $(a+(a+a))$ píšeme $a+(a+a)$.

Na vstupe dostanete dva kompletne uzátvorkované výrazy. O nich chceme dokázať, že sa rovnajú. Môžeme pritom použiť iba *asociatívny zákon*, ktorý hovorí, že $A+(B+C) = (A+B)+C$. V podstate teda chceme previesť prvý výraz na druhý, pričom sú povolené len dve operácie:

- Ak v našom výraze máme podvýraz tvaru $(A+B)+C$, tak ho môžeme prepísať na $A+(B+C)$. Napríklad výraz $$a + ((, \\overbrace{(a + a)}^{A} + \\overbrace{\\vphantom{(}a}^{B}) + \\overbrace{(a + a)}^{C},)$$ môžeme prepísať na $$a + (, \\overbrace{(a + a)}^{A} + (\\overbrace{\\vphantom{(}a}^{B} + \\overbrace{(a + a)}^{C},)) \\text{.}$$ Tejto operácii budeme hovoriť *rotácia doprava*.

- Prepísaniu opačným smerom, teda nahradenie podvýrazu tvaru $A+(B+C)$ výrazom $(A+B)+C$, budeme hovoriť *rotácia doľava*.

Vašou úlohou je nájsť postupnosť rotácii, ktorou prevedieme prvý výraz na druhý.

## Formát vstupu

Na prvom riadku vstupu je kladné číslo $t$: počet testov. Nasledujú popisy jednotlivých testov. Každý test začína prázdnym riadkom, za ktorým nasledujú dva riadky obsahujúce jednotlivé výrazy. Môžete predpokladať, že oba výrazy majú rovnakú dĺžku, $n$.

Je osem sád testovacích vstupov, obmedzenia pre jednotlivé sady sú nasledovné:

| Sada | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | |:----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:| | $t \\leq$ | $1,000$ | $100$ | $10$ | $1$ | $1$ | $1$ | $1$ | $1$ | | $n \\leq$ | $40$ | $120$ | $400$ | $1,200$ | $4,000$ | $12,000$ | $40,000$ | $400,000$ |

## Formát výstupu

Pre každý test vypíšte postupnosť rotácii, ktorou prevedieme prvý výraz na druhý, v nasledujúcom formáte. Na prvom riadku nech je dĺžka postupnosti, $k$, a na nasledujúcich $k$ riadkoch nech sú popisy jednotlivých rotácii v poradí, v akom ich vykonáme.

Očíslujme si znaky $+$ v našom výraze zľava doprava $1, 2, \\ldots$, teda ak by sme z výrazu vynechali zátvorky, dostali by sme

$$a +\_1 a +\_2 a +\_3 a +\_4 \\ldots$$

Rotáciu doprava z $(A +\_i B) +\_j C$ na $A +\_i (B +\_j C)$ zapíšeme ako riadok ""$j$ R"". Podobne, rotáciu doľava z $A +\_i (B +\_j C)$ zapíšeme ako ""$i$ L"".

## Príklady

```vstup
2

a+(a+(a+a))
((a+a)+a)+a

(a+a)+(a+a)
a+((a+a)+a)
```

```vystup
2
1 L
2 L
3
2 L
2 R
3 R
```

*Prvý postup:* $$a+(a+(a+a))\\ \\rightarrow\\ (a+a)+(a+a)\\ \\rightarrow\\ ((a+a)+a)+a$$ *Druhý postup:* $$(a+a)+(a+a)\\ \\rightarrow\\ ((a+a)+a)+a\\ \\rightarrow\\ (a+(a+a))+a\\ \\rightarrow\\ a+((a+a)+a)$$ *Všimnite si, že druhý test sa dá vyriešiť aj na dve rotácie. Nám však stačí vypísať ľubovoľný funkčný postup.*
","# Lenivé prasa

## Reprezentácia výrazu

S výrazom chceme vedieť robiť rotácie. Ak by sme ale pracovali s jeho textovou reprezentáciou, tak by sme zistili, že je to dosť nešikovné.

Zamyslime sa nad tým, čo to je kompletne uzátvorkovaný výraz. Je to buď $a$, alebo $(A + B)$ pre nejaké kompletne uzátvorkované podvýrazy $A, B$. Teda ak sme kompletne uzátvorkovaný výraz, musíme si pamätať, či sme prvého alebo druhého typu. A ak sme druhého typu, tak si musíme tiež pamätať ľavý podvýraz a pravý podvýraz. Z tejto úvahy vidno, že sa na výrazy dá pozerať ako na binárne stromy: koreň reprezentuje celý výraz, ľavý syn reprezentuje ľavý podvýraz a pravý syn reprezentuje pravý podvýraz.

Napríklad výrazu $(a + a) + (a + (a + a))$ prislúcha nasledujúci strom:

Na strome vieme rotáciu implementovať jednoducho: vrcholy pospájame hranami trochu iným spôsobom. Na obrázku nižšie ilustrujeme rotácie v oboch smeroch.

Ako ale z textovej reprezentácie dostaneme reprezentáciu stromovú? Tejto otázke je venovaná nasledujúca časť.

## Parsovanie

Kedže ťažiskom úlohy nie je parsovanie, uvedieme tu iba rýchly algoritmus, ktorý nám z textovej reprezentácie vyrobí strom v čase $O(n)$.

Myšlienka je taká, že budeme strom vyrábať od koreňa k listom, rekurzívne. Predstavme si, že nám zo vstupu postupne prichádzajú znaky výrazu, a my si chceme postupne vybudovať jeho strom. Máme niekoľko možností:

- Buď je prvý znak výrazu `a`, v takom prípade je náš výraz určite $a$. Jemu prislúchajúci strom pozostáva iba z jedného vrcholu.

- Alebo je prvý znak `(`. Potom je výraz je zložený, teda má tvar $(A + B)$ pre nejaké podvýrazy $A$ a $B$. Uvedomme si, že ďalej na vstupe dostaneme podvýraz $A$, potom `+`, potom podvýraz $B$ a nakoniec `)`. Stačí nám preto rekurzívne vybudovať strom pre $A$ (pričom ho celý prečítame), potom prečítame `+`, rekurzívne zostrojíme strom pre $B$, a nakoniec prečítame `)`. Stromy zavesíme pod spoločný koreň reprezentujúci prečítané `+`.

Každý znak výrazu prečítame iba raz, preto je časová zložitosť algoritmu lineárna od dĺžky výrazu, teda $O(n)$. Pamäťová zložitosť je $O(n)$.

## Rotovanie

Všetky naše algoritmy, pomalé či rýchle, budú založené na nasledovnom pozorovaní: keď na strom použijeme rotáciu, vhodnou rotáciou sa vieme vrátiť k pôvodnému stromu (viď obrázok vyššie).

Nemusíme teda priamo upravovať výraz $A$ na $B$, stačí nám oba výrazy upraviť na ten istý tvar $C$ (tvar $C$ budeme volať *normálny tvar* ). Na úpravu $B$ na $C$ sa potom pozrieme odzadu, čím dostaneme úpravu $C$ na $B$. Spolu s úpravou $A$ na $C$ nám to dokopy dá hľadanú úpravu $A$ na $B$.

Tvar $C$ chceme z výrazov určit jednoznačne. Je prirodzené za tento *normálny tvar* zvoliť *najľavejšie uzátvorkovanie* výrazu, teda $((((\\ldots + a) + a) + a) + a)$. Tomu zodpovedá nasledovný strom:

(Rovnako dobre by sme ale mohli použiť *najpravejšie uzátvorkovanie*, teda $(a + (a + (a + (a + \\ldots))))$.)

### Pomalé rotovanie

Chceme upraviť výraz $(A + B)$ na normálny tvar. Ťažko sa ale rozmýšľa nad prípadom, keď $A$ a $B$ môžu byť ľubovoľné. Ak by $A$ a $B$ mali nejaký konkrétny tvar, tak by sa nám s nimi možno ľahšie pracovalo. Už sa tu spomínali normálne tvary, ak by sme uvažovali tie, tak by sme mali navyše tú výhodu, že $A$ a $B$ by sme do nich vedeli dostať rekurzívne.

Predstavme si preto, že by $A$ bol v najľavejšom uzátvorkovaní a $B$ v najpravejšom. (Ako uvidíme, takáto voľba bude viesť k tomu, že veci budú vychádzať pekne.) Teda celý výraz vyzerá nasledovne:

$$(\\overbrace{((((\\ldots + a) + a) + a) + a)}^{l} +\_l \\overbrace{(a + (a + (a + (a + \\ldots))))}^r)$$

kde $l$ označuje počet $a$-čok v $A$ a $r$ označuje počet $a$-čok v $B$. Čo sa s výrazom stane, ak by sme spravili rotáciu doľava na $+$ spájajúcom $A$ a $B$? Dostali by sme

$$(\\overbrace{((((\\ldots + a) + a) + a) + a)}^{l + 1} + \\overbrace{(a + (a + (a + (a + \\ldots))))}^{r - 1})$$

Teda vhodným počtom rotácii doľava vieme náš výraz dostať do najľavejšieho uzátvorkovania. Podobne vhodným počtom rotácii doprava vieme výraz dostať do najpravejšieho uzátvorkovania. Čo je presne to, čo chceme docieliť.

Predpokladali sme ale, že podvýraz $A$ je v najľavejšom uzátvorkovaní a $B$ v najpravejšom. To vo väčšine prípadov neplatí, čo s tým? Stačí ich na začiatku rekurzívne upraviť na požadovaný tvar.

Naša rekurzívna funkcia sa zavolá do každého vrcholu stromu práve raz, pričom v každom volaní urobíme nanajvýš $O(n)$ roboty. To znamená, že určite nerobíme dokopy viac ako $O(n^2)$ roboty. Ukazuje sa, že na najhorších vstupoch^[Príklad zlého vstupu je ""cik-cakový"" strom, ktorý dostaneme z výrazu $(a + \\dots ((a+((a+(a+a))+a))+a)) \\dots + a))$.] naozaj urobíme až kvadraticky veľa práce, teda časová zložitosť je $\\Theta(n^2)$. Pamäťová zložitosť je $O(n)$, nakoľko pracujeme iba so stromom výrazu.

### Rýchle rotovanie

Najprv algoritmus popíšeme a potom ukážeme, prečo je rýchly.

Ak má strom iba jeden vrchol, tak už je v najľavejšom uzátvorkovaní (reprezentuje výraz $a$). V opačnom prípade je koreň `+`, má ľavého aj pravého syna. Vtedy urobíme nasledovné:

1. Kým platí, že pravý syn koreňa nie je list (pravý podstrom koreňa obsahuje aspoň dva vrcholy), robíme rotácie doľava okolo aktuálneho koreňa. Pri každej takejto rotácii sa nám zmení koreň, pričom nový koreň bude mať pravý podstrom o niečo menší, než mal ten starý. Po konečnom počte krokov teda prídeme k stromu, kde je pravý syn koreňa list (zodpovedajúci výraz má tvar $(A + a)$).

1. Ľavý podstrom koreňa rekurzívne upravíme na najľavejšie uzátvorkovanie.

Prečo je tento algoritmus rýchly? Pozerajme sa v priebehu algoritmu na *ľavú diagonálu* -- tak budeme volať množinu vrcholov, ktoré vieme dosiahnuť z koreňa tak, že sa niekoľkokrát presunieme po hrane do ľavého syna.

Vrchol, okolo ktorého rotujeme (teda koreň podstromu spracovávaného v aktuálnom volaní našej rekurzívnej funkcie), leží vždy na tejto diagonále. Pri každej rotácii sa počet vrcholov na tejto diagonále zväčší o $1$ (rozmyslite si). Počet vrcholov na diagonále nemôže byť väčší, ako počet vrcholov stromu $n$, teda spravíme nanajvýš $n$ rotácii. Časová zložitosť je preto $O(n)$. Pamäťová zložitosť je $O(n)$.
",6
8e0f3e1940252073,ksp,"# Otravné notifikácie

Baklažán má konečne nový mobil. A nie hocijaký. Je to novučičký KSP Nokia Lumia S6, limitovaná edícia, s umelou inteligenciou na každom pixeli. Konečne totiž pochopil, že tie smartfóny sú v skutočnosti celkom užitočné, keď mu na starom mobile došla pamäť pri vkladaní nového kontaktu.

Jeho nový mobil sa mu ale bohužiaľ snaží dokázať opak: vyhadzuje jednu notifikáciu za druhou, s náhodnou informačnou hodnotou. Nemôže ich všetky ignorovať, lebo čo ak tá nasledujúca bude dôležitá? Už mu dochádza trpezlivosť... Koľko notifikácii ešte bude musieť dnes prečítať?

## Úloha

Na začiatku nie sú na mobile žiadne neprečítané notifikácie. Následne prichádzajú tri typy udalostí:

1. Aplikácia $x$ vygenerovala jednu novú (neprečítanú) notifikáciu.
1. Baklažán prečítal všetky (neprečítané) notifikácie od aplikácie $x$.
1. Baklažán prečítal prvých $t$ neprečítaných notifikácii. Môžete predpokladať, že Baklažán má aspoň toľko neprečítaných notifikácii, ale môže ich mať aj viac.

Po každej udalosti vypíšte, koľko notifikácii je ešte neprečítaných. (Do toho sa nerátajú notifikácie, ktoré ešte neboli vygenerované.)

## Formát vstupu

Na prvom riadku vstupu sú dve čísla oddelené medzerou: počet aplikácii $n$ a počet udalostí $q$. Platí $1 \\leq n, q \\leq 500,000$.

Každý z nasledujúcich $q$ riadkov popisuje jednu udalosť. Popis udalosti má nasledovný formát: `1 <x>`, `2 <x>` a `3 <t>` postupne pre udalosti prvého, druhého a tretieho typu. Platí $1 \\leq x \\leq n$ (aplikácie číslujeme od $1$) a $1 \\leq t$.

## Formát výstupu

Vypíšte $q$ riadkov, na $i$-tom z nich nech je počet zostávajúcich notifikácii po $i$-tej udalosti.

## Hodnotenie

Sú $4$ testovacie sady, každá za $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | :----:| :-------:| :--------:| :----------:| | $n, q \\leq$ | $500$ | $5,000$ | $50,000$ | $500,000$ |

## Príklad

```vstup
3 4
1 3
1 1
1 2
2 3
```

```vystup
1
2
3
2
```

```vstup
2 4
1 1
1 2
3 1
2 1
```

```vystup
1
2
1
1
```

*Pri tretej udalosti Baklažán prečíta notifikáciu aplikácie $1$, nakoľko tá je prvá v poradí. Pri štvrtej udalosti nič neprečíta, lebo aplikácia $1$ už nemá žiadne ďalšie notifikácie.*

```vstup
4 7
1 2
1 4
1 2
2 3
1 3
3 1
3 1
```

```vystup
1
2
3
3
4
3
2
```

*Pri štvrtej udalosti Baklažán nič neprečíta, lebo sa pozerá na aplikáciu $3$, ktorá vtedy ešte nič nevygenerovala.*
","# Otravné notifikácie

## Jednoduchá simulácia

Neprečítané notifikácie si vieme predstaviť, že sú usporiadané do radu podľa toho, kedy prišli. Na začiatku radu sú najstaršie notifikácie, na konci najnovšie. Jednotlivé udalosti potom zodpovedajú nasledovným operáciám:

- Keď príde nová notifikácia, tak ju umiestnime na koniec radu.

- Keď prečítame všetky notifikácie od aplikácie $x$, z radu vyhodíme všetky také notifikácie. Na to si potrebujeme pre každú notifikáciu pamätať, od ktorej aplikácie pochádza.

- Keď prečítame prvých $t$ notifikácii, z radu vyhodíme prvých $t$ prvkov.

Náš rad je ale neštandardný, požadujeme totiž od neho nielen to, aby sme vedeli pridávať na koniec a mazať odpredu, ale aj to, aby sme vedeli mazať z vnútra radu. Ako to implementovať?

Aby sme vedeli pristupovať do vnútra radu, reprezentujeme si rad štandardne vo vnútri poľa.^\[Viac o rade a príbuzných štruktúrach nájdete tu: [https://www.ksp.sk/kucharka/stack_queue_deque/](https://www.ksp.sk/kucharka/stack_queue_deque/)\] Máme dva smerníky: jeden na začiatok radu a jeden na koniec radu. Obsah radu je tvorený prvkami, ktoré sa v poli nachádzajú za začiatkom, ale pred koncom, pričom ""za"" chápeme cyklicky (za posledným políčkom poľa nasleduje prvé). Takýto rad vie mať iba toľko prvkov, koľko je dĺžka poľa. To nám ale nevadí: za celý život nám príde nanajvýš $q$ notifikácii, stačí teda dĺžka poľa $q$.

V takejto reprezentácii vieme pristupovať k prvkom radu. Čo ale keď chceme niektorý z nich zmazať? Stačí si pre jednotlivé prvky (t.j. políčka poľa) pamätať, či už boli zmazané alebo nie. Pri všetkých operáciách potom ignorujeme už zmazané prvky.

- Ak chceme posunúť začiatok radu (napríklad lebo sme prečítali prvú $1$ neprečítanú notifikáciu), tak preskočíme na prvý ešte-nezmazaný prvok.
- Štandardne sa dĺžka radu dá vypočítať tak, že od seba odrátame pozície smerníkov na koniec a na začiatok radu, modulo dĺžka poľa. V tomto prípade ale nie všetky prvky medzi začiatkom a koncom skutočne sú v rade. Dĺžku radu si preto musíme explicitne počítať.

V skutočnosti sa dá zaobísť aj bez operácie ""zmaž prvok vo vnútri"". Pre záujemcov uvádzame zdrojový kód, skúste z neho sami vyčmuchať, že ako.

Implementácia s použitím modernejších dátových štruktúr, ako je pole ---použijeme dynamické pole `std::vector`.

Pamäťová zložitosť je $O(q)$. Časová zložitosť sa ale ukáže byť až $O(nq)$. Pozrime sa na zložitosti jednotlivých operácii nad radom.

Príchod novej notifikácie máme v čase $O(1)$. Prečítanie prvých $t$ notifikácii trvá v najhoršom prípade toľko, koľko je prvkov medzi smerníkom na začiatok a na koniec, takže na prvý pohľad táto operácia trvá dlho. Ak sa ale pozrieme na ""big picture"", tak si uvedomíme, že pri tejto operácii sa nám smerník na začiatok vždy posunie v poli dopredu. Nikdy nepretečie, lebo notifikácii je len $q$ a viac ich proste z radu nevyberieme. Pritom pole je dlhé tiež $q$, teda sa tam všetky notifikácie zmestia. Takže dokopy nám tieto operácie tiež zaberú len $O(q)$. ^[Odbornými slovami, táto operácia zaberá čas $O(1)$ amortizovane ---niektoré jej volania síce budú trvať dlho, avšak dokopy to v priemere vyjde len $O(1)$.]

Problém ale nastáva, keď chceme prečítať všetky notifikácie niektorej aplikácie. Na to potrebujeme z radu vyhodiť nejaké vnútorné prvky---my postupne prejdeme všetky prvky radu, a o každom rozhodneme, či ho chceme alebo nie. Tento postup môže trvať až $O(q)$, pričom niekedy za toľko veľa práce nemáme veľmi čo ukázať. Napríklad keď prečítame všetko od aplikácie $1$, môže sa stať, že prejdeme celý rad dlhý $O(q)$ a zistíme, že žiadna notifikácia od aplikácie $1$ v ňom nie je. Spravili sme teda veľa práce, ktorú sme si možno mohli ušetriť.

## Vzorové riešenie

Vyššie uvedená analýza nám hovorí, ktorú operáciu potrebujeme urýchliť: čítanie všetkých notifikácii niektorej aplikácie. Ak by sme si vedeli nejakým spôsobom pre každú aplikáciu pamätať, v ktorých políčkach poľa sú jej notifikácie, vyhrali by sme.

No ale to vieme spraviť, nie? Iba si pre každú aplikáciu udržujeme zoznam políčok, na ktorých sa nachádzajú jej notifikácie.

- Keď príde nová notifikácia, tak príslušnej aplikácii na koniec zoznamu pridáme pozíciu v poli, kam notifikácia prišla.
- Keď prečítame všetky notifikácie aplikácie, tak iba prejdeme tie prvky poľa, ktoré sú v jej zozname, a označíme ich za zmazané. Zoznam potom vyprádznime.
- Čo ale, keď prečítame prvú neprečítanú notifikáciu? Celkom vhod nám príde, že je prvá---v zozname pre danú aplikáciu je teda určite na začiatku. Stačí je teda vymazať.

Od týchto zoznamov teda požadujeme len toľko, aby sme vedeli pridávať na koniec, prejsť cez všetky prvky, a mazať zo začiatku. Tieto požiadavky spĺňa (opäť) dátová štruktúra rad. Tentokrát na implementáciu ale nepoužijeme pole, nakoľko nemáme dobrý horný odhad na maximálnu veľkosť radu---určite v ňom bude nanajvýš $q$ prvkov, avšak týchto zoznamov chceme $n$, a $nq$ pamäte je už veľa. Namiesto toho tieto rady implementujeme ako spájané zoznamy.

Týmto sa nám podarilo zlepšiť časovú zložitosť druhej operácie. Opäť, jedna operácia môže trvať až $O(q)$, ale keď sa pozrieme na big picture, zo zoznamu nemôžeme vybrať viac prvkov, ako do neho za celý život vložíme. Každá notifikácia príde len do jedného zoznamu, a teda dokopy vyberieme $O(q)$ prvkov.^[Amortizovane $O(1)$.]

Dostávame tak výslednú časovú zložitosť $O(n + q)$ (potrebujeme $O(n)$ na inicializáciu jednotlivých zoznamov).

Pre záujemcov zdrojový kód alternatívneho riešenia. Je celkom rovnaké, ako to predchádzajúce, až na to, že inak pristupuje k udalostiam tretieho typu. Skúste vyčmuchať, ako funguje a prečo má dobrú časovú zložitosť.
",4
ee22835afea0ac13,ksp,"# Zdobenie torty

Jankove narodeniny sa pomaly, ale isto blížia, a aby nebol taký smutný, že už bude starý, Peťka mu chce upiecť jahodovú tortu. Jediné, čo sa jej dosiaľ nepodarilo vymyslieť, je, ako tortu ozdobiť. Určite na ňu chce zvrchu poukladať $n$ jahôd v pravidelných rozostupoch a pomedzi ne niečo nakresliť cukrovou polevou. Zatiaľ sa s ňou ale nenaučila robiť nič iné ako lomenú čiaru. Peťka preto chce tortu pokresliť lomenou čiarou, ktorá pôjde od jahody k jahode, medzi dvoma jahodami vždy len rovno. Nechce však, aby sa čiara kdekoľvek prekrížila sama so sebou, lebo by sa na tom mieste vytvoril cukrový hrboľ, čo je veľmi neestetické. Pomôžete jej zistiť, či sa čiara, ktorú naplánovala, prekríži?

## Úloha

Pre zadaný kresliaci plán (čísla jahôd, medzi ktorými chce Peťka postupne nakresliť čiaru) má váš program rozhodnúť, či sa čiara niekde pretne sama so sebou. Je zaručené, že plán obsahuje každé číslo nanajvýš raz.

## Formát vstupu

Na prvom riadku vstupu je kladné číslo $t$ neprevyšujúce 30, určujúce počet plánov na vstupe. Každý plán je zadaný na dvoch riadkoch, pričom na prvom sú čísla $n, m$ ($2 \\leq m \\leq n \\leq 200,000$), kde $n$ udáva počet jahôd na torte a $m$ udáva počet jahôd, medzi ktorými chce Peťka urobiť čiaru. Na druhom riadku sú čísla $a_1, \\dots, a_m$ (pričom $1 \\leq a_i \\leq n$), určujúce jahody, medzi ktorými chce Peťka postupne kresliť čiaru.

Pre polovicu vstupov platí $n = m$ (teda ak viete rozhodnúť, či sa čiara pretne, len pre vstupy, kde čiara ide cez všetky jahody, môžete získať polovicu bodov).

## Formát výstupu

Na výstup vypíšte $t$ riadkov. Na $i$-tom má byť reťazec ""`PRETNE`"" (bez úvodzoviek) práve vtedy, keď sa čiara zadaná $i$-tym plánom zo vstupu pretne, inak má byť na $i$-tom reťazec ""`NEPRETNE`"" (bez úvodzoviek).

## Príklad

```vstup
2
8 6
7 8 2 6 3 1
5 5
1 5 4 3 2
```

```vystup
PRETNE
NEPRETNE
```

_V prvom prípade môžete na obrázku vidieť, že pretnutie spôsobila posledná časť čiary od jahody 3 k jahode 1._ _V druhom prípade je jasné, že čiara sa nikde nepretne, pretože ide ""po obvode"" -- iba medzi susednými jahodami._
","# Zdobenie torty

Najprv sa zamyslíme nad tým, ako by sa príklad dal riešiť, keby čiara na torte išla cez všetky jahody. Jahodám, cez ktoré čiara počas kreslenia už prešla, budeme hovoriť *pokreslené*.

&#160;

Keby sa nám počas kreslenia čiary na tortu niekedy stalo, že sme čiarou práve prišli k nejakej jahode, pričom aj naľavo aj napravo od tejto jahody je nepokreslená jahoda, je jasné, že plán sa už nebude dať dokončiť bez prekríženia čiary. (Ak by sme sa totiž v ďalšom kroku vybrali napravo od poslednej jahody, už sa nedostaneme k tej, čo je naľavo, bez toho, aby sa čiara prekrížila -- a naopak analogicky.)

Túto myšlienku môžeme veľmi ľahko zovšeobecniť -- pri kreslení čiary od jahody k jahode musí vždy platiť, že každá jahoda (okrem prvej), ku ktorej pôjdeme čiarou, má aspoň jednu z dvoch susedných jahôd už pokreslenú. To znamená, že počas kreslenia budeme mať vždy jeden súvislý úsek jahôd pokreslený a zvyšné jahody budú nepokreslené -- teda pri každom ďalšom kuse čiary, ktorý budeme kresliť (okrem posledného), budeme mať na výber z dvoch jahôd -- budú to tie nepokreslené, ktoré susedia s pokreslenými.

Program teda v tomto prípade funguje nasledovne: celý čas si bude pamätať interval pokreslených jahôd (na začiatku si ho inicializuje na prvú jahodu) a pri každom ďalšom kroku len skontroluje, či nová jahoda susedí s jednou z krajných jahôd intervalu, a ak áno, interval si príslušne zväčší. Ak nie, vyhlási, že plán je zlý a čiara sa pretne.

&#160;

Čo ale v prípade, že plán neobsahuje všetky jahody? Keď venujeme chvíľku kresleniu rôznych plánov na papier, uvidíme, že z každej jahody sa môžeme pohnúť dvoma rôznymi smermi -- doprava alebo doľava. Navyše, ak ideme vľavo, môžeme si vyberať len z tých jahôd vľavo, ktoré patria do nepokresleného intervalu začínajúceho ľavou susednou jahodou a končiaceho najbližšou pokreslenou jahodou. (Analogicky aj pre druhú stranu -- ak ideme vpravo, môžeme ísť len na takú jahodu, ktorá patrí do nepokresleného intervalu začínajúceho pravou susedou jahody, na ktorej sme, a končiaceho prvou pokreslenou jahodou.) Napríklad v situácií na obrázku interval vpravo obsahuje jahody $3$ a $4$ a interval vľavo jahodu $6$.

Nášmu programu by teda stačilo, keby si udržiaval dva intervaly, a pri každej novej jahode sa pozrel, či patrí do jedného z nich; ak áno, príslušne si intervaly upravil, a ak nie, vyhlásil by, že sa čiara pretne. Môžeme si ale všimnúť, že ak za začiatok pravého intervalu vyhlásime prvú pokreslenú jahodu, ktorá je napravo od naposledy navštívenej jahody a za koniec tú, ktorá je pravou susedou naposledy navštívenej jahody, a pre ľavý interval to spravíme naopak (začiatok na susede naposledy navštívenej jahody), tak interval, ktorý začína začiatkom pravého intervalu a končí koncom ľavého intervalu, obsahuje práve všetky jahody navštíviteľné v najbližšom kroku plus jahodu, na ktorej práve sme. Keďže zadanie nám zaručuje, že jahody sa v pláne nebudú opakovať, môžeme si prácu uľahčiť tým, že budeme kontrolovať príslušnosť nasledujúcej jahody len do jedného intervalu, a nie do dvoch. Na obrázku by to znamenalo, že začiatok spojeného intervalu bude na jahode $2$ a koniec na jahode $7$ (pričom interval ""ide"" v smere hodinových ručičiek).

Ako teda náš program funguje? Keď načítame prvú jahodu, nastavíme si začiatok ($z$) a koniec ($k$) intervalu a aktuálnu ($a$) aj poslednú ($p$) jahodu na tú, ktorú sme práve načítali. Pri načítaní každej ďalšej jahody (uložíme si ju do $a$) skontrolujeme, či $a$ patrí do intervalu $[z, k]$ -- to spravíme zistením, či je $a$ vzdialená od $z$ v smere hodinových ručičiek najviac o toľko, o koľko je v rovnakom smere vzdialené $k$ (keďže $k$ aj $z$ sú už pokreslené, nemôže sa stať, že by $a = z$ alebo $a = k$). Ak nie, zapamätáme si, že čiara sa pretne. Nakoniec si zaktualizujeme interval (čiže jeden z jeho koncov zmeníme na $p$ -- to, ktorý, určíme podľa toho, v ktorej jeho časti leží aktuálna jahoda) a nastavíme $p = a$.

&#160;

Na záver ešte pár slov o zložitosti. Keďže náš program používa len zopár premenných (ich počet nezávisí od veľkosti vstupu), jeho pamäťová zložitosť je konštantná -- $O(1)$. Pre každý vstup spraví v cykle, ktorého dĺžka závisí od veľkosti vstupu, konštantne veľa krokov, takže jeho časová zložitosť je lineárna od veľkosti vstupu -- $O(m)$. Všimnime si, že obe zložitosti sú optimálne -- pamäť $O(1)$ sa nedá vylepšiť zo zrejmých dôvodov, a čas $O(m)$ sa nedá vylepšiť preto, lebo toľko trvá už samotné načítanie vstupu.
",5
c69051450ea1bd8d,ksp,"# Improvizovaná akrobacia

Gašpar už od samej nudy naozaj nevie, čo robiť. Absentuje akákoľvek rozumná myšlienka. A tak otvorí tašku v kúte izby a rozmýšľa, čo by len mohol použiť. Kalkulačka? Stará plesnivá desiata? Zbierka úloh KSP? Vodná pištol? Lano? Lano!

Gašpar už vie, čo spraví. Natiahne lano medzi niektoré stromy v záhrade, bude sa po ňom prechádzať a naučí sa na lane robiť nejaké tie akrobatické kúsky.

Teraz však Gašpar stojí pred závažnou otázkou: ktoré dvojice stromov spojiť povrazom? Samozrejme, že natiahnuté povrazy sa nesmú križovať. Okrem toho sú z rôznych dôvodov niektoré dvojice stromov vylúčené. Popri tomto všetkom by Gašpar chcel vytvoriť, čo najviac spojení.

Pomôžte Gašparovi s týmto problémom!

## Úloha

V záhrade sú dva záhony obsahujúce po $n$ stromov. Stromy v ľavom záhone majú priradené čísla $p_1, \\dots, p_n$. Stromy v pravom záhone majú priradené čísla $q_1, \\dots, q_n$. Platí, že $p_1, \\dots, p_n$ a $q_1, \\dots, q_n$ sú permutáciami čísel $1, \\dots, n$.

Gašpar chce natiahnuť lano medzi niektorými dvojicami stromov tak, aby platilo:

- každé spojenie vedie medzi nejakým stromom z ľavého záhonu a nejakým stromom z pravého záhonu,
- na každý strom je napojené nanajvýš $1$ lano,
- natiahnuté povrazy sa nekrižujú,
- ak sú stromy $p_i$ a $q_j$ spojené povrazom, tak platí $|p_i-q_j| \\leq 4$.

Zistite, koľko najviac spojení môže Gašpar vytvoriť.

## Formát vstupu a výstupu

Na prvom riadku vstupu je číslo $n$ -- počet stromov v jednom záhone, $1 \\leq n \\leq 300,000$.

Druhý riadok vstupu obsahuje $n$ čísel $p_1, \\dots, p_n$ -- čísla stromov v prvom záhone. $p_1, \\dots, p_n$ sú permutáciou čísel $1, \\dots, n$.

Tretí riadok obsahuje $n$ čísel $q_1, \\dots, q_n$ -- čísla stromov v druhom záhone. $q_1, \\dots, q_n$ sú permutáciou čísel $1, \\dots, n$.

Vypíste jeden riadok obsahujúci jedno číslo -- najväčší počet lán, ktoré môže Gašpar medzi stromami natiahnuť.

## Hodnotenie

Vstupy sú rozdelené do 4 sád. Každá sada je hodnotená 2 bodmi. Platia v nich nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:---| ---: | ---: | ---: | ---: | | $1 \\leq n \\leq$ | $100$ | $5000$ | $100,000$ | $300,000$ |

## Príklad

```vstup
6
6 2 1 3 4 5
2 4 6 5 3 1
```

```vystup
5
```

*V jednej z optimálnych konfigurácii sú spojené dvojice stromov $(6, 2), (2, 4), (1, 5), (3, 3)$ a $(5, 1)$.*
","# Improvizovaná akrobacia

## Naivná dynamika

Definujeme $dp[i][j]$ ako maximálny počet spojení, ak posledná dvojica, ktorú sme vybrali je $(i, j)$ (príslušné čísla stromov sú $(p_i, q_j$)). Ak dvojicu $(i, j)$ nie je možné vybrať ($|p_i-q_j| > 4$), definujeme $dp[i][j]$ ako $0$. Teraz je odpoveď jednoducho maximum $dp[i][j]$ spomedzi všetkých $(i, j)$.

Ako spočítať $dp$? Prejdeme vzostupne všetky $i$ od $1$ po $n$ a pre každé $i$ prejdeme všetky $j$ od $1$ po $n$. Ak $|p_i-q_j| > 4$, tak $dp[i][j] = 0$. Inak vyskúšame všetky možné predošlé dvojice, teda $(k, l)$ také, že $k < i, l < j$. Odpoveď je jednoducho $dp[i][j] = 1+ \\max \\lbrace dp[k][l] \\rbrace$. Časová zložitosť je $O(n^4)$ (máme $n^2$ stavov a každý spracujeme v $O(n^2)$).

## Vylepšená dynamika

Dvojice $(i, j)$, ktoré spĺňajú $|p_i - q_j| \\leq 4$ volajme *validné*. Všimnime si, že validných dvojíc je v skutočnosti málo. Pre každé $i$ je ich najviac $9$, celkovo teda $O(n)$. To znamená, že vieme vyššie popísaný algoritmus vylepšiť hneď dvoma spôsobmi:

- môžeme zredukovať počet stavov v našom dynamickom programovaní -- stačia nám stavy zodpovedajúce validným dvojiciam;
- pri počítaní $dp$ nám stačí kontrolovať menej možných predošlých dvojíc.

Na začiatku si vygenerujeme všetky *validné* spojenia. Toto vieme spraviť v čase $O(n)$ (napríklad priamočiaro za pomoci poľa $q\_{inv}$ takého, že $q\_{inv}[q_j] = j$.) Validné spojenia si očíslujeme od $1$ po $S$. Pre $s \\in \\lbrace 1, \\dots, S\\rbrace$ definujeme $dp[s]$ ako najväčší počet spojení, ktorý vieme dosiahnuť, ak posledné vybrané spojenie je $s$.

Ako spočítať $dp$? Prechádzame cez všetky validné spojenia s číslom $\\tilde{s} \\in \\lbrace 1, \\dots, S \\rbrace$. Skontrolujeme, či je spojenie $\\tilde{s}$ naľavo od $s$ (ak spojeniu $s$ zodpovedá $(i, j)$ a spojeniu $\\tilde{s}$ zodpovedá $(\\tilde{i}, \\tilde{j})$, tak kontrolujeme, či $\\tilde{i} < i$ a zároveň $\\tilde{j} < j$ ). Potom $dp[s] = 1 +$ maximum z príslušných hodnôt $dp[\\tilde{s}]$. Časová zložitosť sa zlepšila na $O(n^2)$ (máme $O(n)$ stavov a každý spracujeme v $O(n)$).

## Vzorová dynamika

Kľúč k úspechu je zapracovať na počítaní $dp[s]$ pre konkrétne $s$. Validné dvojice budeme prechádzať v zotriedenom poradí, po skupinkách: najprv spracujeme tie, ktoré majú $i = 1$, potom tie s $i = 2$, atď. Vďaka tomuto bude jednoduché overovať, či $\\tilde{i} < i$. Pri počítaní $dp[s]$ potrebujeme preveriť všetkých kandidátov na predošlú dvojicu. Kto sú reálni kandidáti? Sú to presne všetky validné dvojice $\\tilde{s}$ s $(\\tilde{i}, \\tilde{j})$ z predošlých skupiniek ($\\tilde{i} < i$), pre ktoré $\\tilde{j} < j$. Potrebujeme zobrať maximum z hodnôt $dp[\\tilde{s}]$ pre týchto kandidátov. Na takéto veci je ako stvorený [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/).

Vytvoríme si intervaláč, v ktorom si pre fixné $\\tilde{j}$ od $1$ po $n$ budeme udržovať maximálne $dp[\\tilde{s}]$ pre validné dvojice $\\tilde{s}$ zodpovedajúce $(\\tilde{i}, \\tilde{j})$ pre $\\tilde{s}$ zo skupiniek, ktoré sme už spracovali. (Ak teda práve spracovávame skupinku s nejakým fixným $i$, tak hodnota v intervaláči pre fixné $\\tilde{j}$ bude maximum z hodnôt $dp$ pre validné dvojice spomedzi $(1, \\tilde{j}), \\dots, (i-1, \\tilde{j})$). Intervaláč budeme updatovať vždy po spracovaní celej skupinky. Takýchto updatov bude po každej skupinke najviac $9$ (toľko najviac dvojíc je v jednej skupinke) a intervaláč ich vykoná v $O(\\log n)$. No a pri spracovaní konkrétnej dvojice $s$ zodpovedajúcej $(i, j)$ nám vlastne stačí spočítať maximum hodnôt na intervale $[0, j-1]$. Takéto otázky nám intervaláč zodpovie tiež v $O(\\log n)$.

Celková časová zložitosť tak bude $O(n \\log n)$ (prejdeme $O(n)$ skupiniek, každú spracujeme v $O(\\log n)$). Pamäťová zložitosť bude $O(n)$.
",9
b1cac98945343bfd,ksp,"# Raz počuť (ne)stačí

Prichádza zima. Medvede sa dávno uložili na zimný spánok, lastovičky a dážďovníky odleteli, študenti dopísali zápočtové testy a do skúškového budú tiež už len spať. Príroda sa pomaly, pomaličky, veľmi pomaly zastavila.

Ale práca na novej sérii KSP sa nezastavuje nikdy. A keďže všetci starí vedúci a vedúce by radi oslavovali číru, nádhernú, dlhosiahlu existenciu KSP, treba zaučiť nových vedúcich, aby stimulovali (alebo aspoň simulovali) pracovnú morálku. Noví vedúci sa musia naučiť ešte veľa, aby mohli o sebe hrdo prehlásiť, že vedúcujú KSP. Našťastie, KSP ponúka bezchybný spôsob na určenie, či je niekto naozaj nový vedúci alebo sa tak len tvári.

## Úloha

Každý nový vedúci sa po príchode do KSP postupne naučí $n$ pre neho dôležitých informácí o fungovaní KSP. Tieto informácie si môžeme predstaviť, ako čísla od $1$ po $n$. Informácie sa naučí presne v poradí od $1$ po $n$. Mozog nového vedúceho ale funguje prazvláštne: informácie sú v ňom uložené lineárne, zľava doprava. A vždy, keď sa nový vedúci naučí nejakú novú informáciu, jeho mozog ju spracuje práve jednou z troch možností:

- uloží si ju doľava (ak boli v mozgu informácie `1 2 3`, budú tam `4 1 2 3`)
- uloží si ju doprava (ak boli v mozgu informácie `1 2 3`, budú tam `1 2 3 4`)
- instantne ju zabudne (ak boli v mozgu informácie `1 2 3`, budú tam, ako inak, `1 2 3`)

Keď takto nový vedúci spracuje všetky informácie, dokončí svoju prvú úlohu do KSP a následne zabudne aj tie informácie, ktoré si ešte pamätá. Informácie zabúda v poradí, v akom ich má uložené v mozgu -- postupne zľava doprava.

Práve sme vypočuli $t$ ľudí, ktorí o sebe tvrdia, že sú novými vedúcimi KSP a všetkých sme sa pýtali, v akom poradí získané informácie zabúdali. Pre každého z nich chceme určiť, či daný človek môže byť novým vedúcim.

## Formát vstupu

Na prvom riadku sa nachádza číslo $t$, počet ľudí. Nasleduje $t$ dvojíc riadkov, kde na prvom riadku dvojice je číslo $n$, počet informácií. Na druhom riadku je permutácia prvých $n$ prirodzených čísel - poradie, v akom daný človek informácie zabúdal.

## Formát výstupu

Pre každého z $t$ ľudí vypíšte jeden riadok s textom `Novy veduci`, ak mohol daný človek byť novým vedúcim, alebo s textom `Neveduci`, ak nemohol.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:---------------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $10$ | $100$ | $1,000$ | $100,000$ | | $1 \\leq t \\leq$ | $1$ | $10$ | $100$ | $1000$ | | $1 \\leq \\sum_t n \\leq$ | $10$ | $100$ | $1,000$ | $100,000$ |

## Príklad

```vstup
3
6
1 2 3 4 5 6
5
2 4 1 5 3
6
2 4 6 5 3 1
```

```vystup
Novy veduci
Neveduci
Novy veduci
```

_Prvý človek mohol napríklad všetky informácie instantne zabudnúť alebo prvé tri zabudnúť a zvyšné 3 si zapamätať sprava._

_Druhá osoba určite nie je skutočná vedúca, poradie si musela vymyslieť._

_Tretí človek si mohol prvú informáciu zapamätať sprava, druhú a štvrtú zabudnúť a ostatné zapamätať zľava._ _Jeho mozog by v tomto prípade vyzeral po získaní všetkých informácii takto: 6 5 3 1._
","# Raz počuť (ne)stačí

## Pomalé riešenie

Každá informácia mala práve tri možnosti, čo sa s ňou mohlo stať (byť zabudnutá, zapamätaná zľava, zapamätaná sprava). Túto znalosť môžeme využiť na to, aby sme vygenerovali (napríklad rekurzívne) všetky možné postupnosti patriace novým vedúcim. Potom všetky prejdeme a zistíme, či sa nejaká zhoduje so vstupnou. Dokonca si ich ani nemusíme pamätať, stačí každú postupnosť porovnať rovno potom, čo ju vytvoríme. Tento prístup určite funguje, ale jeho časová zložitosť je bolestivá: potrebujeme vygenerovať $3^n$ postupností dĺžky $n$ a každú porovnať so vstupnou. Takéto riešenie teda nebude fungovať pre $n$ rádovo väčšie, než napríklad 10.

## Vzorové riešenie

Alebo sa najskôr zamyslime nad tým, ako by mohla postupnosť zabúdaných informácií vyzerať v nejakom všeobecnom prípade. Ak je náš človek naozaj nový vedúci, potom niekoľko informácií zabudol instantne ($I$), niekoľko si zapamätal zľava ($L$), a niekoľko sprava ($P$), pričom niekoľko môže byť aj 0. Vieme si to predstaviť aj tak, že existujú tri nezávislé priehradky, do ktorých informácie postupne ukladal, a na konci ich jednoducho prilepil za seba, v poradí $I$, prevrátené $L$ (pretože informácie z $L$ vyberáme v opačnom poradí, ako sme ich tam) dávali, a $R$.

Každá priehradka má prvky v stúpajúcom poradí - keďže informácie v stúpajúcom poradí prichádzali, nemôže to ani byť inak. Takže keď boli prilepené za seba, vznikla postupnosť čísel, ktorá najskôr niekoľkokrát stúpala ($I$), potom klesala (prevrátené $L$) a nakoniec znova stúpala ($R$). Medzi stúpajúcou a klesajúcou postupnosťou je buď nárast alebo pokles, čo vieme interpretovať ako súčasť ľubovoľnej z nich.

Pre každú zadanú postupnosť nám teda stačí overiť, či má takýto formát. Na to potrebujeme zistiť počet zmien jej smeru. Postupnosť budeme prechádzať postupne, a každý prvok porovnáme s predošlým. Začneme so stúpajúcim smerom postupnosti, (prvá priehradka je $I$) a vždy, keď sa smer zmení, prirátame si k počtu zmien 1. Nakoniec overíme, či je počet zmien menší alebo rovný dvom - to zodpovedá prechodom medzi $I$ a $L$ a medzi $L$ a $R$. Ak nastalo viac zmien, určite nešlo o nového vedúceho.

## Časová a pamäťová zložitosť

Každú postupnosť prejdeme práve raz, a pre každý jej prvok vykonáme konštantný počet operácií, takže časová zložitosť pre jedného človeka je $O(n)$. Pre $t$ ľudí potom $O(\\sum_t n)$. Pamäťová zložitosť je dokonca konštantná, pretože nám stačí pamätať si počet zmien a aktuálny smer postupnosti.
",4
dde2957473933a23,ksp,"# Okno do študentovej duše

Miško by si mal robiť domácu. A ísť postrúhať mrkvu. A už niekedy konečne pozrieť zo záznamu minulotýždňovú prednášku z toho či onoho predmetu. A pozbierať si zo sušiaka prádlo, nech sa dá prať ďalšia várka. A upratať po mačke, ktorá podľa zvuku práve zase na chodbe nagrcala. List povinností pokračuje ďalej a ďalej.

Čím je povinností viac, tým sa do nich Miškovi menej chce. A tak si radšej skúma najnovšiu matematickú zaujímavosť, na ktorú práve narazil: správanie sa ciferných súčinov keď ich robíme opakovane.

Začnime napríklad z čísla 47. Jeho ciferný súčin je $4\\times 7 = 28$. Ciferný súčin čísla 28 je $2\\times 8 = 16$. Ciferný súčin čísla 16 je $1\\times 6 = 6$. No a odkedy sme sa dostali k jednocifernému číslu, už je to nuda: ciferným súčinom jednociferného čísla je ono samo. Ak teda časom dosiahneme jednociferné číslo, celý postup ukončíme.

Niekedy je tento proces rýchlejší, inokedy pomalší. Napríklad číslo $987,654,321$ má ciferný súčin $9! = 326,880$ a číslo $326,880$ má ciferný súčin 0. Hoci sme začali s oveľa väčším číslom ako v predošlom príklade, skončili sme skôr. A možno sa niekedy stane aj to, že pre nejaký začiatok vôbec nikdy neskončíme na jednocifernom čísle. Alebo žeby sa to predsa len nemohlo stať? O tom Miško zatiaľ nič netuší.

Miško sa rozhodol, že niektorým nezáporným celým číslam priradí *skóre*, a to nasledovne:

- Každé jednociferné číslo $n$ dostane priradené Miškom zvolené malé nezáporné skóre $z_n$.
- Ak má viacciferné číslo $n$ ciferný súčin $s(n)$ a číslo $s(n)$ má skóre $x$, číslo $n$ dostane skóre $x+1$.

## Úloha

Na vstupe dostanete hodnoty $z_0$ až $z_9$ a tiež cieľové skóre $c$. Vašou úlohou je nájsť **najmenšie** nezáporné celé číslo, ktoré má skóre $c$.

Poriadne si pozrite obmedzenia pre veľkosť vstupu.

## Formát vstupu

V prvom riadku vstupu sú čísla $z_0$ až $z_9$, v druhom je číslo $c$.

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno číslo -- najmenšie nezáporné celé číslo so zadaným skóre.

## Obmedzenia a hodnotenie programov

Obmedzenia použité v testoch sme zvolili tak, že v každom teste správna odpoveď **existuje** (toto nie je úplne zjavné) a navyše vždy platí, že má hodnotu nanajvýš $10^{18}$ (toto už vonkoncom nie je zjavné ale tiež je to pravda). Tieto predpoklady môžete využiť vo svojich riešeniach.

Sú štyri sady vstupov. Vo všetkých štyroch platí:

- hodnoty $z_i$ sú z rozsahu od 0 po 3
- ak označíme $m=\\max z_i$, tak každú z hodnôt od 0 po $m$ má aspoň jedno $z_i$
- $c$ je z rozsahu od 0 po 11

Navyše v prvej sade platí, že odpoveď je nanajvýš 1000, v druhej sade platí, že odpoveď je z rozsahu od 1000 po $1,000,000$ a v tretej sade platí, že všetky $z_i$ sú rovné nule.

## Hodnotenie popisov

Pri hodnotení popisu nezáleží na asymptotickej zložitosti vášho riešenia (keďže všetky čísla na vstupe sú veľmi malé). Ľubovoľné riešenie dosť efektívne na to, aby získalo body za vstupy, môže dostať do 10 bodov za dôkaz toho, že dáva vždy korektný výstup. Posledné dva body sa budú udeľovať za efektívnosť hľadania.

## Príklady

```vstup
0 1 1 1 1 1 1 1 1 1
2
```

```vystup
11
```

- *Číslo 0 má skóre 0.*
- *Čísla od 1 po 9 majú skóre 1.*
- *Číslo 10 má ciferný súčin 0, a keďže 0 má skóre 0, tak 10 má skóre 1.*
- *Číslo 11 má ciferný súčin 1, a keďže 1 má skóre 1, tak 11 má skóre 2.*

```vstup
0 0 0 0 0 0 0 0 0 0
3
```

```vystup
39
```

- \*Číslo 4 má skóre 0, číslo 14 má ciferný súčin 4 a teda skóre 1, číslo 27 má ciferný súčin 14 a teda skóre 2, no a číslo 39 má ciferný súčin 27 a teda skóre 3. \*
- *Žiadne menšie číslo ako 39 nemá skóre 3.*

```vstup
2 0 0 0 0 0 0 0 0 1
2
```

```vystup
0
```

```vstup
2 1 2 2 1 1 1 0 1 0
6
```

```vystup
268
```
","# Okno do študentovej duše

Pripomeňme si, akú úlohu riešime. Máme predpísané, aké skóre majú jednociferné čísla. Každé väčšie číslo má skóre o jedno väčšie ako je skóre jeho ciferného súčinu. Našou úlohou je pre dané $c$ nájsť najmenšie číslo $n$, ktorého skóre je $c$.

## Pointa celej úlohy

Môže byť správnou odpoveďou číslo $n = 3,141,592$?

Nemôže. Prečo? Lebo číslo $1,123,459$ má presne tie isté cifry (a teda ten istý ciferný súčin, a teda aj to isté skóre) a je od $n$ menšie.

A môže byť číslo $1,123,459$ správnou odpoveďou?

Tiež nie. Prečo? Lebo číslo $23,459$ má tiež ten istý ciferný súčin a je ešte menšie.

Ale poďme sa na to celé pozrieť od začiatku a pekne pomaly.

## Každé číslo má skóre

Keď sa chvíľu pohráme s cifernými súčinmi, pomerne rýchlo si všimneme, že pre ľubovoľné $n\\geq 10$ nám jeho ciferný súčin $s(n)$ vyjde menší ako $n$. Je toto naozaj vždy pravda?

Keď už si to všimneme, dokázať to nie je ťažké. Pointa je v tom, že dopísanie ďalšej cifry na koniec čísla zväčší samotné číslo aspoň desaťkrát, zatiaľ čo jeho ciferný súčin len nanajvýš deväťkrát.

To isté ešte raz a poriadnejšie: Majme nejaké $x$-ciferné číslo $n$ ktorého prvá cifra je $y$. Čo o ňom vieme povedať?

- Hodnota $n$ je aspoň $y\\times 10^{x-1}$.
- Každá z $x-1$ cifier nasledujúcich za úvodným $y$ je nanajvýš 9, takže hodnota $s(n)$ je nanajvýš $y\\times 9^{x-1}$.
- A teda pre $x\\geq 2$ máme $n > s(n)$.

No a z toho už by malo byť zjavné, že úplne každé nezáporné celé číslo má korektne definované skóre. (Indukciou podľa $n$. Ak všetky čísla menšie ako $n$ majú korektne definované skóre, $s(n)$ je jedným z nich, a keďže $s(n)$ má skóre, aj $n$ má skóre.)

## Malé skóre vieme efektívne počítať

Pripomeňme si, že nás zaujímajú len čísla, ktorých skóre je nanajvýš 11. Skóre ľubovoľného čísla $n$ preto vieme ľahko a efektívne vyhodnotiť: postupne počítame $s(n)$, $s(s(n))$, atď., až kým sa buď nedostaneme k jednocifernému číslu (kedy vieme povedať, aké skóre má $n$) alebo nespravíme 12 krokov (kedy vieme povedať, že $n$, z ktorého sme začínali, bude mať určite priveľké skóre).

Neskôr si ukážeme, že ani to počítanie krokov do 12 nie je potrebné robiť, lebo úplne každé číslo do $10^{18}$ má vždy maličké skóre. Ak ste teda v programe len priamo implementovali počítanie skóre podľa definície, bolo to v praxi rovnako dobré.

## Ako vyzerá hľadané riešenie?

Zamyslime sa teraz, čo vieme povedať o správnej odpovedi.

Začneme tým, že skontrolujeme čísla od 0 po 19. Čísla od 0 po 9 majú skóre dané na vstupe a hociktoré z nich môže byť tým, ktoré hľadáme. Čísla od 10 po 19 sú najmenšie viacciferné čísla, ktorých ciferný súčin je od 0 po 9. Aj každé z nich môže byť správnou odpoveďou. Ak sme medzi nimi správnu odpoveď nenašli, vieme, že má hodnotu aspoň 20. Uvažujme teraz o situáciách, kedy je správna odpoveď aspoň 20:

- Správna odpoveď nemôže obsahovať cifru 0. Ak by ju obsahovala, mala by ciferný súčin 0, a teda rovnaké skóre ako číslo 10, ktoré je od nej menšie.

- Ako už vieme, správna odpoveď musí mať cifry usporiadané od najmenšej po najväčšiu. (Keďže už vieme, že nemáme cifru 0, nemôže nám pri usporadúvaní cifier vzniknúť problém s nulou na začiatku čísla.)

- Správna odpoveď následne nemôže obsahovať ani cifru 1. Takéto číslo musí byť aspoň trojciferné (dvojciferné začínajúce 1 sme už pozerali) a keď mu úvodnú cifru 1 zmažeme, tak sa samotné číslo zmenší a jeho ciferný súčin sa nezmení.

## Už sme vyhrali?

Áno. Totiž po úvahe, ktorú sme práve spravili, nám ostane tak malé množstvo kandidátov na správnu odpoveď, že si môžeme dovoliť všetkých vygenerovať a skontrolovať. Dokopy je medzi nanajvýš 18-cifernými číslami len pribiližne 1.5 milióna takých, ktorých cifry sú 2-9 a sú usporiadané od najmenšej po najväčšiu.

## Implementácia

Samotná implementácia je už pomerne priamočiara. Všetkých $k$-ciferných kandidátov na riešenie vieme vygenerovať tak, že vygenerujeme všetkých $(k-1)$-ciferných a každému na koniec pridáme všetky možnosti pre ďalšiu cifru. Takýmto postupom vieme dokonca všetkých kandidátov generovať v usporiadanom poradí, takže akonáhle narazíme na nejakého so správnym skóre, môžeme si byť istí, že sme práve našli riešenie.

## Efektívnejšie hľadanie

Množinu kandidátov, ktorých treba prezrieť, vieme ešte ďalej celkom výrazne prečistiť. Napríklad takto:

- Číslo $n$ nebude obsahovať cifry 22 (lepšie je mať jednu štvorku), 23 (šestku), 24 (osmičku) ani 33 (deviatku).

- Číslo $n$ nebude obsahovať cifry 34, lebo lepšie je mať cifry 26 -- číslo bude menšie a ciferný súčin rovnaký. Podobne vieme, že $n$ nebude obsahovať cifry 36 (lepšie je 29), 44 (lepšie je 28), 46 (lepšie je 38) ani 66 (lepšie je 49).

- Ak máme v $n$ cifru 5 tak nemôžeme mať žiadnu párnu cifru -- lebo $s(n)$ bude končiť nulou a potom $s(s(n))$ bude nula. Medzi zakázané dvojice cifier teda môžeme pridať aj 25, 45, 56 a 58.

Ak do generovania kandidátov pridáme tieto obmedzenia, zredukujeme ich počet z vyššie spomínaného približne 1.5 milióna na iba približne $9,000$.

## Checkpoint

Niekde tu by sa dalo vzorové riešenie tejto úlohy ukončiť. My v ňom však ešte nejakú tú chvíľu budeme pokračovať a doplníme ešte nejaké detaily a zaujímavostí navyše.

## Počítanie kandidátov

Vyššie sme uvádzali nejaké číselné odhady počtov kandidátov. Tie samozrejme vieme získať tak, že ich naozaj vygenerujeme a spočítame. Vieme ich ale veľmi ľahko spočítať aj pomocou kombinatoriky.

Pozrime sa napríklad na všetky $d$-ciferné čísla, ktorých cifry sú od 2 po 9 a sú usporiadané od najmenšej po najväčšiu. Koľko ich je?

Predstavme si, že máme premennú, v ktorej je na začiatku cifra 2, a dve rôzne inštrukcie: inštrukcia `+` zväčší hodnotu v premennej a inštrukcia `p` ju vypíše.

Pomocou takýchto inštrukcií vieme vyrábať čísla, ktorých cifry sú usporiadané. Napr. postupnosť inštrukcií `++p+pp+++p+` vyrobí číslo 4558.

Pozrime sa na postupnosti inštrukcií, ktoré obsahujú práve sedem inštrukcií `+` a práve $d$ inštrukcií `p`. Každá takáto postupnosť vyrobí nejaké $d$-ciferné číslo, ktorého cifry sú od 2 do 9 a postupne rastú. A naopak, keď zoberieme ľubovoľné takéto číslo, vieme nájsť práve jednu takúto postupnosť inštrukcií, ktorá ho vyrobí: ideme zľava doprava a pri každej cifre najskôr stlačíme správne veľa `+` aby sme premennú nastavili na jej hodnotu a potom stlačíme `p`. (Po poslednej cifre ešte doplníme prípadné chýbajúce `+`.)

Hľadaných čísel je teda presne toľko isto ako reťazcov dĺžky $d+7$, ktoré obsahujú $d$ péčok a 7 plusov. No a takýchto reťazcov je zjavne ${d+7\\choose 7}$: vyberieme, na ktorých siedmich pozíciách sú plusy a tým je jednoznačne určené, kde sú péčka.

## Asymptotické odhady

Môžeme rozpísať, že ${d+7\\choose 7} = \\frac{(d+7)(d+6)\\cdots(d+1)}{7!}$. Z toho je zjavné, že počet čísel, ktoré majú usporiadané cifry od 2 po 9, závisí od ich dĺžky $d$ len polynomiálne: je ich $\\Theta(d^7)$.

Keď sme prečistili množinu kandidátov, ostali nám v nej len čísla, ktoré mali nanajvýš po jednej z cifier 2, 3, 4, 6. Navyše buď mali len nepárne cifry (vtedy sú premenlivé len počty cifier 5, 7 a 9) alebo neobsahovali cifru 5 (a vtedy sú premenlivé zase len počty cifier 7, 8 a 9). Podobnou kombinatorickou úvahou dostávame, že čísel dĺžky $d$ jedného aj druhého typu je len $\\Theta(d^2)$.

## Otvorený problém na záver

Najjednoduchšou možnou formou zadania našej úlohy je verzia v ktorej všetky jednociferné čísla majú skóre nula. Pre takýto vstup platí, že skóre čísla udáva jednoducho počet opakovaní operácie ""nahraď číslo jeho ciferným súčinom"" po ktorom dostaneme jednociferné číslo. Matematici v teórii čísel toto občas nazývajú nie skóre, ale _multiplikatívna perzistentnosť_ čísla.

Ak ste si skúšali svoj program spustiť pre najväčšie platné vstupy, určite ste v jeho výstupoch často narazili na číslo $277,777,788,888,899$. Toto je najmenšie číslo, ktoré má multiplikatívnu perzistentnosť 11.

Prečo sme ako najväčšie povolené $c$ v zadaní zvolili práve 11? O koľko väčšia je vlastne správna odpoveď pre $c=12$? Nevieme podobným postupom nájsť aj tú?

Nuž... nielen že nevieme, my vlastne dodnes ani nevieme, či vôbec nejaké takéto číslo existuje. Jeho existencia je otvoreným problémom, ktorý už nejaký ten rok odoláva snahám matematikov. Zatiaľ vieme dokázať, že _ak_ takéto číslo existuje, _tak_ určite musí mať výrazne viac ako $20,000$ cifier. Ale skôr si myslíme, že neexistuje. A dokonca _pravdepodobne_ platí ešte podivuhodnejšie tvrdenie: je možné, že už poznáme _úplne všetkých_ kandidátov, ktorí majú multiplikatívnu perzistentnosť väčšiu ako 2. Vyzerá to totiž tak, že keď budeme postupne prezerať väčších a väčších kandidátov, tak nielen že nenájdeme žiadneho s multiplikatívnou perzistentnosťou 12, ale naopak sa veľmi rýchlo minú všetci s multiplikatívnou perzistentnosťou väčšou ako 2.

Prečo je to tak? Intuitívne sa to dá priblížiť nasledovne. Majme nejakého kandidáta s veľmi veľkým počtom cifier. Toto je nejaké pekné systematické číslo, ktorého cifry sú od 2 od 9. Jeho ciferným súčinom je nejaké iné, tiež ešte obrovské číslo. Toho cifry sú však už všelijaké chaotické a skoro vždy niekde medzi nimi vybehne nejaká tá nula. Takže to vyzerá tak, že pre ľubovoľného veľkého kandidáta $n$ skoro určite platí $s(s(n)) = 0$.

Posledná známa výnimka má 140 cifier. Presnejšie, 140-ciferné číslo $v = 2^{25} \\times 3^{227} \\times 7^{28}$ neobsahuje žiadnu nulu a jeho multiplikatívna perzistentnosť je presne 2. Toto číslo $v$ je rovné $s(n)$ pre niekoľko podobne veľkých kandidátov $n$ ktorí potom majú multiplikatívnu perzistentnosť až 3. Ale od 140 cifier ďalej až po vyše $20,000$ cifier už sme prezreli všetky možnosti a sme si úplne istí, že úplne všetky možné $s(n)$ obsahujú v sebe aspoň jednu nulu.

Zrejme to bude platiť aj ďalej pre ešte väčšie čísla. Hja, ale ako takéto niečo exaktne dokázať?
",6
290642f940261adf,ksp,"﻿#O()kúzlení

*Udalosti spomínané v tomto zadaní sú založené na pravdivých faktoch. Však si vyžiadaj vystúpenie, keď ho najbližšie stretneš.*

Komu z nás sa nepáči mágia? Rýchle prsty, odvádzanie pozornosti a na prvý pohľad neuskutočniteľné veci? Niet divu, že aj Mišof sa v svojej mladosti naučil zopár trikov, ktoré teraz predvádza na skrátenie dlhej chvíle alebo na machrovanie v krčme.

Pozná pár kartových trikov, necháva miznúť zápalky a rôzne iné predmety, na povrazoch sa objavujú všelijaké uzly a dokonca dokáže opraviť roztrhnutú bankovku. Ako to robí? To ti, samozrejme, nemôžem povedať. Chápeš, tajomstvo kúzelníka.

Nedávno sa Mišof naučil nový trik a preto ti ho chcel predviesť. Do radu postavil $n$ nepriehľadných pohárov otočených hore dnom. Pod niektoré z nich položil guličku. Spýtal sa ťa na súvislý interval pohárov a začal odkrývať, čo sa nachádza pod nimi. Na tvoje prekvapenie pod každým z vybraných pohárov bolo presne to, čo si neočakával. Ak tam na začiatku gulička bola, teraz tam nie je a naopak. Uau. Potom guličky opäť zakryl a postup opakoval s novým intervalom. Si okúzlený?^\[Tak stále buď, ale ak by ťa zaujímalo ako sa také niečo dá spraviť, odporúčam pozrieť [www.youtube.com/watch?v=8osRaFTtgHo](https://www.youtube.com/watch?v=8osRaFTtgHo)\]

""A to nie je všetko!"" chváli sa Mišof. ""Tiež ti viem ukázať najdlhšiu, nie nutne súvislú podpostupnosť pohárov, v ktorej sa pod pohármi najskôr guličky nenachádzajú a potom sa tam už stále nachádzajú.""

""Ale však to nie je ťažké."" Povieš a po chvíli premýšľania ukážeš správnu podpostupnosť.

""Áno? A dokážeš to, aj keď ti zmením tento interval, aj tento a nakoniec aj tento?"" nedá pokoj Mišof.

No čo, dokážeš?

## Úloha

Na vstupe dostaneš popis postupnosti a zmeny, ktoré nastali. Každá zmena je daná (uzavretým) intervalom pohárov. V tomto intervale sa objaví gulička pod každým pohárom, kde sa nenachádzala a zmizne spod každého pohára, kde bola. Jednotlivé zmeny na seba postupne naväzujú.

Raz za čas sa ťa Mišof opýta otázku: Aká je dĺžka najdlhšej (nesúvislej) podpostupnosti, kde na začiatku tejto podpostupnosti sú prázdne poháre a na konci poháre s guličkou? Presnejšie, po žiadnom pohári, pod ktorým je skrytá gulička nemôže v tejto podpostupnosti nasledovať pohár, pod ktorým gulička nie je.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($1 \\leq n \\leq 300,000$) -- počet pohárov v postupnosti.

V druhom riadku je reťazec znakov `0` a `1`, kde `0` reprezentuje pohár, pod ktorým sa gulička nenachádza, a `1` reprezentuje pohár so skrytou guličkou. Tento reťazec určuje začiatočné rozmiestnenie guličiek.

V treťom riadku je číslo $q$ ($1 \\leq q \\leq 300,000$) -- počet udalostí.

Nasleduje $q$ riadkov popisujúcich jednotlivé udalosti. Ak sa v riadku nachádza iba jediný znak `1`, znamená to, že Mišof sa pýta otázku na aktuálny stav pohárov a guličiek. Ak riadok začína znakom `2`, znamená to zmenu intervalu, ktorý je definovaný nasledujúcimi dvoma číslami $x_i$ a $y_i$ ($1 \\leq x_i,y_i \\leq n$) na riadku. Prvé číslo je začiatok a druhé číslo je koniec daného intervalu.

Úloha má osem testovacích sád. V prvých piatich z nich platí, že $n\\cdot q \\leq 1,000,000$. Navyše, v každej párnej sade platí, že $x_i=y_i$.

## Formát výstupu

Pre každú Mišofovu otázku, udalosť `1`, vypíšte jedno číslo -- dĺžku najdlhšej podpostupnosti pohárov, kde sa všetky poháre, pod ktorými nie je gulička, nachádzajú pred všetkými pohármi, pod ktorými gulička je.

## Príklad

```vstup
5
00001
6
1
2 1 2
1
2 1 1
2 4 4
1
```

```vystup
5
3
4
```

*V prvej otázke je správna odpoveď celá postupnosť. Po prvej zmene vyzerá celá postupnosť `11001`. V tomto prípade jedna so správnych podpostupností pozostáva iba z jednotiek. Na konci dostaneme `01011` a do výsledku vyberiem obe nuly a posledné dve jednotky.*
","# O()kúzlení

## Ako získať ľahké body

V piatich z ôsmich testovacích sád platilo, že $n\\cdot q \\leq 1,000,000$. To znamená, že pri každej otázke môžeme prejsť celým poľom, v ktorom si pamätáme, pod ktorým pohárikom sa nachádza gulička a niečo s ním spraviť. Toto nám dáva takú voľnosť, že sa úloha blíži obtiažnosťou k úlohe číslo 4. Preto, ak ste nezískali za túto úlohu žiadne body, zoberte si to ako ponaučenie a nabudúce sa pozerajte, čo vám dovoľujú limity v zadaní.

Ako teda vymyslieť prvé riešenie, ktoré spracováva každú otázku v čase $O(n)$? Potrebujeme spracovávať dve operácie -- invertovanie intervalu a zistenie najdlhšej podpostupnosti núl a následne jednotiek. Prvá operácia je ľahká. Naozaj prejdeme celý zadaný interval a zmením každé číslo na to opačné.

Čo sa týka druhej, použijeme veľmi jednoduché dynamické programovanie. Budeme poľom prechádzať zľava doprava a v každom momente si budeme pamätať dve čísla. Aká je najdlhšia podpostupnosť z doposiaľ videných prvkov, ktorá končí nulou ($p_0$) a aká je najdlhšia postupnosť z doposiaľ videných prvkov končiaca jednotkou ($p_1$). Nie je problém vymyslieť, ako sa tieto čísla budú meniť.

Ak budeme mať na aktuálnom políčku nulu, tak $p_0 = p_0+1$ a $p_1$ zostane nezmenené. V opačnom prípade, keď sa na políčku nachádza jednotka, tak $p_0$ zostane nezmenené a $p_1 = \\max(p_0+1, p_1+1)$. Po prejdení celého poľa si jednoducho vyberieme väčšiu z hodnôť $p_0$ a $p_1$ ako dĺžku najdlhšej hľadanej podpostupnosti.

Pamäťová zložitosť takéhoto riešenia je $O(n)$ a časová $O(nq)$. Aj samotný program, ktorý implementuje toto riešenie je pomerne jednoduchý:

## Intervalový strom

Keď sa pozeráme na úlohu, mali by sme sa snažiť nájsť podobnosti s inými úlohami, ktoré sme riešili. Z veľkostí vstupu nám môže vyplynúť, že chceme každú operáciu vykonať v čase $O(\\log n)$. Naviac naše operácie sa zameriavajú na intervaly našeho poľa. Toto všetko by malo ukazovať na to, že chceme použiť intervalový strom.

Samozrejme, toto nemusí byť zakaždým pravda. Môže sa stať, že riešenie použije vyhľadávacie stromy, alebo otázky spracováva offline, alebo kopec iných možností. Vždy sa však oplatí si prejsť zoznam používaných konceptov a skúsiť ich aplikovať.

Na prvý pohľad to však pôsobí zvláštne. Klasický sčítací, či maximový/minimový strom nám je v tomto prípade úplne nanič. To však nie je jediné využitie intervalových stromov. Tie nám totiž ponúkajú oveľa všeobecnejšiu štruktúru, ktorá si pamätá v každom vrchole **nejaké informácie** o prislúchajúcom intervale a vie jednoduchým spôsobom spájať informácie pre synov do informácií pre otca. V našej úlohe teda musíme vymyslieť, čo si musí pamätať každý z vrcholov.

Vieme, že jedna z otázok, ktorú sa pýtame, je: ""Aká je dĺžka najdlhšej podpostupnosti, ktorá začína nulami a končí jednotkami, na celom poli?"" Čo v podstate znamená, že túto hodnotu si musí pamätať koreň našeho intervalového stromu. A ak si to pamätá on, musí si to pamätať každý vrchol. Pre každý vrchol si teda zapamätáme hodnotu $p\_{01}$ -- dĺžku najdlhšej podpostupnosti, ktorá sa nachádza na danom intervale, začína nulami a končí jednotkami.

Otázkou ale je, či vieme z hodnôt $p\_{01}$ pre synov určiť túto hodnotu aj pre otca. Odpoveďou je, že nie. Ak totiž spojím dve takéto postupnosti, dostanem postupnosť, ktorá začína nulami, končí jednotkami, ale niekde v strede sa to ešte zmení z jednotiek na nuly a opačne. A to nie je dobre -- v celej podpostupnosti máme mať len jeden zlom medzi nulami a jednotkami.

Pozrime sa, kde sa tento zlom nachádza. Ak sa nachádza v interale prislúchajúcom ľavému synovi, znamená to, že z pravého syna môžeme zobrať už iba jednotky. A kľudne môžeme zobrať všetky jedotky, ktoré sa v jeho intervale nachádzajú. Naopak, ak sa zlom nachádza v pravom synovi, z ľavého môžeme zobrať všetky nuly. To znamená, že každý vrchol si musí pamätať ďalšie dve hodnoty -- $p_0$ je počet núl v jeho intervale a $p_1$ je počet jednotiek.

V tomto okamihu vieme všetky tri hodnoty vyrátať veľmi jednoduchým spôsobom. Hodnoty $l_0$, $l_1$ a $l\_{01}$ nech patria ľavému synovi, hodnoty $r_0$, $r_1$ a $r\_{01}$ pravému a tie s $p$ patria otcovi. Potom platí:

$$p_0 = l_0 + r_0$$ $$p_1 = l_1 + r_1$$ $$p\_{01} = \\max (l\_{01}+r_1, l_0+r\_{01}, l_0+r_1)$$

Všetky vyššie uvedené vzorce by mali byť intuitívne, ak vám niektorý nie je jasný, nakreslite si to. Posledná možnosť $l_0+r_1$ nastane vtedy, ak je zlom presne medzi ľavým a pravým synom.

Tieto tri hodnoty nám stačia, keď sa nám invertuje iba interval o dĺžke jeden. Keďže však budeme meniť aj väčšie intervaly, pridáme si do každého vrcholu ešte hodnotu $p\_{10}$ -- najdlhšia podpostupnosť v tomto intervale, ktorá začína jednotkami a končí nulami. Jej rátanie je veľmi podobné tomu pri $p\_{01}$:

$$p\_{10} = \\max (l\_{10}+r_0, l_1 + r\_{10}, l_1+r_0)$$

## Spracovávanie dlších intervalov

V našom riešení už vieme odpovedať na jeden typ operácie (otázku), tým že jednoducho z koreňa vypíšeme hodnotu $p\_{01}$. Treba však vyriešiť, ako meniť náš strom na základe druhého typu operácií (inverz intervalu).

V prípade, že menený interval má dlžku $1$, je všetko pomerne jednoduché. Proste zmeníme hodnotu tohto konkrétneho prvka v poli a následne postupujeme hore stromom až do koreňa, pričom zakaždým prepočítame hodnoty vo vrchole. Zložitosť takejto operácie je $O(\\log n)$. To nám však nepomôže, keď máme zmeniť dlhší interval.

V takomto prípade použijeme metódu, ktorá sa volá lazy loading. Namiesto toho, aby sme začali zdola, začneme od koreňa a postupne budeme zisťovať, ktoré vrcholy majú celý svoj interval vnútri invertovaného intervalu. Keď nájdeme takýto vrchol, spravíme nasledovné: vieme, že všetky čísla, ktoré ležia pod týmto vrcholom sa zmenili na opačné. Tým pádom sa nám vymenia hodnoty $p_0$ a $p_1$ a tiež $p\_{01}$ a $p\_{10}$ (preto sme si ju pridali). Tento vrchol $x$ teda vieme opraviť na správne požadované hodnoty bez toho, aby sme mali správne hodnoty aj v jeho synoch.

Čo však s vrcholmi, ktoré ležia pod ním? Tým zatiaľ zatajíme, že sa zmenili, akurát si do tohto vrchola $x$ v premennej $lazy$ zaznačíme, že ešte nepovedal vrcholom pod sebou, že sa majú invertnúť. Následne prepočítame hodnoty všetkých vrcholov na ceste z koreňa do tohto vrchola a máme vybavené.

Čo však keď budeme potrebovať hodnotu z nejakého vrchola, ktorý má byť invertovaný, ale ešte o tom nevie? Ak sa stane niečo takéto, určite budeme musieť prejsť cez vrchol $x$. Ten však v momente, keď cez neho prechádzame, zbadá, že ešte nepovedal vrcholom pod sebou, že sa majú invertovať, tak im to rýchlo oznámi a zmaže si hodnotu $lazy$. Vrcholy pod ním si teda povymieňajú svoje hodnoty a zaznačia si hodnotu $lazy$, lebo to musia povedať tým pod sebou. Tým pádom vždy, keď potrebujeme použiť hodnotu nejakého vrchola, tento vrchol už pozná svoje skutočné hodnoty a vie nám ich povedať.

Dôvod, prečo je niečo takéto rýchlejšie je ten, že robíme iba robotu, ktorá je absolútne nevyhnutná. Ak sa totiž nikdy nespýtame na žiaden vrchol pod $x$, načo by sme im oznamovali, že sú zmenené? A vďaka premenným $lazy$ si vieme pamätať, kto ešte musí niečo povedať. Tento princíp vôbec nie je taký zložitý, ako by sa mohlo na prvý pohľad zdať. Odporúčame si nakresliť nejaký strom na papier a popozerať sa, ako by sa tie hodnoty mali meniť a takisto si poriadne preštudovať nižšie uvedený program, hlavne funkcie $update()$ a $process_lazy()$.

Zložitosť takejto operácie nie je o nič väčšia ako klasické intervalové vyhľadávanie -- $O(\\log n)$. Dostávame algoritmus s časovou zložitosťou $O(q \\log n)$ a pamäťovou zložitosťou $O(n)$.
",10
150ca88b199bca4d,ksp,"﻿# Opravte matfyz

Po výskyte ploštíc na matfyze vedeniu došla trpezlivosť. Rozhodlo sa urobiť jeho kompletnú prerábku.

Gratulujeme! Tvoja stavebná firma Kopu Stavieb Postavím vyhrala verejné obstarávanie a teraz má zabezpečiť prerábanie matfyzu. Prerábka pozostáva z úloh, pričom o každej vieš ako dlho trvá jej dokončenie. K dispozícii máš stavbyvedúceho, zároveň si môžeš najať niekoľko robotníkov. Predtým, ako sa robotník zapojí do práce, musí absolvovať školenie u stavbyvedúceho, ktorý počas toho nepracuje. Bez stavbyvedúceho na stavbe sa robotníci flákajú a nepracujú. Ako rýchlo dokážeš vykonať prerábku?

## Úloha

Úlohou je nájsť najrýchlejší možný čas za aký sa dá stihnúť vykonať $n$ úloh, pričom každá trvá $t$ hodín. Na začiatku máš iba stavbyvedúceho, ale na začiatku každej hodiny si môžeš najať najviac $r$ robotníkov. Robotníci musia absolvovať povinné školenie u stavbyvedúceho, ktorý počas tej doby nepracuje. Každý robotník je inak šikovný a trvá mu iný čas, kým bude zaškolený. Stavbyvedúci dokáže školiť jedného robotníka naraz. Bez stavbyvedúceho sa nepracuje. Po absolvovaní školenia dokáže robotník pracovať rovnako rýchlo ako stavbyvedúci. Na každej úlohe môže pracovať najviac 1 človek (či už robotník, alebo stavbyvedúci).

## Formát vstupu

Na vstupe je jediný riadok, na ktorom sú medzerou oddelené čísla $n,t,r;(1\\leq t\\leq 5,000)$ -- počet úloh, trvanie jednej úlohy, a počet robotníkov, ktoré máš k dispozícii. Na druhom riadku je $r$ medzerou oddelených čísel $p_i; (1\\leq p\\leq 100,000)$ -- čas, koľko trvá zaškoliť $i$-teho robotníka. Platí, že:

- v prvej sade platí, že školenie aj vykonanie úlohy trvá vždy 1 ($\\forall i: p_i=t=1$)
- v druhej a tretej sade platí, že školenie trvá vždy rovnako ako vykonanie úlohy ($\\forall i: p_i=t$)
- o zvyšných piatich sadách nemôžete nič predpokladať

Pre premenné platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------|---------:|---------:|---------:|---------:| | $1 \\leq n \\leq$ | $100$ | $10000$ | $100000$ | $300000$| | $1 \\leq r \\leq$ | $100$ | $5000$ | $200000$ | $1000000$|

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo, najkratší možný počet hodín za ktorý sa dá stihnúť prerábka.

## Príklady

```vstup
2 2 3
3 2 1
```

```vystup
3
```

*Samotný stavbyvedúci by prácu vykonal za $2\\cdot 2=4$ hodiny, ale viac sa oplatí, ak hneď na začiatku za 1 hodinu zaškolí jedného (tretieho) robotníka, a potom tento robotník spolu s ním urobí každý jednu 2 hodiny trvajúcu úlohu. Celkovo teda stavba bude trvať len $2+1=3$.*

```vstup
1 2 3
1 2 3
```

```vystup
2
```

*Pri jednej úlohe sa neoplatí najímať robotníka.*

```vstup
3 3 3
50 50 50
```

```vystup
9
```

*Školenie robotníka by trvalo tak dlho, že sa viac oplatí robiť všetko sám.*
","# Opravte matfyz

Úlohou bolo nájsť najrýchlejší možný čas, za ktorý sa dalo splniť $n$ úloh, pričom splnenie každej trvá $t$ hodín. Plnenie úloh bolo možné urýchliť (ale aj spomaliť) vyškolením a najatím najviac $r$ robotníkov, pričom každý má samostatne určenú zručnosť.

## Bruteforce

Platí, že jediné spôsoby, akými môžeme ovplyvniť čas splnenia úloh sú:

- počet robotníkov, ktorých najmeme, označme si ho $i$, pričom $0\\leq i\\leq r$ - to je $r$ možností
- ktorých konkrétnych $i$ robotníkov z $r$ si vyberieme - to je $r \\choose i$ možností
- po splnení ktorej úlohy každého z nich vyškolíme - to je $r^n$ možností.

Čas splnenia $n$ úloh, pričom každá trvá $t$ hodín s $i$ robotníkmi vieme vypočítať v konštantnom čase vzorcom $\\lceil\\frac{n}{i}\\rceil\\cdot t+u$, kde $u$ je doba školenia daných robotníkov. Pomocou bruteforce teda vyskúšame nájsť čas splnenia úloh pre každú kombináciu týchto faktorov. Pamäťová zložitosť takéhoto riešenia je $O(r)$, keďže si pamätáme len zručnosť každého robotníka. Časová zložitosť takéhoto riešenia je $O(r^n)$.

## Vlastnosti optimálneho riešenia

Poďme za pozrieť na spôsoby, akými vieme eliminovať niektoré z vyššie opísaných faktorov.

### Kedy vyškoliť robotníkov

Zamyslime sa nad tým, kedy sa najviac oplatí školiť robotníkov. Predpokladajme, že už sme našli optimálny počet aj výber konkrétnych robotníkov, ktorých zamestnáme a stačí nájsť už len optimálne úlohy, po ktorých splnení jednotlivých robotníkov vyškolíme. Zrejme platí, že to bude vždy ešte pred začatím stavby, keď nie je splnená ani jedna úloha. Keďže školenie robotníka trvá rovnako dlho bez ohľadu na to, kedy sa začne, nikdy sa neoplatí školenie nejakých robotníkov odkladať, lebo sa tým zbytočne stratí čas, počas ktorého mohli títo robotníci pracovať, ale nepracujú.

### Ktorých robotníkov si vybrať

Teraz predpokladajme, že už máme optimálny počet robotníkov a aj sme určili správny moment, kedy ich vyškoliť (už vieme, že to je na začiatku). Môže nastať prípad, kedy je optimálny počet robotníkov menší ako $r$, čiže si môžeme vyberať, ktorých konkrétnych najmeme. V tomto prípade bude zrejme najoptimálnejšie najať tých najzručnejších, lebo ich školenie zaberie najkratší čas.

### Koľko robotníkov vyškoliť

Keďže sme už určili, kedy sa najviac oplatí vyškoliť robotníkov aj ktorých konkrétnych si vybrať, stačí nám už len nájsť optimálny počet robotníkov, ktorý vyškolíme. Nakoľko čas splnenia $n$ úloh s $i$ robotníkmi ak každá trvá $t$ dlho vieme vypočítať v konštantnom čase vzorcom z predošlého riešenia, môžeme si dovoliť vyskúšať všetky možné počty robotníkov, ktoré zaškoliť. Uvedomme si, že ak by sme aj mali možnosť vyškolit viac robotníkov ako je úloh, zrejme sa to nikdy neoplatí, a teda počet robotníkov ktorý sa oplatí vyškolit je zhora ohraničený počtom úloh.

Počet možností bude preto vždy najviac $\\text{min}(r, n)$.

## Riešenie

Zhrňme si, ako bude vyzerať nájdenie optimálneho riešenia. Nemusíme skúšať všetky možné úlohy, po ktorých vyškoliť robotníkov, ale ich všetkých vyškoliť hneď zo začiatku. Zároveň nemusíme skúšať všetky možné kombinácie jednotlivých robotníkov, ale vybrať vždy len tých najzručnejších. Zoradenie robotníkov od najzručnejších zaberie $O(r\\log r)$. Tým pádom stačí nájsť len optimálny počet robotníkov. Tento počet nájdeme vyskúšaním všetkých možností. Teda, pre každý počet robotníkov od $0$ po $r$ vypočítame, ako dlho bude trvať splnenie úloh a vypíšeme najmenšiu nájdenú hodnotu, čo bude trvať O(r). Pamäťová zložitosť takéhoto riešenia je $O(r)$, keďže si pamätáme len zručnosť každého robotníka. Časová zložitosť takéhoto riešenia je $O(r\\log r)$.
",4
81497995b89140a9,ksp,"# Radšej budem upratovať v T2

Na poslednej chate vedúcich Trojstenu vznikol nápad, že by Trojstenáci mohli spolu chodievať do divadla aby si utužili kolektív, získali inšpiráciu na dej sústredenia, naučili sa hereckému majstrovstvu na hranie dejových scénok... Vtedy ti to prišlo ako dobrý nápad, však čo sa môže takým divadlom pokaziť. Veď to si tam proste sadneš, a pozeráš sa. To nemôže byť také zlé... Jedine, ak by bolo. Kvôli tragickým hereckým výkonom si po prvých piatich minútach predstavenia začal ľutovať, že si radšej neostal na intráku robiť domáce úlohy. Po desiatich ti už aj umývať špinavé riady v T2 príde ako dobrý nápad. Po 15tich minútach sa postavíš, aby si odišiel, ale čo sa to deje? Naľavo aj napravo od teba sedia vedúci, a je neslušné ich prekračovať kým sedia. Našťastie, nie si jediný, ktorému to predstavenie príde zlé, a chce odísť... V akom poradí odídu všetci Trojstenáci zo sály?

## Úloha

V divadle sedí v jednom rade $n$ vedúcich. Pre jednoduchosť si ich označme prirodzenými číslami $1$ až $n$. Každého z nich po nejakom čase prestane baviť sa pozerať na divadlo, a bude chcieť odísť. Odísť ale môže len vtedy, ak naľavo, alebo napravo od neho nikto nesedí. Viete poradie, v akom sedia vedúci v rade, a viete poradie, v akom ich prestane baviť sa pozerať na divadlo. Vypíšte poradie, v akom odídu zo sály.

## Formát vstupu

Na prvom riadku sa nachádza číslo $n$, ($1\\leq n \\leq 100,000)$: počet vedúcich, ktorí sedia v rade. Na druhom riadku sa nachádza $n$ medzerou oddelených čísel $s_i$, ktoré označujú vedúcich v poradí v akom sedia v rade. Prvé a posledné číslo predstavujú vedúcich, ktorí sedia na kraji. Na poslednom riadku dostanete $n$ medzerou oddelených čísel $p_i$, ktoré znamenajú poradie, v akom vedúcich prestalo baviť pozerať divadlo.

## Formát výstupu

Vypíšte jeden riadok s $n$ medzerou oddelenými číslami, poradie v akom vedúci odídu zo sály. Za posledným číslom medzeru nevypisujte. Nezabudnite na znak konca riadku.

## Príklad

```vstup
3
3 1 2
1 3 2 
```

```vystup
3 1 2
```

*Najprv prestane divadlo baviť vedúceho $1$, ktorý ale nemôže odísť. Potom, ako prestane divadlo baviť vedúceho $3$, ktorý sedí na kraji, už má aj vedúci $1$ voľnú cestu zo sály, a odíde aj ten. Nakoniec prestane divadlo baviť vedúceho $2$, ktorý okamžite odíde.*

```vstup
5
1 2 3 4 5
1 5 2 4 3
```

```vystup
1 5 2 4 3
```
","# Radšej budem upratovať v T2

## Pomalá simulácia

Prvá vec, ktorú si môžeme všimnúť je, že človek, ktorý je na kraji môže odísť. Skúsme teda postupne simulovať všetkých ľudí, ktorí budú chcieť odísť z divadla. Pre každého človeka, si pamätáme, že či ešte ostáva alebo chce odísť alebo už odišiel. Vieme to urobiť napríklad pomocou poľa, v ktorom každý index znamená jedného človeka. Ak v poli na danom indexe je $0$, tak človek ešte nechce odísť, ak je tam $1$, tak človek chce odísť, ale nemôže, a ak je tam $2$, tak už odišiel.

Teraz môžeme postupne prejsť ľudí, v poradí v ktorom chcú odísť. Vždy keď niekto chce odísť, prepíšeme mu $0$ na $1$, prejdeme všetkých ľudí (celé pole), a skontrolujeme či tento človek môže odísť. Teda či na všetkých menších alebo na všetkých väčších indexoch je $2$. Ak môže odísť, tak si k nemu poznačíme že odišiel a následne zmeníme všetkých ľudí, ktorí vďaka tomu, že odišiel tento človek, môžu odísť tiež. (Môžete si všimnúť, že keď človek odchádza doľava, uvoľní sa cesta človeku vpravo od neho.)

Avšak, problém tohoto riešenia je, že pre každého človeka v poradí v akom chce odísť musíme prejsť všetkých ostatných ľudí, teda časová zložitosť je $O(n^2)$.

## Lineárne riešenie

Lepšie riešenie je, ak by sme si pamätali, že kde na oboch stranách sedí najkrajnejší človek (ako takú zarážku). Úsek sediacich bude totiž vždy súvislí, keďže zo stredu nemôže odísť nikto. Ďalej si budeme pamätať ku každému človeku, že či už chce odísť alebo nie; podobne ako v pomalom riešení. Keď nejaký človek začne chcieť odísť (slovenčina je krásna ;) ), tak si k nemu poznačíme, že chce odísť a skontrolujeme či sa jedna z týchto ""zarážok"" vďaka tomu už dá posunúť.

## Časová a pamäťová zložitosť

Toto riešenie na prvý pohľad nevyzerá o nič lepšie, ak sa na to nepozrieme takto: Keď je človek na rade, tak si v konštantnom čase poznačíme, že už chce odísť, a následne nejako posunieme zarážku. Obe zarážky dokopy ale určite neposunieme viac ako $n$-krát a ľudí je tiež práve $n$. Naša časová zložitosť je teda $O(n)$ času poznačiť si všetkých ľudí, a k tomu tiež spolu $O(n)$ posunutí zarážky. Časová zložitosť je teda $O(n)$.

Čo sa týka pamäťovej zložitosti, potrebujeme si pamätať len niekoľko polí dĺžky $n$: poradie v akom sedia ľudia, poradie v akom chcú odísť a to či už chcú odísť alebo nie. Pamäťová zložitosť je teda tiež $O(n)$.
",2
62a0eaabcbff06f0,ksp,"﻿# Zaujímavé kŕmenie strašidelnej príšery

Kým ste prázdninovali, kúpali sa, plávali, KSPáci svedomito pracovali. Kolektívne spisovali príklady, ktorými sa po konci slnečných prázdnin potrápite. Samozrejme, príklady sa spravili počas prvých pár piatkov. Krátko potom prišla prázdnota.

""Kam sa počneme po spravení príkladov?"" premýšľali.

""Pôjdeme sa kúpať? Prechádzať sa po kopcoch? Spoznávať krásy sveta? Programovať? Kŕmiť pestrofarebné papagáje poletujúce po parku?""

""Kdeže, kúpime si príšeru!"" prehlásil Peter. Každý súhlasil.

Po kúpe príšery prišli prvé problémy. Príšeru potrebovali pravidelne kŕmiť. Samozrejme, potrebovali pre príšeru pekné priestory. Príšera potrebuje pohodlie. Posledný problém, ktorý súvisí s pohybom príšery, spôsobili KSPáci kŕmením.

Poznatky KSPákov súvisiace s prirodzeným prostredím príšer sú slabé. Skúšali kartónovú krabicu, plastové poháre, sklenenú karafu, sivú prútenú klietku, komoru skrytú pod kamenným stolom, plesnivú pivnicu, plechový kváder pokrytý strieborným plátnom, ktoré kedysi patrilo svetoznámemu kinu. Príšera pohrdla každým spomenutým priestorom. Správna potrava pre príšery? Príšerne podpriemerné poznatky prebývajú pod kučerami KSPáckych kotŕb. Sprvu sa KSPáci pokúšali kŕmiť príšeru kvasenou kyslou kapustou. Ktovie, prečo práve kyslú stravu skúsili KSPáci prvú. Pokus kŕmiť príšeru kapustou skončil katastrofou. Príšera sa priotrávila. Krátko potom stratila schopnosť korigovať smer svojho pohybu. Smutný príbeh. KSPáci potrebovali kompletne pozmeniť prístup. Snáď sa stav príšery polepší.

Po poradení sa s profesionálom posadili KSPáci svoju príšeru pod podlhovastú skrinku pokrývajúcu severnú stenu prastarej kúpeľne. Kopa prachu pod skrinkou poskytuje príšere príjemné pohodlie. Kúpeľňa sa prestala používať pred storočiami, preto se stala príbytkom poriadneho počtu pavúkov. Pavúky sú skvelým krmivom pre pažravú príšeru, pretože sú plné sviežich substancií. Krása. Sen pre pažravé príšery, ktoré sa snažia pribrať. Podlahu kúpeľne pokrýva $k$ krát $s$ kachličiek ($s$ stĺpcov, každý s $k$ kachličkami). Poniektoré kachličky sú prázdne, poniektoré sa pýšia pavúkom sediacim prostred kachličky.

Srstnaté končatiny príšery spôsobujú pavúkom strach. Keď sa príšera prvýkrát pozrie spod skrinky, poškrabká svojou krivou paprčou studenú kachličku, pavúky sa preľaknú. Každý pavúk sa pustí strečkovať smerom ku ktorejsi stene. Keď pribehnú ku kraju kúpeľne, schovajú sa pod podlahu. Preto príšera potrebuje pochytať pavúky počas svojej prvej prechádzky. Kvôli pokazenej koordinácii pohybov (spôsobenej priotrávením sa kyslou kapustou) stratila príšera schopnosť kráčať kľukato. Preto sa pohybuje po polpriamke kolmej so severnou stenou kúpeľne.

Príšera sa pohybuje súčasne s pavúkmi. Keď príšera spraví krok, pavúky spravia krok. Keď príšera prejde kachličku, pavúky prejdú kachličku.

Poznáte pozície pavúkov. Poznáte smer pohybu každého pavúka. Pre každý stĺpec kachličiek spočítajte počet pavúkov, ktoré príšera stretne, keď stĺpcom pôjde.

## Úloha

Ako ste určite pochopili z predošlého textu, vedúci KSP si kúpili príšeru, ktorú ubytovali v starej opustenej kúpeľni. V tejto kúpeľni žijú pavúky a príšera by chcela nejaké z nich zjesť.

Kúpeľna obdĺžnikového tvaru je rozdelená na mriežku kachličiek rozmerov $k\\times s$. V kúpeľni je $p$ pavúkov, každý sa nachádza uprostred niektorej kachličky. O každom pavúkovi viete jeho počiatočnú pozíciu a tiež smer jeho pohybu. Smer môže byť na sever, východ, západ alebo juh.

Príšera si vyberie nejaký zo stĺpcov a vykukne spod skrinky severne od prvej rady kachličiek. Potom sa bude pohybovať smerom na juh rovnako rýchlo ako pavúky. Kým sa dostane doprostred prvej kachličky, pavúky akurát prejdú vzdialenosť jednej kachličky. Vždy, keď stretne nejakého pavúka, zožerie ho a pokračuje ďalej v pohybe.

Pre každý stĺpec vypíšte, koľko pavúkov príšera zje, ak si vyberie daný stĺpec.

## Formát vstupu

V prvom riadku vstupu sú tri čísla $p$, $k$ a $s$ udávajúce počet pavúkov a rozmery kúpeľne.

Nasleduje $p$ riadkov, na $i$-tom z nich sú dve čísla $k_i$, $s_i$ ($1\\leq k_i\\leq k, 1\\leq s_i\\leq s$) a písmeno. Pavúk sedí na začiatku v riadku $k_i$ a stĺpci $s_i$. Podľa toho, či je písmeno `S`, `V`, `J` alebo `Z` sa bude pavúk pohybovať na sever, východ, juh alebo západ. Smerom na juh stúpajú čísla riadkov a smerom na východ stúpajú čísla stĺpcov.

Pre jednotlivé vstupné sady platia nasledovné obmedzenia:

| Číslo sady | 1 | 2 | 3 | 4 | |---------------------| ---:| ---:| ---:| ---:| | Maximálne $k$, $s$, $p$ | $50$ | $1,000$ | $100,000$ | $500,000$ |

## Formát výstupu

Vypíšte jeden riadok, na ktorom bude $s$ čísel oddelených medzerami. Za posledným číslom nevypisujte medzeru. $i$-te z týchto čísel má byť počet pavúkov, ktoré by príšera zjedla, keby sa vybrala $i$-tym stĺpcom.

## Príklad

```vstup
4 4 5
1 1 V
3 2 V
1 4 J
4 5 S
```

```vystup
0 1 0 0 2
```
","# Zaujímavé kŕmenie strašidelnej príšery

Každý pavúk môže stretnúť príšeru najviac v jednom stĺpci a to najviac raz. Vieme pomerne jednoducho spočítať, či pavúk vôbec dokáže stretnúť príšeru a ak áno, tak v ktorom stĺpci ju stretne.

Ak sa nám toto podarí zistiť, odpoveď na úlohu zistíme tak, že najprv vyrobíme pre každý stĺpec počítadlo (na začiatku s hodnotou 0) a následne cyklom prejdeme všetky pavúky. Pre každého pavúka vypočítame stĺpec, v ktorom pavúk stretne príšeru a ak taký stĺpec existuje, zvýšime si počítadlo daného stĺpca. Na konci len vypíšeme počítadlá pre každý stĺpec.

V programe budeme rozlišovať pavúky podľa toho, ktorým smerom sa hýbu. Pavúky, ktoré idú na juh (dolu) príšeru nestretnú nikdy, pretože sú vždy pred ňou. Pavúky, ktoré idú na sever (hore) stretnú príšeru v tom stĺpci, v ktorom sa nachádzajú.

Pavúky, ktoré idú na západ (vľavo), môžu stretnúť príšeru len vtedy, keď sa príšera ocitne v rovnakom riadku, pretože tieto pavúky idú stále po tom istom riadku. To, kedy to bude, vieme ľahko vypočítať: príšera sa do $k$-teho riadku dostane po $k$ sekundách. Takže pavúk, ktorý ide na západ a začína na pozícii $(k_i, s_i)$ môže stretnúť príšeru iba po $k_i$ sekundách od začiatku pohybu. A vtedy sa pavúk bude nachádzať v stĺpci $s_i - k_i$ (alebo už bude schovaný pod podlahou, ak $s_i - k_i < 1$). Preto tento pavúk buď stretne príšeru v stĺpci $s_i - k_i$, alebo ju nestretne vôbec (ak $s_i - k_i < 1$).

Podobne pavúky, ktoré idu na východ (doprava) stretnú príšeru v stĺpci $s_i + k_i$ alebo vôbec, ak $s_i + k_i > s$.

Časová zložitosť riešenia je $O(p + s)$. Načítanie vstupu a výpočet pre každého pavúka zaberie $O(p)$ času. Výpis výstupu $O(s)$. Pamäťová zložitosť je $O(s)$.
",4
6c70461f479dcaef,ksp,"# Ozajstné vzrušenie

Zdeno má veľmi rád vlaky. Raz sa takto premával celým Slovenskom -- najprv Poprad, potom Žilina, následne Piešťany, Leopoldov, Trnava, až nakoniec vlak zastal v Bratislave. A potom opačným smerom -- do Košíc. A zase naspäť. Zdeno celé dni nič iné nerobil, iba sa vozil vlakom z Košíc do Bratislavy a z Bratislavy do Košíc.

Počas svojich dobrodružstiev Zdeno poriadne vyhladol. Nemal inú možnosť, ako vystúpiť a kúpiť si bagetu v najbližšom stánku s občerstvením. Neuveríte, ale keď sa sýty Zdeno vracal na nástupište, nevedel si spomenúť, ktorým smerom išiel vlakom naposledy.

Zdeno si po toľkých cestách presne pamätá, ako vyzerá trasa z Bratislavy do Košíc -- pamätá si ju ako postupnosť farieb domov, ktoré vidí z okna na severnej strane vlaku. (Zdeno vždy sedáva na severnej strane, aby mu nesvietilo slnko do očí.)

Pri svojej poslednej ceste sa Zdeno nepozeral z okna celý čas. Chvíľku sa pozeral, potom si prečítal noviny. Znova sa pár minút pozeral a zadriemal. A tak ďalej. Preto si pamätá len niekoľko **súvislých** úsekov trasy. Pomôžte mu na základe týchto spomienok zistiť, či cestuje z Bratislavy do Košíc, alebo opačným smerom.

## Úloha

Daný je reťazec znakov, popisujúci farby domov na ceste z Bratislavy do Košíc. Zdeno rozoznáva 26 farieb, ktoré si označil písmenami `a` až `z`. Cesta z Košíc do Bratislavy vyzerá rovnako, len reťazec je obrátený (znaky čítame sprava doľava).

Ďalej máme niekoľko ďalších reťazcov, popisujúcich súvislé časti jazdy, ktoré si Zdeno pamätá. Časti sa neprekrývajú, môžu však na trase nasledovať aj hneď za sebou. Vlak cestuje z Bratislavy do Košíc, ak na ceste vieme nájsť všetky časti, a navyše v tom poradí, v akom sú časti zadané. Podobne to platí pre opačný smer, len časti hľadáme na opačnej ceste.

Zistite, ktorými smermi môže vlak cestovať.

## Formát vstupu

Na prvom riadku vstupu je reťazec malých písmen anglickej abecedy -- cesta z Bratislavy do Košíc. Na druhom riadku je číslo $n$ -- počet úsekov, ktoré Zdeno videl z okna vlaku.

Nasleduje $n$ riadkov a na každom z nich je jeden reťazec malých písmen anglickej abecedy, popisujúci jeden úsek. Úseky sú dané v poradí, v akom ich Zdeno videl.

Súčet dĺžok všetkých reťazcov na vstupe nepresiahne $2,000,000$.

## Formát výstupu

Ak je jednoznačne určený smer jazdy, tak ak cestuje z Bratislavy do Košíc, vypíšte jeden riadok s textom ""z Bratislavy do Kosic"", inak vypíšte ""z Kosic do Bratislavy"".

Ak môže vlak cestovať oboma smermi, vypíšte ""neviem"".

Ak vlak nemohol cestovať ani jedným smerom, vypíšte ""zabludil"".

## Príklad

```vstup
abcaabbabaa
3
aab
ba
ba
```

```vystup
neviem
```

```vstup
xxyyzzxyzxyz
2
yyzz
zz
```

```vystup
zabludil
```

```vstup
cbaxxxxabcdefxxxxccbbaa
2
abc
xx
```

```vystup
z Bratislavy do Kosic
```
","# Ozajstné vzrušenie

Zamyslime sa nad tým, ako by mohol Zdeno sám overiť, ktorým smerom mohol cestovať. Zaoberajme sa len cestou z Bratislavy do Košíc, cestu opačným smerom overíme analogicky. Zdeno môže postupovať nasledovne: začne v Bratislave, a pôjde smerom do Košíc. Pritom si postupne vyškrtáva úseky, ktoré už videl -- vždy, keď vlak prejde časť cesty reprezentovanú jedným znakom, tak Zdeno overí, či práve *nedopozeral* aktuálne overovaný úsek. Ak áno, tak si ho zaškrtne (nakoľko nič nestratí tým, že ho zaškrtne najskôr, ako vie), a začne overovať nasledujúci úsek.

Zamyslime sa teraz nad tým, ako môže Zdeno overovať, či práve nedopozeral aktuálny úsek. Jeho reťazec si označíme $B$ a jeho znaky si postupne označíme $B_1, B_2, \\ldots, B\_{|B|}$. Reťazec reprezentujúci cestu z Bratislavy do Košíc si označíme $A$, a jeho znaky postupne $A_1, A_2, \\ldots, A\_{|A|}$. Aktuálnu pozíciu vlaku označíme $i$.

## Riešenie hrubou silou

Uvedomíme si, čo chceme zistiť. To, či Zdeno dopozeral $B$, znamená presne to, že reťazec posledných videných $|B|$ znakov je rovný $B$. Formálne, je to ekvivalentné tomu, že $B = A\_{i-|B|+1} A\_{i-|B|+2} \\ldots A\_{i-1} A_i$. A to vieme overiť jedným prechodom -- najprv overíme, či $A_i = B\_{|B|}$. Ak nie, tak Zdeno $B$ nemohol dopozerať, a skončíme. Ak áno, tak overíme $A\_{i-1} = B\_{|B|-1}$, ak aj to platí, tak overíme $A\_{i-2} = B\_{|B|-2}$, a tak ďalej, až po posledný znak. Ak sme nenašli žiaden rozdiel, Zdeno práve dopozeral $B$.

Zamyslime sa nad časovou zložitosťou tohto algoritmu. Na jednej pozícii $i$ môžeme potrebovať overiť až $O(|B|)$ znakov. Dokopy môže Zdeno spraviť až $O|A|\\cdot |B|)$ operácií -- presnejšie $O(d \\cdot |B|)$, kde $d$ je vzdialenosť prejdená vlakom, kým Zdeno nenájde pozíciu, kde končí hľadaný úsek. A naozaj existuje vstup, na ktorom ich toľko spraví -- napríklad $A = aaaaaa \\ldots a$ a $B = aaaa \\ldots aaab$.

Všimnime si, že náš algoritmus v skutočnosti robí nasledovné: zistí, aký najdlhší **sufix** $B$ končí na pozícii $i$^[Každý podreťazec slova $W$ vieme reprezentovať dvojicou $(l, r)$, kde $l$ je pozícia začiatku podreťazca, a $r$ je pozícia konca podreťazca. Sufix je každý taký podreťazec, pre ktorý $r = |W|$. Prefix je každý taký podreťazec, pre ktorý $l=1$. Sufixy slova $abca$ sú teda $a, ca, bca, abca$. Prefixy sú $a, ab, abc, abca$.]. Keď ale Zdeno uvidí nový znak, tak nevieme jednoducho z predchádzajúceho najdlhšieho sufixu povedať, aký bude najdlhší sufix teraz.

## Skoro algoritmus KMP

Čo keby sme sa ale nepozerali na najdlhší sufix, ale **najdlhší prefix $B$ končiaci na pozícii $i$**? Z takej informácie tiež vieme ľahko overiť, či Zdeno práve dopozeral $B$ -- vtedy je najdlhší prefix dlhý $|B|$.

Predpokladajme, že poznáme najdlhší prefix končiaci na pozícii $i$. Označme jeho začiatok $l_1$. (Potom je tento najdlhší prefix dlhý $i+1-l_1$.) Zamyslime sa nad tým, ako by sme vedeli zistiť najdlhší prefix končiaci na $i+1$. Na to nám stačí zistiť jeho začiatok $l_2$ -- takže hľadáme najmenšie $k$ také, že $A_k A\_{k+1} \\ldots A_i A\_{i+1}$ je prefixom $B$. (Potom $l_2 = k$.) Keďže $A\_{l_2} A\_{l_2+1} \\ldots A_i A\_{i+1}$ je prefixom $B$, tak aj $A\_{l_2} A\_{l_2 + 1} \\ldots A_i$ je prefixom $B$. Preto je najviac taký dlhý, ako prefix začínajúci na $l_1$ a končiaci na $i$, ktorý je najdlhší možný končiaci v $i$. Takže nový prefix, končiaci v $i+1$ nemôže začínať skôr ako na pozícii $l_1$, kde začína $A\_{l_1} A\_{l_1 + 1} \\ldots A_i$. Teda musí platiť $l_2 \\geq l_1$.

Potom nám stačí overovať, či pridaním znaku $A\_{i+1}$ na koniec *predĺžime* starý prefix. Ak áno, tak sme našli najdlhší prefix $B$ končiaci na $i+1$ (teda platí $l_2 = l_1$). Ak nie, tak vyskúšame $k = l_1+1$, ak ani to nevyhovuje, tak vyskúšame $k = l_1+2$, a tak ďalej. Pri overovaní nového $k$ musíme porovnať $i-k+1$ znakov prefixu $B$, či sa zhodujú so znakmi $A_k \\dots A_i$.

Zamyslime sa nad časovou zložitosťou. Ak sa nám podarilo starý prefix *predĺžiť*, tak sme spravili len 1 porovnanie. V opačnom prípade sme pri každom posune $k$ spravili najviac $O(|B|)$ porovnaní. $k$ posúvame vždy len *doprava* (zvyšuje sa), a týchto posunov môže byť najviac $|A|$, alebo $d$ -- vzdialenosť prejdená vlakom, kým Zdeno nenájde pozíciu. Takže celková časová zložitosť môže byť najviac $O(|A| \\cdot |B|)$, resp. $O(d \\cdot |B|)$. Vyzerá to teda tak, že sme si veľmi nepomohli...

## Algoritmus KMP

V predošlej časti sme zistili, že ak si pamätáme najdlhší prefix $B$, ktorý končí na pozícii $i$, občas vieme rýchlo nájsť prefix $B$ končiaci na $i+1$ -- ak je znak $A\_{i+1}$ ďalším znakom v $B$. Ak ale $A\_{l_1} A\_{l_1 + 1} \\ldots A\_{i+1}$ nie je prefixom $B$, potrebujeme zistiť, kde má začínať najdlhší prefix $B$ končiaci na pozícii $i+1$. Teraz si ukážeme, ako program vylepšiť tak, aby sme pre $l_2$ nemuseli skúšať všetky hodnoty $l_1+1, l_1+2, \\dots, i+1$ ale len tie, ktoré by *veľmi pravdepodobne* mohli byť začiatkami nejakého prefixu $B$ -- začiatky druhého najdlhšieho, tretieho najdlhšieho, ... prefixu $B$, ktorý končí v $i$.

Zopakujme si, že $l_2$ má nasledujúce vlastnosti: $l_2 \\geq l_1$. $P_2 = A\_{l_2} A\_{l_2+1} \\ldots A_i$ je prefixom $B$ a $P_1 = A\_{l_1} A\_{l_1+1} \\ldots A_i$ je tiež prefixom $B$. Potom $P_2$ je sufixom $P_1$. Takže by nám stačilo skúšať také **$k$, pre ktoré $A_k A\_{k+1} \\ldots A_i$ je sufixom $P_1$ (a zároveň prefixom $B$)**. Označme si všetky takéto $k$ od najmenšieho postupne $l_1 = k_1 < k_2 < \\ldots < k_K$. Všimneme si, že $A\_{k_2} A\_{k_2+1} \\ldots A_i$ je najdlhší sufix $A\_{k_1} A\_{k_1+1} \\ldots A_i$, ktorý je aj prefixom $B$. Podobne pre $k_3$ a $k_2$, $k_4$ a $k_3$, a tak ďalej až po $k_K$ a $k\_{K-1}$.

Ak by sme vedeli **pre každý prefix $B$, označme ho $P$, zistiť jeho najdlhší vlastný (rôzny od $P$) sufix taký, že je tiež prefixom $B$**, tak by sme našu postupnosť vedeli ľahko zostrojiť:

Nech $P$ je prefix $B$ a $suf(P)$ je najdlhší vlastný sufix $P$. Naša postupnosť možných začiatkov prefixov $B$ -- $k_1 < k_2 < \\ldots < k_K$ -- je potom: $$l_1 = i - |P| + 1,~ i-|suf(P)|+1,~ i-|suf(suf(P))|+1,~ \\ldots,~ i+1$$

Ak sa nám podarí tieto sufixy prefixov $B$ spočítať, program si bude pre každú overovanú pozíciu $i$ v $A$ pamätať $P_i$ -- najdlhší prefix $B$ končiaci v $i$. Keď chceme zistiť najdlhší prefix končiaci na pozícii $i+1$:

- Ak bude ďalšie písmenko v $A$ *dobré* (teda rovnaké ako ďalšie písmenko v $B$, formálne $A\_{i+1} = B\_{|P_i|+1}$), $P\_{i+1}$ bude o 1 dlhší prefix $B$ ako $P_i$.
- Ak bude ďalšie písmenko v $A$ *zlé*, skúsime sa pozrieť, či toto písmenko $A\_{i+1}$ nepasuje za prefix $suf(P_i)$, teda či $A\_{i+1} = B\_{|suf(P_i)|+1}$. Ak áno, našli sme prefix $B$ končiaci v $i+1$ a $P\_{i+1}$ je $suf(P_i)$ s pridaným znakom $A\_{i+1}$ na koniec.
- Ďalej, ak sme nenašli prefix $B$ končiaci na $i+1$, skúsime kratší sufix $P$ a overíme $A\_{i+1} = B\_{|suf(suf(P_i))|+1}$
- ...
- Na konci overíme $A\_{i+1} = B\_{1}$ a dostaneme buď $P\_{i+1} = \\emptyset$ alebo $P\_{i+1} = B_1$.

Program skončí (nájde $B$ v $A$), ak $P_i = B$, teda ak najdlhší prefix $B$ končiaci na pozícii $i$ je samotné $B$.

Aká je časová zložitosť takéhoto programu? Vždy, keď Zdeno uvidí nový znak $A\_{i+1}$, overíme, či vieme aktuálnemu prefixu $P_i = B_1 B_2 \\ldots B\_{|P_i|}$ ($B$ označuje úsek, ktorého *dopozeranie* overujeme) pridať na koniec tento znak, teda či $B_1 B_2 \\ldots B\_{|P_i|} A\_{i+1}$ je prefix $B$. Stačí nám teda len overiť, či $A\_{i+1} = B\_{|P_i|+1}$. Ak nie, tak to skúsime pre prefix dĺžky $|suf(P_i)|$. Overenie každého kratšieho prefixu trvá konštantne dlho -- porovnáme 2 znaky. Pozícia začiatku prefixu $B$, ktorý končí na pozícii $i+1$, sa navyše vždy len zvyšuje. Z toho vyplýva, že celkovo spravíme týmto spôsobom najviac $O(|A|)$ operácií. Ak teda máme čiernu krabičku, ktorá nám konštantne rýchlo odpovedá hodnoty $suf(B_1 B_2 \\dots B_n)$ pre každé $n \\in \\lbrace 0,1,2,\\ldots,|B|\\rbrace$, tak časová zložitosť pre nájdenie $B$ v $A$ bude $O(|A|)$.

Posledná vec, ktorú potrebujeme vyriešiť je, **ako spočítame hodnoty $suf(B_1 B_2 \\dots B_n)$** -- najdlhší sufix $B_1 B_2 \\dots B_n$, ktorý je prefixom $B$. Môžeme si uvedomiť, že každý prefix $B$ je jednoznačne určený jeho dĺžkou. Stačí nám teda pre prefix dĺžky $n$ spočítať dĺžku jeho najdlhšieho vlastného sufixu, čo označíme $suf(n)$.

Všimnime si, čo sme robili v horeuvedenom algoritme. Keď sme chceli zistiť najdlhší sufix slova $B_1 B_2 \\ldots B_n c$, tak nám stačilo skúšať za prefixy slova $B_1 B_2 \\ldots B_n$ pridať $c$. To funguje aj v prípade, že $c = B\_{n+1}$. $suf$ potom vieme spočítať dynamickým programovaním.

Na začiatku nastavíme $suf(0)$, následne, ak poznáme $suf(0),suf(1),\\ldots,suf(n)$, tak na spočítanie $suf(n+1)$ robíme nasledovné: vyskúšame za prefix určený $suf(n)$ pridať $c$, ak to nevyjde, tak za $suf(suf(n))$, ak ani to nevyjde, tak za $suf(suf(suf(n)))$, a tak ďalej $\\ldots$ Až kým sa nám podarí pridať $c$, alebo nepodarí -- vtedy nastavíme $suf(n+1) = 0$. Časová zložitosť je rovnaká, ako vyššie uvedenej časti algoritmu (ale už nepotrebujeme čiernu krabičku, keďže že si tie hodnoty $suf$ po spočítaní pamätáme), lebo sme v podstate ten istý algoritmus spustili na vstupe $B$. Teda časová zložitosť predpočítania dĺžok prefixov bude $O(|B|)$.

Dokopy je časová zložitosť prinajhoršom $O(|A|+|B|)$ -- presnejšie $O(d + |B|)$ ($d$ je vzdialenosť prejdená vlakom).

## Návrat k pôvodnému problému

Pôvodný problém teda vieme riešiť nasledovne: pomocou KMP vieme vytvoriť funkciu, ktorá na vstupe dostane reťazec $A$ reprezentujúci cestu, reťazec $B$ reprezentujúci úsek, ktorého dopozeranie Zdeno overuje, a pozíciu vlaku na nej (prvý znak, ktorý Zdeno zatiaľ nevidel). Tá nám vráti pozíciu, na ktorej Zdeno prvýkrát dopozerá $B$ (resp. nám povie, že taká pozícia neexistuje nejakou nezmyselnou hodnotu, napríklad $-1$). Označíme si $A$ reťazec reprezentujúci cestu z Bratislavy do Košíc, a $A'$ cestu opačným smerom (zrkadlovo obrátený reťazec). $p, p'$ označíme aktuálne pozície vlakov. Postupne načítavame úseky $B$ a zisťujeme, kde Zdeno dopozerá $B$ na úseku $A_p A\_{p+1} \\dots A\_{|A|}$, čo zistíme volaním funkcie $dopozeraj(A, B, p)$ a túto pozíciu zapíšeme do $p$, podobne $dopozeraj(A', B, p')$ zapíšeme do $p'$.

Nakoniec overíme, či mohol Zdeno cestovať prvým smerom (či $p \\neq -1$), a druhým smerom (či $p' \\neq -1$), a podľa toho vypíšeme odpoveď.

Časová zložitosť je $O((d_1 + |B_1|) + (d_2 + |B_2|) + \\ldots + (d_b + |B_b|))$, kde $d_i$ je vzdialenosť prejdená vlakom, kým Zdeno nedopozerá úsek $B_i$. To je rovné $O((d_1 + \\ldots + d_b) + (|B_1| + \\ldots + |B_b|)) = O(|A| + (|B_1| + \\ldots + |B_b|))$, teda je lineárna od veľkosti vstupu.

Pamäťová zložitosť je $O(A + max(|B_1|,|B_2|,\\ldots,|B_b|))$ -- nemusíme si pamätať všetky $B_1,\\ldots,B_b$ naraz, stačí ich načítavať postupne (po každom načítaní zistíme nové $p,p'$ -- pozície vlakov, a následne reťazec môžeme zahodiť, lebo ho už ďalej nepotrebujeme).
",9
3ca1fc1a4e67283e,ksp,"# Črieda pažravých vedúcich

Je pondelňajšie ráno a Kubo sa vyvaľuje na gauči v T2^[T2 je KSP-ácka miestnosť na matfyze]. Aby zvládol náročný týždeň sedenia na prednáškach, v batohu si so sebou dovliekol hromadu čokolád. V momente, ako začal jednu rozbaľovať, dvere do T2 sa otvorili a zjavili sa v nich Vlejd s Baškou. Sotva zračili fialový obal, div si neoslintali svoje krásne nové KSP tričká.

Kubovi bolo teda hneď jasné, že sa bude musieť o čokolády deliť. Kubo je **k**rásny, **s**pravodlivý a **p**rajný, preto sa chce deliť rovnomerne. Rýchlo v hlave prerátal, koľko dielikov treba každému z nich troch ulomiť, no skôr ako stihol čokoládu prerozdeliť, dvere sa rozleteli znova a vošla Šandyna s Jarom. Celý proces slintania a prerátavania sa zopakoval, no to sa už do T2-ky tlačil Adam s Dendou. Kubo, vidiac tento nemilý trend, začal premýšľať.

Koľko najviac vedúcich môže ešte do T2 prísť po dvojiciach tak, aby im mohol (vrátane seba) spravodlivo rozdeliť čokoládu?

## Úloha

Keďže vedúci prichádzajú do T2 po dvojiciach, spolu s Kubom ich bude vždy nepárny počet. Každá z Kubových čokolád má nejaký počet dielikov (označme ho $n$), ktoré by chcel (teda, už musí :) ) rovnomerne prerozdeliť spravodlivo medzi seba a zvyšných vedúcich. Zaujíma ho najväčší možný počet vedúcich, pre ktorý sa čokoláda ešte dá rozdeliť. A vy mu s tým máte pomôcť.

## Formát vstupu

Na prvom riadku sa nachádza číslo $q$ -- počet čokolád, ktoré má Kubo v batohu. Nasleduje $q$ riadkov, pričom $i$-ty z nich obsahuje číslo $n_i$ -- počet dielikov $i$-tej čokolády. Pre jednotlivé testovacie sady sú horné limity pre $q$ a $n_i$ dané nasledujúcou tabuľkou:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:-----------------:|:--------:|:--------:|:--------:|:---------:| | $1 \\leq n_i \\leq$ | $2^{16}$ | $2^{32}$ | $2^{60}$ | $2^{60}$ | | $1 \\leq q \\leq$ | $100$ | $500$ | $1,000$ | $10,000$ |

(Nezabudnite použit 64bitové premenné. V C++ **long long**, v Pascale **Int64**, v Jave **long**)

## Formát výstupu

Pre každú čokoládu vypíšte jeden riadok obsahujúci najväčší (nepárny) počet vedúcich, medzi ktorých sa dá čokoláda rozdeliť rovnomerne.

## Príklady

```vstup
3
24
60
1
```

```vystup
3
15
1
```

_Čokoládu s 24 dielikmi vieme rovnomerne rozdeliť medzi troch vedúcich (každému dáme 8 dielikov). Čokoládu s 60 dielikmi vieme rozdeliť medzi pätnástich (každému dáme 4 dieliky). Čokoláda s jedným dielikom sa nedá deliť, takže ju Kubo musí zjesť, keď bude niekde sám._
","# Črieda pažravých vedúcich

Pre zadaný počet dielikov čokolády $n$ chceme vedieť, koľkým najviac vedúcim ich vieme spravodlivo rozdeliť, ak je vedúcich nepárne veľa. V preklade to znamená, že hľadáme najväčšie nepárne číslo $k$, ktoré delí $n$ bezo zvyšku.

Úplne najjednoduchšie riešenie môže fungovať tak, že postupne budeme cyklom prechádzať čísla $1 \\dots n$ a pre každé otestujeme, či je nepárne a zároveň deliteľom $n$. Ak také nájdeme, uložíme si ho, a po skončení cyklu tak dostaneme správnu odpoveď. Takéto riešenie hrubou silou má pre jedno $n$ časovú zložitosť $O(n)$, pre $q$ požiadavok $O(n \\cdot q)$ a mohli ste zaň dostať maximálne jeden bod.

Predošlé riešenie vieme vylepšiť tak, že budeme deliteľe skúšať nie po $n$ ale iba $\\sqrt{n}$. Ak by totiž $n$ malo deliteľ $d$ väčší ako $\\sqrt{n}$ potom nutne $n \\div d < \\sqrt{n}$. Prejdeme teda $1 \\dots \\sqrt{n}$ a pre každé číslo $k$ z tohto intervalu sa pozrieme, či delí $n$. Ak áno, pozrieme sa, či $k$ alebo $n \\div k$ je nepárne a ak je, aktualizujeme jeho hodnotou doterajšie nájdené maximum. Toto riešenie má celkovú časovú zložitosť $O(\\sqrt{n} \\cdot q)$ a na testovači získalo maximálne dva body (aj to len v rýchlych jazykoch).

Dostávame sa ku vzorovému riešeniu. Zamyslime sa, ako vieme efektívne nájsť _všetky_ deliteľe čísla, alebo aspoň ich počet. Odpoveďou je rozklad na prvočísla, s ktorým ste sa už určite stretli. Každý deliteľ čísla $n$ je súčinom niekoľkých (možno aj nula, možno aj všetkých) prvočísel z prvočíselného rozkladu $n$. Aby sme dostali nepárny súčin, musíme násobiť iba nepárne čísla. Najväčší nepárny deliteľ čísla $n$ teda bude súčin všetkých nepárnych prvočísel z prvočíselného rozkladu $n$^[Pre matematických detailistov: ak obsahuje prvočíselný rozklad čísla $n$ nejaké prvočíslo vo vyššej mocnine, chápeme to tak, že obsahuje viac rovnakých prvočísel.].

To znamená, že z rozkladu stačí eliminovať všetky dvojky, keďže dvojka je jediné párne prvočíslo. V praxi nám teda stačí číslo $n$ deliť dvojkou kým to ide a akonáhle to nejde, dostali sme náš hľadaný najväčší nepárny deliteľ.

Náš algoritmus urobí pre každé $n$ iba toľko krokov, koľkokrát je $n$ deliteľné dvojkou. V najhoršom prípade je $n$ mocninou dvojky a algoritmus by sa delením dostal až ku jednotke. Urobil by teda logaritmicky^[Logaritmus čísla $n$ so základom $a$ nám hovorí, na koľkú treba umocniť $a$, aby sme dostali $n$. Napríklad $\\log_2 16 = 4$ a $\\log_3 27 = 3$] veľa krokov od veľkosti $n$ a teda časová zložitosť tohto riešenia je $O(\\log_2 n \\cdot q)$. Toto riešenie už získa po otestovaní plný počet bodov.
",1
96388613c371ed67,ksp,"# Odpad spoločnosti

Obaly od orechovníka, októbrové olovranty, omrvinky od obilných otrúb, odvädnuté obzerance, oreganom ochutená omáčka...

Hrôza. To všetko nájde pani upratovačka v školských laviciach. Každý deň. V jednej triede. Je to na nevydržanie. Ak náhodou stretne nejakého odchádzajúceho študenta a spýta sa ho, čie veci sú v lavici, odpoveď je vždy rovnaká: ""Spolusediaceho."" A Janko je fuč. Hlavne, že všetci vychvaľujú, ako čisto majú vo Viedni... a doma si takýto bordel nechajú...

Keďže anonymní spolusediaci sa ťažko obviňujú, rozhodla sa pani upratovačka, že si pekne zistí, kto s kým sedí. Ak náhodou s Jankom sedí Miško, nabudúce mu to poriadne vytmaví. Cez vyučovanie do triedy vojsť nemôže, takže musí vymyslieť iný spôsob ako nájsť dvojice obyvateľov zaprataných lavíc.

Našťastie si pani upratovačka posledných desať rokov zapisuje, koľko lavíc musela vypratávať každý deň. Ak navyše použije záznamy o dochádzke z triednej knihy, nič ju nemôže zastaviť. ""Ha ha ha."" Jedine mesiac listovania v zoznamoch... ale na to ste tu vy, dobrosrdeční riešitelia.

## Úloha

Táto úloha je interaktívna. Namiesto kompletného vstupu budete dostávať odpovede na vaše otázky.

Pre každú testovaciu sadu dostanete najprv číslo $n$, udávajúce počet lavíc v triede. Do triedy chodí $2n$ študentov, číslujeme ich od $1$ po $2n$ a v každej lavici sedia práve dvaja. Vašou úlohou je zistiť ktoré dvojice študentov sedia spolu.

Zdrojom vašich informácií sú záznamy o dochádzke a zápisník pani upratovačky. Váš program sa môže spýtať na ľubovoľnú množinu žiakov a zistiť v koľkých laviciach dokopy sedia. (Teda napríklad ak 1 sedí spolu s 2, tak ${1, 2}$ sedia v jednej lavici, ${1,3}$ sedia v dvoch laviciach a ${1,2,3}$ sedia tiež v dvoch laviciach.)

Môžete sa však spýtať **najviac $20,000$ otázok**.

## Formát vstupu

Na prvom riadku vstupu je malé kladné celé číslo $t$ udávajúce počet sád.

Pre každú sadu dostanete na novom riadku kladné celé číslo $n$ neprevyšujúce $1,000$, určujúce počet lavíc v triede.

Následne testovač odpovedá na každú vašu otázku vypísaním jedného celého čísla na nový riadok -- počet lavíc, v ktorých títo žiaci sedia. Túto odpoveď viete načítať zo štandartného vstupu.

## Formát výstupu

Na počet lavíc, v ktorých sedí $m$ študentov sa spýtate vypísaním čísla $m$ a následne vypíšte čísla študentov $s_1, s_2, ..., s_m$, o ktorých sa zaujímate do jedného riadku oddelených medzerami. Aby bola vaša otázka spracovaná **potrebujete** výstup presunúť z pamäte na štandartný výstup pomocou príkazu `fflush(stdout);` v C++, alebo `flush(output);` v Pascale.

Keď ste si istí, že poznáte všetky dvojice, vypíšte $0$ na nový riadok a $n$ riadkov dvojíc čísel študentov, ktorí sedia spolu.

Pokiaľ sa spýtate viac ako $20,000$ otázok, váš program bude nemilostrdne ukončený, avšak v testovači sa to môže prejaviť rôzne. Odpovede ""prekročený časový limit"", ""chyba počas vykonávania programu"" aj ""zlá odpoveď"" môžu ale nemusia v skutočnosti zmanenať, že ste sa opýtali priveľa otázok.

## Príklad

```vstup
2       // počet sád
3       // počet lavíc v prvej sade
2
1
2
2
2       // počet lavíc v druhej sade
1
```

```vystup
3 1 2 3
2 1 2
2 3 4
2 3 5
0
1 2
3 6
4 5
2 1 2
0
1 2
4 3
```

_Skutočné vstupy neobsahujú ""`//`"" ani text za týmito znakmi. Pridali sme ich do ukážkového vstupu kvóli prehľadnosti._

_Najprv sa dozvieme, že študenti $1, 2, 3$ obsadzujú 2 lavice. Zistíme, že $1, 2$ sedia spolu. Treťou a štvrtou otázkou zistíme, že študent $3$ nesedí so $4$ ani s Peťkou, teda musí sedieť so spolužiakom $6$. Zvyšní dvaja študenti, $4, 5$ musia teda sedieť spolu._

_V druhej sade sa spýtame na dvojicu $1, 2$. Keď sa dozvieme, že sedia spolu, už je zjavné, ako trieda vyzerá._
","# Odpad spoločnosti

## Skúšanie všetkých dvojíc

Ako sa dá najjednoduchšie zistiť, kto s kým sedí? Spýtame sa na všetky dvojice študentov. Stačí klásť otázky typu $1~2$, $1~3$, ... a vždy keď dostaneme odpoveď $1$, čo znamená, že títo dvaja sedia v jednej lavici, zapamätáme si túto dvojicu. Ak sa na každú dvojicu spýtame len raz, položíme ${ 2n \\choose 2 } = \\frac{2n(2n-1)}{2}$ otázok. Časová zložitosť takéhoto riešenia je $O(n^2)$ a mohli ste zaň dostať 2 body.

Pokiaľ neviete s úlohou pohnúť, je dobré skúsiť aspoň to prvé (správne), čo vás napadne. Navyše, na jednoduchom programe si viete vyskúšať spôsob komunikácie s testovačom -- ""flushovanie"" výstupu, spracúvanie viacerých sád a formát otázok a odpovedí.

## Skúšanie všetkých rozumných dvojíc

Môžeme si všimnúť, že ak sedia spolu študenti $1$ a $2$, v predošlom programe sa dozvieme o tejto dvojici hneď v prvej otázke. Ďalších $2n-2$ otázok ohľadom študenta $1$ je teda úplne zbytočných. Preto sa dá vyššie popísaný program v praxi mierne zlepšiť, ak si budeme o každom študentovi pamätať, či už vieme, s kým sedí. Pred vypísaním otázky potom zvážime, či je zbytočná, alebo či sa ňou niečo nové dozvieme.

V najhoršom prípade môžu spolu sedieť žiaci $1, 2n$; $2, 2n-1$; ... $n, n+1$. Pre prvého sa tak spýtame $2n-1$ otázok, pre druhého $2n-3$, atď. Teda $2(n)-1 + 2(n-1)-1 + 2(n-2)-1 + \\dots + 2(n-(n-1))-1 = 2 \\frac{n(n-1)}{2} - n = n(n-2)$ otázok. A hoci časová zložitosť zostáva stále $O(n^2)$, aj v najhoršom prípade sa spýtame približne o polovicu otázok menej. Za takéto zlepšenie ste mohli dostať až 4 body.

## Binárne vyhľadávnie

Viete, kadiaľ vedie cesta k lepšiemu riešniu^[Cez binárne vyhľadávnie predsa, veď je to tu napísané!]? Ak ste bezradní, prečítajte si zadanie a zistite, čo z toho, čo ste mali k dispozícii, ste zatiaľ nevyužili.

V predošlých riešeniach sme totiž vôbec nepoužili to, že sa môžeme pýtať na _ľubovoľnú podmnožinu študentov_. Sústreďme sa na jedného študenta, napr. s číslom $1$ a pokúsime sa zistiť jeho spolusediaceho. Ak sa spýtame, v koľkých laviciach sedí celá trieda, dostaneme neprekvapivú odpoveď $n$. Spýtajme sa radšej:

Koľko lavíc bolo obsadených, ak bola v škole polovica žiakov spolu so žiakom $1$?

Dostaneme odpoveď $d$ a toto číslo môže byť v rozmedzí $\\langle n/2, n\\rangle$. Skúsme sa ešte raz spýtať tú istú otázku bez študenta $1$.

- Ak je odpoveď $d-1$, študent $1$ sedel v tento deň sám -- v tejto polovici triedy jeho spolusediaci nie je, teda je v druhej polovici.
- Ak je odpoveď $d$, v tejto polovici triedy musí byť aj spolusediaci študenta $1$, lebo aj po odchode žiaka $1$ zostala jeho lavica obsadená.

Čo sme dosiahli? Pomocou dvoch otázok sme rozhodli, či môže byť polovica študentov spolusediaca s $1$. Ďalej nás bude zaujímať už len tá polovica študentov, medzi ktorými je aj jeho spolusediaci. Ďalšími dvoma otázkami vylúčime štvrtinu, potom osminu, atď. Po spýtaní sa $2 \\log 2n$ otázok bude možný spolusediaci len jeden. Ak sa pre každého študenta spýtame $2 \\log 2n$ otázok, pre $n=1,000$ sa spýtame približne $20,000$ otázok a za takéto riešnie ste mohli dostať 8 bodov. Spýtame sa teda $O(n \\log n)$ otázok.

Ak by vás zaujímala aj časová zložitosť, musíte zvážiť to, že pýtanie sa rôznych otázok vyžaduje rôzny čas. Ak sa napríklad pýtate na polovicu triedy, položenie jednej otázky si vyžiada čas $O(n)$. Pri kladení otázok o jednom študentovi vypisuje program $n, n/2, n/4 \\dots$ čísel, čo sa nasčítava na približne $2n$. Časová zložitosť zostáva stále $O(n^2)$, no počet otázok sa nám podarilo efektívne znížiť, čo bolo, koniec koncov, to podstatné v tejto úlohe.

Toto riešenie sa dá tiež mierne zlepšiť, ak sa budeme pýtať len na študentov, o ktorých nevieme, s kým sedia. Na polovice, štvrtiny... nemusíme teda deliť celú triedu, stačí deliť len množinu neznámych študentov.
",6
e76e59ccf2402edf,ksp,"# Zajačí problém

V Krajine Slepačích Paprčiek (ďalej už len KSP) nastal čas zimy. Hlavnou náplňou práce v tejto krajine je chov sliepok a pestovanie špeciálnej mrkvy. Mrkva pestovaná v KSP sa od ostatných druhov odlišuje tým, že žiadne dve mrkvy nenarastú rovnako veľké. Keďže sliepky cez zimu nevynášajú toľko, aby celú krajinu uživili a mrkvu už nikto nechce^[Všetci vegetariáni z Krajiny Mäsožravých Slonov sa totiž na zimu sťahujú do teplých krajov, kam sa mrkva kvôli diplomatickým problémom nevyváža.], rozhodla sa vláda využiť svoju špeciálnu mrkvu iným spôsobom. Po dlhom rokovaní sa rozhodlo, že sa kúpia špeciálne zajace typu T2, ktoré sú známe predovšetkým vďaka svojmu vyberavému vkusu v oblasti mrkvy. Problém však nastal, keď sa rozhodli zajace nakŕmiť. Niektoré zajace svoje mrkvy nejedli a iba škaredo zazerali na zajace vedľa seba.

Našťastie bola k zajacom doručená aj príručka chovateľa, z ktorej obyvatelia zistili, že kŕmenie je u zajacov T2 veľmi háklivou kultúrnou záležitosťou. V závislosti na veku, pohlaví a postavení v zajačej hierarchii sú niektoré zajace ochotné jesť iba vtedy, keď má zajac pred nimi väčšiu mrkvu. Iné zajace zasa budú jesť, iba keď má zajac pred nimi menšiu mrkvu.

Po zistení tejto informácie už dokázali obyvatelia zajace nakŕmiť. Na druhý deň sa ale zajace zoradili na kŕmenie v inom poradí a obyvatelia zostali opäť zaskočení. Vláda sa teda rozhodla siahnuť po trvalom^[samozrejme úspornom] riešení a využiť zostávajúce financie rozumne. Rozhodla sa teda najať si vás na vyriešenie tohto problému.

## Úloha

Počet zajacov si označme $n$. Mrkvy, ktorými chcú v daný deň Slepačopaprčkania nakŕmiť zajace, si očíslujme od najmenšej po najväčšiu číslami $1, 2, \\dots, n$.

Dostanete reťazec tvorený $n - 1$ znakmi `'<'` (menší) a `'>'` (väčší), ktoré určujú vzťah medzi veľkosťami mrkvy susedných zajacov. Vašou úlohou je nájsť takú permutáciu čísel $1$ až $n$, v ktorej po sebe idúce členy spĺňajú zadané nerovnosti (permutácia čísel $1$ až $n$ je taká postupnosť čísel z rozsahu $1$ až $n$, ktorá každé z čísel od $1$ po $n$ obsahuje presne raz).

## Formát vstupu

Na vstupe sa nachádza jeden riadok skladajúci sa z $n-1$ znakov ""$\<$"" a ""$>$"". Platí $2 \\leq n \\leq 10^6$.

## Formát výstupu

Vypíšte jeden riadok a v ňom $n$ medzerami oddelených čísiel: hľadanú permutáciu. Vždy existuje aspoň jedno riešenie. Ak existuje viac riešení, vypíšte ľubovoľné z nich.

## Príklad

```vstup
>>>>
```

```vystup
5 4 3 2 1
```

*Platí $5>4, 4>3, 3>2, 2>1$*

```vstup
><><
```

```vystup
4 2 3 1 5
```

*Platí $4>2, 2\<3, 3>1, 1\<5$. Tento vstup má rôzne možnosti riešenia -- správnym riešením je napríklad aj 2 1 4 3 5.*
","# Zajačí problém

Táto úloha sa dala riešiť rôznymi, viac, či menej zložitými spôsobmi (ak ste to chceli potiahnuť do extrému, mohli ste použiť trebárs topologické triedenie). Vzorové riešenie je však až zarážajúco jednoduché.

## Vzorové riešenie

Máme čísla $1, 2, \\dots, n$ a potrebujeme ich zoradiť tak, aby spĺňali nerovnosti zo zadania. Pozrime sa na prvý znak vstupu. Môžu nastať dve možnosti:

- Ak je prvý znak vstupu `<`, znamená to, že prvé číslo postupnosti musí byť menšie ako druhé.

  V tomto prípade za prvé číslo môžeme vziať najmenšie z čísel, ktoré máme k dispozícii (teda číslo $1$). To nám zaručí, že nech akokoľvek usporiadame zvyšné čísla, táto nerovnosť bude určite platiť.

- Ak je prvý znak `>`, prvé číslo musí byť väčšie ako druhé. V takom prípade môžeme za prvé číslo zobrať najväčšie možné číslo (teda $n$). Opäť budeme mať zaručené, že táto nerovnosť bude platiť bez ohľadu na to, ako usporiadame ostatné čísla.

V oboch prípadoch teda vieme určiť prvé číslo tak, aby nerovnosť určená prvým znakom vstupu zaručene platila. Ak sa nám potom podarí usporiadať zvyšné čísla tak, aby boli splnené zvyšné nerovnosti, máme vyhrané -- všetky nerovnosti už budú platiť.

Ako zoradiť zvyšných $n-1$ čísel tak, aby spĺňali zvyšné nerovnosti? Môžeme použiť tú istú myšlienku. Tento raz sa pozrieme na druhý znak vstupu. Ak je to `<`, potom môžeme za druhé číslo postupnosti zvoliť najmenšie z $n-1$ čísel, ktoré nám zostali a aj táto nerovnosť bude zaručene splnená (bez ohľadu na to, ako zoradíme zvyšných $n-2$ čísel). Ak bude druhý znak vstupu `>`, potom za druhé číslo postupnosti vezmeme najväčšie možné číslo.

Takto budeme pokračovať, až kým neprečítame celý vstup. Keď spracujeme všetkých $n-1$ znakov vstupu, budeme mať určených prvých $n-1$ čísel postupnosti. Za posledné číslo postupnosti vezmeme to jediné, čo nám zostane. Vzniknutá postupnosť bude určite spĺňať všetky nerovnosti na vstupe -- prvú nerovnosť bude spĺňať vďaka tomu, ako sme zvolili prvé číslo postupnosti, druhú vďaka spôsobu voľby druhého čísla postupnosti, tretiu vďaka voľbe tretieho čísla atď.

## Implementácia

Otázkou zostáva, ako tento algoritmus dobre implementovať. Asi najťažšou otázkou je, ako si pamätať zoznam doteraz nepoužitých čísel. Mohli by sme si ich pamätať v nejakom poli, ale ide to aj jednoduchšie. Stačí si uvedomiť, že zoznam nepoužitých čísel je v každom okamihu nášho algoritmu nejaká súvislá postupnosť prirodzených čísel: na začiatku je to $1, 2, \\dots, n$ a vždy keď z neho niečo vyhadzujeme, tak je to buď najväčšie, alebo najmenšie číslo (teda aj po vyhodení zostane súvislý). Preto si stačí v dvoch premenných pamätať najmenšie a najväčšie číslo v zozname.

Výslednú postupnosť by sme si mohli pamätať v poli. To ale tiež nie je nutné, keďže ju môžeme počas konštruovania rovno vypisovať.

## Zložitosť

Časová zložitosť algoritmu je $O(n)$ -- lineárna od počtu znakov na vstupe. Pamäťová zložitosť tohto algoritmu je tiež $O(n)$, keďže je potrebné načítať vstup do poľa. Zvyšok operácií využíva už iba premenné $minimum$ a $maximum$. Všimnime si, že jediný dôvod, prečo potrebujeme čítať celý vstup už na začiatku je, že potrebujeme vedieť aký je dlhý (aby sme vedeli, aké najväčšie číslo má byť vo výslednej permutácii). Keby sme na začiatku na vstupe dostali číslo $n$ a až potom postupnosť znakov `<` a `>`, úloha by sa dala riešiť v konštantnej pamäti -- vstup by sme čítali po znakoch a vždy by sme si pamätali len znak, ktorý práve spracúvame.
",4
7bed983308e22d10,ksp,"# Átriové problémy

Vlejd vystúpil z autobusu. Prišiel práve na internáty a jediné, čo ho ako správneho študenta zaujíma je to, kde zohnať jedlo. Vonku panuje treskúca zima. On však vie, že cestou za jedlom bude musieť ešte prekonať bájny kopec ku átriovým domom^[Ide o časť internátov, ktoré si obľúbite aj vy, ak budete niekedy študovať na matfyze alebo sa zúčastníte Letnej školy Trojstenu. Nachádzajú sa tam totiž všetky dobré jedálne v okolí internátov.] a až tam ho čaká odmena, v podobe najlepšej jedálne v Mlynskej doline.

Po chvíli celý uzimený dôjde do jedálne a tam vidí dlhý rad stolov s jedlom. Pri prvom podávajú $30$ rôznych rezňov, pri druhom $50$ rôznych šalátov. Inde zas $10$ druhov koláča a takto by mohla jeho myseľ pokračovať vééľmi dlho. Vidí prichádzať zmrznutých študentov, ktorí už nemyslia na nič iné ako na jedlo. Vtom si uvedomí, ako hlúpo sa hladní študenti správajú.

Každý študent si zoberie tácku a prechádza okolo stolov s jedlom. V jednom momente uvidí na stole, pri ktorom sa práve nachádza, druh jedla, na ktorý má chuť. Zoberie si ho a vtom sa začne správať iracionálne a pažravo. Z každého ďalšieho stolíka si vyberie nejakú vec a prihodí si ju na tácku. Takto pokračuje, pokým si neuvedomí, že už na ďalšie jedlo nemá peniaze. Vtedy skončí s prihadzovaním jedla na tácku, odkráča k pokladni a zaplatí.

Ako to už chodí, každého študenta zaujíma, z koľkých možností má na výber. Vlejd je schopný programátor a tak si povedal, že by skúsil študentom uľahčiť život. Práve prebiehajúce skúškové mu však neumožnuje sústrediť sa na nič iné ako na školu. Pomôžte mu a vyriešte túto úlohu zaňho.

## Úloha

V jedálni stojí v jednom dlhom rade $n$ stolov s jedlom. Na $i$-tom stole od začiatku je $k\_{i}$ rôznych druhov jedla. Každé jedlo stojí $1$ euro.

Ak má teda nejaký študent $x$ eur a jedlo si začne brať pri $a$-tom stole, vydržia mu peniaze až po stolík s číslom $a+x-1$. Na tácke nakoniec bude mať jednu z $k\_{a} \\cdot k\_{a+1} \\cdot ... \\cdot k\_{a+x-1}$ možností.

Pre každého študenta vieme, pri ktorom stole si začne brať jedlo a koľko má peňazí. Vypočítajte, z koľkých rôznych možností si môže vybrať.

Tento počet, samozrejme, môže byť veľmi veľké číslo a jednotlivým študentom nemusí dávať priveľký zmysel. Pre každého študenta teda dostanete jeho kapacitu: najväčšie číslo, ktoré si vie predstaviť. Vypíšete zvyšok výsledku po delení týmto číslom.

## Formát vstupu

Na prvom riadku vstupu sú dve celé čísla $n, q$ ($1 \\leq n, q \\leq 10^{5}$): počet stolov v jedálni a počet študentov. Na druhom riadku vstupu sa nachádza $n$ čísel $k_1, k_2, \\dots k_n$ ($1 \\leq k\_{i} \\leq 100$), kde číslo $k\_{i}$ udáva počet rôznych možností, z ktorých má študent na výber pri $i$-tom stole.

Na každom z ďaľších $q$ riadkov je popis jedného študenta pozostávajúci z troch čísel $a, x, m$ ($1 \\leq a \\leq n$, $1 \\leq x$ a $2 \\leq m \\leq 10^{9}$). Tie hovoria, že študent si začne brať jedlo pri $a$-tom stole (stoly číslujeme od $1$), má pri sebe $x$ peňazí a jeho kapacita je $m$.

Môžete navyše predpokladať, že každému študentovi dôjdu peniaze najneskôr pri poslednom stole, teda že $a+x-1 \\leq n$.

## Formát výstupu

Pre každého študenta vypíšte na samostatný riadok jedno číslo: počet možností, z ktorých má na výber, modulo jeho kapacita.

## Hodnotenie

Vaše riešenie bude otestované na $4$ sadách vstupov. Pre jednotlivé sady platia tieto obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:---:| | $n, q \\leq$ | $1,000$ | $10,000$ | $100,000$ | $100,000$ |

Upozorňujeme, že aj vzorové riešenie napísané v nejakom z pomalších jazykov, napr. v Pythone, nemá prakticky žiadnu šancu proti väčším vstupom.

## Príklad

```vstup
5 3
20 4 5 7 3
2 2 2
1 4 3
4 2 5
```

```vystup
0
1
1
```

*Prvý súčin vychádza $(4 \\cdot 5) \\bmod 2 = 0$, druhý $(20 \\cdot 4 \\cdot 5 \\cdot 7) \\bmod 3 = 2800 \\bmod 3 = 1$ a tretí $21 \\bmod 5 = 1$.*
","# Átriové problémy

Ak si odmyslíme príbeh, našou úlohou je načíťať $n$ čísel a potom nájsť na nejakých úsekoch súčin týchto čísel, vždy modulo nejaké iné číslo.

Prvá vec, ktorá by programátorovi mala napadnúť v úlohe, kde sa vyskytuje nejaký typ otázok, je, čo si môžeme predpočítať pred ich samotným spracovávaním. Začnime ale na začiatok riešením hrubou silou, ktoré si nič nepotrebuje predpočítať.

## Bruteforce

Na začiatku načítame čísla na vstupe. Potom postupne načítavame otázky a každú z nich hneď po načítaní zodpovieme. Pre každú otázku prejdeme zadaný úsek zľava doprava a postupne násobíme čísla v úseku, pričom si medzivýsledok priebežne modulujeme.

Takéto riešenie má časovú zložitosť na jednu otázku až $O(n)$, keďže existujú otázky, ktoré nás donútia prejsť celé pole. Pre $q$ otázok to teda dáva celkovú časovú zložitosť $O(n \\cdot q)$ a pamäťovú $O(n)$, kedže si pamätáme iba čísla na vstupe.

Toto riešenie funguje v praxi veľmi dobre, ale na ozaj veľkú sadu stačiť nebude. Na vzorové riešenie sa ešte budeme musieť zamyslieť. Ako sme spomenuli, podozrivé nám môže byť, že sme si nič nepredpočítavali pred samotným spracovávaním otázok.

## Prefixové súčty a prečo sú veľké čísla zlé

Ak vám pojem *prefixové súčty* nie je známy, pred čítaním zvyšku vzoráku sa vám oplatí sa s ním zoznámiť, napríklad v [kuchárke](https://www.ksp.sk/kucharka/prefixove_sumy/).

Prefixové súčty riešia príbuzný problém, kde namiesto súčinu čísel v úseku chceme zistiť ich súčet. Uvedomme si ale, že tu nefunguje niečo ako ""prefixové súčiny"". Nevieme si pre každé políčko $x$, od $1$ po $n$, vypočítať $k_1 \\cdot k_2 \\cdot ... \\cdot k_x$, nakoľko takéto číslo môže byť naozaj veľké.

Čo je také zlé na veľkých číslach? A aké veľké čísla by to boli? V poradí $i$-ty súčin je súčinom prvých $i$ čísel, každé z nich je od $1$ do $100$. Na jeho uschovanie by sme preto potrebovali až rádovo $i \\cdot \\log 100$ bitov. Všetky prefixové súčiny by teda zaberali až $O(n^2)$ pamäte, a zaplnenie tejto pamäte by trvalo až $O(n^2)$ času. Navyše, pri implementácii v C++ by sme si museli implementovať vlastný typ pre veľké čísla a aritmetiku na ňom, nakoľko `long long` nestačí.

Dokonca, problém s nimi nie je len ten, že zaberajú veľa miesta. Ak by sme chceli sčítať dve čísla dĺžky $i$, trvalo by nám to až $O(i)$ času. A ich súčin by trval ešte dlhšie. Vidíme teda, že veľké čísla sú zlé, pretože operácie s nimi trvajú dlho.

V úlohe je veľmi dôležité, že nás zaujíma zvyšok súčinu po delením nejakým relatívne malým číslom $m \\leq 10^9$. Ak by nás zaujímal celý súčin, dostali by sme veľké číslo. Už len jeho výpis by trval dlho.

Vo zvyšku textu sa veĺkým číslam vyhneme tak, že všetky medzivýsledky budeme modulovať $m$. Nebojte sa, vždy, keď tak učiníme, na to upozorníme. Priebežným modulovaním si zaručíme, že budeme vždy narábať s číslami do $10^9$. Operácie s nimi teda budú zaberať konštantne veľa času.

## Vzorové riešenie

Keď čítame úlohu, môžeme sa snažiť nájsť niečo, čo nám udrie do očí, akúsi slabinu úlohy. Tu si všimneme, že čísla na vstupe nie sú veľké, sú do $100$. Toto by sme snáď mohli využiť. Ak dostaneme nejaký úsek, zjavne v ňom bude najviac $100$ rôznych čísel. Ich počty môžu byť veľké, avšak nikdy týchto čísel nebude veľa rôznych. Predstavme si, že poznáme počty výskytov jednotlivých čísel. Teda, že pre každý úsek a každé číslo $x$ vieme rýchlo povedať, koľkokrát sa číslo $x$ nachádza v danom úseku. Ako vieme toto využiť? Ak máme takúto informáciu, stačí nám vynásobiť jednotlivé čísla umocnené na počty ich výskytov, pričom to berieme modulo $m$, a dostaneme našu odpoveď. Ako rýchlo však vieme umocniť $x$ na $i$-tu, modulo $m$?

Zrekapitulujme si to. Máme dva podproblémy, ktoré chceme vedieť riešiť. Po prvé, chceme vedieť pre ľubovoľný úsek rýchlo povedať, koľkokrát sa v ňom ktoré číslo nachádza. Po druhé, chceme vedieť rýchlo umocniť $x$ na $i$-tu modulo $m$. Začnime riešením prvého.

Ako zistiť počet výskytov jednotlivých čísiel na intervale? Predstavme si, že sa pýtame na počet výskytov čísla $42$. Každé číslo v poli buď je $42$ a prispeje do výsledku $+1$, alebo nie je $42$ a prispeje $0$. Vytvorme si teda pomocné pole dĺžky $n$, kde si na pozíciách, kde boli v pôvodnom poli $42$-ky, budeme pamätať jednotky a na ostatných pozíciách nuly. Počet $42$-jek v nejakom úseku v pôvodnom poli je rovný súčtu čísel v rovnakom úseku v našom pomocnom poli. A súčty čísel v úsekoch vieme rýchlo počítať pomocou prefixových súčtov.

Nás ale nezaujíma odpoveď len pre $42$, ale pre všetky čísla od $1$ po $100$. Tak budeme mať $100$ pomocných polí s prefixovými súčtami -- jedno pre každé z týchto čísel. Predpočítať si ich nám zaberie $O(100 \\cdot n) = O(n)$ času. Následne vieme v konštantnom čase zistiť počet výskytov nejakého čísla v ľubovolnom úseku.

Vrhnime sa na druhý podproblém: ako sa dá rýchlo umocniť $x$ na $i$-tu, modulo $m$?

Jedným cyklom by sme to vedeli zaiste v $O(i)$. Avšak, čo ak je $i$ naozaj veľké, tak ako v našom prípade? Využijeme techniku opakovaného umocňovania na druhú. Tá sa dá elegantne implementovať za pomoci [rekurzie](https://www.ksp.sk/kucharka/rekurzia/#wiki-toc-6-chvostova-rekurzia). Ak máme umocniť $x^i$ a $i$ je nepárne, tak si rekurzívne vypočítame $x^{i-1}$ a vrátime túto hodnotu vynásobenú $x$, modulo $m$. Rozdiel oproti pomalému umocňovaniu uvidíme v prípade, keď $i$ je párne. Vtedy si vieme rekurzívne vypočítať $x^{\\frac{i}{2}}$. Ak označíme túto hodnotu $pom$, $x^i$ dostaneme zadarmo ako $pom \\cdot pom$ alebo $pom^2$, modulo $m$.

Akú ma toto časovú zložitosť? Môžme nahliadnuť, že aspoň každý druhý krok klesne $i$ na polovicu. Koľko krát môže takto klesnúť? Nanajvýš $O(\\log i)$-krát, čo je aj výsledná časová zložitosť tohto rekurzívneho umocňovania. V kontexte našej úlohy je počet výskytov nejakého čísla v nejakom úseku vždy nanajvýš $n$. Časová zložitosť bude teda $O(\\log n)$.

Aká je celková časová zložitosť nášho algoritmu? Spočítanie si prefixových súčtov nám trvá $O(n)$. Následne, spracovanie každej z $q$ otázok trvá $O(100 \\cdot \\log{n}) = O(\\log n)$. Dokopy máme časovú zložitosť $O(n + q \\cdot log(n))$. Toto riešenie si potrebuje pamätať prefixové súčty polí dĺžky $n$, z čoho vyplýva pamäťová zložitosť $O(n)$.
",5
bd8faa4e0671853f,ksp,"# Zajova paranoja

Zajo sa hral príliš veľa počítačových hier a teraz sa mu o nich aj sníva. Najhoršie sú nočné mory, v ktorých sa ho snaží odstreliť ostreľovač. Keď sa totiž Zajo z takejto nočnej mory prebudí, nevie sa zbaviť pocitu, že naňho cez okno niekto mieri a po celý zvyšok noci už nezaspí.

Preto si chce dať posteľ do takej časti izby, v ktorej ho nemajú šancu trafiť. Samozrejme, bol by rád, ak by táto bezpečná časť izby bola čo najväčšia (ani s pocitom, že niekto mieri na miesto desať centimetrov od vašej postele sa nespí veľmi dobre).

## Úloha

Zajova izba má tvar obdĺžnika, ktorého strany sú rovnobežné so základnými svetovými stranami a má okná smerom na sever a na východ. Tieto okná sú veľmi úzke (človek, ktorý staval Zajovu izbu bol zrejme tiež paranoický) a pre účely tejto úlohy ich budeme považovať za body na stranách nášho obdĺžnika.

Ostreľovači, o ktorých sa Zajovi sníva, naňho mieria vždy buď z kopca ležiaceho presne na sever od Zajovho domu, alebo z vysokej budovy na východ od Zajovho domu. Takže ak ho chcú odstreliť, musia strieľať rovnobežne so stenami izby.

Poznáte rozmery miestnosti a pozície jednotlivých okien. Nájdite súvislú časť Zajovej izby neohrozenú ostreľovačmi, s najväčším obsahom.

## Formát vstupu

Na prvom riadku vstupu sú 4 celé čísla $x, y, m, n$, kde $x$ a $y$ sú rozmery izby ($x$ je dĺžka severnej steny a $y$ je dĺžka východnej steny), $m$ je počet okien na severnej stene a $n$ je počet okien na východnej stene. Platí $1\\leq x, y, m, n \\leq 10^6$.

Na druhom riadku vstupu je $m$ celých čísel $x_1, \\dots, x_m$: pozície jednotlivých okien na severnej stene. $i$-te okno je vo vzdialenosti $x_i$ od severozápadného rohu Zajovej izby. Platí $0 < x_1 \< x_2 < \\dots < x_m < x$ -- okná sú teda zadané v poradí od západu na východ.

Na treťom riadku je $n$ celých čísel $y_1, \\dots, y_n$: pozície jednotlivých okien na východnej stene. $i$-te okno je vo vzdialenosti $y_i$ od juhovýchodného rohu izby. Platí $0 < y_1 < y_2 < \\dots < y_n < y$ -- okná sú zadané v poradí od juhu na sever.

V 1. sade testovacích vstupov platí, že $m,n \\leq 10$, v 2. sade $m,n\\leq 1,000$).

## Formát výstupu

Vypíšte jeden riadok a v ňom hodnotu $S$, kde $S$ je plocha (obsah) najväčšieho súvislého územia, na ktoré nemôže mieriť ostreľovač.

Môžete predpokladať, že $S$ sa zmestí do bežnej **64-bitovej** premennej. V C++ použite `long long`, v Pascale `Int64`.

## Príklady

```vstup
4 10 2 3
1 3
5 8 9
```

```vystup
10
```

```vstup
5 5 1 1
1
1
```

```vystup
16
```

```vstup
6 5 2 1
2 4
4
```

```vystup
8
```

*Situácie v jednotlivých príkladoch vyzerajú nasledovne (v poslednom príklade sú až tri rôzne časti s obsahom 8):*
","# Zajova paranoja

Zajo chce mať posteľ umiestnenú v bezpečí. To sú také časti územia, cez ktoré nemieri žiaden ostreľovač. Všimneme si, že priestor medzi dvomi susednými ostreľovačmi je vždy bezpečný. Podobne územie medzi **ne**susednými ostreľovačmi je vždy nebezpečné, lebo sa medzi nimi nachádza nejaký iný ostreľovač.

## Pomalšie riešenie

Pre každú dvojicu susedných ostreľovačov zo severu, prejdeme každú dvojicu susedných ostreľovačov z východu. Šírku medzery medzi ostreľovačmi zo severu označme $a$, šírku medzery medzi ostreľovačmi z východu označme $b$. Časť miestnosti ohraničená týmito dvojicami je tvorená obdĺžnikom so stranami $a$ a $b$. Obsah tohto obdĺžnika je zrejme $a \\cdot b$. Pri prechádzaní všetkými týmito možnosťami, si počítame maximálny obsah, ktorý sme doposiaľ našli. Nakonci iba vypíšeme toto číslo. Takéto riešenie má časovú zložitosť $O(m \\cdot n)$, lebo týchto dvojíc je rádovo $m \\cdot n$ a každú spracujeme v konštantnom čase. Pretože si pamätáme celý vstup, pamäťová zložitosť je stále $O(m+n)$.

#### Trik na ošetrenie okrajov

Treba si ešte dať pozor na to, že ideálne miesto pre posteľ môže byť aj pri okrajoch miestnosti. Toto treba ošetriť buď manuálne (pridať podmienky), alebo si pomôžeme trikom. Vyrobíme si dvoch ostreľovačov v každom smere takých, že budú na okrajoch miestnosti. Riešenie bude rovnako správne a rýchle, ale sprehľadníme si tým náš kód.

Všimnime si tiež, že pri všetkých premenných okrem výslednej plochy nám stačí použiť v C++ typ `int`, pretože podľa zadania sa nám do neho všetko zmestí. Pri výslednej ploche ale násobíme dve čísla, ktoré môžu byť veľké až $10^6$ a vtedy by nám už `int` nestačil.

## Vzorák

Na plný počet bodov bolo nutné spraviť ešte jeden myšlienkový krok. Naše pôvodné riešenie prechádzalo zbytočne veľa možnosťami. Stačilo si uvedomiť, že najväčšie územie sa vždy nachádza na prieniku území medzi dvomi najvzdialenejšími ostreľovačmi na východe a dvomi najvzdialenejšími na severe. Počítanie maximálneho územia je preto ekvivalentné s hľadaním maximálnej vzdialenosti medzi ostreľovačmi zo severu a z východu. Hľadané územie je potom rovné súčinu týchto čísel. Časová zložitosť tohto riešenia je teda $O(m+n)$, pretože stačí raz prejsť cez obe polia. Pamäťová zložitosť je stále $O(m+n)$, lebo si musíme pamätať vstup (tú už preto nezlepšíme).

## Čerešnička na torte

Na získanie plného počtu bodov stačilo predošlé riešenie, avšak aj to sa dá ešte zlepšiť. Už nevieme zlepšiť časovú zložitosť (lebo musíme aspoň načítať vstup), vieme však zlepšiť pamäťovú zložitosť. Na vyriešenie problému totiž hľadáme maximum z nejakého počtu čísel, a to vieme robiť popri tom, ako načítavame vstup. Takéto riešenie má zložitosti $O(m+n)$ časovú a $O(1)$ pamäťovú.
",2
932e74f94a46686c,ksp,"﻿# Takmer na to vidím

Kristína si ráno čítala maily a našla tam pozvánku na nejaký výlet od Marcela. Nakoľko len pred chvíľou vstala, bez menšieho zaváhania otvorila prihlášku a začala vypĺňať. Keď už bola na konci, narazila na najťažšiu otázku: ""Ako dlhá by mala byť trasa výletu?"". Kike sa z rána veľmi nechcelo rozmýšľať, tak rovno napísala ""Ja nevieeem"".

Keď si Marcel pozeral prihlášky a zbadal túto odpoveď, hneď mu bolo jasné, čo musí spraviť. Musí pripraviť vhodnú trasu na každú dĺžku. Ak by nejaká dĺžka chýbala, Kika by si vybrala presne tú a celý deň by sa sťažovala (čo ale teda neznamená, že to nebude robiť aj tak).

Marcel teda naplánoval perfektné trasy všetkých dĺžok. Začiatok majú všetky spoločný, no koncov je už niekoľko. Nakreslil si aj mapku, vyznačil začiatok, cieľové body, rázcestia a teraz mu ostáva už len označiť odbočky pri rázcestníkoch. Nebude to však také ľahké. Marcel by chcel, aby všetky trasy mohol popísať jedným slovom, nech si to Kika zapamätá!

Presnejšie musí platiť nasledovné:

- Slovo popisujúce trasy má rovnakú dĺžku ako najdlhšia trasa.
- Trasu dĺžky $k$ nájdeme _jedine_ nasledovaním posledných $k$ písmen slova.
- Z každého rázcestia vychádza niekoľko ciest označených rôznymi písmenami.
- V každom cieľovom bode končí aspoň jedna trasa.
- Každá trasa končí v nejakom ceľovom bode.

Napríklad, ak je slovo `abbab`, tak trasy, ktoré končia v cieli nájdeme _práve vtedy_, ak budeme nasledovať slová `abbab`, `bbab`, `bab`, `ab`, `b` alebo ostaneme v začiatočnom vrchole (pre prípad, že by sa Kike vôbec nechcelo chodiť).

## Úloha

Na vstupe dostanete orientovaný graf a zoznam cieľových vrcholov.

Vašou úlohou je doplniť ku hranám písmená tak, aby graf spĺňal Marcelove podmienky pre nejaké slovo $w$ a nájsť nejaké takéto slovo.

Pre jednoduchosť budeme namiesto písmen používať celé čísla od $1$ do $k$, pričom jediná podmienka je, že $k \\le m$. Môžete tiež predpokladať, že graf, ktorý dostanete sa dá označiť tak, aby Marcelove podmienky spĺňal.

## Formát vstupu

Na prvom riadku dostanete tri celé čísla - počet vrcholov $n$, počet orientovaných hrán $m$ a počet cieľových vrcholov $t$ ($1 \\le t \\le n$).

V druhom riadku dostanete $t$ celých čísel -- cieľové vrcholy.

Nakoniec nasleduje $m$ riadkov, popisujúcich hrany v grafe. Na každom riadku sú dve medzerou oddelené čísla $s_i$ a $t_i$, označujúce hranu z vrcholu $s_i$ do vrcholu $t_i$. Vrcholy sú označené číslami od $1$ do $n$, pričom vrchol $1$ je vždy začiatočný.

Úloha má 4 sady, pre ktoré platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|---------------:|---------------:|---------------:| | $1 \\leq n \\leq$ | $60$ | $6 \\cdot 10^3$ | $2 \\cdot 10^5$ | $3 \\cdot 10^5$ | | $1 \\leq m \\leq$ | $60$ | $6 \\cdot 10^3$ | $2 \\cdot 10^5$ | $3 \\cdot 10^5$ | | $1 \\leq t \\leq$ | $60$ | $3 \\cdot 10^2$ | $5 \\cdot 10^2$ | $8 \\cdot 10^2$ |

## Formát výstupu

Na prvý riadok výstupu vypíšte dve čísla $l$ a $k$ - dĺžka slova $w$ a počet rôznych čísel na hranách. Na druhý riadok vypíšte slovo $w$ ako $l$ celých čísel medzi $1$ a $k$ oddelených medzerami.

Na tretí riadok vypíšte $m$ čísel -- označenia hrán v poradí, v akom sú na vstupe tak, aby graf spĺňal Marcelove podmienky.

## Príklad

```vstup
7 8 4
1 3 4 7
1 2
1 3
2 4
3 5
3 6
4 5
5 6
6 7
```

```vystup
5 2
1 2 2 1 2
1 2 2 2 1 2 1 2
```

_Riešenie je zobrazené na obrázku kde $1$ predstavuje `a` a $2$ `b`_
","# Takmer na to vidím

Zadanie tejto úlohy hovorí, že máme pre orientovaný graf nájsť nejaké ohodnotenie hrán, tak aby spĺňalo niekoľko podmienok. Tento orientovaný graf má navyše vyznačený štartovací vrchol a niekoľko cieľových vrcholov. Nemenej dôležitá je informácia, že v cieľových vrcholoch končia cesty ktoré popisujú *sufixy* nejakého slova (alebo postupnosti čísel v našom prípade).

Keďže sú to sufixy, môžeme si všinúť, že každá trasa končí rovnakým číslom, teda napríklad $1$. Z toho nám hneď vyplýva, že hrany ktoré vedú do cieľových vrcholov musia niesť práve číslo $1$. Získali sme jeden znak riešenia. Aby sme mohli určiť nasledujúci, stačí sa posunúť po hranách ktoré sme prave označili. My totiž vieme, že všetky cesty sú sufixy, takže aj predposledné písmeno musia mať rovnaké. Pozrieme sa teda na všetky hrany ktoré vedú ku tým ktoré sme práve označili a vieme že musia mať rovnaké číslo. Ak o niektorej hrane vieme, aké má číslo, tak ho len priradíme všetkým ostatným a máme druhý znak riešenia. Ak žiadna z hrán ešte číslo nemá, musíme im priradiť nejaké nové číslo (napríklad $2$).

Tento postup následne stačí opakovať, až kým sa dostaneme do takého stavu, že do daných vrcholov žiadne hrany nevedú. Vtedy sme sa totiž všetkými cestami dostali do štartovného vrcholu a ak si medzičasom budeme aj zapisovať čísla ktoré hranám priraďujeme, máme aj finálne slovo, skonštruované od konca.

## Implementácia

Postup popísaný vyššie je v podstate BFS, teda prehladávanie do šírky^\[[https://www.ksp.sk/kucharka/bfs/](https://www.ksp.sk/kucharka/bfs/)\]. Zásadný rozdiel je v tom, že graf neprehľadávame z jedného počiatočného vrchola, ale zo všetkých cieľových vrcholov ako počiatočných naraz a posúvame sa po hranách v opačnom smere. Aby sa to viac podobalo na BFS, môžeme si predstaviť že máme ešte jeden cieľ, z ktorého vedie hrana práve do tých vrcholov, ktoré sú cieľové. Potom sa to už podobá na klasické BFS z tohoto vrchola.

Druhý rozdiel od klasickej implementácie BFS je v tom, že sa potrebujeme vždy pozerať na celú ""vrstvu"" vrcholov, ktoré sú v rovnakej vzdialenosti od cieľa. Toto dosiahneme jednoducho tak, že namiesto toho aby sme z fronty vyberali jeden vrchol, vyberieme ich naraz všetky. To budú totiž vrcholy v rovnakej vzdialenosti. Následne ich spracujeme, teda pozrieme sa na všetky hrany ktoré do nich vedú, nájdeme medzi nimi ohodnotenú, alebo vyberieme nové číslo a všetky tieto hrany ohodnotíme. Až po tomto kroku pridáme do fronty nové vrcholy, teda začiatky novoohodnotených hrán, ktoré sú opäť o jedna ďalej od cieľa. Inak povedané, vo fronte bude jedno pole vrcholov ktoré sú v rovnakej vzdialenosti od cieľa, a teda to vlastne ani nemusí byť fronta.

## Časová a pamäťová zložitosť

Čo si treba uvedomiť je, že síce hovoríme že je to ""nejaké BFS"", ale v skutočnosti to nie je jedno prehľadanie grafu. Aby sme mohli povedať že je to lineárne, mselo by platiť že každú hranu prejdeme konštantný počet krát -- čo nie je pravda.

Náš algoritmus dá na začiatku do fronty všetky cieľové vrcholy, tých môže byť najviac $n$. V ďalšom kroku pridávame do fronty všetky vrcholy pred nimi. Tých môže byť najviac $n-1$, pretože jedna z ciest patrila suffixu dĺžky 1 a tou sme sa už dostali do cieľa. Rovnako v každom ďalšom kroku nám určite jedna cesta vypadne a teda v najhoršom prípade budeme do fronty pridávať postupne $n, n-1, n-2, \\cdots, 1$ vrcholov čo je spolu $O(n^2)$. Čo sa pamäte týka, ukladáme si vstup, a niekoľko pomocných štruktúr, koré nepresahujú veľkosť vstupu, teda pamäťová zložitosť je $O(m+n)$
",6
6287864cba981238,ksp,"# Týrajú ma hladom

Oslava sa už blížila k jej vyvrcholeniu (teda aspoň pre Miška), a to k slávnostnej večeri. Šéfkuchárka Kika pripravila siahodlhú výzvu pre nejeden žalúdok -- večeru pozostávajúcu z postupnosti niekoľkých chodov. Za chod považujeme jeden druh jedla, napríklad polievku alebo dezert. Slávnostná večera môže byť zostavená napríklad takto: polievka, polievka, predjedlo, dezert, polievka -- teda päť chodov pozostávajúcich z troch druhov jedál.

Miško, hoci sa večere nevie dočkať, nemôže zabúdať na svoje zdravie. Doktor mu totiž pred touto oslavou dovolil papať iba jeden druh chodu. Ktorý? To už je na Miškovom výbere. Okrem toho mu doktor povedal, že najlepšie bude, keď nebude mať príjem potravy prerušovaný väčšími pauzami. Teda, ak už raz začne papať, bude môcť papať iba pokiaľ sa bude servírovať ten jeho jeden druh chodu. Po zvyšok večere mu potom už ostávajú iba oči pre závisť. Miško ale má jedno eso v rukáve, a to kontakt na šéfkuchárku Kiku. Miško môže Kiku poprosiť, aby niektoré druhy chodu (napríklad polievku a predjedlo) prehlásila za niektorý iný (napr. obe prehlási za dezert). Tým pádom by mohol papať aj všetky polievky, predjedlá a aj všetky dezerty, pričom by sa ale tváril, že to je len jeden druh chodu. Ak Miško poprosí šéfkuchárku Kiku, aby najviac $k$ druhov chodov prehlásila za iný druh chodu, koľko najviac chodov, bezprostredne po sebe, bude môcť Miško spapať?

## Úloha

Dostanete reťazec $n$ znakov, v ktorom môžete urobiť najviac $k$ operácií: zmeň všetky znaky `X` na `Y`. Vašou úlohou je nájsť dĺžku najdlhšej možnej súvislej podpostupnosti rovnakých znakov, aká sa najviac $k$ takýmito operáciami dá vytvoriť.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ ($1 \\leq n \\leq 10^6$), udávajúce počet chodov a $k$ ($0 \\leq k \\leq 100$), udávajúce počet druhov chodov, ktoré Kika prehlási za iný chod. Nasleduje postupnosť chodov, zložená z malých a veľkých písmen anglickej abecedy a číslic, kde každý znak reprezentuje druh chodu.

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|---------:|-------:|---------:| | $1 \\leq n \\leq$ | $100$ | $1,000$ | $10^4$ | $10^6$ |

V prvej sade navyše platí, že reťazec na vstupe je zložený iba z číslic, teda zo znakov `0` až `9`.

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo, udávajúce najväčšiu dĺžku súvislej podpostupnosti, v ktorej sú všetky chody jedného druhu (po prehlásení najviac $k$ druhov chodov za iné).

## Príklad

```vstup
10 2
abbcbadabc
```

```vystup
6
```

*Ak zmeníme `b` a `c` na `a`, dostaneme postupnosť `a`-čok oddelenú jedným `d`. Pred `d`-čkom je táto postupnosť `a`-čok dlhá 6, čo je ľahko overiteľne najdlhšia podpostupnosť tvorená rovnakým znakom, ktorú z tejto postupnosti vieme vytvoriť.*

```vstup
20 5
9z2bX3dQquQevLFRmhYH
```

```vystup
7
```
","# Týrajú ma hladom

Úlohu zo zadania môžeme preformulovať tak, že chceme nájsť najdlhšiu súvislú podpostupnosť vstupného slova skladajúcu sa najviac z $k+1$ rôznych písmen.

Totiž ak $k$ písmen prepíšeme na to $k+1$vé, budeme mať úsek písmen, ktoré vyzerajú rovnako.

## Priamočiare riešenie

Ak by sme vedeli kde hladaný interval začína, vieme pomerne jednoducho zistiť aký je dlhý. Skúsime preto od každého písmena na vstupe spočítať aký dlhý interval by na ňom mohol začínať a riešením bude ich maximum.

Skúsime to teda naprogramovať.

Na pamätanie si, či sme dané písmenko už zarátali nám pomôže `set`, do ktorého budeme pridávať každé písmenko. Set je štruktúra ktorá ukladá iba rôzne prvky, preto sa stačí po každom vložení písmena pozrieť na veľkosť setu. Ak veľkosť setu presiahne $k+1$, vieme, že už v ňom máme viac ako $k+1$ písmeniek, teda posledné písmenko už do aktuálnej postupnosti patriť nemôže.

Toto riešenie má časovú zložitosť $O(n^2)$^[V závislosti od programovacieho jazyka, ak použijeme implementáciu založenú na hashovaní je to $O(n^2)$ ale ak máme set implementovaný pomocou binárneho vyhľadávacieho stromu je to $O(n^2 \\log p)$ kde $p$ je počet rôznych písmen.] a pamäťovu $O(n)$. Mohli ste zaň získať $4$ body.

## Ide to ale aj lepšie

Keď sme narazili na $k+2$ písmeno v predošlom riešení, museli sme celý interval zahodiť a začať od začiatku. Po krátkom zamyslení však zistíme, že ten nasledujúci interval sa nebude veľmi líšiť. Môžu nastať dve situácie. Buď sa prvé písmenko v intervale ešte niekde nachádza a teda nasledujúci interval bude rovnaký, alebo odstránením prvého písmena nám klesne aj počet rôznych písmen v sete a môžeme interval predĺžiť.

Aby sme mohli takto postupovať, musíme si namiesto setu ale pamätať aj počet výskytov v intervale pre každé písmeno. Rôznych znakov môže byť najviac $62$ (čísla, veľká a malá anglická abeceda), takže najlepšie bude použiť statické pole. Ak ho spravíme o niečo dlhšie, môžeme do neho indexovať priamo ASCII hodnotou znaku. Namiesto veľkosti setu si potom potrebujeme v nejakej premennej pamätať počet rôznych písmen v intervale.

Vstupné slovo budeme teda pechádzať z ľava do prava a to nasledovne:

Kým je počet menší ako $k+2$, budeme sa koncom hýbať doprava. Keď sa pohneme, prečítame písmenko a započítame jeho výskyt. Ak je prvý, počet rôznych písmen zväčšíme o jeden.

Ak sa nám ale stalo, že počet je väčší ako $k+1$, máme maximálny interval a môžeme posunúť začiatok. Písmeno ktoré na začiatku intervalu strácame odrátame z výskytov a skontrolujeme či bolo posledné. Ak sme zistili, že to bolo posledné písmeno toho druhu v intervale, znížime počet rôznych písmen o jeden môžeme zase posunúť koniec. Inak sa počet rôznych písmen nezmenil a koniec nevieme posunúť, takže pokračueme v posúvaní začiatku. Medzičasom si budeme pamätať maximálnu dĺžku intervalu. Takémuto postupu sa niekedy hovorí aj _dvaja bežci_.

## Časová a pamäťová zložitosť

V tomto riešení máme dva indexy do pola ktoré postupne posúvame od začiatku po koniec. Každý teda nezávysle na druhom spraví $O(n)$ krokov. Okrem toho používame statické pole na počet výskytov písmen, do ktorého však indexujeme iba keď posúvame jeden z indexov, teda časovú zložitosť to nemení a ostáva $O(n)$.

Skúseného riešiteľa neprekvapí, že pamäťová zložitosť je tiež $O(n)$^[Aby sme boli presní, je to $O(n+p)$ kde $p$ je počet možných písmen, no ak zadanie hovorí že pre dosť veľké $n$ je $p\<n$ stačí písať $O(n)$.] nakoľko viac pamäte v čase $O(n)$ nestihneme ani naplniť.
",5
98d3f07fd913af3a,ksp,"# Zázračné karty

Žaba má zázračné karty. Aspoň to tak tvrdí. V skutočnosti má úplne obyčajný balíček kariet, s ktorými robí všakovaké triky. Minule stretol Kozzu a jeden takýto trik mu predviedol. Karty premiešal, balíček párkrát prevrátil hore nohami, znovu premiešal... A na koniec Kozzu ohúril tým, že vedel presne povedať poradie, v akom karty sú. Kozza bol úplne nadšený. Hneď chcel, aby ho Žaba trik s kartami naučil. Žaba mu teda prezradil tajomstvo svojho úspechu: totiž, že na začiatku vedel, v akom poradí karty sú a keď ich miešal, vždy len zobral kartu zvrchu a dal ju na spodok, alebo zobral kartu zospodu a dal ju navrch, alebo celú kopu otočil hore nohami. Ako ale vedel tak rýchlo povedať, ako bude vyzerať finálne poradie? To si teraz naprogramujete!

## Úloha

Každá karta je označená nejakým (nie nutne jedinečným) prirodzeným číslom. Máte zadaných $n$ kariet, v poradí, v akom boli na začiatku v kope kariet, od spodku po vrch. Ďalej máme zadanú postupnosť $q$ krokov: **D** -- zoberieme kartu z vrchu kopy a presunieme ju **d**ole, **H** -- zoberieme kartu zospodu kopy a presunieme ju **h**ore, a **R** -- otočenie kopy (**r**everz). Pre dané poradie kariet na začiatku a postupnosť krokov zistite, v akom poradí budú karty na konci.

## Formát vstupu

Na prvom riadku vstupu sú čísla $n$ ($1 \\leq n \\leq 1,000,000$) a $q$ ($1 \\leq q \\leq 1,000,000$) oddelené medzerou -- počet kariet v kope a počet krokov miešania. Na ďalšom riadku je $n$ medzerami oddelených čísel -- čísla kariet v poradí, v akom boli na začiatku v kope od spodku po vrch. Čísla nepresiahnu $1,000,000$ a môžu sa opakovať. Nasleduje riadok s $q$ znakmi oddelenými medzerami. Každý znak popisuje jeden krok miešania -- D (presun dole), H (presun hore) a R (reverz kopy).

## Formát výstupu

Na výstup vypíšte $n$ čísel -- čísla kariet v poradí, v akom budú karty na konci triku v kope, odspodu po vrch.

## Príklad

```vstup
5 4
7 8 9 1 2
D D H R
```

```vystup
1 9 8 7 2
```

_Vykonávaním jednotlivých krokov sa bude poradie kariet v kope meniť nasledovne: $7 8 9 1 2 \\rightarrow 2 7 8 9 1 \\rightarrow 1 2 7 8 9 \\rightarrow 2 7 8 9 1 \\rightarrow 1 9 8 7 2$_

```vstup
3 7
1 2 3
R D D R H H R
```

```vystup
1 3 2
```
","# Zázračné karty

Na začiatok je dôležité si všimnúť niekoľko vecí. Prvé pozorovanie je, že keď $x$ kariet presunieme na vrch a potom $x$ kariet presunieme na spodok, budú v rovnakom poradí, ako na začiatku. Podobne môžeme vidieť, že ak presunieme $n$ kariet jedným smerom, budú opäť všetky na pôvodnom mieste.

Predstavme si, že karty rozložíme do kruhu a medzi vrchnú a spodnú kartu vložíme zarážku tak, aby vrchná karta bola napravo od zarážky. Čo sa stane, ak presunieme vrchnú kartu na spodok balíčka a opäť ich rozložíme do kruhu? Jediné, čo sa zmení je pozícia zarážky, ktorá bude mať naľavo od seba vrchnú kartu, ktorá sa posunula a napravo bude druhá karta zvrchu. To znamená, že zarážka sa nám po kruhu posunula o jedno miesto doprava. A samozrejme, presunutie spodnej karty navrch je len posunutie zarážky o jedno miesto doľava.

Ak teda iba presúvame karty zvrchu naspodok a naopak, stačí si pamätať, kam sme presunuli našu zarážku. A keď máme následne vypísať aktuálny stav balíčka, tak pôjdeme postupne po kruhu kariet, pričom začínať budeme na karte napravo od zarážky (aktuálna vrchná karta) až kým nenarazíme opäť na zarážku.

Čo sa ale stane ak otočíme celý balíček? Vrchná karta bude zrazu naľavo od zarážky, kým spodná bude napravo. Samotné usporiadanie kariet sa teda nezmenilo a dokonca ani zarážka sa neposunula, iba sa zmenila strana, na ktorej je vrchná karta. Je jasné, že ak v takomto stave budeme presúvať vrchnú kartu naspodok, zarážka sa posunie o jedno miesto **doľava**. Takisto výsledok sa bude vypisovať v opačnom smere ako predtým, lebo vrchná karta je na opačnej strane zarážky.

A ako to naprogramujeme? Budeme si pamätať dve premenné. Premenná $reverz$ určuje, na ktorej strane od zarážky sa nachádza vrchná karta. Premenná $zarazka$ potom hovorí pozíciu zarážky v našom kruhu. My ale nemáme kruh, iba obyčajné pole. To nevadí. Hodnota $zarazka=0$ bude znamenať, že zarážka sa nachádza medzi prvou a $n$-tou kartou balíčka. $zarazka=1$ znamená, že zarážka je medzi prvou a druhou kartou atď. Ak teda budeme musieť otočiť balíček, jednoducho upravíme hodnotu $reverz$ a keď budeme musieť presunúť kartu, tak podľa hodnoty $reverz$ zmeníme hodnotu $zarazka$ -- ak je vrchná karta napravo od zarážky a presúvame túto kartu naspodok, k hodnote $zarazka$ pričítame číslo 1, ak je vrchná karta naľavo, tak k hodnote $zarazka$ pričítame $-1$. A naopak pri presúvaní spodnej karty.

Samozrejme, môže sa nám stať, že hodnota $zarazka$ bude záporná, alebo privysoká. Vtedy však využijeme naše prvé pozorovanie -- ak posunieme $n$ kariet jedným smerom, dostaneme rovnakú situáciu. To znamená, že k hodnote $zarazka$ môžeme kedykoľvek pričítať alebo odčítať číslo $n$ bez toho, aby sme zmenili situáciu, ktorú popisujeme. Vďaka tomu bude hodnota $zarazka$ vždy v intervale $0$ až $n-1$.

Nakoniec, keď budeme chcieť vypísať výsledok, tak si z hodnôt $reverz$ a $zarazka$ zistíme, kde sa nachádza vrchná karta a v správnom smere (závislom od $reverz$) vypíšeme postupne všetky čísla. Časová aj pamäťová zložitosť bude lineárna od $n$, čo zapíšeme ako $O(n)$.
",2
3c83fb4ded00a3d3,ksp,"# Antény

Nad mestom je kopec a na kopci stojí rad antén. Každá anténa je pripojená ku svojmu vysielaču a ten má priradenú nejakú frekvenciu $f_i$, na ktorej smie vysielať. Všetky vysielače momentálne patria štátu. V meste pod kopcom bývajú dvaja podnikatelia: Amálka a Branko. Obaja by radi založili vlastné rádio, nemajú ale vysielač.

(Amálka si chce založiť Rádio eKSPres, ktoré bude vysielať zaujímavosti zo sveta algoritmov. Brankovo rádio sa bude volať RadioSiTy a dozviete sa z neho o svete 3D grafiky, to ale pre našu úlohu nie je dôležité.)

Povráva sa, že štát čoskoro uvoľní nejaký súvislý úsek antén na kopci a ponúkne ich na prenájom súkromníkom. Nevie sa, ktorý úsek to bude, ale Amálka a Branko už vopred uzavreli dohodu: prenajmú si také dve antény, aby sa frekvencie, na ktorých budú vysielať, líšili aspoň o $\\delta$.

## Úloha

Daný je počet antén $n$, číslo $\\delta$ a frekvencie $f_0,\\dots,f\_{n-1}$ na ktorých jednotlivé antény vysielajú. Potom je dané číslo $q$ a následne $q$ otázok. Každá otázka je určená dvomi číslami $l_i$ a $h_i$ a má nasledovný tvar: ""Keby boli na prenájom antény s číslami od $l_i$ po $h_i$ vrátane, koľkými rôznymi spôsobmi si vedia Amálka a Branko prenajať dve z nich?""

Napíšte program, ktorý načíta všetky vyššie popísané údaje a následne čo najefektívnejšie odpovie na všetky zadané otázky.

(Dve možnosti považujeme za rôzne, ak sa líšia neusporiadané dvojice indexov antén, ktoré im zodpovedajú. Nezáleží nám teda na tom, kto dostane ktorú anténu z konkrétnej dvojice.)

## Formát vstupu

V prvom riadku sú celé čísla $n$ a $\\delta$ oddelené medzerou: počet antén a minimálny rozdiel frekvencií. Antény sú očíslované od 0 po $n-1$ v poradí, v ktorom stoja na kopci. Platí $1\\leq\\delta\\leq 10^6$.

V druhom riadku sú celé čísla $f_0,\\dots,f\_{n-1}$: frekvencie pre jednotlivé antény. Platí $\\forall i: 1\\leq f_i\\leq 10^6$.

V treťom riadku je celé číslo $q$: počet otázok.

Zvyšok vstupu tvorí $q$ riadkov, každý z nich obsahuje dve medzerou oddelené celé čísla $l_i$ a $h_i$ popisujúce jednu otázku. Pre každú otázku platí $0\\leq l_i < h_i\\leq n-1$.

## Formát výstupu

Na výstup vypíšte $q$ riadkov s odpoveďami na otázky, v poradí, v ktorom sú tieto zadané na vstupe.

## Hodnotenie

Pre jednotlivé sady vstupov platia nasledovné dodatočné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ---:| ---:| ---:| -----:| | $1 \\leq n \\leq$ | $100$ | $3,000$ | $50,000$ | $100,000$ | | $1 \\leq q \\leq$ | $100$ | $50,000$ | $50,000$ | $100,000$ |

## Príklad

```vstup
5 10
45 60 40 50 45
3
0 2
2 4
0 4
```

```vystup
2
1
5
```

*V prvej otázke vyhovujú dvojice antén $[0, 1]$ a $[1, 2]$ s frekvenciami $[45, 60]$ a $[60, 40]$. V druhej otázke vyhovuje iba dvojica $[2, 3]$ s frekvenciami $[40, 50]$. V tretej otázke vyhovujú dvojice $[0, 1]$, $[1, 2]$, $[1, 3]$, $[1, 4]$ a $[2, 3]$.*
","# Antény

Vzorové riešenie tejto úlohy bude mať vtipnú časovú zložitosť $O((n+q)\\sqrt{n}\\log f)$, kde $n$ je počet antén, $q$ je počet otázok a $f$ je rozsah hodnôt pre frekvencie antén. Ako takáto veselá časová zložitosť vznikne? Uvidíme časom.

## Jednoduchšia úloha

Zabudnime na to, že máme nejaké pole a nejaké otázky, a zamyslime sa nad jednoduchšou úlohou, ktorá vyzerá nasledovne: Dané je číslo $\\delta$. Začíname s prázdnou (multi)množinou. Následne dostaneme sadu príkazov, pričom každý je buď tvaru ""pridaj toto číslo"" alebo ""odstráň toto skôr pridané číslo"". Všetky čísla sú celé z rozsahu od 0 po $f$. Po každej operácii musíme odpovedať, koľko dvojíc čísel v našej množine má vzdialenosť aspoň $\\delta$.

Ako túto úlohu efektívne riešiť? Existujú mnohé dátové štruktúry, pomocou ktorých vieme každú otázku zodpovedať v logaritmickom čase. Napr. pomocou vhodného vyvažovaného binárneho stromu by sme pre danú postupnosť $n$ príkazov vedeli každý príkaz spracovať v čase $O(\\log n)$, a to dokonca bez ohľadu na veľkosť $f$.

Existujú však aj riešenia omnoho jednoduchšie na implementáciu. Asi najľahšie je použiť Fenwickov (""fínsky"") strom, resp. súčtový [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom). Pre každé číslo od 0 po $f$ si budeme v strome pamätať, *koľkokrát* sa už v našej množine nachádza. Strom nám následne umožní v čase $O(\\log f)$ o ľubovoľnom intervale zistiť, koľko prvkov našej množiny v ňom leží.

No a toto využijeme nasledovne: Ak napr. dostaneme príkaz pridať nový prvok $x$, najskôr si zistíme, koľko prvkov leží v $(x-\\delta,x+\\delta)$ a z toho vieme vypočítať, koľko nových dvojíc dostatočne vzdialených prvkov nám práve pribudlo.

Toto riešenie teda každý príkaz (pridanie alebo odobratie čísla) spracuje v čase $O(\\log f)$.

## Pôvodná úloha

Vráťme sa teraz k našej pôvodnej úlohe.

Technika, ktorú si ukážeme, sa dá použiť vždy, keď sú splnené isté predpoklady. V prvom rade potrebujeme, aby išlo (rovnako ako v tejto úlohe) o *offline* problém -- teda všetky otázky dostaneme naraz a môžeme si vybrať, v akom poradí ich zodpovieme. To ale samo o sebe nestačí.

Druhá vlastnosť, ktorú potrebujeme, súvisí práve s vyššie uvedenou jednoduchšou úlohou. Naša technika bude použiteľná pre všetky problémy, kde takýmto spôsobom zjednodušenú úlohu vieme efektívne riešiť.

## Odmocninové vedierka

Na vstupe sme dostali $q$ rôznych otázok, ktoré máme všetky zodpovedať. Náš algoritmus bude efektívny vďaka tomu, že si otázky šikovne prerozdelíme do skupín a potom vyriešime vždy celú skupinu naraz.

Predstavme si, že sme si celý rad antén (pole dĺžky $n$) rozdelili na $\\sqrt{n}$ úsekov. Následne môžeme zobrať všetky otázky a roztriediť ich do $\\sqrt{n}$ vedierok podľa toho, *v ktorom úseku začínajú*.

Formálne, zoberme si $s=\\lceil\\sqrt{n},\\rceil$ a potom každú otázku $[l_i,h_i]$ umiestnime do vedierka $\\lfloor l_i/s\\rfloor$.

Čo sme takto dostali? V každom vedierku máme otázky, ktoré *začínajú zhruba na tom istom mieste.* (Končiť však môžu veľmi rôzne. Vedierko číslo 0 môže obsahovať ako otázku na jediné políčko, tak aj otázku na úplne celé pole.)

## Spracovanie jedného vedierka

Každé vedierko s otázkami teraz spracujeme nasledujúcim spôsobom:

1. Všetky otázky vo vedierku usporiadame vzostupne podľa ich *konca*.
1. Prvú otázku zodpovieme hrubou silou: začneme s prázdnou množinou a postupne po jednom do nej pridáme prvky úseku, na ktorý sa otázka pýta.
1. Každú ďalšiu otázku zodpovieme tak, že postupne prerobíme predchádzajúci interval na nový: najskôr pridávame prvky na konci, potom pridávame alebo uberáme prvky na začiatku.

Teda ak sme napr. práve zodpovedali otázku $[7, 47]$ a čaká nás otázka $[3, 52]$, tak postupne do našej množiny pridáme prvky na indexoch 48, 49, 50, 51, 52, 6, 5, 4, a 3. Ak by potom nasledovala otázka $[4, 53]$, tak by sme do našej množiny následne pridali prvok na indexe 53 a potom opäť odstránili prvok na indexe 3.

A to je už úplne všetko. Jednoduché, nie?

## Odhad časovej zložitosti

Implemenácia je skutočne veľmi jednoduchá, odhad časovej zložitosti nás však trochu potrápi.

V každom vedierku, v ktorom máme aspoň jednu otázku, budeme jednu otázku spracúvať hrubou silou. Keďže táto otázka má dĺžku $O(n)$, jej spracovanie si vyžiada $O(n)$ množinových operácií. Ak by sme teda z každého z $\\sqrt n$ vedierok spracovali len prvú otázku, trvalo by to $O(\\sqrt{n}\\cdot n\\log f)$.

Koľko práce dokopy pridá spracovanie všetkých ostatných otázok?

V každom vedierku potrebujeme otázky usporiadať podľa konca. Ak každé vedierko samostatne usporiadame napríklad [MergeSortom](https://www.ksp.sk/kucharka/mergesort), dokopy nám to bude trvať $O(q \\log q)$ času (keďže dokopy je vo vedierkach $q$ otázok). Iná možnosť s rovnakou časovou zložitosťou je usporiadať si na začiatku všetky otázky podľa konca a až potom ich prerozdeliť do vedierok -- čím automaticky budú usporiadané v každom z vedierok. No keďže koniec je číslo z rozsahu 0 až $n-1$, namiesto MergeSortu môžeme použiť CountSort, čím dostaneme zložitosť $O(q + n)$. Ak je počet otázok $q$ zhruba rovný počtu antén $n$, časová zložitosť ľubovoľnej z týchto možností bude zanedbateľná oproti zvyšku riešenia.

Keď prerábame nejakú otázku na nasledujúcu, robíme dva typy zmien:

- pridávame prvky na pravom okraji otázky
- pridávame a uberáme prvky na ľavom okraji otázky

Pridávanie prvkov na pravom okraji je efektívne. Pozrime sa na ľubovoľné vedierko. Keďže sú otázky v ňom usporiadané podľa konca, vždy, keď ideme na nasledujúcu, budeme na pravom kraji len pridávať prvky, nikdy nie odoberať. A teda každý z $n$ prvkov poľa takto pridáme do našej množiny nanajvýš raz. Dokopy teda tieto kroky pre jedno vedierko budú trvať $O(n\\log f)$. No a keďže vedierok je $\\sqrt{n}$, celkový čas strávený posúvaním pravého konca je $O(n\\sqrt{n}\\log f)$.

No a aj pridávanie a uberanie prvkov na ľavom okraji je efektívne. Toto je to miesto, kde sa ukáže, prečo sme vlastne delili otázky do vedierok. Totiž keď sú dve otázky v tom istom vedierku, sú ich začiatky vzdialené nanajvýš o $\\sqrt n$. No a teda keď prerábame jednu z nich na druhú, na ľavom okraji stačí postupne spraviť $O(\\sqrt n)$ zmien. Dokopy pre všetkých $q$ otázok teda dostávame $O(q\\sqrt n)$ zmien, a keďže každú vieme spraviť v čase $O(\\log f)$, celkový čas strávený týmito krokmi je $O(q\\sqrt n\\log f)$.

Celkovú časovú zložitosť teraz dostaneme sčítaním vyššie uvedených odhadov.

## Historická poznámka

Táto technika je pomerne známa v svete efektívnych algoritmov, ale do súťažného programovania dorazila až v roku 2009, kedy Mo Tao touto technikou vyriešil úlohu počas čínskeho prípravného sústredenia pred IOI. V súťažnom programovaní sa následne zaužívalo volať túto techniku *Mo's algorithm*.
",10
bff542ba8706245d,ksp,"# Zatúlané cukríky

Kuko má rád sladkosti. Nepohrdne čokoládou, horalkou, ba ani čistým cukrom. No zo všetkého najradšej má rád cukríky. Takmer vždy má pri sebe otvorené vrecúško jeho obľúbených maškŕt.

Jedného krásneho dňa šiel ako každý správny matfyzák na prednášku. A ako každý správny vedúci samozrejme na poslednú chvíľu. No ako obiehal Zergbota s kofolou, potkol sa a celé balenie sa mu rozsypalo po chodbe.

Rád by ich čo najviac pozbieral späť do sáčku, no nemôže sa veľmi zdržať, keďže už aj tak mešká na prednášku. Preto vás požiadal o pomoc.

## Úloha

Chodbu na matfyze si môžete predstaviť ako obdĺžnik $n\\times m$ dláždený štvorcovými kachličkami. Keď Kuko prejde cez kachličku, zoberie všetky cukríky, ktoré sú na nej vysypané. Začína v ľavom hornom rohu chodby, prednášku má v pravom dolnom. Keďže sa na ňu ponáhľa, tak sa k nej chce v každom kroku posunúť bližšie. Môže teda chodiť iba doprava alebo dole.

Vašou úlohou je zistiť, koľko najviac cukríkov vie Kuko vyzbierať a ako sa má hýbať aby sa mu to podarilo.

Úloha sa testuje na piatich sadách vstupov. Pre vyriešenie prvých $2$ sád nemusíte vypisovať Kukovu cestu, stačí zistiť počet cukríkov. Za takýto program dostanete $2$ body.

Pre jednotlivé testovacie sady platia nasledovné obmedzenia:

| Sada | Limity vstupov | Treba cestu | |:--- | :--- | ---:| | $1$ | $n,m \\leq 10$ | `Nie` | | $2$ | $n,m \\leq 1,000$ | `Nie` | | $3$ | $n,m \\leq 10$ | `Áno` | | $4$ | $n,m \\leq 100$ | `Áno` | | $5$ | $n,m \\leq 1,000$ | `Áno` |

## Formát vstupu

Na prvom riadku vstupu dostanete čísla $n$ a $m$ -- rozmery chodby. Nasleduje $n$ riadkov, každý obsahuje $m$ čísel oddelených medzerou -- počty cukríkov na jednotlivých kachličkách. Tieto čísla sú v rozsahu od $1$ po $10^6$.

## Formát výstupu

Na prvý riadok vypíšte najväčší počet cukríkov, ktoré vie Kuko zozbierať. Na nasledulúci riadok vypíšte jeden reťazec bez medzier, reprezentujúci Kukovu trasu. Písmeno `D` označuje pohyb dole, písmeno `R` pohyb doprava. Ak existuje viacej optimálnych trás, vypíšte ľubovoľnú z nich.

##Príklad

```vstup
4 5
1 2 5 1 2
3 2 1 2 1
1 4 3 2 1
3 1 2 2 2
```

```vystup
19
DRDRRDR
```
","# Zatúlané cukríky

Pozrime sa najprv na trochu jednoduchšiu úlohu, v ktorej nebudeme musieť vypisovať celú Kukovu cestu, ale len počet cukríkov, ktoré nazbieral.

## Rekurzia

Asi najjednoduchšie funkčné riešenie, aké sa dalo vymyslieť, je rekurzia.

Cheme zistiť, koľko najviac cukríkov mohol Kuko zobrať po ceste z ľavého horného rohu do pravého dolného rohu mapy. Dostať sa na pravé dolné políčko mohol buď zhora alebo zľava. Rekurzívne si zistíme, koľko najviac cukríkov vedel zozbierať na ceste zo začiatku do jedného z týchto políčok (túto otázku sa pýtam dvakrát, postupne pre obe políčka) a vyberieme si lepšiu možnosť. Tieto kratšie cesty vyrátame rovnakým spôsobom, buď sa na posledné políčko na nej prišiel zľava alebo zhora. Jedinou výnimkou sú políčka na ľavom a hornom okraji mapy, kde mám vždy len jednu možnosť, ako som sa mohol na ne dostať a ľavé horné políčko, kde nie je ani jedna možnosť.

Aká je časová zložitosť? Prvé volanie funkcie sa zavolá dvakrát, každé z týchto volaní sa však tiež zavolá dvakrát, čo je dokopy už štyrikrát, a čo nevidieť tu máme exponenciálnu časovú zložitosť. To nám zbehne tak na vstupoch do veľkosti $10$, ale na ostatné potrebujeme niečo rýchlejšie.

## Rekurzia s memoizáciou

Riešenie obyčajnou rekurziou je pomalé preto, lebo veľakrát hľadáme cestu na to isté políčko. Algoritmus preto upravíme: namiesto toho, aby sme vždy danú cestu počítali nanovo, si ju spočítame len raz, výsledok uložíme do pamäte a pri ďalších otázkach vrátime rovno túto už vypočítanú hodnotu.

Vďaka tomu, že cestu na každé políčko prepočítavame najviac raz a pýtame sa ňu najviac dvakrát^[raz keď počítame cestu na políčko pod ním a raz na cestu na políčko vpravo], sa časová zložitosť rekurzie zlepšila na počet políčok, teda O($nm$). Táto zložitosť je naviac najlepšia možná, lebo musíme načítať hodnotu všetkých políčok, čo nám zaberie čas $O(nm)$.

## Vypisovanie cesty

Vypisovanie cesty je pri vyššie uvedených algoritmoch už len čerešničkou na torte a dá sa doprogramovať veľmi jednoducho. Pri všetkých sme sa totiž pre danú cestu na políčko pýtali, či je lepšie ísť doňho zvrchu alebo zľava. Zapamätáme si teda, ktorá z týchto možností bola výhodnejšia, napríklad do dvojrozmerného poľa znakov. Z neho budeme na konci vedieť priamo vyskladať cestu -- stačí, ak pôjdeme odzadu.

## Dynamické programovanie

Táto úloha sa dala riešiť aj principiálne inak, než rekurziou, a to pomocou dynamického programovania. Pri rekurzii sme sa snažili zrátať rovno výsledok a postupne si dopočítavať zvyšné informácie, ako sme ich potrebovali. Dynamické programovanie sa na problém pozerá z opačného konca -- z údajov, ktoré už poznáme vyráta ďalšie, až kým sa nedopracuje k výsledku. Postupne preto ráta najväčší počet cukríkov, ktoré vieme zozbierať na ceste na dané políčko, ale začína rátať v ľavom hornom rohu a od neho ide postupne doprava a dole.
",4
86dbbdbe84028868,ksp,"# Štrádovanie si

Ján Ploštica sa spolu s rodinou nedávno presťahoval do mesta Gaučislava. Je to novozaložená kolónia ploštíc v T2, ktorá láka na pestrú a súdržnú susedskú komunitu, ale aj ľahkú dostupnosť služieb a občianskeho vybavenia, či prepracovanú a udržiavanú sieť tunelov. Celá navyše leží v príjemnom prostredí molitánu, ktorý plošticiam poskytuje zdravé a podnetné prostredie pre napĺňajúci každodenný život.

Pri návrhu komunikácií sa ploštičím inžinierom podarilo naplánovať mesto bez jedinej zbytočnej cesty -- medzi každými dvoma miestami v Gaučislave sa dá dostať práve jedným spôsobom, pokiaľ sa ploštice po ceste nevracajú späť. Zároveň každá lokácia v meste má presne podľa plánu zaznačenú nadzemnú výšku, v ktorej sa nachádza, v jednotkách nožičkomilióntiny (nm). S rôznymi nadzemnými výškami sa totiž spájajú rozdielne podmienky, ktoré rozličným plošticiam vyhovujú rozdielnym spôsobom. Tým si ale lámať hlavu nemusíme, pretože to už predsa inžinieri vyriešili a navrhli.

Ján P. by sa rád pochválil svojim ploštičím kamarátom tým, aké veľké je mesto, kam sa presťahoval. Preto sa vydal na prechádzku tunelmi od svojho domu, a pri každej budove, ktorú minul, si poznačil jej nadzemnú výšku. Je si pritom istý, že sa mu podarilo navštíviť každé miesto v Gaučislave.

Dostal tak postupnosť výšok, ktorú ukázal kamarátom. Tí ale namietali, že ak navštívil nejaké miesto veľakrát, tak v zápise sa tiež vyskytlo veľakrát, a teda sa bude zdať, že Gaučislava je väčšia, než v skutočnosti. Preto potrebuje zistiť, aké najmenšie mesto môže byť, aby ich presvedčil, že určite musí byť masívne.

## Úloha

Trochu formálnejšie, mesto Gaučislava tvorí [strom] -- neorientovaný súvislý acyklický graf. To znamená, že medzi každými dvoma vrcholmi vedie práve jedna cesta (postupnosť vrcholov a hrán, v ktorej sa žiadny vrchol ani hrana neopakuje). Každý vrchol má svoju určenú výšku v nm, v rozsahu $0$ až $10^9$ (zhruba výška gauča aj s operadlom). Rôzne vrcholy môžu mať rovnakú výšku.

Dostanete číslo $n$ a postupnosť výšok navštívených vrcholov $v_1 ... v_n$. Vašou úlohou je vypísať najmenšie číslo $m \\leq n$ také, že existuje strom s $m$ vrcholmi nejakých výšok, ktorého prechádzaním vieme dostať zadanú postupnosť výšok, pričom si zapisujeme **každý** vrchol, na ktorý vstúpime (a ten istý vrchol nevieme zapísať znova bez toho, aby sme z neho najskôr odišli a vrátili sa).

## Formát vstupu

Na prvom riadku dostanete číslo $n$ -- počet zaznamenaných výšok. Na druhom riadku dostanete $n$ čísel v rozsahu $\\langle 0, 10^9 \\rangle$ -- postupnosť výšok navštívených vrcholov.

## Formát výstupu

Vypíšte jedno číslo $m$ spĺňajúce zadanie -- najmenší možný počet vrcholov stromu.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:--------------- |-----: | -------: | ---------: | ------------: | | $1 \\leq n \\leq$ | $100$ | $3,000$ | $100,000$ | $1,000,000$ |

## Príklad

```vstup
4
4 20 4 20
```

```vystup
2
```

_Naozaj masívne mesto, ktoré obsahuje dva domy s výškami 4 a 20. Videli ste hádam niekedy väčšie ploštičie mesto?_

```vstup
8
4 20 20 4 4 4 20 10
```

```vystup
6
```

_Prvých 5 výšok je síce podobných, no popisujú rôzne budovy. Šiesta výška popisuje štvrtú budovu, siedma tretiu, ôsma predtým nenavštívenú šiestu, ktorá susedí s tretiou._

[strom]: ttps://www.ksp.sk/kucharka/grafy_uvod/#wiki-toc-specialne-druhy-grafov
","# Štrádovanie si

Našou úlohou je nájsť **najmenší** možný strom (čiže súvislý acyklický graf), ktorý zodpovedá popisu. V takomto strome, pre každú zadanú výšku, existuje vrchol danej výšky, ktorý susedí s vrcholmi výšok zadaných tesne pred a po jeho výške.

## Ako vyzerá najmenší strom

Môžeme si všimnúť, že nemá zmysel, aby jeden vrchol $V$ mal dvoch susedov rovnakej výšky. Keby takí dvaja susedia existovali, nazvime ich $S$ a $T$, mohli by sme zobrať všetkých susedov vrcholu $S$ (vrátane $V$) a napojiť ich do $T$ namiesto do $S$. Potom by sme mohli vrchol $S$ úplne zmazať, pretože by nemal žiadnych susedov. Postupnosť výšok by bola stále validná, pretože medzi každými dvoma susedmi pôvodného vrcholu $S$ by viedla rovnaká cesta cez $T$ (čo sa týka poradia výšok), ako viedla cez $S$. Zároveň by náš nový strom mal o jeden vrchol ($S$) menej, čo by bol spor s tvrdením, že pôvodný strom bol najmenší možný. Preto vieme, že žiadny vrchol nemá dvoch rovnako vysokých susedov.

To už nám v podstate hovorí, ako vytvoriť najmenší strom -- budeme si vždy pamätať posledný navštívený vrchol a pre každú výšku sa pozrieme, či tento vrchol už má suseda danej výšky. Ak má, iba sa do tohoto suseda presunieme. Ak nemá, vytvoríme si nový vrchol danej výšky a presunieme sa do neho.

Ideálny strom nemôže byť menší, pretože sa nevieme presúvať medzi vrcholmi, ktoré nesusedia (a keďže ide o strom, vrcholy, ktoré nie sú zadané tesne po sebe v nejakej časti postupnosti výšok, spolu susediť nemôžu, inak by existoval cyklus).

## Ako to implementovať

Vrcholy si budeme pamätať v poradí, v akom sme ich prvý krát videli. Na to vieme použiť obyčajné pole, kam vždy pri vytvorení nového vrcholu pridáme jeho výšku. Vrcholy budeme inde reprezentovať indexami tohoto poľa.

Zároveň si pre každý vrchol chceme pamätať výšky všetkých jeho susedov, a to tak, aby sme sa vedeli čo najrýchlejšie spýtať, či má aktuálny vrchol suseda danej výšky. A ak áno, ktorý to je. Pomalá implementácia by mohla vyzerať takto:

Pre každý vrchol máme pole, v ktorom si ukladáme všetkých jeho susedov. Keď chceme zistiť, či má vrchol suseda s danou výškou, prejdeme všetkých jeho susedov a skúsime nájsť jedného so správnou výškou. Takáto implementácia je kvadratická, čo sa najlepšie predstavuje na grafe tvaru hviezdy -- každý druhý raz navštívime stredový vrchol a potom prejdeme až lineárne mnoho vrcholov, aby sme zistili, či treba pridať nový.

Aby sme zlepšili časovú zložitosť, môžeme namiesto poľa susedov použiť rýchlejšiu dátovú štruktúru - napríklad slovník alebo vyhľadávací strom. Pri použití slovníku a hashovania sa nám lineárny čas na otázku zlepší na konštantný a taký bude aj čas pridávania vrcholu. Pri použití vyhľadávacieho stromu budú oba časy logaritmické.

## Časová a pamäťová zložitosť

Prechádzame celý vstup a pre každú výšku robíme konštantne mnoho operácií, preto je celková časová zložitosť $O(n)$ (respektíve $O(n log n)$ pri použití vyhľadávacieho stromu namiesto slovníka). Pamäťová zložitosť je rovná počtu vrcholov plus počtu hrán, ale keďže graf je strom, je oboch lineárne mnoho.

*Pri praktickej implementácií môžeme tiež použiť jeden slovník pre všetky vrcholy tak, ako v autorskom riešení.*
",5
e7d94ba99b0c8239,ksp,"# Utrápený Marcel

Marcel má veľký sen. Jedného dňa by chcel byť skutočným vedcom v Slovenskej akadémii vied, tak ako jeho kamaráti Samko a Emko. Laboratórium vákuovej fyziky mu však zatiaľ dáva robiť iba podradné práce. Varí kolegom kávu, chodí po balíčky na poštu, seká uhorky, prípadne plní iné ich želania.

Jedného dňa ho Emko so Samkom poslali na nákup do Teska. Marcel si okrem nákupu kúpil aj dve veľké tašky, do ktorých chcel vkladať tovar. Kým predavač blokoval jeho nákup, Marcel rozmýšlal, ako tovar rozdeliť medzi tašky, aby ich hmotnosti boli čo najviac vyrovnané. Kedže v rade za ním je veľa ľudí, Marcel nechce zdržovať a ukladá tovar to tašiek jeden po druhom.

Po krátkom výpočte Marcel zistil, kedy má začať nákup ukladať do druhej tašky. Keď doniesol nákup svojim kolegom, spýtal sa ich, či aj oni vedia takúto úlohu vyriešiť. Pomôžte Samkovi a Emkovi vyriešiť tento problém.

## Úloha

Marcel má dve tašky neobmedzenej veľkosti, do ktorých balí tovar v poradí, v akom mu ho predavač podáva. Postupuje pri tom tak, že niekoľko prvých predmetov vloží do prvej tašky a zvyšné predmety dá do druhej. Vašou úlohou je zistiť, koľko predmetov má dať do prvej tašky, aby bol rozdiel hmotností tašiek čo najmenší. Ak existuje viacero optimálnych riešení, potom vypíšte väčšie číslo (snažte sa teda dávať predmety do prvej tašky).

## Formát vstupu

Na prvom riadku vstupu bude jedno kladné celé číslo $n$ -- počet predmetov v Marcelovom nákupe. Druhý riadok obsahuje postupnosť $n$ kladných celých čísel oddelených medzerami -- hmotnosti predmetov v poradí, v akom ich predavač podáva Marcelovi.

Pre jednotlivé testovacie sady platia nasledujúce obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ---:| ---:| ---:| -----:| | $n \\leq$ | $1,000$ | $5,000$ | $100,000$ | $100,000$ | | maximálna hmotnosť predmetu $\\leq$ | $1,000$ | $5,000$ | $10,000$ | $10,000$ |

## Formát výstupu

Na výstup vypíšte jeden riadok obashujúci jedno číslo -- počet predmetov, ktoré má Marcel dať do prvej tašky.

## Príklad

```vstup
5
7 3 2 8 1
```

```vystup
2
```

*V prvej taške bude $7+3=10$ a v druhej $2+8+1=11$.*

```vstup
6
2 4 7 1 2 3
```

```vystup
3
```

*Nezáleží na tom, či dáme do prvej tašky prvé dva, alebo prvé tri predmety, rozdiel hmotností tašiek bude rovnaký. V prípade rovnosti máme však pridať predmet do prvej tašky, preto je odpoveď $3$.*
","# Utrápený Marcel

bodypopis=12 bodyprogram=8}

Našou úlohou bolo pomôcť Samkovi a Emkovi zistiť, koľko predmetov treba vložiť do prvej tašky. Ukážeme si najprv pomalšie riešenie, ktoré potom vylepšíme. Zadanie hovorí, že Marcel do určitého momentu dáva predmety iba do prvej tašky a od tohto momentu ich dáva iba do druhej. Prvý predmet, ktorý Marcel vloží do druhej tašky, budeme v ďalšej časti vzoráku nazývať *zmrzlina*.

## Pomalšie riešenie

Vyskúšame všetky možnosti pre zmrzlinu. Pre každú možnosť vypočítame súčet hmotností predmetov, ktoré sú nablokované pred zmrzlinou a súčet hmotností zvyšných predmetov. Čím menší je rozdiel týchto čísel, tým lepšie sú tašky vyvážené. Kedže všetkých predmetov (možností pre zmrzlinu) je $n$ a pri každej možnosti musíme sčítať $n$ hmotností, výsledná časová zložitosť bude $O(n^2)$, pamäťová je $O(n)$.

## Vzorové riešenie

Čo robíme navyše? Stačí si všimnúť dve veci:

1. Najlepší výsledok dostaneme, ak bude hmotnosť prvej tašky najbližšie k polovici z celkovej hmotnosti všetkých predmetov.

1. Nemusíme pre každú možnú pozíciu zmrzliny počítať hmotnosť prvej tašky samostatne. Rozdiel medzi taškou, ktorá obsahuje prvých $x$ prvkov a taškou, ktorá obsahuje prvých $x+1$ prvkov je len jeden predmet. Tiež si všimnime, že ak vieme hmotnosti oboch tašiek (nazvime tieto hmotnosti $A$ a $B$) a hmotnosť predmetu $p$, ktorý ideme dať z druhej do prvej tašky, tak hmotnosti týchto tašiek sa zmenia nasledovne: prvej taške stúpne hmotnosť na $A + p$ a druhej klesne na $B - p$.

Čo teda spravíme? Najprv si spočítame súčet hmotností všetkých predmetov. Na začiatku si predstavujeme, že všetky predmety sú v druhej taške. Potom postupne prechádzame cez všetky predmety zľava doprava a zisťujeme, či sa nám oplatí dať predmet z druhej tašky do prvej. Kým sa to oplatí, dávame predmety do prvej tašky až nastane situácia, že pridaním ďalšieho predmetu sa už nič nezlepší. Vtedy môžeme skončiť, lebo pridávaním ďalších predmetov do prvej tašky sa situácia vždy len zhorší. Výsledná časová zložitosť bude $O(n)$, pamäťová ostáva $O(n)$.

## Iný typ vzorového riešenia

Ukážeme si ešte jedno riešenie, založené na [prefixových sumách](https://www.ksp.sk/kucharka/prefixove_sumy/).\
Všimnime si, že v našom pomalšom riešení zbytočne sčitujeme hmotnosti predmetov pre každú voľbu zmrzliny. To, čo nás zaujíma, je súčet prvých $x$ predmetov (pre $x \\leq n$) a súčet hmotností zvyšných predmetov. Tieto súčty vieme získať v konštantnom čase použítím práve spomínaných prefixových súm. Výsledná časová zložitosť bude $O(n)$, pamäťová ostáva $O(n)$ rovnako ako v prvom vzorovom riešení.
",1
77eb84514fe1dbc1,ksp,"# Dalo by sa?!

""Dalo by sa pohnúť?""

""Kto ti dal vodičák?""

""Slečna ja Vás zveziem, moje auto je dosť veľké...""

""Ľudiaaa? Nevideli ste niekto jeden valec z môjho auta?""

""Čo to bola za značka? Nebolo to _Daj prednosť v jazde_?""

""Odtiahnete ma niekto? Asi som zase prerazil olejovú vaňu...""

""Joooj, posunúť sa, aby som mohol odísť? Dalo by sa?""

""Dávam Vám ešte 2 minúty, a potom sa proste pohnem tým smerom, ako stojím.""

""Vajcia? Ja som naozaj do auta nebalila vajcia! Tie musí mať niekto iný, ja ich určite nemám""

Osadenstvo T2^[KSP miestosť na matfyze] tento hluk spočiatku ignorovalo, ale ako neutíchal, postupne sa preberali z letargie a knedliačenia na gaučoch. Hneď ako vstali a pozreli sa z okna, pochopili čo sa stalo. FKS odchádza na sústredenie. A všetci vedúci išli vlastným autom. Pred sústredkom sa všetci stretli na matfyze a zastali autom pred okno T2, na jednu dlhú a úzku cestu. Po čase do áut pobalili veci, a ako už chceli všetci odísť, tak zistili, že nikto sa nie je ochotný autom otočiť, každý chce pokračovať tým smerom, ako teraz stojí.

Aby mali na túto situáciu pamiatku, Adam zobral foťák a odfotil všetky autá, ktoré boli na ceste. Hneď potom sa ale stali naraz dve veci: zapípala mikrovlnka (a všetci sa k nej otočili) a autá sa pohli (a teda do seba ponarážali). Keďže nikto z osadenstva T2 sa na autá nepozeral, tak nikto nevidel priebeh zrážky, ktorá nastala.

Po čase smútenia (nad tým, že nevideli zrážku, nie nad autami) si ale uvedomili, že možno by sa dalo aspoň z fotky povedať, koľko zrážok sa pred oknom udialo. Vedeli by ste im to zistiť?

## Úloha

Vašou úlohou bude určiť počet zrážok, ktoré nastali pred oknom T2. Pred T2 oknom sa nachádzajú autá, ktoré buď smerujú doľava, stoja, alebo smerujú doprava. Všetky autá, ktoré smerujú doľava alebo doprava sa v rovnakom momente pohli rovnakou rýchlosťou. Vašou úlohou je zistiť počet zrážok, ktoré nastanú. Autá po zrážke zastanú na mieste a ostanú stáť.

Zrážka nastane vtedy, keď hýbajúce sa auto do niečoho narazí (teda ak narazí auto do stojaceho auta, je to jedna zrážka, ak sa čelne zrazia dve autá, čo doteraz išli opačne, sú to 2 zrážky).

## Formát vstupu

Na jedinom riadku vstupu dostanete $n$ znakov dlhý reťazec. Tento reťazec sa skladá zo znakov `>` (doprava idúce auto), `<` (doľava idúce auto), `=` (stojace auto).

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |----: |------: |-------------: |-------------: | | $1 \\leq n \\leq$ | 5 | $1,000$ | $1,000,000$ | $5,000,000$ |

V prvej a druhej sade sa nevyskytujú stojace autá.

V prvej sade sa všetky autá okrem jedného hýbu rovnakým smerom (napríklad `<<<><`, alebo `><<<<<`).

## Formát výstupu

Vypíšte jediný riadok, počet zrážok, ktoré pred oknami T2 nastanú. Nezabudnite za číslom vypísať znak nového riadku.

## Príklady

```vstup
><><
```

```vystup
4
```

```vstup
<=>
```

```vystup
0
```

_Krajné autá odídu a stredné sa nikam nepohne, takže nenastane žiadna zrážka_

```vstup
>>=<><
```

```vystup
5
```

```vstup
>>><><<><<>>==<>==<><<>><><>=><=
```

```vystup
26
```
","# Dalo by sa?!

Našou úlohou bolo spočítať počet zrážok, ktoré nastanú. Vieme, že za zrážku sa ráta všetko, kde idúce auto narazí do niečoho. Vieme tiež, že všetky autá po zrážke ostanú stáť.

## Pomalé riešenie

Prvou možnosťou je pre každé auto, ktoré sa niektorým smerom hýbe (doprava alebo doľava) sa pozrieť, či má do čoho naraziť. Naraziť má do čoho vtedy, keď sa tým smerom, ktorým sa hýbe, nachádza auto, ktoré stojí, alebo smeruje opačne. Takže pre každé auto sa pozrieme, či má do čoho naraziť a spočítame tieto zrážky.

Pre každé auto (ktorých je $n$), pozrieme prinajhoršom všetky ostatné autá (ktorých je $n$), takže spolu urobíme $O(n^2)$ operácií.

Časová zložitosť je $O(n^2)$, a pamäťová $O(n)$, lebo okrem vstupného poľa si nič nemusíme pamätať.

## Vzorové riešenie

Je pomerne jasné, že ak auto, ktoré je na ľavej strane, smeruje doľava, tak do ničho nenarazí. Rovnako je to aj na pravej strane s autom, ktoré smeruje doprava. Môžeme si uvedomiť, že to ale neplatí len pre autá, ktoré sú úplne na kraji, ale aj pre všetky autá, ktoré sú naľavo (tým myslíme také, že naľavo od nich sú len autá, ktoré smerujú doľava), a smerujú doľava. Analogicky to platí aj pre autá, ktoré sú napravo. Napríklad, ak máme autá:

`<<<>=<>>`

Tak vieme povedať, že ľavé 3 autá a pravé 2 autá určite do ničoho nenarazia, iba pekne za sebou odídu preč.

To znamená, že nás nezaujíma súvislý úsek áut, ktoré sú naľavo a smerujú doľava, a súvislý úsek áut napravo, ktoré smerujú doprava.

Z nášho príkladu vyššie nás teda zaujímajú iba tieto autá:

`>=<`

Čo vieme povedať, o zrážkach, ktoré nastanú v tejto strednej časti?

Vieme, že každé auto, ktoré nestojí musí do niečoho naraziť. Prečo? Lebo jediná iná možnosť je, že by odišlo preč, a nikdy do ničoho nenarazilo, ale to sa nemôže stať, keďže také autá sú naľavo, a smerujú doľava, alebo napravo a smerujú doprava, a tie ignorujeme.

Vzorové riešenie teda najprv zistí, ktorý úsek áut nás presne zaujíma, teda zistí aký dlhý je úsek áut, ktoré sú naľavo a smerujú doľava. To isté urobí aj pre pravú stranu. Následne pre každé auto v strednej časti, ktoré nestojí, pripočíta $1$ k výslednému počtu zrážok, a vypíše tento výsledok.

Toto riešenie prejde celé pole práve raz, a teda jeho časová zložitosť je $O(n)$. Pamätať si stále musíme len celé pole, teda pamäťová zložitosť je tiež $O(n)$.

## Vzorovejšie riešenie (v konštantnej pamäti)

Existuje aj riešenie v konštantnej pamäti. Jeho kľúčovou myšlienkou je, že ak ideme po vstupom poli áut, tak vždy keď nájdeme auto, ktoré smeruje doľava (`<`), tak vieme, že všetky autá naľavo od neho, ktoré idú doprava do niečoho narazia. V prípade, že nájdeme auto, ktoré smeruje doprava, tak si iba musíme poznačiť, že sme ho niekde videli. No a v prípade, že nájdeme auto, ktoré stojí na mieste, tak vieme, že všetky autá, čo sme videli, a smerovali doprava tiež majú do čoho naraziť.
",1
57144852cbda096e,ksp,"# Idiomatický slovník

Kristína veľmi rada skúma mŕtve jazyky a už oddávna je vysoko postavenou členkou Klubu Starobylých Prekladateľov. Celý klub srší aktivitou, lebo archeológovia objavili na dne Atlantického oceánu ruiny Atlantídy a v nich perfektne zachované vodotesné zvitky. Všetkým členom klubu je jasné, že prvý, komu sa podarí preložiť atlančinu do moderných jazykov, získa obrovskú slávu a naveky sa zapíše do dejín nekrolingvistiky.

Od pochopenia významu textu je ešte ďaleko, ale Kristína si už všimla jedno kľúčové pozorovanie: vyzerá, že atlanťania píšu každé slovo dvakrát, raz odpredu a raz odzadu. Kto vie, či je to poistenie proti prípadnému poškodeniu zvitku, alebo to má v atlantickej kultúre nejaký iný dôvod...

Kristína by si chcela overiť, či je jej hypotéza naozaj správna. Lenže v atlančine sa medzi slovami nepíšu medzery, takže to nie je také ľahké skontrolovať.

## Úloha

Váš program dostane niekoľko reťazcov textu v atlančine. O každom reťazci musíte zistiť, či sa dá rozdeliť na slová tak, aby spĺňali Kristíninu hypotézu. Čiže po každom (nepárnom) slove musí nasledovať to isté slovo naopak.

## Formát vstupu

V prvom riadku vstupu je číslo $t$ udávajúce počet reťazcov.

Na každom z ďalších $t$ riadkoch je neprázdny reťazec zložený z malých a veľkých písmen anglickej abecedy. Malé a veľké písmená považujeme za rôzne.

Dĺžku najdlhšieho reťazca na vstupe si označme $n$. (Toto číslo je len na vysvetlenie a na vstupe sa nepíše.) V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------|-----:|-------:|-------:|-------:| | $1 \\leq t \\leq$ | $20$ | $20$ | $20$ | $20$ | | $1 \\leq n \\leq$ | $30$ | $10^3$ | $10^5$ | $10^6$ |

Navyše v sade 3 sú vstupy nejakým bližšie nešpecifikovaným spôsobom ľahšie.

## Formát výstupu

Vypíšte $t$ riadkov a na každom jedno číslo: $1$, ak sa ten reťazec nejako dá rozdeliť na slová požadovaným spôsobom, alebo $0$, ak nedá.

## Príklad

```vstup
6
rummur
deedee
aaaaaaa
kajak
abcxxyycba
mMmMmM
```

```vystup
1
1
0
0
0
0
```

*""rummur"" sa dá rozdeliť na ""rum mur"", a ""deedee"" na ""de ed e e"".*
","# Idiomatický slovník

Potrebujeme zistiť, či sa reťazec dá rozdeliť na niekoľko párne dlhých palindrómov. V tomto vzoráku budeme pod ""palindróm"" myslieť párne dlhý palindróm.

## Bruteforce

Spočítajme dvojrozmernú tabuľku, kde pre každú začiatočnú a konečnú pozíciu zistíme, či je daný podreťazec vstupného reťazca palindróm. Pre dvojznakové podreťazce je to ľahké, stačí tie dva znaky porovnať. Dlhší podreťazec je palindróm vtedy, keď sa jeho prvý a posledný znak rovnajú, a všetko medzi nimi je tiež palindróm (zistíme z tabuľky). Tabuľku môžeme vypĺňať napríklad v poradí vzostupne podľa dĺžky podreťazca, alebo zostupne podľa začiatočnej pozície, aby sme vždy čítali len z buniek čo už sme naplnili.

Potom už len treba zistiť, či v reťazci vieme cez palindrómy preskákať zo začiatku na koniec. Keď prídeme na nové miesto, pozrieme sa aké palindrómy tam začínajú a na aké ďalšie miesta vďaka tomu dokážeme skočiť. Zo stringologického pohľadu sa pýtame o každom prefixe vstupného reťazca, či je dobrý (nakrájateľný na palindrómy). Z grafového pohľadu hľadáme či existuje cesta v topologicky zoradenom grafe, ktorého vrcholy sú pozície v reťazci ($0$ až $n$) a hrany sú palindrómy.

Toto riešenie má časovú aj pamäťovú zložitosť $O(n^2)$.

## Trochu lepší bruteforce

Ak máme šťastie a vo vstupe je len málo palindrómových podreťazcov, počítať a pamätať si celú $(n+1)\\times (n+1)$ tabuľku je trochu mrhanie. Radšej si pamätajme pre každú pozíciu iba zoznam palindrómov, čo na nej začínajú. Grafovo povedané, namiesto matice susednosti si pamätajme zoznamy susednosti každého vrcholu. Spočítame ich tak, že pre každú možnú stredovú pozíciu rozširujeme palindróm doľava aj doprava, až kým nenarazíme na dva rôzne znaky alebo na kraj vstupu.

Dalo by sa povedať, že toto riešenie má časovú aj pamäťovú zložitosť $O(n+p)$, kde $p$ je počet palindrómových podreťazcov. Ale to samozrejme stále môže byť priveľa. Napríklad pre vstup zložený iba z $n$ áčiek je $p=O(n^2)$.

## Ide to pažravo

V skutočnosti platí, že môžeme vždy pažravo (greedy) spredu reťazca odkrojiť najkratší možný palindrómový prefix. Grafovo povedané, môžeme kľudne skákať po najkratšej hrane a nič si tým nepokazíme, nedostaneme sa do žiadnej slepej uličky. Stringologicky povedané, ak z dobrého reťazca (takého čo sa dá nakrájať na palindrómy) odrežeme najkratší palindrómový prefix, aj ten zvyšok bude dobrý reťazec.

Dokážeme to takto. Ukážeme, že ak existuje akékoľvek riešenie, ktoré by náš greedy algoritmus nevyplodil, tak existuje aj krajšie riešenie, ktoré sa od výstupu nášho algoritmu líši trošku menej. Opakovaním tohto procesu dôjdeme k riešeniu, čo sa od výstupu nášho algoritmu nelíši vôbec.

Poďme na vec. Majme nejaké riešenie (nejaké korektné rozdelenie celého reťazca na palindrómy). Možno už začína $k$ najkratšími palindrómami (t.j. takými čo by na svojej pozícii vybral aj greedy algoritmus), ale tie nás nezaujímajú. Pozrime sa na prvé miesto, kde sa nezhodnú: najkratší vybrateľný palindróm je $xx^{-1}$, ale zvolené riešenie si namiesto toho vybralo odrezať nejaký dlhší palindróm $yy^{-1}$. (Reťazec $x$ je prvá polovica a $x^{-1}$ znamená opak $x$.)

Rozoberme dve možnosti:

- $y$ je relatívne dlhý ($|y|\\geq 2|x|$). Keďže $yy^{-1}$ sa na vstupe prekrýva s $xx^{-1}$, $xx^{-1}$ musí byť prefixom $y$. Zapíšme ho ako $y = xx^{-1}z$ s nejakým (možno prázdnym) zvyškom $z$. Tým pádom $yy^{-1} = xx^{-1}zz^{-1}xx^{-1}$. Super, to sú tri palindrómy. Môžeme z obidvoch koncov $yy^{-1}$ odrezať $xx^{-1}$ a text medzi nimi bude tiež palindróm. Riešenie, čo takto dostaneme, už začína na nie $k$ ale aspoň $k+1$ najkratších palindrómov. O krok sme sa priblížili ku greedy algoritmu.

- $y$ je relatívne krátky ($|x|\<|y|\<2|x|$). Rozdeľme $x$ na dve neprázdne časti $p, q$ na tom mieste, kde končí $y$. Nech $x=pq$ kde $q$ má $|y|-|x|$ znakov. Potom $xx^{-1} = pqq^{-1}p^{-1}$, $y = pqq^{-1}$, $yy^{-1} = pqq^{-1}qq^{-1}p^{-1}$. Z polohy na vstupe vieme, že $xx^{-1}$ je prefixom $yy^{-1}$, preto (po dosadení) $pqq^{-1}p^{-1}$ je prefixom $pqq^{-1}qq^{-1}p^{-1}$, preto (po škrtnutí $pqq^{-1}$) $p^{-1}$ je prefixom $qq^{-1}p^{-1}$. Tak ho napíšme ako $qq^{-1}p^{-1} = p^{-1}z$ pre nejaký neprázdny zvyšok $z$. Lenže tým pádom môžeme dosadiť $xx^{-1} = pp^{-1}z$, čo je spor s pôvodným predpokladom, že $xx^{-1}$ je na tomto mieste najkratší vybrateľný palindróm. Takže tento prípad nemôže nastať.

Pre úplnosť, podobne sa dá dokázať, že môžeme odkrojiť úplne ktorýkoľvek palindróm. Je to úplne jedno -- žiaden rez nevyrobí z dobrého reťazca zlý. Ale toto v našom riešení nebudeme potrebovať, nám sa hodia krátke palindrómy.

## Hashovanie

Plán je jasný: náš program prejde celým vstupom a vždy keď si všimne, že od pozície predošlého rezania po aktuálnu pozíciu je to palindróm, odkrojí ho.

Ako môžeme rýchlo zistiť o ľubovoľnom podreťazci, či je to palindróm? Použijeme hashovanie. Hashovanie sa bežne používa, keď chceme rýchlo testovať rovnosť dvoch podreťazcov, ale test palindromicity je vlastne iba test rovnosti vhodného podreťazca pôvodného vstupu a vhodného podreťazca obráteného vstupu.

Hashovacie funkcie prevádzajú reťazce na čísla a správajú sa pomerne chaoticky. Ak sa dva reťazce rovnajú, samozrejme budú mať aj rovnaký hash. Ak sa nerovnajú, pomerne pravdepodobne budú mať rôzny hash. Takže pri porovnávaní dvoch reťazcov sa oplatí najprv porovnať ich hashe. Ak sú rôzne, ušetrili sme si kopu práce. Ak sú rovnaké, môžeme si dať tú námahu porovnať ich znak po znaku (so šťastím ani netreba).

Vyberme si nejaké pekné prvočíslo $p$ (napríklad $10^9+9$) a nejakú peknú konštantu $a$ (napríklad $47$; niektorí machri používajú v každom vstupe iné náhodné číslo). Definujme *polynomiálny rolling hash* reťazca $S = c_1c_2\\ldots c_n$ ako súčet $H(S) = (c_1a^1 + c_2a^2 + \\ldots + c_na^n) \\bmod p$.

Táto definícia má všelijaké pekné vlastnosti. Môžeme si zapamätať nielen finálny výsledok, ale aj medzisúčty pre každý prefix nášho reťazca. Vďaka nim budeme vedieť počítať aj hash ľubovoľného podreťazca: $H(S[x..y]) = (H(S[0..y]) - H(S[0..x])) / a^x$. Pozor, že odčítanie a delenie tiež robíme modulo $p$.

Delenie modulo $p$ sa dá robiť tak, že nájdeme inverzné prvky pomocou modulárneho umocňovania a malej Fermatovej vety. Ale to v tejto úlohe vôbec netreba. Stačí si všimnúť, že nás vždy zaujímajú iba porovnania tvaru $e / a^f \\equiv g / a^h \\pmod{p}$, čo sa dá upraviť na $e \\cdot a^h \\equiv g \\cdot a^f \\pmod{p}$, čím sa delenia úplne zbavíme.

Greedy algoritmus s hashovaním má priemernú časovú aj pamäťovú zložitosť $O(n)$.
",8
50565dcc6a1d71d3,ksp,"# Aminokyseliny

Šandyna je šikovná bioinformatička a vo svojej práci často manipuluje RNA a DNA rôznych vírusov. Naposledy potrebovala izolovať sekvenciu istého Krutého Sveta-Paralyzujúceho vírusu. Žiaľ, pri pokuse sa jej to nepodarilo, miesto toho len izolovala $n$ úsekov aminokyselín a nie presnú sekvenciu ktúru by potrebovala. Ale ešte nič nie je stratené! V laboratóriu biologickými čarami vie Šandyna spájať sekvencie, aby dostala RNA vírusu. Ale to nie je len tak, spájať genetické sekvencie. Niektoré sa pripájajú ťažšie než iné. Potrebuje preto zistiť ako ich čo najľahšie spojiť do chceného RNA. Pomôžte jej!

## Úloha

Šandyna má reťazec $T$, RNA vírusu ktorý chce zostaviť. Tiež už má $n$ rôznych úsekov genetického kódu. Genetický kód si vieme zapísať ako reťazec malých písmen anglickej abecedy. Šandyna má tiež vzorky nukleidov reprezentovaných každým písmenom. Šandyna začína s prázdnou sekvenciou a tú výslednú by chcela zostrojiť pomocou týchto štyroch postupov:

- Na začiatok aktálnej sekvencie prilepí jeden nukleid (písmenko). Prilepenie nukleidu $c$ má cenu $cl_c \\cdot |S|$ .

- Na koniec aktuálnej sekvencie prilepí jeden nukleid (písmenko). Prilepenie nukleidu $c$ má cenu $cr_c \\cdot |S|$

- Na začiatok aktuálnej sekvencie prilepí genetickú sekvenciu číslo $i$ ($1 \\leq i \\leq n$). Prilepenie sekvencie má cenu $kl_i \\cdot |S|$

- Na koniec aktuálnej sekvencie prilepí genetickú sekvenciu číslo $i$ ($1 \\leq i \\leq n$). Prilepenie sekvencie má cenu $kr_i \\cdot |S|$

Kde $|S|$ je dĺžka aktuálnej sekvecie. Všimnime si, že pridať prvý nukleid/sekvenciu je vždy zadarmo.

Šandyna nevie vytvárať paralelne viac sekvencíí a potom ich prilepiť k sebe. Ako najlacnejšie môže vytvoriť správny genetický kód?

## Formát vstupu

Na prvom riadku je číslo $n$ - počet predom izolovaných sekvencií.

Na ďalších $n$ riadkoch sú tieto sekvencie, $p_1$ až $p_n$, reprezentované ako reťazce malej anglickej abecedy.

Na ďalšom riadku je $26$ medzerami oddelených cien pripojenia jediného nukleidu na začiatok: $cl_a$, až $cl_z$.

Na ďalšom riadku je $26$ medzerami oddelených cien pripojenia jediného nukleidu na koniec: $cr_a$, až $cr_z$.

Na ďalšom riadku je $n$ medzerami oddelených cien pripojenia genetických sekvencií na začiatok: $kl_1$, až $kl_n$

Na ďalšom riadku je $n$ medzerami oddelených cien pripojenia genetických sekvencií na koniec: $kr_1$, až $kr_n$

A na poslednom riadku je reťazec $T$ - genetická sekvencia ktorú Šandyna chce vytvoriť.

## Formát výstupu

Vypíšte jediný riadok: najmenšiu cenu za ktorú vie Šandyna sekvenciu vytvoriť.

## Hodnotenie

Vo všetkých vstupoch platia nasledovné limity:

- $1 \\leq |T| \\leq 1,000$

- $0 \\leq n \\leq 100,000$

- Všetky počiatočne izolované genetické sekvencie $p_i$ majú dĺžku najviac $100$.

- Všetky ceny sú medzi $1$ a $10^9$

- Všetky reťazce obsahujú iba malé písmená anglickej abecedy

Sú $4$ testovacie sady. V nich navyše platia nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:------------------------ |----: | ---: | ----: | --------: | | $n \\leq$ | $0$ | $10$ | $10,000$ | $100,000$ |

V sade $2$ navyše platí $|p_i| \\leq 10$.

## Príklady

```vstup
0
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
10 1 1 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26


abaca
```

```vystup
15
```

_Najlepšie je budovať sekvenciu odzadu. Cena je tak $0 + 3\\cdot 1 + 1\\cdot 2 + 2 \\cdot 3 + 1 \\cdot 4 = 15$_

```vstup
3
aba
ba
xy
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
3 2 1 3 5 9 10 11 11 9 9 8 7 6 5 1 33 22 11 90 1 1 2 3 5 8
1 2 3
1 1 1
abacaba
```

```vystup
5
```

_Šandyna by mala začať s nukleidom $c$. Potom za cenu $1\\cdot 1 = 1$ by mala pripojiť sekvenciu 'aba' na začiatok a napokon tú istú sekvenciu aj na koniec (za cenu $1\\cdot 4 = 4$, keďže sekvencia po druhom kroku bola 'abac'. Celková cena je teda $5$._
","# Aminokyseliny

## Stavanie z jednotlivých nukleidov

V prvej sade za dva body máme iba nukleidy ($n=0$) a tak nemusíme implementovť žiadny algoritmus na vyhľadávania podreťazcov. Stačí nám jednoduché dynamické programovanie: pre každý (súvislý) podreťazec si spočítame aká je minimálna cena za ktorý ho vieme dostať.

Cenu pre podreťazec začínajúci na pozícii $i$ a končiaci na pozícii $j$ ($i < j$) získame iba tak, že sme na začiatok, alebo na koniec prilepili nukleid. Vyskúšame obe možnosti, a keď podreťazce spravcovávame od najkratších, tak získame takto riešenie v čase aj pamäti $O(|T|^2)$.

## Krátke sekvencie

V druhej sade už máme nejaké sekvencie, ale je ich málo a sú krátke. Vieme teda rýchlo zistiť, či na nejakú pozíciu sekvencia pasuje. Môžeme upraviť dynamické programovanie pre prvú sadu: okrem pozretia sa na reťazce o prvé/posledné písmenko kratšie, si pre všetkých $n$ sekvencií pozrieme, či mohol podreťazec vzniknúť pridaním sekvencie na koniec/začiatok. Toto nám pre každý podreťazec zaberie $O(n \\cdot \\max |p_i|)$, čo bohato stačí na získanie ďalších dvoch bodov v druhej sade.

## Lepšie riešenie

Prvé dve sady vyžadovali nie až tak trikové dynamické programovanie. Pre posledné dve sady je však pomalé a musíme ho zlepšiť.

Algoritmus nám spomaľujú dva hlavné faktory:

Po prvé, naivné hľadanie, či vieme sekvenciu pridať, alebo nie, je príliš pomalé. Aj keby sme si to pre každú pozíciu predpočítali, bolo by to $O(n|T|\\max |p_i|)$ operácií, čo je priveľa. Vedeli by sme to zlepšiť algoritmom [KMP](https://www.ksp.sk/kucharka/kmp/), takto dostaneme zložitosť $O(n(|T| + \\max |p_i|))$.

Druhý problém nastáva s dynamickým programovaním: reťazcov je príliš veľa, takže skúšať pre každý podreťazec všetkých $n$ je pomalé. Pomôže nám nasledovné uvedomenie: sekvencie nie sú veľmi dlhé. Každý podreťazec môže vzniknúť buď pridaním jedného písmenka na koniec/začiatok, alebo prilepením sekvencie s dĺžkou od 1 do 100 (také sú limity na dĺžky sekvencií). Pre každú pozíciu si dostatočne rýchlym algoritmom vypočítame pre každú dĺžku, či existuje sekvencia, ktorá sedí a aká je najlacnejšia sekvencia pre pridanie zo začiatku/konca. Pre každý podreťazec (od najkratších, cenu nulových vieme) si spočítame najmenšiu cenu, za ktorú ho vieme dostať. Následne spočítame cenu pre dlhšie reťazce pridávaním po písmenku/sekvencie na koniec/začiatok. Pre každý podreťazec takto skúsime najviac $2 + \\max |p_i|$ pridaní, takže časová zložitosť dynamického programovanie je $O(|T|^2 \\max |p_i|)$.

S predpočítaním dostaneme časovú zložitosť $O(|T|^2 \\max |p_i| + n(|T| + \\max |p_i|))$ a pamäťovú zložitosť $O(\\sum p_i + |T|^2 + |T|\\max |p_i|)$, čo stačí na šesť bodov.

## Vzorové riešenie

Aj posledné riešenie, ktoré sme tu doteraz videli, je príliš pomalé pre $n$ okolo stotisíc. Konkrétne, pomalé je hľadanie všetkých výskytov sekvencíí v reťazci $T$. Našťastie existuje zovšeobecnenie KMP pre vyhľadávanie viac podreťazcov, a to sa volá Aho-Corasick. (Tutoriál napríklad [tu](https://codeforces.com/blog/entry/14854))

Tento algoritmus už nájde všetky výskyty v čase $O(|T| + \\sum p_i)$ a keď ním nahradíme $n$ volaní KMP, dostaneme vzorové riešenie za osem bodov.

## Iné riešenie

Existujú riešenia založené na hešovaní. Keďže sekvencie sú krátke, pre každú dĺžku si vieme pamätať samostaný set s hešmi. Následne to, či existuje reťazec dĺžky $l$, ktorý končí na pozícii $i$, si vieme zistiť spočítaním vhodného rolling hashu a nazretím do setu.

Toto riešenie tiež vie získať osem bodov. Dôvod, prečo je ako vzorové uvedený Aho-Corasick, je len ten, že na hash ide teoreticky nájsť vstup, na ktorom bude veľa kolízií a tak nepôjde/bude pomalé.
",10
460d422db4e9381c,ksp,"# Kreslenie stromov

""Let's make some happy little trees,"" povedal Bob Ross[^1] a začal kresliť stromy na plátno. Inšpirovaná týmto známym umelcom, zobrala Paulínka svoje obľúbené voskovky a začala kresliť stromy na papier.

Paulínka rada kreslí zakorenené informatické stromy, a aby bol výsledný obrázok čo najkrajší, musia byť všetky stromy rôzne a zároveň musia všetky pochádzať z rovnakého materského stromu. (Potom môže obdivovateľom umenia hovoriť, že stromy majú spoločnú dušu.) V časti _úloha_ hneď vysvetlíme, čo to znamená.

Pomôžte Paulínke zistiť, koľko najviac stromov, môže nakresliť, aby splnila želané podmienky. A nezabudnite, keby sa vám to aj na prvý pokus nepodarilo, Bob Ross má pre vás jednu múdrosť: ""We don't make mistakes, we have happy accidents.""

\[^1\]: Príklad Bobovej tvorby nájdete na [youtu.be/0n4f-VDjOBE](https://youtu.be/0n4f-VDjOBE).

## Úloha

_Informatický strom_ (ďalej len _strom_) je množina $n$ vrcholov a $n-1$ hrán, taká, že z každého vrcholu do každého vedie práve jedna cesta. _Zakorenený informatický strom_ (ďalej len _zakorenený strom_) je strom, v ktorom sme jeden vrchol vybrali ako koreň.

Zo stromu vieme vytvoriť $n$ zakorenených stromov tak, že postupne označíme každý z $n$ vrcholov ako koreň (viď obrázok pri prvom príklade vstupu).

Pre tieto zakorenené stromy si zavedieme nový pojem, _rovnakosť_, ku ktorému opačný pojem je _rôznosť_. Zakorenené stromy budeme volať _rovnaké_, keď sa líšia len v označení vrcholov a v poradí synov každého vrcholu. T.j. pokiaľ dovolíme ľubovoľne prehadzovať poradie synov, vieme pretvoriť jeden strom na druhý. Pokiaľ sa takto nedajú pretvoriť, tak uvažujeme, že sú stromy _rôzne_.

Formálna definícia by mohla byť nasledovná: Dva zakorenené stromy voláme _rovnaké_, ak existuje bijektívne zobrazenie^[každému vrcholu prvého stromu je priradený práve jeden vrchol z druhého stromu] $f$ vrcholov jedného stromu na vrcholy druhého stromu, také že pre všetky $x,y$ platí, že $x$ je otec $y$ práve vtedy, keď $f(x)$ je otec $f(y)$.

Na obrázkoch môžeme vidieť príklady troch stromov, z ktorých prvé dva sú _rovnaké_ a tretí je od oboch _rôzny_. Zobrazenie, ktoré spĺňa formálnu definíciu je $1,2,3,4,5,6,7,8 \\rightarrow 8,7,6,5,4,1,2,3$, ale aj $1,2,3,4,5,6,7,8 \\rightarrow 8,7,6,5,4,3,2,1$

Na vstupe máte zadaný strom. Vypíšte koľko najviac navzájom _rôznych_ zakorenených stromov môžeme dostať označením niektorého vrcholu tohto stromu ako koreň.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ -- počet vrcholov zadaného stromu. Vrcholy sú očíslované $1$ až $n$.

Na nasledujúcich $n-1$ riadkoch su vymenované hrany zadaného stromu, na každom riadku sú čísla dvoch vrcholov, $a_i, b_i$, ktoré táto hrana spája. $1\\leq a_i, b_i \\leq n$

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet _rôznych_ zakorenených stromov, ktoré dostaneme, ak postupne každý z vrcholov označíme ako koreň.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:--------------- | --: | --: | --: | --: | --: | --: | --: | --: | | $2 \\leq n \\leq$ | $10$ | $100$ | $100$ | $1,000$ | $1,000$ | $50,000$ | $100,000$ | $300,000$ |

## Príklady

```vstup
4
1 2
2 3
3 4
```

```vystup
2
```

_Ak strom zakoreníme za prvý alebo posledný vrchol, dostaneme rovnaký strom. Podobne dostaneme rovnaké stromy, ak ho zakoreníme za druhý alebo tretí. Vieme teda nakresliť dva rôzne zakorenené stromy._

_Na obrázku nižšie môžeme vidieť, aké stromy dostaneme, pokiaľ zakoreníme vstupný strom postupne vo vrcholoch $1, 2, 3, 4$_

```vstup
11
1 2
2 3
3 4
4 5
4 6
4 7
5 10
10 9
10 8
7 11
```

```vystup
10
```

```vstup
7
7 1
7 2
3 2
7 4
5 4
6 5
```

```vystup
7
```
","# Kreslenie stromov

To, čo sme v zadaní volali _rovnakosť_ sa v informatike zvykne nazývať _izomorfizmus_. Ďalej teda budeme hovoriť, že dva zakorenené stromy sú **_izomorfné_**, ak existuje bijektívne zobrazenie $f$ vrcholov jedného stromu na vrcholy druhého stromu, také že pre všetky $x,y$ platí, že $x$ je otec $y$ práve vtedy, keď $f(x)$ je otec $f(y)$. (Toto je rovnaká definícia ako v zadaní, len na pripomenutie.)

Intuitívna predstava izomorfizmu je, že zodpovedajúce vrcholy sa môžu líšiť len v poradí synov. Toto je dôležité mať na pamäti.

Mimochodom, keď máme zakorenený strom za koreň $v$, tak stromy, ktorých korene sú synovia $v$, budeme volať podstromy tohto stromu, alebo podstromy koreňa, alebo podobne. Občas budeme zamieňať pojmy podstrom a vrchol, väčšinou by malo byť jasné, že ide o tú istú vec. Ak napríklad označíme vrchol $u$ nejakým číslom, tak toto číslo obvykle hovorí niečo o celom podstrome.

## Obsah

Riešenie si rozdelíme na niekoľko častí:

V prvej časti sa pozrieme na to, ako algoritmicky spočítať, či ľubovoľné dva stromy sú izomorfné. Ukážeme si tri spôsoby, jeden z nich ilustruje podstatu zvyšných dvoch spôsobov, avšak je pomalý. Zvyšné dva implementujú túto podstatu efektívne, či už pomocou hashovania alebo pomocou iných techník. Obe rýchlejšie riešenia budú vedieť porovnať dva stromy v čase $O(n)$, hoci v jednom prípade si podrobne rozoberieme iba jednoduchšiu $O(n \\log n)$ variantu.

V druhej časti sa pozrieme, ako zovšeobecniť algoritmus z dvoch stromov na izomorfizmus $n$ stromov, a následne ako pomocou toho vyriešiť samotnú úlohu v celkovom čase $O(n)$ resp. $O(n\\log n)$.

Na plný počet bodov za popis úlohy stačí časová zložitosť $O(n\\log n)$ a zároveň žiaden riešiteľ neodovzdal popis deterministického riešenia so zložitosťou $O(n)$, takže nebudú ani bonusové body ;)

## Izomorfizmus dvoch stromov -- naivné riešenie

Stromy porovnávať zatiaľ nevieme, ale napríklad také reťazce znakov vieme porovnávať celkom dobre. Čo keby sme každý strom zapísali ako reťazec znakov? Celkom štandardný zápis zakoreného stromu je: _ľavá zátvorka, zreťazené zápisy všetkých podstromov koreňa, pravá zátvorka_.

Napríklad jednovrcholový strom, má zápis ""()"", trojvrcholový binárny strom má zápis ""(()())"", reťaz vysoká 3 má zápis ""((()))"". Na obrázku môžete vidieť pri každom vrchole zápis zodpovedajúceho podstromu.

Žiaľbohu a niekedy aj chvalabohu, izomorfné stromy môžu mať rôzny zápis, lebo v tomto zápise záleží na poradí podstromov. Tento problém však ľahko vyriešime, nasledovnou zmenou. Nový zápis zakoreneného stromu bude: _ľavá zátvorka, zretazené **abecedne zoradené** zápisy všetkých podstromov koreňa, pravá zátvorka_.

Dôkaz, že s touto definíciou, dva stromy majú rovnaký zápis práve vtedy, keď sú izomorfné, necháme ako cvičenie pre čitateľa. Na obrázku môžeme vidieť príklad pre dva izomorfné stromy.

Skonštruovať zápis celého stromu nám môže v najhoršom prípade (dlhá reťaz) trvať až $O(n^2)$. Porovnať dva zápisy a tým overiť izomorfizmus stromov potom vieme už v lineárnom čase.

## Izomorfizmus dvoch stromov -- hashovanie

Celý problém predošlého algoritmu je, že zápis stromu je potenciálne veľmi dlhý reťazec. Čo keby sme dokázali celý strom zapísať ako jedno číslo? Na základe predošlej úvahy by toto číslo malo byť rekurzívne definované cez podstromy a zároveň nezávislé od poradia podstromov.

Ako riešenie sa nám ponúka nasledovná hashovacia funkcia. Hash stromu $T$ bude $$H_T = chaos(S \\mod M) = chaos\\left(\\left(\\sum\_{t\\in P(T)} H_t\\right) \\mod M\\right)$$

kde $P(T)$ je zoznam podstromov stromu $T$, resp. $S$ je súčet hashov podstromov stromu $T$. $M$ je nejaké prvočíslo, ktorým modulujeme, aby nám udržala rozumná veľkosť čísel. $chaos$ je funkcia, ktorá pre každý vstup z ${0..M}$ vráti iný náhodný výstup z ${0..M}$.

Čo prosím? (Sa právom pýtate). V prvom rade súčet hashov podstromov je jednoduchý spôsob, ako zabezpečiť, aby nezáležalo na poradí podstromov. Potom ale potrebujeme, aby sa hashovacia funkcia nesprávala lineárne (t.j. zväčšenie nejakého zo vstupov o $x$ zväčší výstup o $kx$), lebo to by sa nám ľahko stalo, že presun jedného vrchola z jedného podstromu do iného by nemuselo zmeniť hash (na jednom mieste $+kx$, na inom $-kx$, výsledok rovnaký), hoci by zmenilo izomorfizmus. A čo sa správa menej lineárne ako random?

Funkciu chaos môžeme implementovať lazy spôsobom -- keď nám príde nový vstup, aký sme ešte nevideli, vygenerujeme si nový náhodný výstup a zapamätáme si ho. Ak nám príde vstup, aký už sme niekedy videli, vrátime zapamätanú hodnotu. Buď si môžeme dávať explicitne pozor, aby sme vždy vygenerovali iný výstup, alebo pokiaľ $M >> n^2$, je pomerne malá šanca, že by nastala kolízia.

S touto hashovacou funkciou, dva izomorfné stromy majú vždy rovnaký hash, a dva neizomorfné stromy majú s veľkou pravdepodobnosťou rôzny hash. Stále môže nastať neželaná kolízia, ale tak to pri hashovacích algoritmoch často býva a tak v princípe iba nastavíme dostatočne veľké $M$ a dúfame, že to bude fungovať.

Spočítať hash celého podstromu dokážeme rekurzívne v čase $O(n)$

## Izomorfizmus dvoch stromov -- labely a AHU

Ak sa nechceme spoliehať na náhodu, môžeme skúsiť nájsť iný spôsob, ako každému stromu priradiť jedno číslo, nazvime ho label (čítaj lejbl).

Pre spočítanie labelu stromu najprv rekurzívne spočítame labely všetkých podstromov, a zoberieme utriedený zoznam týchto labelov. Napríklad, pre list stromu (ktorý nemá žiadnych potomkov) dostaneme prázdny zoznam []. Ak má koreň stromu 5 synov s labelami 2,11,4,2,4, dostaneme zoznam [2,2,4,4,11].

Vždy, keď dostaneme takto utriedený zoznam, buď vidíme takýto zoznam prvýkrát a pridelíme mu najmenšie nepoužité prirodzené číslo ako label, alebo sme už zoznam videli a tak použijeme rovnaký label ako naposledy. Tu je príklad ako by vyzerali labely pre ukážkový strom a jeho podstromy. (Labely číslujeme od nuly).

Ako vieme efektívne priraďovať, labely zoznamom? Napríklad pomocou mapy (vyvažovaný binárny strom), kde zoznam bude kľúč a label bude hodnota. Na utriedenie zoznamu labelov podstromov a tiež vyhľadanie zoznamu v mape potrebujeme čas $O(p \\log p)$, kde $p$ je dĺžka zoznamu, resp. počet potomkov vrchola. Keďže súčet počtu potomkov pre všetky vrcholy stromu je $n-1$, celkový čas je $O(n \\log n)$.

Veľmi podobne funguje AHU algoritmus (Aho, Hopcroft and Ullman), čo je štandardný a asi najznámejší algoritmus na overenie izomorfizmu dvoch stromov. Tento algoritmus používa fakt, že dva stromy môžu byť izomorfné, iba ak majú rovnakú hĺbku (môžete si nechať chvíľku na zamyslenie, prečo je to tak). Potom izomorfizmus overujeme iba pre stromy s rovnakou hĺbkou, nech je to $h$. Najprv spočítame labely pre vrcholy v hĺbke $h$, potom pre vrcholy v hĺbke $h-1$, atď. až po koreň. Na jednej úrovni vždy najprv spočítame všetky zoznamy a potom im naraz priradíme labely postupne od nuly. V AHU algoritme, môžeme použiť v rôznych hĺbkach ten istý label.

Vďaka tomu, že labely počítame po vrstvách, môžeme naraz skonštruovať v čase $O(p)$, kde $p$ je počet vrcholov vo vrstve. Celý algoritmus potom beží v čase $O(n)$. Detaily sú nad rámec tohto vzoráku ale aspoň stručné zhrnutie je, že lexikograficky triedime samotné utriedené sekvencie labelov pomocou zovšeobecného radix-sortu pre rôzne dĺžky sekvencií a potom priradíme nové labely podľa tohto poradia. Jednotlivé sekvencie nemusíme triediť, lebo ich už konštruujeme v utriedenom poradí, a to tak, že spracúvame synov vrcholov na vyššej vrstve od najmenších labelov po najväčšie.

Ak vás to zaujíma a viete po anglicky, celý algoritmus na overenie izomorfizmu dvoch stromov je popísaný v knižke [The Design and Analysis of Computer Algorithms z roku 1974](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/The%20Design%20and%20Analysis%20of%20Computer%20Algorithms%20%5BAho,%20Hopcroft%20&%20Ullman%201974-01-11%5D.pdf), strana 84-85, example 3.2.

## Izomorfizmus $n$ stromov.

Ak máme $n$ zakorenených stromov a každý z nich má $n$ vrcholov, môžeme pomocou predošlých algoritmov spočítať zápis, hash, alebo label každého z nich, a potom overiť, koľko rôznych zápisov, hashov, resp. labelov vidíme. Toto vieme spraviť v čase $O(n^3)$ resp. $O(n^2)$, pretože zápis, hash, resp. label každého so stromov vieme spočítať v čase $O(n^2)$ resp. $O(n)$.

Riešenie, založené na tomto princípe, pokiaľ ako základ algoritmu použijeme hashovanie by mohlo vyzerať takto:

Posledné dve časti vzoráku sa budú zaoberať tým, ako to spraviť rýchlejšie.

## Vzorové riešenie -- hashovaie

Máme teda nezakorenený strom a chceme vedieť, aký hash by mali všetky jeho zakorenené verzie. Označme si hash vrcholu $u$ v strome zakorenenom za vrchol $v$ ako $H_v(u)$. Označme si tiež súčet hashov potomkov vrchola $u$ v strome zakorenenom za vrchol $v$ ako $S_v(u)$. Ak si ešte pamätáme definíciu našej hash funkcie, tak

$$H_v(u) = chaos(S_v(u))$$

Zakoreňme si náš strom najprv za vrchol 1 a spočítajme všetky hashe s týmto koreňom, čiže $H_1(v)$ pre všetky $v$.

Následne pre vyriešenie úlohy nám stačí vedieť $H_v(v)$ pre všetky $v$, a to vieme spočítať pomerne jednoducho. Vačsinu informácie potrebnú na spočítanie už máme. Pokiaľ $u$ je predok $v$ (v strome zakorenenom za vrchol 1) a $w_1..w_k$ sú potomkovia vrchola $u$ okrem $v$, tak platí, že

$$H_1(w_i) = H_v(w_i)$$

pre všetky $i\\in {1..k}$. Je to kvôli tomu, že podstromy pod $w_i$ neobsahujú ani vrchol $v$ ani vrchol $1$, a teda je ich podoba rovnaká pri zakorenení či už za $v$ alebo za $1$.

Zároveň z definície našej hash funkcie vieme, že:

$$H_1(u) = chaos(S_1(u)) = chaos\\left(H_1(v) + \\sum\_{i=1}^k{H_1(w_i)}\\right)$$

$$H_v(u) = chaos(S_v(u)) = chaos\\left(\\sum\_{i=1}^k{H_1(w_i)}\\right) = chaos(S_1(u) - H_1(v))$$

$$H_v(v) = chaos(S_1(v)+H_v(u)) = chaos\\left(S_1(v)+chaos(S_1(u)-H_1(v))\\right) $$

Na ľavej strane je to, čo chceme vedieť a na pravej sú informácie spočítané v strome zakorenenom za prvý vrchol. Implementácia sú dve po sebe spustené rekurzívne prehľadania stromu (`dfs_1` a `dfs_2`). Časová zložitosť je $O(n)$, pamäťová tiež $O(n)$

## Vzorové riešenie -- labely a AHU

Našim cieľom je efektívne všetkým $n$ zakoreneným stromom, a všetkým vrcholom (tieto zodpovedajú menším stromom pod vrcholmi) v nich priradiť labely (čísla) také, že dva stromy majú rovnaké číslo práve vtedy, keď sú izomorfné.

Podobne ako v predošlej časti, label vrcholu $u$, pokiaľ je celý strom zakorenený za $v$, budeme volať $L_v(u)$.

Zdalo by sa, že takto musíme skonštruovať potenciálne $n^2$ labelov, ale v skutočností môže existovať najviac $3n$ rôznych labelov, resp. stromov. Jeden label má každý vrchol ak je koreňom a najviac jeden ďalší label za každého suseda (ak by daný sused bol otcom vrchola). Dokopy majú všetky vrcholy v strome $2n-2$ susedov. Vôbec nás ale nezaujíma, aké labely by dostali nejaké úplne iné stromy, mimo týchto $3n$ stromov, a to nám dá trocha slobody.

Vo vzorovom riešení s hashovaním, sme v podstate riešili problém, že na spočítanie labelu vrcholu $v$ potrebujeme spočítať label vrcholu $u$ a naopak, ale obišli sme to dvoma dfs prechodmi a odčítavaním hashov. Iný spôsob je skúsiť nájsť nejaký jedinečný vrchol $v$ taký, že strom zakorenený vo $v$, nie je izomorfný so žiadnym iným stromom. Takýmto jedinečným vrcholom je centrum stomu, ktoré si hneď vysvetlíme.

Priemer stromu je vzdialenosť najvzdialenejších vrcholov v strome, resp. dĺžka najdlhšej cesty v strome. Na chvíľu ignorujme stromy s priemerom nepárnej dĺžky, neskôr sa k nim vrátime. Ak je priemer stromu párny, tak existuje takzvané centrum, čo je stred najdlhšej cesty. Aj keď najdlhších ciest môže byť viac, centrum je vždy jednoznačné (zamyslite sa prečo). Označme si centrum nášho stromu $c$.

Ak zakoreníme strom za centrum, dostaneme najplytšie možné zakorenenie a navyše strom zakorenený za vrchol $v$ má hĺbku rovnú vzdialenosti $v$ od $c$ plus hĺbka pri zakorenení za $c$. Z tohto vyplýva zaujímavá vec -- ak majú byť dve zakorenenia stromu izomorfné, musia byť ich korene rovnako vzdialené od centra.

Druhá, dôležitejšia, vec je, že strom zakorenený za centrum nie je izomorfný so žiadnym iným stromom. $L_c(c) \\neq L_v(u)$ pre žiadne $(v, u) \\neq (c, c)$. Pre $v=u$ nesedí hĺbka a pre ostatné nesedí počet vrcholov. Dokonca, ak aj strom zakoreníme za hociaký vrchol, tak $L_v(c) \\neq L_v(u)$ pre $c\\neq u$. Opäť dôvod je jednoduchý -- všetky ostatné stromy pod $v$ musia mať inú hĺbku a teda nemôžu byť izomorfné.

S týmito pozorovaniami by sme mali vedieť zvoliť takú definíciu $L_v(u)$, ktorá sa dá ľahko spočítať a zároveň dostatočne spĺňa izomorfickú podmienku (až na jednu výjnimku, viď nižšie).

Definujme si $L_v(c) = -1$ pre všetky $v$, inak povedané, dáme centru label, ktorý nepoužijeme nikde inde. Pre všetky ostatné stromy použijeme na definíciu labelu postup, ktorý poznáme zo sekcie _Izomorfizmus dvoch stromov - labely a AHU_.

$$L_v(u) = m(S_v(u))$$

kde $S_v(u)$ je utriedený zoznam labelov synov $w$ vrchola $u$ za predpokladu, že $v$ je koreň. $m$ je funkcia, ktorá na vstupe dostane zoznam celých čísel a na výstupe vráti jedno prirodzené číslo. Funkcia $m$ vracia rovnaké čísla pre rovnaké zoznamy, a rôzne čísla pre rôzne zoznamy (inak povedané $m$ je prostá funkcia). Implementácia takéhoto niečoho je jednoduchá pomocou mapy alebo hash-mapy (python vie dobre hashovať tuples).

Výstupom algoritmu je počet rôznych hodnôt $L_v(v)$, ktoré spočítame podobne ako v predošlej sekcii, zakoreníme strom za $c$ a dvakrát ho prejdeme pomocou `dfs`.

No počkať, ale strom pod $c$ môže vyzerať inak pre rôzne korene, prečo môžeme mať všade rovnakú hodnotu $L_v(c) = -1$? Všimnime si, že stromy zodpovedajúce $L_v(c)$ a $L_u(c)$ sú izomorfné práve vtedy, keď sú izomorfné stromy zodpovedajúce $L_c(v)$ a $L_c(u)$ (cvičenie pre čitateľa). Vďaka tomu, že pre výpočet $L_v(v)$ používame aj $S_c(v)$, tak nám jedna hodnota $L_v(c)$ nikdy nespraví problém.

A čo ak strom na vstupe nemá centrum? (T.j. priemer stromu má párnu dĺžku). V takom prípade je v strede jedinej najdlhšej cesty hrana. Do stredu tejto hrany pridáme nový vrchol, ktorý bude centrum. Vďaka tomu, že toto nové centrum je opäť unikátne (z hľadiska izomorfizmu), ostane všetko v poriadku. Ak v pôvodnom strome boli nejaké dva zakorenené stromy izomorfné, tak aj v strome s pridaným centrom budú izomorfné. Nesmieme však zabudnúť z výslednej odpovede odpočítať jednotku, lebo sme pridali jeden nový koreň, iný od všetkých ostatných.

Časová zložitosť riešenia je $O(n \\log n)$, ale podobne ako pri AHU algoritme, môžeme počítať labely po vrstvách, viď. popis AHU algoritmu vyššie, a dokážeme v lineárnom čase od počtu vrcholov na o jedna hlbšej vrstve spočítať všetky labely pre danú vrstvu. Takéto riešenie má časovú aj pamäťovú zložitosť $O(n)$.

Pri doprogramovaní si dávajte pozor, že vzorové riešenie v Pythone sa nemusí zmestiť do časového limitu, obzvlášť ak máte $O(n\\log n)$ časovú zložitosť. Vzorák v C++ zbehne s prehľadom a naše hashovacie riešenie v Pythone tiež v pohode prejde.
",9
9d3170ab7657430d,ksp,"# Správne poradie

Život súťažného bojovníka v Ríme je náročná záležitosť. Okrem všetkých zjavných výziev, s ktorými sa každodenne stretávajú je tu aj hlboký a fundamentálny problém, kvôli ktorému to mnohí bojoví géniovia vzdávajú hneď na začiatku. Týmto problémom je príprava tesne pred súbojom.

Asi si to viete predstaviť. *Musím si nasadiť zbroj. Musím si upevniť koženú čiapku. Musím sa obuť. Musím si nasadiť holenné chrániče... Ajajáj, veď som už obutý! Musím sa vyzuť a nasadiť si holenné chrániče. Ej bisťu, zabudol som na správne bojové pomaľovanie!* A všetko odznova.

Uznajte, že takýmto tempom by aj vás akurát tak porazilo. Aby Rím neprichádzal o talenty, všetky významnejšie arény začali zamestnávať prípravných špecialistov. Ich úlohou je pre každého bojovníka usporiadať jeho prípravné akcie tak, aby vzájomne nekolidovali.

## Úloha

V bojovníckom svete existuje $n$ rôznych možných prípravných akcií. Každý bojovník pri príprave na boj potrebuje vykonať niektoré z nich (nie nutne všetky). Pre niektoré dvojice akcií $A$ a $B$ platí, že keď niekedy vykonáme $A$, už nikdy nebudeme vedieť vykonať $B$ (napríklad, ak si oblečieme krúžkovú košeľu, už si nemôžeme obliecť tielko, alebo ak si nasadíme chrániče predlaktí, už si nemôžeme obliecť krúžkovú košeľu). Našťastie existuje poradie, v ktorom sa dajú vykonať **všetky** akcie.

Dostanete zoznam spomenutých závislostí medzi akciami. Ďalej dostanete $q$ bojovníkov, každý z nich bude chcieť vykonať nejaký zoznam akcií. Vašou úlohou bude usporiadať akcie pre každého bojovníka.

## Formát vstupu

Na prvom riadku dostanete čísla $n$, $m$ a $q$ ($1 \\leq n, m, q \\leq 100,000$) -- počet rôznych možných akcií, počet závislostí medzi nimi a počet bojovníkov. Akcie sú očíslované od $1$ po $n$.

Nasleduje $m$ riadkov, v každom z nich dostanete dve rôzne čísla $A_i$ a $B_i$ ($1 \\leq A_i, B_i \\leq n$), ktoré označujú, že keď vykonáme akciu $A_i$, už nebudeme vedieť vykonať akciu $B_i$.

Nakoniec nasleduje $q$ riadkov, $i$-ty z nich začína celým číslom $q_i$ ($1 \\leq q_i \\leq n$) -- počtom akcií $i$-teho bojovníka. Za týmto číslom nasleduje $q_i$ ďalších čísel z rozsahu $1$ až $n$ -- čísla akcií $i$-teho bojovníka.

Počet všetkých akcií, ktoré chcú bojovníci vykonať (súčet všetkých $q_i$), neprekročí $100,000$. Môžete predpokladať, že prípravné kroky každého bojovníka sa dajú usporiadať tak, aby nebola porušená žiadna závislosť.

## Formát výstupu

Vypíšte $q$ riadkov, v $i$-tom z nich $q_i$ čísel -- zoznam krokov $i$-teho bojovníka v poradí, v akom ich má vykonať. Ak existuje viacero možných poradí, vypíšte ľubovoľné z nich.

## Príklad

```vstup
5 5 3
4 3
2 4
3 1
2 1
5 4
4 1 4 3 2
2 1 4
1 5
```

```vystup
1 3 4 2
4 1
5
```

_Prvý bojovník má iba jedno vhodné poradie akcií. Druhý bojovník by mohol akcie vykonať aj v opačnom poradí._
","# Správne poradie

Táto úloha pozostáva z dvoch podproblémov:

- Ako vieme k nejakému zoznamu akcií zistiť poradie, v ktorom ich vieme vykonať

- Ako vieme rýchlo spracovať podmnožiny, v ktorých sa môžu prvky opakovať

Najprv rozoberieme riešenie prvého podproblému a potom to celé poskladáme dohromady. Pre ľahší popis časovej zložitosti budeme celkový počet akcií (súčet $q_i$ zo vstupu) označovať ako $s$.

## Topologické usporiadanie

Prvý problém bol mierne zamaskovaný problém topologického usporiadania. Najprv si uvedomíme, že podmienka ,,po vykonaní $A$ nemôžeš vykonať $B$'' je rovnaká, ako podmienka ,,ak chceš vykonať $A$ aj $B$, musíš najprv vykonať $B$ a až potom $A$''.

Akcie usporiadame nasledovne: Najprv si pre každú akciu spočítame, koľko iných akcií musíme vykonať *pred* ňou, toto číslo budeme dalej volať *počet závislostí*. Niektoré akcie budú mať nula závislostí; ktorúkoľvek z nich vieme vykonať. Keď ju vykonáme, všetkým akciám, ktoré na nej záviseli, znížime počítadlo o jedna. Tým môže niektorým akciám klesnúť počet závislostí tiež na nulu.

Aby sme nemuseli pred vykonávaním každej akcie prejsť cez všetky a hľadať nejakú, ktorú môžeme vykonať, inšpirujeme sa prehľadávaním grafu [do šírky](https://www.ksp.sk/kucharka/bfs/). Na začiatku všetky akcie s nula závislosťami hodíme do fronty na spracovanie. S každým znížením počtu závislostí nejakej akcii skontrolujeme, či tento počet neklesol na nulu. Ak klesol, akciu pridáme do fronty.

Vo všeobecnosti by sa mohlo stať, že v niektorom momente nevieme vykonať žiadnu akciu, lebo všetky majú nejakú nevykonanú závislosť. V zadaní je však garantované, že všetky akcie sa dajú vykonať v nejakom poradí a teda takáto situácia nemôže nastať.

Pokiaľ potrebujeme usporiadať $n$ akcií s $m$ závislosťami, celé nám to bude trvať čas $O(n+m)$, lebo každú závislosť práve raz započítame a raz odpočítame, a každú akciu raz pridáme do fronty a raz spracujeme.

## Viacero bojovníkov

Keď vieme robiť topologické usporiadanie, môžeme rovno spraviť riešenie polohrubou silou. Pre každého bojovníka vezmeme jeho zoznam akcií, vyberieme relevantné závislosti a topologicky ich usporiadame. Dostaneme tým riešenie s časovou zložitosťou $O((n+m) \\cdot q)$.

Lepšie riešenie však dostaneme, keď využijeme nasledujúce pozorovanie: Ak vieme vykonať všetky akcie v nejakom poradí, v tom istom poradí môžeme vykonať akcie každého bojovníka (s tým, že niektoré jednoducho vynecháme).

Na začiatku teda zistíme poradie, v ktorom sa dajú vykonať všetky akcie. Pre každého bojovníka usporiadame jeho zoznam akcií svojim obľúbeným ([rýchlym](https://www.ksp.sk/kucharka/mergesort/)) [triediacim algoritmom](https://www.ksp.sk/kucharka/triedenie/). Keď nasčítame členy v tvare $q_i \\cdot \\log(q_i)$, dostaneme časovú zložitosť $O(s \\log(s) + n + m)$.

## Optimálne riešenie

Predošlé riešenie stačilo na to, aby sme získali všetky body od testovača. Existuje však komplikovanejšie riešenie, ktoré bude mať lepšiu časovú zložitosť. Využijeme fakt, že bojovníci sa pýtajú stále na ,,tie isté'' akcie.

Najprv nájdeme topologické usporiadanie všetkých akcií v čase $O(n+m)$. Ďalej načítame akcie všetkých bojovníkov, ale uložíme si ich ,,čudne'': Pre každú z $n$ akcií si budeme pamätať zoznam bojovníkov, ktorí ju chceli vykonať (v čase $O(s + n)$).

Nakoniec budeme vytvárať pre každého bojovníka jeho usporiadaný zoznam akcií, na začiatku prázdny zoznam. Spracujeme všetky akcie v ich topologickom usporiadaní. Keď spracúvame akciu $X$, pre všetkých bojovníkov, ktorí ju chcú vykonať, ju pridáme na koniec ich aktuálnych zoznamov. Táto časť programu sa bude vykonávať v čase $O(n + s)$.

Nakoniec vypíšeme všetky skonštruované zoznamy pre bojovníkov. Celková časová zložitosť bude $O(n + m + s)$.
",6
9c2741e757f0b062,ksp,"# Obchod mení cenu kryptomeny!

*Táto úloha je podobná úlohe s pred dvoch kôl, [Ako Jemo Etku spoznal](https://www.ksp.sk/ulohy/zadania/1479/). Rozdiel je v tom, že sa ceny kryptomien menia v čase, a sú iné obmedzenia na vstup.*

Jemko sa ešte stále pokúša očariť Etku pri pulte s kryptomenami. Každý deň chodí do Teska a nakupuje kryptomeny čo najvýhodnejšie. Etkinu pozornosť sa mu ale zachytiť nedarí.

Prednedávnom ale spravil objav a hneď mu svitlo, kde by mohol byť problém---všimol si, že každý deň sa v Tesku zmení cena práve jednej kryptomeny. Háčik bol v tom, že doteraz predpokladal, že tieto ceny sú konštantné. Ak pri nákupe zoberie do úvahy tieto zmeny, tak jeho nákupy budú skutočne optimálne, a takúto optimálnosť si Etka určite všimne.

## Úloha

V Tesku predávajú $n$ kryptomien, ktoré sú vyložené na pulte v jednom dlhom rade. Každá kryptomena má nejakú cenu v obchode a nejakú hodnotu na trhu. Jemko bude obchod navštevovať nasledujúcich $q$ dní. Na začiatku dňa sa zmení cena práve jednej kryptomeny, hodnoty ale zostávajú rovnaké.

Pretože Jemko chodí vždy večer, na pulte je vždy z každej meny už len $1$ minca. Pre každú návštevu vieme, koľko má Jemko peňazí v peňaženke a odkiaľ pokiaľ vidí, a zaujíma nás odpoveď na otázku: “Akú najväčšiu hodnotu vie Jemko nakúpiť, ak si vyberá len medzi menami, na ktoré dovidí?”

## Formát vstupu

Na prvom riadku vstupu sú dve celé čísla $n$ a $q$ oddelené medzerou: počet rôznych kryptomien a počet dní, počas ktorých Jemko navštívi Tesko. Kryptomeny sú číslované od $1$ po $n$.

Ďalší riadok je prázdny.

Nasleduje $n$ riadkov, v každom sú dve medzerou oddelené celé čísla $c_i$, $h_i$: počiatočná cena $i$-tej kryptomeny v Tesku, a hodnota tejto kryptomeny na trhu.

Ďalší riadok je prázdny.

Na konci bude $q$ riadkov popisujúcich udalosti v jednotlivých dňoch: Jemkove návštevy a zmeny cien v obchode. V každom riadku je pätica čísel $k_i$, $b_i$, $l_i$, $r_i$, $p_i$ oddelených medzerou. Prvé dve čísla hovoria, že cena kryptomeny $k_i$ sa na začiatku dňa zmení na $b_i$. Posledné tri čísla hovoria, že Jemko má v peňaženke $p_i$ peňazí a môže nakupovať kryptomeny od $l_i$ po $r_i$, vrátane.

## Formát výstupu

Pre každú Jemkovu návštevu Teska vypíšte jeden riadok a v ňom jedno celé číslo: najväčšiu hodnotu, ktorú vie Jemko nakúpiť.

## Hodnotenie

Pre jednotlivé sady vstupov platia nasledovné obmedzenia.

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------------------:|:--------:|:---------:|:---------:|:----------:| | $1 \\leq n \\leq$ | $3,000$ | $30,000$ | $30,000$ | $300,000$ | | $1 \\leq q \\leq$ | $3,000$ | $10,000$ | $10,000$ | $10,000$ |

Vo všetkých vstupoch platia nasledovné obmedzenia pre ceny kryptomien a peňaženku: $1 \\leq c_i, b_i, p_i \\leq 50$.

Pre hodnoty kryptomien platí $0 \\leq h_i \\leq 10^6$.

Kryptomeny indexujeme od jednotky; platí teda $1 \\leq k_i \\leq n$ a $1 \\leq l_i \\leq r_i \\leq n$.

## Príklad

```vstup
5 3

5 5
6 6
7 7
8 8
9 9

1 7 1 5 22
2 8 1 5 22
3 9 1 5 22
```

```vystup
22
20
17
```
","# Obchod mení cenu kryptomeny!

V odhadoch časovej zložitosti budeme označovať ako $P$ horný odhad množstva peňazí, ktoré má Jemko pri sebe. (V testovacích prípadoch $P = 50$.)

## Hrubá sila

Tak ako v pôvodnej úlohe, aj v tejto vieme použiť štandardný algoritmus na riešenie problému batoha (tzv. *knapsack algoritmus*). O kryptomenách si neudržujeme žiadnu ďalšiu informáciu, iba ich ceny a hodnoty. Zmenu ceny potom vieme vykonať v konštantnom čase.

Zvyšok riešenia vyzerá nasledovne:

Na druhej strane, nájdenie optimálneho nákupu bude pomalé: robíme knapsack na $n$ kryptomenách, a máme vo vrecku najviac $P$ peňazí. Toto potrvá $O(n \\cdot P)$, a keďže máme $q$ otázok, celková časová zložitosť bude až $O(n \\cdot P \\cdot q)$.

Za toto riešenie sa dalo získať $2$ body. Veď hrubú silu ste si mohli naprogramovať už v [pôvodnej úlohe](https://www.ksp.sk/ulohy/zadania/1479/)...

### Rozšírenie pôvodnej úlohy? Nie...

Kto ale skúšal riešenie v duchu ""upravím vzorák pôvodnej úlohy"", zistil, že to nie je také ľahké^[Nie je nám známe žiadne riešenie na takéto motívy.]. Problém robia zmeny hodnôt kryptomien, ktoré nevieme vykonať efektívne. V štruktúrach, ktoré využívame na riešenie pôvodnej úlohy, by sa toho menilo príliš veľa.

Nie všetko je ale stratené---netreba zabudnúť na to, že obmedzenia tejto úlohy sú iné. Možno teda existuje úplne iné riešenie, ktoré nebuduje na riešení pôvodnej úlohy.

## Jemko má nejako málo peňazí... náhoda?

Všimnime si, že Jemko má pri sebe vždy najviac $50$ peňazí, čo je výrazne menej ako limit v pôdovnej úlohe (kde bol $2000$). Nevedeli by sme to nejako využiť?

Predstavme si, že Jemko by mal na výber iba z kryptomien ceny $1$. Určite sa mu oplatí kupovať od najhodnotnejších kryptomien. Navyše, kedže každá kryptomena stojí $1$ peniaz a Jemko má pri sebe nanajvýš $P$ peňazí, kúpi nanajvýš $P$ z týchto kryptomien.

Toto pozorovanie vieme zovšeobecniť: spomedzi kryptomien ceny $c$ stačí Jemkovi pri nákupe uvažovať iba najhodnotnejších $\\lfloor \\frac{P}{c} \\rfloor$ ^[Symbol $\\lfloor x \\rfloor$ označuje dolnú celú časť reálneho čísla $x$, teda $x$ zaokrúhlené nadol.] z nich. Viac ich určite nekúpi, lebo potom by minul viac peňazí, ako má pri sebe.

To nám ale výrazne zužuje výber. Aj keby Jemko dovidel na $300,000$ kryptomien, stačí mu pri nákupe uvažovať dokopy iba

$$\\lfloor \\frac{P}{1} \\rfloor + \\lfloor \\frac{P}{2} \\rfloor + \\ldots + \\lfloor \\frac{P}{P} \\rfloor$$

kryptomien, čo je asymptoticky $O(P \\log P)$. Dôkaz tohto odhadu presahuje rámec tohto vzoráku, záujemcom ale odporučím [túto stránku](<https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Integral_test>).

Nemusíme byť ale matematický mágovia na to, aby sme zistili, že onen súčet je dosť malý. Pre $P = 50$ ho vieme zrátať jednoduchým skriptom:^\[alebo aj pomocou [WolframAlpha](<http://www.wolframalpha.com/input/?i=sum+floor(50%2Fi)+for+i%3D1...50>)\]

Z čoho dostaneme, že sa Jemkovi stačí v našich testovacích prípadoch pozerať vždy na najviac $207$ kryptomien. To je výrazne menej, ako keby sa pozeral na všetkých potenciálne až $300,000$ kryptomien.

## Lepšie riešenie

Ako pomocou vyššie uvedeného tvrdenia možno urýchliť riešenie hrubou silou? Namiesto toho, aby sme pri knapsacku uvažovali všetky kryptomeny, na ktoré Jemko dovidí, stačí uvažovať len niekoľko málo z nich. Konkrétne, každej cenovej kategórie $c$ uvažujeme len $\\lfloor \\frac{P}{c} \\rfloor$ najhodnotnejších kryptomien. Pre každú cenu vieme tento zoznam zostrojiť jednoducho pomocou minimovej haldy: vložíme kryptomenu do haldy, a ak je v halde priveľa prvkov, vyhodíme z nej najmenej hodnotnú kryptomenu.

Zlúčením všetkých $P$ háld dostaneme zoznam všetkých kryptomien, na ktoré má zmysel sa pozerať. Potom spustíme knapsack algoritmus, ale iba na kryptomenách v tomto zozname.

Časová zložitosť na jeden nákup sa nám zmenšila na $O(n \\log P + P^2 \\log P)$: na zostrojenie zoznamu relevantných kryptomien musíme prejsť $O(n)$ kryptomien, a pri každej strávime $O(\\log P)$ času na haldu^[Šikovné oko si všimne, že v skutočnosti zoznam vieme zostrojiť rýchlejšie, ako pomocou haldy.]. Následný knapsack trvá $O(P \\log P \\cdot P)$, pretože máme $O(P \\log P)$ vecí a $P$ peňazí.

Toto riešenie si vyslúžilo $6$ bodov. Jeho najpomalšou časťou je konštrukcia zoznamu relevantných kryptomien. To robíme jednoducho (ale pomaly) tak, že prejdeme všetky kryptomeny, na ktoré Jemko dovidí.

## Vzorové riešenie

V úlohe sa často pýtame na nejaké intervaly, a tak by nás hneď mohol napadnúť intervalový strom. Nevedeli by sme ho tu nejako využiť?

Avšak, priamočiare využitie, kde by sme si v každom intervale pamätali knapsack na tom intervale, nestačí. Problém je so spájaním viacerých podknapsackov do jedného---nejde to robiť efektívne.^[Možno argumentujete, že v pôvodnej úlohe sme predsa použili intervalový strom. Zamyslite sa ale, či nebol nejaký divný. Napríklad, keď sme dostali nejaký interval, na koľko najviac vrcholov v strome sme ho rozdelili? Bolo to $O(\\log n)$, tak ako v obyčajných intervaláčoch?]

Avšak my máme niečo lepšie. Vieme, že nám stačí uvažovať iba niekoľko málo kryptomien z každej ceny. Možno by sme si vedeli pamätať túto informáciu vo vrcholoch stromu.

V každom vrchole si budeme pre každú cenu pamätať zoznam relevantných kryptomien. Navyše budeme mať tieto zoznamy utriedené podľa hodnôt.

Teraz nás zaujímajú dve veci. Po prvé, čo má byť v listoch? To je ľahké: list obsahuje iba jedinú kryptomenu. Nech jej cena je $c$, potom zoznam pre cenu $c$ obsahuje túto kryptomenu, a ostatný zoznamy sú prázdne.

Ďalej, dajú sa tieto zoznamy efektívne spočítať v nejakom vrchole, ak ich už máme pre jeho synov? Dajú. Postupujeme podobne ako pri *mergesorte*. Pri zostrojovaní zoznamu pre cenu $c$ opakujeme nasledovnú úvahu:

- Ktorý prvok ceny $c$ môže byť najväčší? Zrejme to bude buď najväčší prvok ceny $c$ v ľavom synovi, alebo v pravom synovi. Pre oboch synov ale máme usporiadaný zoznam prvkov s touto cenou. Bude to teda prvý prvok niektorého z týchto zoznamov.

- Porovnáme tieto prvé prvky, zoberieme väčší z nich a umiestnime ho na prvé voľné miesto v našom zozname.

- Opakujeme so zvyškom, pričom vybratý prvok ďalej neberieme v úvahu. Za najväčší prvok v tom synovi teda budeme považovať druhý prvok, keď sa vyberie ten tak potom tretí, ...

Aká je časová zložitosť tohto predpočítania? Zlučovanie dvoch intervalov do jedného trvá $O(P \\log P)$, a vrcholov v strome je $O(n)$. Bude teda trvať $O(n \\cdot P \\log P)$.

Ako zistiť zoznam relevantných kryptomien pri nákupe? Interval rozbijeme na $O(\\log n)$ intervalov zo stromu, a tie zlúčime. To potrvá $O(\\log n \\cdot P \\log P)$, a následné vyriešenie knapsacku bude trvať $O(P \\cdot P \\log P)$. Časová zložitosť jedného nákupu je teda $O(P \\log P \\cdot (P + \\log n))$.

Ako prepočítať intervalový strom, keď sa zmení hodnota kryptomeny? Keď vieme zlučovať intervaly, nie je problém: zmeníme príslušný vrchol-list^[reprezentujúci interval dĺžky $1$] a všetkých jeho predkov ^[reprezentujúce všetky ďalšie intervaly, ktoré kryptomenu obsahujú] prepočítame. Tých je iba $O(\\log n)$, časová zložitosť jednej úpravy je teda $O(\\log n \\cdot P \\log P)$.

Celková časová zložitosť je

$$O(P \\log P \\cdot (n + (P + \\log n) \\cdot q)),$$

čo síce nevyzerá pekne, ale aspoň je to dosť málo. Toto riešenie si vyslúžilo plných $8$ bodov.

Pomocou *lazy-loadingu* by sme sa vedeli vyhnúť zdĺhavému predpočítaniu a dosiahnuť tak o chlp lepšiu časovú zložitosť. Na plný počet bodov sme to ale nevyžadovali.
",10
21383d68d6e5962d,ksp,"﻿# Čarovný lexikón kúziel

David si z knižnice požičal lexikón kúziel. V lexikóne kúziel sa ukrýva jeho obľúbené zaklínadlo. Chcel nájsť, koľkokrát sa tam nachádza. Lenže! Čarodejnica pred ním zo srandy lexikón zakliala, takže sa po každom prečítaní text trochu zmení. David bol tvrdohlavý a po každej zmene lexikónu znova zisťoval, koľkokrát je tam zaklínadlo. Toto robil, až kým mu neuplynula výpožičná lehota a keďže nechcel platiť pokutu, musel lexikón vrátiť.

## Úloha

Máme reťazec a podreťazec, v reťazci hľadáme počet výskytov podreťazca. Reťazec sa mení. Po každej zmene chceme znova zistiť počet výskytov podreťazca.

## Formát vstupu

V prvom riadku je reťazec dlhý $n$ ($1 \\leq n \\leq 10^6$). V druhom riadku je podreťazec dlhý $m$ ($1 \\leq m \\leq 10^4$). Možeš predpokladať, že $m \\leq n$. V treťom riadku je číslo $q$ ($0 \\leq q \\leq 10^3$). Nasleduje $q$ riadkov vo formáte [$p$] [$S$], $p$ označuje miesto v texte, kam zapísať podreťazec $S$ ($0 \\leq p \\leq n-m$). Dĺžka podreťazca $S$ je rovná $m$, to znamená, že dĺžka reťazca sa celý čas nemení.

## Formát výstupu

Na výstupe je $1+q$ riadkov, jeden pre pôvodný text a jeden pre každú zmenu v reťazci. Na každom riadku je jedno číslo, počet výskytov podreťazca v reťazci.

V niektorých pomalších jazykoch (Python) nemusia optimálne riešenia prechádzať na plný počet bodov. Body za popis táto skutočnosť samozrejme neovplyvní.

## Príklady

```vstup
BANANANOS
NANA
2
5 ANAS
3 XXXX
```

```vystup
1
2
0
```

*V pôvodnom reťazci sa podreťazec ""NANA"" vyskytuje raz. Potom sa reťazec zmení na ""BANANANAS"", preto sa tam podreťazec vyskytuje dvakrát. Potom sa zmení na ""BANXXXXAS"", kde už sa podreťazec nevyskytuje.*

```vstup
AAAAAAAAAAAAAAA
AAA
2
1 XXX
6 XXX
```

```vystup
13
9
4
```

```vstup
BALALAJKA
ALA
2
5 ALA
1 BLA
```

```vystup
2
3
2
```

```vstup
BLBALABLA
BL
2
1 LB
2 AL
```

```vystup
2
2
2
```

```vstup
BABANANASSSSSS
NANA
1
1 XXXX
```

```vystup
1
0
```
","# Čarovný lexikón kúziel

Úlohou bolo hľadať počet výskytov podreťazca v reťazci, ktorý sa mení. Po každej zmene bolo treba znova zistiť počet výskytov podreťazca.

## Pomalé riešenie

Prvou možnosťou je jednoduché prehľadanie reťazca, pričom pre každú pozíciu overíme, či sa na nej začína podreťazec. Overenie prebehne porovnávaním znakov podreťazca s aktuálne overovanou časťou reťazca. Pre každý znak, ktorých je $n$, skontrolujeme prinajhoršom $m$ znakov, teda celkovo urobíme $O(nm)$ operácii. Časová zložitosť je teda $O(nm)$ Po každej zmene reťazca, ktorých je $q$, kontrolujeme znovu celý reťazec, teda časová zložitosť riešenia bude $O(qnm)$. Pamäťová zložitosť je $O(n+m)$, lebo okrem reťazca a podreťazca si nemusíme nič pamätať. Toto riešenie prejde prvou sadou testov.

## Trochu lepšie riešenie

Pomalé riešenie môžeme vylepšiť tak, že celý text prehľadáme len raz a po každej zmene už prehľadáme len zaujímavú časť reťazca. Zaujímavá je samotná zmenená časť a aj rovnako dlhá časť pred ňou a po nej. To je potrebné aby sme zistili, či sa úpravou textu neporušil alebo nevytvoril nový výskyt, ktorý sa nenachádal úplne celý v zmenenej časti textu. Keďže sme neprehľadali celý reťazec, musíme zistiť rozdiel počtu výskytov podreťazca v zaujímavej časti pred a po zmene, čiže zaujímavú časť musíme prehľadať dvakrát. Po úvodnom prehľadaní si zapamätáme počet výskytov v celom reťazci a ten potom zvyšujeme alebo znižujeme pomocou rozdielu získaného po každej zmene. Časová zložitosť sa tým zlepší na $O(nm+qm^2)$. Pamäťová zložitosť sa oproti predošlému riešeniu nezmení. Toto riešenie prejde prvé dve sady testov.

## Rabinov-Karpov algoritmus

Algoritmus spočíva na rolling hash funkcii. To je taká hash funkcia, ktorá vie vypočítať nový hash pomocou starého hashu v konštantnom čase. Na začiatku si vypočítame hash podreťazca a hash prvých $m$ znakov reťazca. Tak isto ako v pomalom riešení prehľadávame reťacec po znakoch, avšak výskyt podreťazca neoverujeme pre každú pozíciu, ale len ak sa zhoduje hash práve prehľadávanej časti textu s hashom hľadaného podreťazca. Po každom znaku vieme zo starého hashu vypočítať nový v konštantnom čase. Časová zložitosť tohto riešenia je v najhoršom prípade $O(mn+qm^2)$ čo je zložitosť predchádzajúceho riešenia, ale v očakávanom a veľmi pravdepodobnom prípade $O(n+qm)$ čo je zložitosť optimálneho riešenia. Prvý prípad nastane, ak sa text skladá iba z podreťazca, čiže podreťazec sa vyskytuje na každej pozícii. Tomuto sa môžeme vyhnúť a algorimus urýchliť vynechaním overenia v prípade zhody hashu. Vtedy hrozí, že v prípade kolízie hashu nesprávne určíme, že sa vyskytol podreťazec. Dá sa ukázať, že kolizii je veľmi málo, navyše sa vyskytnú v iných prípadoch závisiacich od zvolenej hashovacej funkcie resp. prvočísla, ktorým modulujeme. Pre zníženie pravdepodobnosti kolízie môžeme použiť viac ako jednu hashovaciu funkciu. Pamäťová zložitosť bude $O(n+m)$, keďže si pamätáme reťazec dĺžky $n$ a podreťazec dĺžky $m$. Toto riešenie prejde prvé tri sady testov a v prípade vynechania overenia prvé štyri sady testov.

## Vzorové riešenie

Vzorové riešenie využíva [KMP algoritmus](https://www.ksp.sk/kucharka/kmp/). Časová zložitosť predspracovania, čiže konštrukcie funkcie `next` bude $O(m)$ a samotné prehľadanie reťazca bude trvať $O(n)$. Po prvom prehľadaní celého reťazca už kontroluje len zaujímavé časti reťazca. Zaujímavá je samotná zmenená časť a aj rovnako dlhá časť pred ňou a po nej. To je potrebné aby sme zistili, či sa úpravou textu neporušil alebo nevytvoril nový výskyt, ktorý sa nenachádal úplne celý v zmenenej časti textu. Časová zložitosť riešenia bude $O(n+qm)$. Pamäťová zložitosť bude $O(n+m)$, keďže si pamätáme reťazec dĺžky $n$ a podreťazec a automat dĺžky $m$.
",8
65e359e4e244964f,ksp,"# Slimačie spojenie

Krtko a Hodobox - posledné piliere KSP - pracujú na novom ksp. Každý má list svojich úloh, ktoré má pripraviť, aby mohla ďalšia séria prebehnúť. Avšak, internet je beznádejne zaťažený Netflixami, online vyučovaním, Zoom callmi s mačiatkami... čo značne sťažuje komunikáciu. Čo sťažuje -- internet im beznádejne padol, a nevyzerá, že by chcel znovu nabehnúť. Nuž - čo už, séria aj tak musí byť, offline či online.

Na poslednom stretku pred padnutím internetu si Krtko a Hodobox rozdelili úlohy. Avšak, po pokuse začať pracovať zistili, že rozdelenie úloh je nerovnomerné. Za veľmi obmedzenej komunikácie^[poštové holuby] si dokázali sprostredkovať, že by si mali nejakú úlohu vymeniť.

Problém je, že internet nefunguje, tak si musia poslať úlohu poštou. Listy sú ale drahé, takže si môžu vymeniť presne dve úlohy^[ani jeden z nich si nepamätá zadania úloh toho druhého] (Hodobox pošle jednu svoju úlohu Krtkovi a neopak).

Pre každú úlohu vedia koľko práce na ňu bude treba. Ktoré dve úlohy by si mali vymeniť?

## Úloha

Každý z nich má spraviť $N$ úloh ($N \\leq 10^5$). Hodoboxova $m$-ta úloha zaberie $h_m$ minút času. Krtkova $m$-tá úloha zaberie zase $k_m$ minút času.

Ktorú úlohu by si mali vymeniť, aby strávili čo najvyrovnanejší čas prácou na úlohách?

## Formát vstupu

Na prvom riadku je číslo $N$.

Na ďalšom riadku je $N$ čísel $h_1$, ..., $h_N$.

Na poslednom riadku je $N$ čísel $k_1$, ..., $k_N$.

Všetky časy sú od $1$ do $10^9$ vrátane.

## Formát výstupu

Ak by nemali vymeniť žiadnu úlohu, vypíšte $-1$.

Inak vypíšte dva čísla $1 \\leq i, j \\leq N$ - naznačujúce, že Krtko má pripraviť Hodoboxovu úlohu číslo $i$, a Hodobox Krtkovu úlohu číslo $j$.

Ak existuje viac optimálnych riešení, vypíšte také, že $i$ je najmenšie možné. Ak je viac riešení s rovnakým $i$ vypíšte také, že $j$ je najmenšie možné. V prípade že jedno z optimálnych riešení zahŕňa nemenenie úlohy, vypíšte to.

## Obmedzenia

Úloha má osem sád.

V prvých štyroch platí, že $N \\leq 1000$.

Vo zvyšných $N \\leq 10^5$

Navyše, v sade $1$, $2$, $5$ a $6$ sú časy Krtkových a Hodoboxových úloh usporiadané od najmenej časovo náročnej, po najviac.

## Príklad

```vstup
5
1 4 2 5 3
7 10 5 8 9
```

```vystup
1 2
```

*Pôvodné rozdelenie úloh dáva oveľa viac (o $24$ minút) práce Krtkovi ako Hodoboxovi. Najlepšie je, aby si Hodobox zobral Krtkovu najťažšiu úlohu, a Krtko Hodoboxovu najľahšiu. Následne bude Krtko mať len o $6$ minút viac práce než Hodobox*

```vstup
6
2 4 10 17 99 123
1 7 17 17 101 112 
```

```vystup
-1
```

*Pôvodné rozdelenie úloh je už vyrovnané. Netreba meniť.*

```vstup
4
2 7 2 7
3 4 4 3
```

```vystup
2 2
```

*Najlepšie je vymeniť Hodoboxovu úlohu zaberajúcu $7$ minút času za Krtkovu úlohu zaberajúcu $4$ minúty času. Existuje tu viacero riešení, ale to s najmenšími indexami je vymeniť si úlohy na druhej pozícii.*
","# Slimačie spojenie

## Skúšame všetky možnosti

Základné riešenie na všetky úlohy je skúsiť všetky možnosti. Ako to funguje tu?

Máme $n^2$ dvojíc ktoré by si Krtko s Hodoboxom mohli vymeniť. Stačí pre každú spočítať aký je rozdiel medzi výslednými súčtami časov.

Spočítať súčty síce trvá $O(n)$, môžeme si však pomôcť nasledovným trikom:

Predstavme si, že Krtko si zoberie Hodoboxovu úlohu číslo $i$, a Hodobox si zoberie Krtkovu úlohu číslo $j$. Potom rozdiel medzi ich časmi bude

$$ |k_1 + \\dots k\_{j-1} + k\_{j+1} + \\dots + k_n + h_i - (h_1 + \\dots h\_{i-1} + h\_{i+1} + \\dots + h_n + k_j)| = |\\sum\_{l_1}^{n} k_l + h_i - k_j - \\left( \\sum\_{l=1}^n h_i - h_i + k_j \\right)| $$

Takže nám stačí spočítať sumu všetkých originálne Krtkových úloch, $K$, všetkých originálne Hodoboxových úloh $H$ raz na začiatku. Následne, rozdiel po vymenení $h_i$ a $k_j$, dostanú rozdiel $|K - H + 2h_i - 2k_j|$.

Takto vieme v konštatnom čase spočítať rozdiely pre všetky možné dvojice vymenení, a teda v časovej zložitosti $O(n^2)$ vyriešiť úlohu. Toto riešenie mohlo získať $4$ body.

## S ktorou úlohou je najlepšie meniť $k_i$?

Pre jednoduchosť predpokladajme, že náročnosti sú zoradené podľa minutáže, teda $h_1 \\leq h_2 \\leq \\dots \\leq h_n$ a $k_1 \\leq k_2 \\leq\\dots\\leq k_n$.

Na ceste ku vzorovému riešeniu si pomôžme nasledovnou modifikáciou úlohy.

Predstavme si, že Krtko sa rozhodol, že sa mu úloha $k_i$ nepáči a teda ju bude musieť pripraviť Hodobox. Ktorú úlohu by mu mal poslať Hodobox, aby bol rozdiel časov pripravovania čo najmenší?

Predstavme si najskôr, že Hodoboxove úlohy sú utriedené od najkratšej po najdlhšiu.

Tiež si predstavme, že $k_i$ je najdlhšie trvajúca Krtkova úloha.

Bez ujmy na všeobecnosti, rátajme s tým, že Krtko má na začiatku viac práce ako Hodobox, a chce si vymeniť úlohu $k_n$.

Krtko by mohol (trochu neintuitívne) začať skúšať od Hodoboxovej najviac času konzumujúcej úlohy, a postupne porovnávať $|K - H + 2h_i - 2k_n|$, ako v riešení s hrubou silou.

Avšak, všimnime si, že keď sa stane, že výsledný rozdiel časov klesne, teda $|K - H + 2h_i - 2k_n| < |K - H + 2h\_{i-1} - 2k_n|$, potom sme už ""prestrelili"" a Hodobox bude mať oveľa viac práce ako Krtko, a zameniť za kratšiu úlohu čas môže len zhoršiť.

Takže v prípade, že nám rozdiel klesne, Krtko vie, s ktorou úlohou má meniť. Povedzme, že je to úloha číslo $i$.

Pozorný čitateľ si teraz myslí - počkať, veď toto je stále lineárne, v ničom to nepomohlo!

Avšak, teraz nastane trik: predstavme si že Krtko sa zrazu rozhodne, že si úlohu $k_n$ chce nechať, a miesto toho chce dať Hodoboxovi $k\_{n-1}$, druhú najdlhšiu úlohu.

Všimnime si, že meniť $k\_{n-1}$ s úlohou dlhšie trvajúcou než $h_i$ sa nemôže oplatiť. Takže jediné, čo sa môže zlepšiť rozdiel oproti $|K - H + 2h_i - 2k\_{n-1}|$ je skúšať výmenu s kratšími Hodoboxovými úlohami.

Znova, ak raz nastane že výmena s kratšou úlohou by zhoršila balans, už sa ďalej skúšať neoplatí, a teda sme našli s ktorou úlohou má Krtko meniť $k\_{n-1}$.

Čitateľ, sledujúci časovú zložitosť, si môže všimnúť, že sme neporovnali oba z $k_n$, $k\_{n-1}$ s každou Hodoboxovou úlohou - dokopy sme ich porovnali s najviac $n+1$ úlohami.

Čo tak ďalej pokračovať s $k\_{n-2}, \\dots, k_2, k_1$? Ak vždy začneme porovnávať len s predchádzajúceho maxima, tak určite dokopy nájdeme optimálne riešenie pre každé $k_j$, a zároveň prejdeme Hodoboxove pole presne raz.

Ako získame odpoveď na originálnu otázku? Ak pre každé $k_j$ máme $h\_{i(j)}$ - úlohy ktoré je najlepšie vymeniť, za predpokladu, že Krtko dá Hodoboxovi úlohu číslo $j$, tak najlepší rozdiel časov, ktorý vedia výmenou dosiahnuť je minimum z $|K - H + 2h\_{i(j)} - k_j|$. Toto vieme tiež spočítať v lineárnom, a teda dokopy v $O(n)$ čase dostať výsledok.

Myšlienka tejto úlohy sa volá *dvaja bežci*.

## Implementačné detaily

Naše riešenie trochu odmávalo pár detailov v ktorých sa môže dobré riešenie stratiť. Poďme sa teda pozrieť na ne.

Po prvé, postupnosť časov na vstupe nemusí byť utriedená. To sa dá vyriešiť utriedením v programe, čo nám síce zväčší časovú zložitosť na $O(n\\log n)$ (to ale v tejto úlohe nie je problém).

Čo ak súčet pôvodných Krtkových časov je viac ako Hodoboxových? Jedno z riešení je ich jednoducho vymeniť - tvárime sa že Krtkove úlohy sú Hodoboxove a naopak. Ich polia v programe rovno vymeníme, a pokračujeme ako predtým.

Posledný problém je, že potrebujeme vypisovať ktoré úlohy by si mali vymeniť. Toto môžme vyriešiť tak, že miesto polí s $k_i$ a $h_i$, máme polia párov $(k_i, i)$, resp. $(h_i, i)$, a keď sa nám stane, že dve rôzne výmeny by mali rovnaký rozdiel, porovnáme indexy.

Celkovo tak dostávame riešenie ktoré beží v čase $O(n\\log n)$ (pre nezotriedené postupnosti úloh), s pamäťovou zložisťou $O(n)$
",4
600a6e7814a330dd,ksp,"# Zimný problém Sysľa Mariána

Ako všetci viete, v našich Nízkych Tatrách v hojnom počte žijú sysle. Býva tam aj syseľ Marián. Svoj príbytok si vybudoval tak, že vyhĺbil na lúke priechodný, pohodlný tunel, ktorý na konci rozšíril na priedušnú, útulnú izbu. V nej opäť vyhĺbil niekoľko priechodných, pohodlných tunelov, ktoré na konci rozšíril na priedušné, útulné izby. Takto pokračoval, v každej už vyhĺbenej priedušnej, útulnej izbe vyhĺbil smerom nadol niekoľko (nula alebo viac) priechodných, pohodlných tunelov. Keď skončil, jeho syslie obydlie tvorilo $n$ útulných, priedušných izieb spojených $n-1$ priechodnými, pohodlnými tunelmi. Marián bol so svojím výtvorom náramne spokojný.

Jedného večera, zatiaľ čo riešil syslie veci v jednej zo svojich izieb, začalo vonku mrznúť. Mariánovi bolo jasné, že ak by vyliezol do niektorej izby, ktorá je bližšie k povrchu ako tá, v ktorej práve je, tak by určite prechladol. Nič si z toho však nerobil -- uložil sa spať v jednej z prístupných izieb (buď ostal v tej, čo bol, alebo sa presunul niekam hlbšie). No nemohol tušiť, že kvôli ukrutnej zime primrzol neďaleký rybník. Žaba Michal sa teda rozhodol, že si nájde priedušnejší, útulnejší príbytok. A tak zamieril priamo do Mariánovej nory. Vďaka priechodnosti a pohodlnosti tunelov bez problémov doskákal až do priedušnej, útulnej izby v ktorej spal Marián. Marián sa v tú noc prebudil na neúprosné chrápanie jeho novonadobudnutého spolubývajúceho.

Čo má teraz robiť? Marián dobre vedel, že ak by Michala vyhnal, tak by v studenej noci určite ochorel. Na to však nemá srdce. Nechal teda žabu spať, prešiel cez priechodný, pohodlný tunel do vedľajšej priedušnej, útulnej izby a horko-ťažko predsa len zaspal. Keď sa ráno zobudil, žaby už nebolo. Marián si však domyslel, že sa táto situácia bude celú zimu opakovať -- akonáhle začne večer vonku mrznúť, Marián si bude musieť nájsť takú priedušnú, útulnú izbu, do ktorej sa vie dostať pomocou priechodných, pohodlných tunelov bez toho, aby liezol smerom nahor (tam by totiž prechladol). Hneď na to k nemu doskáče žaba Michal a Mariánovi nedá svojim chrápaním spať. Teraz Marián potrebuje ujsť do inej izby čo najďalej od žaby bez toho aby vyliezol nad izbu v ktorej bol večer (tam sa mu bude najľahšie zaspávať). Marián si ďalšiu noc radšej naplánuje.

## Úloha

Izbám v svojej nore priradil Marián čísla od $1$ po $n$. Číslo izby, ktorú vyhĺbil ako prvú (teda izby najbližšie k povrchu) označme $l$. _Hĺbka_ izby je počet tunelov, cez ktoré treba prejsť smerom nadol, aby ste sa do nej dostali z lúky. Hĺbka izby $l$ je teda 1 a hĺbka každej inej izby je o 1 väčšia než hĺbka izby nad ňou.

_Vzdialenosť_ medzi dvoma izbami je počet tunelov, cez ktoré musíme prejsť, aby sme sa dostali z jednej do druhej.

Mariánova nora môže vyzerať napríklad takto:

Izbu, kde sa Marián zdržiava večer, označme $v$. Počas celej noci sa Marián nemôže ani na chvíľu ocitnúť v izbe s menšou hĺbkou, než hĺbka izby $v$. To znamená, že ani počas presunu z izby $v$ do izby, kam sa prvotne uloží spať, ani počas nočného úteku od žaby nemôže Marián ani len prechádzať cez izbu s menšou hĺbkou ako má izba $v$. Samozrejme, aj obe izby, kde bude Marián spať, musia byť aspoň tak hlboko ako $v$.

Marián potrebuje o každej izbe zistiť, aká je dobrá. To znamená, že pre každú izbu ho zaujíma odpoveď na otázku ""Ak by som sa večer zdržiaval v tejto izbe a izbu na spanie by som si zvolil čo najlepšie, ako ďaleko od žaby sa mi v noci podarí dostať?"" Inými slovami, pre každú izbu $x$ ho zaujíma najväčšia možná vzdialenosť medzi dvojicou izieb $y, z$ takou, že z izby $x$ sa vie dostať do izby $y$ a z izby $y$ do izby $z$ bez toho, aby musel vyliezť do menšej hĺbky než má izba $x$.

Pomôžte úbohému sysľovi!

## Formát vstupu

V prvom riadku sú dve čísla $n$, $l$ ($1 \\leq l \\leq n \\leq 150,000$) -- počet izieb v Mariánovej nore a číslo izby, ktorá je priamo prepojená s lúkou (a má teda hĺbku $1$). Nasleduje $n-1$ riadkov s dvojicami čísel izieb $a_i, b_i$, ktoré sú prepojené tunelom. Je zaručené, že z každej izby sa dá postupnosťou tunelov dostať do každej inej práve jedným spôsobom. Izbičky s chodbami teda tvoria strom.

V prvej sade testovacích vstupov navyše platí, že z každej izby ide najviac jeden priechodný, pohodlný tunel do izby s väčšou hĺbkou. To znamená, že nora sa nerozvetvuje, iba stále klesá dodola.

## Formát výstupu

Vypíšte $n$ riadkov. V $i$-tom z nich vypíšte hľadanú vzdialenosť pre izbu $i$, ako je popísané v časti `Úloha`.

## Príklad

```vstup
4 2
2 3
4 1
3 4
```

```vystup
0
3
2
1
```

_Toto je príklad vstupu z prvej sady._

```vstup
7 3
4 7
2 1
6 2
5 2
3 4
5 3
```

```vystup
0
2
5
1
2
0
0
```

_Toto je syslia nora z obrázku v Úlohe. Ak je Marián večer v niektorej z izieb 1, 6 alebo 7, má smolu a musí v nej ostať po celú noc (teda bude od žaby vzdialený nula). Ak je večer v izbe 2, môže sa uložiť spať do izby 6 a počas noci utiecť do izby 1 (vzdialenosť 2). Ak je večer v izbe 3, môže ísť spať napríklad do izby 1 a v noci sa presunúť do izby 7 (vzdialenosť 5). Ak začína v izbe 4, môže ostať spať v nej a v noci utiecť do izby 7 (vzdialenosť 1). Ak bude večer v izbe 5, môže sa uložiť v izbe 6 a v noci prejsť späť do izby 5 (vzdialenosť 2)._
","# Zimný problém sysľa Mariána

Pred čítaním vzorového riešenia tejto úlohy silno odporúčame mať prečítané články z kuchárky o [grafoch](https://www.ksp.sk/kucharka/grafy_uvod/) a [prehľadávaní do hĺbky](https://www.ksp.sk/kucharka/dfs/).

Formálne si popíšeme, čo je vlastne našou úlohou. Sysľova nora je zakorenený strom (koreňom je izba číslo $l$). Pre každý vrchol v tomto strome nás zaujíma dĺžka najdlhšej cesty v jeho podstrome.

## Riešenie prvej sady

Spomenieme stručne riešenie prvej sady -- v nej nám bolo sľúbené, že z každej izby vedie (najviac) jeden tunel do hlbšej izby. Keď sa v takejto nore Marián v niektorej izbe rozhoduje, kam si má ľahnúť a následne kam utiecť, má jednoduchú optimálnu stratégiu -- ľahne si do najhlbšej izby v nore, po príchode žaby utečie do tej v ktorej začal; vyššie vyjsť nemôže, smerom nadol je najviac vzdialená predsa najhlbšia izba. Tá bude mať v prvej sade vždy hĺbku $n$ (keďže sa nora nerozvetvuje, ale stále iba klesá nadol). Jediné, čo teda potrebujeme zistiť, je pre každú izbu, ako hlboko vlastne je -- označme si hĺbku i-tej izby $h_i$; odpoveď pre izbu $i$ bude $n-h_i$.

Hĺbku každej izby vieme zistiť jednoduchým prehľadávaním do hĺbky -- nastavíme hĺbku izby $l$ na $1$, začneme z nej prehľadávať a izbe ktorá je s ňou spojená nastavíme hĺbku $2$. Následne pokračujeme v prehľadávaní z nej, teda izbe ktorá je spojená s ňou (a nie je to izba $l$) nastavíme hĺbku $3$. Teraz pokračujeme v prehľadávaní z nej, a tak ďalej.

Z každej izby budeme prehľadávať práve raz, teda časová zložitosť je $O(n)$. Noru si môžeme pamätať ako graf so zoznamami susedov pre každý vrchol, pamäťová zložitosť bude teda tiež $O(n)$ (v prvej sade bolo však vrcholov málo, takže ľubovoľná implementácia bola v poriadku).

## Čo nám chýbalo pre rozvetvujúcu noru?

Predstavme si, že Marián si pre zvolenú začiatočnú miestnosť už vybral, kam sa najprv uloží spať. Jeho úniková cesta môže byt len troch rôznych typov:

1. vráti sa do začiatočnej izby a tu ostane

1. prejde cez začiatočnú izbu a bude pokračovať niekam inam

1. do začiatočnej izby sa nevráti a ani cez ňu neprejde

Žiadne iné scenáre sa neodohrajú, takže ak každý z nich rozoberieme, určite sme na nič nezabudli a máme celé riešenie. Pre každú izbu samozrejme povieme najväčší výsledok z hore uvedených možností.

\\medskip

V prvom type cesty utečie Marián rozdiel hĺbok izby v ktorej začal a v ktorej si najprv ľahol. Spočítame si teda hĺbky izieb rovnako ako v predošlom riešení (prehľadávame vždy z každej doteraz nevidenej izby) a pre každú izbu si zapamätáme najväčšiu hĺbku izby, ktorá je v jej podstrome -- označme si túto hodnotu i-tej izby $maxh_i$. Jedna možná odpoveď pre izbu $i$ je teda $maxh_i - h_i$ (v druhom príkladovom vstupe to bola odpoveď napríklad pre izby 1,4,6,7 -- obrázok sa nachádza na konci vzorového riešenia).

Toto riešenie sa však dá triviálne vylepšiť na druhý spomínaný typ cesty, ak je izba **priamo** spojená s aspoň dvoma hlbšími izbami. V takom prípade, po ľahnutí do najhlbšej možnej izby a vrátení sa do začiatočnej, sa Marián naviac poberie cez inú, priamo spojenú hlbšiu izbu a ľahne si do niektorej izby dosiahnuteľnej z nej. Do ktorej izby sa mu oplatí si ľahnúť? Čím hlbšie pôjde Marián cez inú izbu ako tú, pod ktorou si najprv ľahol, tým bude ďalej od žaby. Určite si teda bude chcieť nakoniec ľahnúť v čo najhlbšej izbe, ako sa len dá. Zapamätáme si dve najväčšie $max_h$ izieb s ktorými sme priamo spojení v izbe $i$; nech je to $maxh_j$ a $maxh_k$. Najprv teda pôjdeme z izby $i$ v hĺbke $h_i$ do izby s hĺbkou $maxh_j$ cez izbu $j$. Následne od žaby utečieme tak, že sa vrátime naspäť do izby $i$ (zatiaľ teda vzdialenosť $maxh_j - h_i$) a potom pôjdeme do izby v hĺbke $maxh_k$ cez izbu $k$ -- tým si prilepšíme o vzdialenosť $maxh_k - h_i$. Dokopy sme teda prešli od žaby $maxh_j - h_i + maxh_k - h_i = maxh_j + maxh_k - 2 \\times h_i$ (v druhom príkladovom vstupe to bola odpoveď napríklad pre izby 2,3).

Posledný prípad je taký, že si Marián chce najprv ľahnúť niekam hlbšie a potom utiecť do druhej izby bez toho aby sa vrátil do začiatočnej -- vlastne chce využiť nejakú existujúcu najdlhšiu cestu ktorá neobsahuje tú izbu, v ktorej práve je. To je jednoducho len maximum z už vypočítaných odpovedí všetkých priamo spojených hlbších izieb. Keby v druhom príkladovom vstupe bol od izby 1 tunel do hlbšej izby 8 a od izby 6 tunel do hlbšej izby 9, odpoveď pre izbu 2 je 4 (druhým spôsobom) -- Marián si ľahne napríklad do izby 8 a potom utečie do izby 9. Pre izbu 5 je odpoveď rovnaká -- Marián má na výber buď spôsob 1 (utiecť do najhlbšej izby s hĺbkou o 3 väčšou) alebo využiť už nájdenú odpoveď pre izbu 2 -- a tá je teda lepšia.

\\medskip

Graf si budeme pamätať rovnako ako v riešení prvej sady - ako zoznamy susedov, s konštantne veľa premennými pre každý vrchol navyše ($h_i, maxh_i, odpoved_i$). Pamäťová zložitosť je teda $O(n)$.

Časová zložitosť bude tiež rovnaká -- $O(n)$ -- keďže opäť prehľadávame z každej izby práve raz, a pre každú raz spočítame $h_i, maxh_i$ a $odpoved_i$.
",5
8754043d2f0f7759,ksp,"# Ovce v Koloseu?!

Ráno bitka, na obed bitka, poobede bitka, večer bitka. Napriek tomu, že sledovať súboj gladiátorov na život a na smrť^[aj keď úmrtnosť výrazne klesla po nástupe zdravotníka Anuru] vie byť pomerne zábavný spôsob ako premárniť zopár hodín voľného času^[hlavne preto, že v tých dobách ešte neexistovalo rekreačné súťažné programovanie], takýto program miestny ľud rýchlo omrzel.

Cézar dal teda po krajine rozhlásiť, že sa plánuje spestrenie vystúpení v Koloseu -- organizuje sa prvý ročník šou _Rímska ríša má talent!_. Prvé oficiálne kolo bude už o mesiac priamo v Koloseu -- a rozhodovať bude samotný cézar.

Farmárovi Denisiovi sa splnil sen. Konečne bude môcť zažiariť a ukázať, čo sa v ňom skrýva. Doteraz sa v Koloseu nemal čím predvádzať -- na gladiátorské súboje bol príliš chudý a slabý. Ale s ovcami, s tými si teda rozumie.

Dlhé roky ich vyháňal na pašu a vo voľnom čase ich učil rôzne cirkusové kúsky. Je si však vedomý, že konkurencia bude veľká -- už sa šíria chýry o cestujúcom, ktorý vie chodiť po vode. Aby mal šancu na víťazstvo, musí si Denisius nechať svoje najúžasnejšie ovčie kúsky na neskoršie kolá súťaže. Najlepšie by bolo, keby sa do ďalšieho kola dostal s najmenej nacvičeným trikom -- ovce priučil jednoduchej geometrii a na jeho povel sa chaotické stádo oviec razom rozostaví na najviac dve priamky.

Pred svojim vystúpením by si chcel tento kúsok so svojimi ovcami ešte precvičiť -- ak sa mu nevydarí, určite nepostúpi, a to ho potom cézar dá zožrať levom^[aby aj z nudných vystupujúcich bol dajaký osoh]. Z hľadiska Kolosea sa výkon jeho oviec hodnotí ľahko, keď však Denisius stojí spolu s ovcami na lúke za dedinou, nevidí, či sa jeho ovce naozaj poslušne postavili na najviac dve priamky. Na to potrebuje vašu pomoc!

## Úloha

V Denisiovom stáde je $n$ oviec. Každú ovcu si môžeme predstaviť ako bod v rovine s celočíselnými súradnicami. Dostanete rozostavenie oviec po tom, čo Denisius zadal povel, aby sa postavili na najviac dve priamky. Zistite, či sa im to podarilo.

## Formát vstupu

V prvom riadku je celé číslo $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) -- počet oviec v Denisiovom stáde.

V nasledujúcich $n$ riadkoch sú po dve celé čísla $x_i, y_i$ -- súradnice $i$-tej ovce po tom, čo Denisius dal svoj povel.

Súradnice v absolútnej hodnote neprekročia $10^9$. Žiadne dve ovce nestoja na rovnakých súradniciach.

Sú štyri sady testovacích vstupov. Maximálne hodnoty $n$ v jednotlivých sadách sú nasledovné:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:------:|:------:| | $n \\leq$ | $10$ | $1,000$ | $10,000$ | $200,000$ |

## Formát výstupu

Ak existujú dve priamky také, že každá ovca stojí aspoň na jednej z nich, vypíšte `ANO`. Inak vypíšte `NIE`.

## Príklady

```vstup
6
0 1
3 4
10 11
5 0
6 2
8 6
```

```vystup
ANO
```

_Prvé tri ovce stoja na jednej priamke, posledné tri na druhej:_

```vstup
6
0 1
3 4
9 11
5 0
6 2
8 6
```

```vystup
NIE
```
","# Ovce v koloseu ?!

## Predslov o priamkach

Ešte predtým, ako sa pustíme do samotných algoritmických riešení, musíme vymyslieť ako vlastne budeme reprezentovať priamku a ako potom overíme, či na nej niektorá ovca je alebo nie je.

Priamku si vieme jednoznačne určiť pomocou dvojice bodov, ktoré na nej ležia -- v tejto úlohe teda všetky priamky, ktoré nás môžu zaujímať, budú definované dvoma rôznymi ovcami.

\\medskip

V programoch vzorových riešení sme použili nasledovný spôsob: keď máme dve ovce na súradniciach $(x_1,y_1)$ a $(x_2,y_2)$, priamku si vyjadríme ako prvý bod a smernicu od tohto bodu $(x_2 - x_1, y_2 - y_1)$ = $(d_x,d_y)$. Voľne prerozprávané, smernica nám hovorí že za každý krok dĺžky $d_x$ v kladnom smere $x$-ovej osi máme spraviť krok dĺžky $d_y$ v kladnom smere $y$-ovej osi.

Túto smernicu ešte upravíme do nami definovaného kanonického tvaru -- vydelíme $d_x$ a $d_y$ ich najväčším spoločným deliteľom, ak je $d_x$ záporné vynásobíme ju $-1$ (teda našu smernicu chceme mať v 'kladnom smere'), a ak je $d_x = 0$ tak chceme $d_y$ kladné.

Teraz bod patrí na túto priamku, ak je jeho smernica od prvého bodu rovnaká ako tá, ktorou sme si vyjadrili priamku. Teda napríklad pre ovce $(10,15)$ a $(12,25)$ by sme dostali smernicu $(2,10)$, ktorú upravíme do základného tvaru $(1,5)$ -- čo voľne prerozprávané znamená, že aby niektorá ovca ležala na tejto priamke, musíme sa k nej vedieť dostať tak že začneme na súradniciach prvej ovce a pohybujeme sa tak, že za každý posun v kladnom smere $x$ o $1$ sa posunieme o $5$ v kladnom smere $y$ (posun v zápornom smere je analogický). Teraz napríklad bod $(6,-5)$ na túto priamku patrí -- jeho smernica k prvému bodu je $(6-10,-5 - 15) = (-4,-20)$ čo sa po upravení do kanonického tvaru ($\\rightarrow (-1,-5) \\rightarrow (1,5)$) rovná smernici ktorú sme prvotne vyrátali. Bod $(8,25)$ na túto priamku nepatrí, keďže jeho smernica je $(8-10,25-15) = (-2,10) \\rightarrow (-1,5) \\rightarrow (1,-5)$, čo sa našej smernici nerovná.

\\medskip

Inou možnosťou, ktorá vyžaduje trochu viac znalostí stredoškolskej geometrie, je využiť vektorový súčin -- o ňom sa môžete dočítať v [kuchárke KSP](https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin/).

## Riešenie hrubou silou

Už teda vieme priamku aj reprezentovať, aj overovať, či na nej leží niektorá ovca. Čo nám chýba k riešeniu? Rozmyslieť si, ktoré priamky musíme overiť.

\\medskip

Prvým, najprimitívnejším riešením je jednoducho vyskúšať všetky možné riešenia (dvojice priamok) -- zoberieme postupne všetky štvorice oviec na vstupe, určíme prvú priamku pomocou prvých dvoch oviec vo štvorici a druhú priamku pomocou tretej a štvrtej ovce. Následne spôsobom, ktorý nám je milší, vždy overíme, či všetky ovce zo vstupu patria aspoň na jednu z týchto priamok. Ak sa nám to raz podarí, odpovieme ,,áno'', ak nám to ani raz nevyjde, tak také dve priamky neexistujú -- vyskúšali sme predsa všetky možnosti čo pripadali do úvahy.

\\medskip

Štvoríc oviec je rádovo $O(n^4)$ a overiť pre každú z $n$ oviec, či leží na aspoň jednej z nich, nám zaberie $O(n)$, teda dokopy nám to zaberie $O(n^5)$ času. Pritom nám netreba pamätať si nič viac ako súradnice všetkých oviec, čiže pamätová zložitosť je $O(n)$.

## Riešenie polohrubou silou

Horeuvedené riešenie vieme jednoduchým pozorovaním vylepšiť. Zoberme si ľubovoľnú ovcu -- pre jednoduchosť pokojne prvú zo vstupu. Ak všetky ovce sú na najviac dvoch priamkach, tak aj táto ovca je na jednej z nich. A na akej priamke môže byť? No na priamke určenej ňou a druhou ovcou, alebo ňou a treťou ovcou, ..., alebo ňou a poslednou ovcou. Postupne pre každú ovcu okrem prvej si teda určíme priamku (označme ju $p$) pomocou nej a prvej ovce a overíme ktoré ďalšie ovce na nej stoja.

\\medskip

No a teraz si stačí uvedomiť, že všetky ovce, ktoré neležia na priamke $p$, musia byť na jednej inej priamke $q$ -- tá bude teda určená ľubovoľnými dvomi z nich (napríklad prvými dvomi, o ktorých pri overovaní zistíme, že nepatria na priamku $p$). Zoberieme si teda priamku $q$ a opäť prejdeme všetky ovce (prípadne len tie, o ktorých sme zistili, že neležia na priamke $p$, ak sme si ich niekam ukladali) -- ak potom všetky ovce patria na nejakú priamku ($p$ alebo $q$), zahlásime Denisiov úspech. Inak opäť od začiatku skúšame novú priamku $p$ určenú prvou a ďalšiou ovcou. Ak bez úspechu vyskúšame všetky možné priamky $p$, odpovieme nakoniec ,,nie''.

\\medskip

O koľko sme naše riešenie urýchlili? V prípade, že riešenie neexistuje, vyskúšame rádovo $n$ priamok $p$ -- priamku určenú prvou a druhou ovcou, prvou a treťou, ... , prvou a $n$-tou ovcou. Zakaždým prejdeme všetkých $n$ oviec a overíme či ležia na priamke $p$. Následne určíme priamku $q$ a pre všetky (zvyšné) ovce overíme, či na nej ležia. Aj toto je v najhoršiom prípade zhruba $n$ oviec. Keďže $n$ krát môžeme robiť až $n$ operácií, výsledný odhad časovej zložitosti v najhoršiom prípade je $O(n^2)$. Teraz si už musíme aj zakaždým pamätať, ktoré ovce nestoja na priamke $p$, ktorú práve skúšame. To nám však zaberie len $O(n)$ pamäte, pamäťová zložitosť je teda opäť $O(n)$.

## Vzorové riešenie -- ešte menej priamok!

Stále ešte overujeme príliš veľa priamok. K vzorovému riešeniu nás privedie pozorovanie podobné tomu, ktoré sme spravili v predošlom riešení. Zoberme si ľubovoľné tri ovce -- pre jednoduchosť prvé tri zo vstupu. Predpokladajme, že ovce naozaj stoja na najviac dvoch priamkach a predstavme si, že pre každú ovcu si zaznačíme či leží na prvej alebo na druhej (alebo na oboch, toto však nerobí rozdiel), a pozrime sa na naše tri ovce. Sú len dve možnosti -- buď všetky tri naše ovce ležia na spoločnej priamke (ktorá je jedna z dvoch, na ktorých ležia všetky ovce), alebo dve ovce ležia na jednej z našich dvoch priamok a tretia leží na druhej. V oboch prípadoch platí, že na jednej z priamok stoja aspoň dve z našich troch oviec. Povedané inak, nemôže sa stať, že by existovali dve priamky (také že všetky ovce stoja aspoň na jednej z nich), bez toho aby niektoré dve ovce z našich troch stáli na jednej z nich.

\\medskip

Vzorové riešenie je teda skoro rovnaké ako predošlé -- overíme však len tri možné priamky $p$:

- Priamku určenú prvou a druhou ovcou
- Priamku určenú prvou a treťou ovcou
- Priamku určenú druhou a treťou ovcou

Toto overovanie urobíme rovnako ako v minulom riešení. Ak ani jedna z týchto priamok neuspeje, môžeme spokojne oznámiť, že ovce nestoja na najviac dvoch priamkach.

\\medskip

Overenie priamky nám, neprekvapivo, ešte stále zaberie $O(n)$ času, skúšame ich však iba tri -- čiže konštantne veľa. Časová zložitosť je teda $O(n)$. Pamäť využívame úplne rovnako ako v predošlom riešení, čiže tá je aj do tretice $O(n)$.
",5
29baf78d9d9e3ef0,ksp,"# Zavesme tam niečo!

Izby na internátoch nie sú veľmi zaujímavé. Všetky vyzerajú rovnako -- na jednej stene sú skrine, na druhej okno a balkón, zvyšné dve sú skoro prázdne. Niektorí študenti si na to jednoducho zvyknú a často chodia domov, tí ostatní sa snažia svoje izby trochu zútulniť.

Baška a Olívia sa o to snažili tiež. Doniesli si farebné obliečky na paplóny, kúpili si koberec, oblepili ošarpané poličky pekným papierom a dokonca aj vymaľovali. Keď už boli takmer spokojné, všimli si veľkú prázdnu plochu na stene nad poličkou. Hneď im bolo jasné, že tam treba niečo zavesiť. Zhodli sa, že to bude obraz a že by mal byť veľký, aby zakryl čo najviac z ich steny. Vedeli, akú plochu má ich stena, stačilo už len nájsť k nej dostatočne vhodný obraz.

Vybrali sa preto do obchodu. Obchod bol veľký a bolo v ňom veľa stien a veľa obrazov. Nevedeli sa na žiadnom zhodnúť, tak si ich všetky nafotili, aby si ich mohli v pokoji na izbe pozrieť a vybrať ten najvhodnejší.

## Úloha

Na vstupe dostanete jednu fotku v podobe [ASCII art](https://sk.wikipedia.org/wiki/ASCII_umenie). Vašou úlohou je nájsť na fotografii obraz a zistiť, aký je veľký. Obraz sa skladá z ľubovolných znakov a medzier. Je celý ohraničený obdĺžnikovým rámom. Zvyšok vstupu tvoria medzery a znázorňujú stenu okolo obrazu na fotografii. Veľkosť obrazu je plocha steny, ktorú zakryje, teda jeho výška krát šírka v ASCII znakoch (každý obraz je obdĺžnikový).

## Formát vstupu

Na vstupe je niekoľko rovnako dlhých riadkov ukončených znakom konca riadku. Dĺžka jedného riadku neprekročí 250 znakov. Rám sa skladá zo znakov `+` v rohoch, `-` navrchu a dole a znaku `|` na bokoch. Každý obraz má veľkosť minimálne 1 (do tejto hodnoty sa neráta plocha rámu).

## Formát výstupu

Vypíšte jedno číslo -- veľkosť plochy obrazu bez rámu. Nezabudnite za výsledkom vypísať koniec riadku.

## Príklad

```vstup
                                    
                                    
                                    
                                    
   +---------------------------+    
   |   .-. .-. .----..----.    |    
   |   | |/ / { {__  | {}  }   |    
   |   | |\ \ .-._} }| .--'    |    
   |   `-' `-'`----' `-'       |    
   +---------------------------+    
                                    
                                    
                                    
                                    
                                    

```

```vystup
108
```

*Obraz má šírku $27$ znakov a výšku $4$ znaky, t.j. veľkosť $27\\times 4=108$. Na začiatku sú $4$ riadky plné medzier, pred obrazom sú na každom riadku $3$ medzery a za ním $4$, na konci je ešte $5$ riadkov plných medzier. (Vstup z pdf zadania sa vám možno neskopíruje v správnom formáte)*
","# Zavesme tam niečo!

Ako funguje čítanie vstupu? Štandardne čítame vstup po slovách -- funkcie ako `cin` a `read` nám do premennej uložia _ďalšie_ slovo (alebo číslo) na vstupe.

Každý textový súbor (aj vstup pre naše programy) sa skladá z množstva znakov. Niektoré z nich sú takzvané _prázdne_ znaky (whitespace characters) -- napríklad medzera (`' '`), tabulátor (`'\t'`), znak nového riadku (`'\n'`) alebo aj znak konca súboru (EOF, End Of File). Program tieto prázdne znaky pri čítaní vstupu pomocou horeuvedených funkcií preskakuje. Na to, aby sme vyriešili túto úlohu, musíme postupovať inak...

Vstup musíme čítať buď po jednotlivých znakoch, kedy načítame naozaj každý znak na vstupe samostatne, alebo načítavať celé riadky naraz -- teda načítať znaky, až kým neprídeme k znaku konca riadku.

Ako to ale naprogramovať? Ak ste nič takéto ešte nerobili, na internete rýchlo nájdete odpoveď.

Čítanie celých riadkov je pre nás o niečo pohodlnejšie. V `C++` na to môžeme použiť funkciu `getline(cin, s)`, kde `s` je názov premennej typu `string`. Táto funkcia vracia hodnotu typu `boolean`, ktorá je `true`, ak sa programu podarilo niečo načítať. Ak používame `Pascal`, môžeme použiť funkciu `readln(s)`. Ak by ste potrebovali zistiť, čo presne dané funkcie robia, ľahko nájdete ich presné popisy na internete v _dokumentácií_ daných jazykov, napríklad pre C++ na stránke [cplusplus.com](http://www.cplusplus.com/reference/string/string/getline/).

Keď už vieme vstup načítať, musíme ešte vymyslieť, ako spočítať plochu obrazu. Jedna možnosť je pozerať sa na výskyt znakov `+`, ktoré tvoria rám obrazu. Musíme si však dať pozor, aby nás nepomýlil znak `+` vo vnútri obrazu. Najelegantnejšie to vyriešime tak, že si uložíme súradnice prvého a posledného `+` na vstupe a z nich následne vypočítame plochu obrazu.

Druhou možnosťou je zistiť počet riadkov, ktoré nie sú prázdne, zistiť dĺžku jedného z nich po orezaní medzier na okrajoch a veľkosť dopočítať z týchto dvoch údajov.
",1
3c2e70ed20e879b3,ksp,"# Zved Tigrík

Každý z vás určite pozná ""Súkromné očká"". Podstatnou náplňou ich práce je zhánať informácie. Rozlišujú práve 26 typov informácií a každá z nich má kódove označenie podľa jedného veľkého písmenka abecedy.

V tejto organizácií pracuje aj Tigrík (jeho pravé meno je, samozrejme, iné). Jeho úlohou je zhánať informácie rôznych typov a doniesť ich svojmu šéfovi. Je platený za každý deň samostatne.

Tigrík má práve $n$ tajných zdrojov. Každý z nich má informáciu jedného typu. Za jeden deň vie obehať iba $k$ svojich zdrojov (potrebuje ich stretnúť osobne, inak by mu nič nepovedali).

""Súkromné očká"" sú za svoj deň hodnotení nasledovne: ich šéf si vezme zoznam informácií, ktoré za daný deň doniesol konkrétny zamestnanec a každej priradí spoľahlivosť. Spoľahlivosť jednej informácie je rovná počtu informácii toho istého typu, ktoré dané očko donieslo. Plat, ktorý pracovník za deň dostane, je celkový súčet spoľahlivostí všetkých informácií. Napríklad za prinesenie $3$ informácií typu `A` a $2$ informácie `F` dostane $3+3+3 + 2+2 = 13$ peňazí.

Tigríka by zaujímalo, koľko najviac peňazí môže za konkrétny deň dostať.

## Úloha

Na vstupe dostanete počet Tigríkových tajných zdrojov a počet zdrojov, ktorý dokáže Tigrík za daný deň obehať. Okrem toho dostanete reťazec $n$ znakov, v ktorom $i$-ty znak predstavuje typ informácie $i$-teho zdroja.

Zistite, koľko najviac môže Tigrík za tento deň zarobiť. Nezabudnite správnosť svojho riešenia odôvodniť.

## Vstup

Prvý riadok vstupu obsahuje prirodzené čísla $n$ a $k$ ($1 \\leq k \\leq n \\leq 1,000,000$).

Druhý riadok obsahuje $n$ veľkých písmen anglickej abecedy -- typy informácií, ktoré majú tajné zdroje.

## Výstup

Vypíšte jeden riadok a v ňom jedno číslo -- najväčší súčet spoľahlivostí, aký vie Tigrík dosiahnuť.

## Príklady

```vstup
15 10
DZFDFZDFDDDDDDF
```

```vystup
82
```

```vstup
6 4
YJSNPI
```

```vystup
4
```

*V prvom príklade prinesie 9 krát `D` a raz `Z`. V druhom príklad prinesie informácie 4 rôznych typov.*
","# Zved Tigrík

## Na začiatok jednoduchší prípad

Uvažujme na začiatok jednoduchšiu úlohu: čo ak by $k$ bolo rovné $n$? Vtedy vieme, že Tigrík stihne navštíviť všetky svoje zdroje a treba len spočítať, koľko za tento deň zarobí.

Na to potrebujeme pre každý typ informácie zistiť, koľko zdrojov ju má. Inými slovami, potrebujeme spočítať počet výskytov každého písmena. Toto najľahšie spravíme tak, že pre každé písmeno budeme mať jedno počítadlo. Najlepšie je uložiť si tieto počítadlá do poľa veľkosti $26$ -- toľko je rôznych písmen v anglickej abecede.

Keď to už máme spočítané, tak si stačí uvedomiť, že ak máme $x$ informácií rovnakého typu (teda $x$ výskytov konkrétneho písmena), tak každé z nich má cenu $x$, a dokopy za toto písmeno dostaneme $x\\times x = x^2$ peňazí.

Takže ak sme si spočítali počty výskytov jednotlivých písmen, stačí nám sčítať ich druhé mocniny a máme Tigríkov zárobok.

##Pôvodný problém

Teraz sa vráťme k všeobecnému zadaniu, kedy môže byť $k\<n$. Vtedy musíme zistiť, ktoré zdroje sa Tigríkovi oplatí navštíviť -- inými slovami, ktorých $k$ písmen máme zobrať, aby sme dokopy dostali čo najväčší zárobok.

Myslím, že každý z vás si všimol, že čím viac máme rovnakých písmen, tým viac Tigrík zarobí. Intuícia nám teda napovedá, že Tigrík by mal preferovať tie písmená, ktorých je na vstupe veľa.

Nádejne teda vyzerá nasledovný postup: Tigrík si nájde to písmeno, ktorého je na vstupe najviac, a zoberie čo najviac jeho výskytov. Potom spraví to isté s druhým najčastejším, tretím najčastejším, a tak ďalej, až kým už nemôže zobrať žiadne ďalšie písmeno.

Zamyslime sa najskôr, ako by sme takéto riešenie implementovali. Rovnako ako v prvej časti začneme tým, že si spočítame počty výskytov jednotlivých písmen. Teraz by sme ich potrebovali usporiadať podľa počtu výskytov. Keďže máme len 26 rôznych písmen, je úplne jedno, aký algoritmus na to použijeme. Môžeme použiť štandardné knižničné triedenie (napr. `sort()` v C++) alebo implementovať nejaké vlastné.

Po usporiadaní počtov výskytov už odpoveď vypočítame jednoduchým cyklom (všimnite si, že sa musíme zakaždým pozrieť, či môžeme zobrať všetky písmená daného typu, alebo ich je priveľa a len naplníme našu kapacitu):

Asi najjednoduchšie na implementáciu je triedenie max-sort. Priamo počas neho vieme aj počítať riešenie. Jednoducho postupne 26-krát zopakujeme nasledovný postup: ""Nájdi najčastejšie sa vyskytujúce ešte nespracované písmeno a zober z neho najviac ako sa dá.""

##Dôkaz správnosti

Teraz nás ale čaká tá ťažšia časť tohto vzorového riešenia. Je síce pekné, že sme si vymysleli jednoduché *pažravé*^[Pažravé sa nazýva preto, lebo používa nejakú podmienku, ktorá je založená na maximalite (minimalite) nejakého prvku.] riešenie, ktoré sa nám ľahko implementovalo, čo nám ale zaručí, že toto riešenie je naozaj optimálne? Nemôže sa niekedy stať, že by iný spôsob výberu písmen viedol k väčšiemu celkovému zárobku?

Aby bolo naše riešenie úplné, musíme na tieto otázky vedieť odpovedať. Inými slovami, potrebujeme ešte dokázať správnosť nášho algoritmu.

### Pomocné tvrdenie

Dokážeme si nasledovné tvrdenie: *""Nič nepokazíme, keď z najčastejšieho písmena zoberieme najviac kusov, ktoré môžeme zobrať.""* Inými slovami, tvrdíme, že pre ľubovoľný vstup existuje medzi optimálnymi riešeniami také riešenie, v ktorom Tigrík zoberie najväčší možný počet výskytov najčastejšieho písmena.

Dôkaz: Nech $v$ je počet výskytov najčastejšieho písmena a nech $z$ je celkový počet písmen, ktoré ešte môžeme zobrať. Dôkaz nášho tvrdenia si rozdelíme na dva prípady.

Prípad prvý: $v > z$, teda nemôžeme zobrať všetky výskyty najčastejšieho písmena.

V ľubovoľnom riešení by sme zobrali nejakých $z$ písmen. Keďže každého z nich by sme zobrali najviac $z$ kusov, bol by celkový zisk najviac $z^2$. Viac ako $z^2$ sa zjavne dosiahnuť nedá. No a pri našej stratégii zoberieme $z$ kusov najčastejšieho písmena a dostaneme tak zisk presne $z^2$, čo je zjavne optimálne.

Prípad druhý: $v \\leq z$, teda môžeme zobrať všetky výskyty nášho písmena a možno ešte aj niečo navyše.

Chceme teraz dokázať, že existuje optimálne riešenie, v ktorom Tigrík vezme všetkých $v$ kusov tohto písmena. Toto dokážeme tak, že ukážeme, že k ľubovoľnému riešeniu, v ktorom zoberie *menej ako $v$* kusov, existuje *aspoň tak isto dobré* riešenie, v ktorom ich vezme *viac*.

Uvažujme teda ľubovoľné riešenie, v ktorom Tigrík nezobral $v$ kusov nášho písmena, ale len $w$, pričom $w\<v$.

- Podprípad 2a: Nejakého iného písmena zobral Tigrík $x > w$ kusov.

  V tomto prípade vieme dostať *rovnako dobré* riešenie tak, že zoberieme $x$ kusov nášho a $w$ kusov toho druhého písmena. (Touto zmenou sme *zväčšili* počet zobratých kusov nášho písmena.)

- Podprípad 2b: Každého iného písmena zobral Tigrík $w$ alebo menej kusov.

  Za každé písmeno teraz Tigrík dostane $w$ alebo menej bodov. V tejto situácii vieme vyrobiť *ostro lepšie* riešenie tak, že zahodíme jedno iné písmeno a namiesto neho zoberieme jedno ďalšie naše. Ak tých iných písmen bolo doteraz $x$ (pričom $x \\leq w$), tak zisk klesol o $2x-1$ za odstránené písmeno, ale stúpol o $2w+1$ za písmeno pridané, a teda v súčte aspoň o 2 stúpol. Oplatí sa nám teda vymieňať písmená za tie, ktoré sa tam vyskytujú častejšie.

A tým je dôkaz hotový.

### Záver dôkazu správnosti

Z práve dokázaného pomocného tvrdenia už priamočiaro vyplýva dôkaz správnosti nášho algoritmu. Na začiatku vieme, že existuje optimálne riešenie, v ktorom zoberieme najväčší možný počet výskytov najčastejšieho písmena, tak to urobíme. Na toto písmeno môžeme teraz šťastne zabudnúť. Ostala nám opäť taká istá situácia: máme na výber nejaké písmená a máme nejakú voľnú kapacitu. Teraz môžeme znovu použiť tú istú argumentáciu -- z toho písmena, ktoré je *teraz* najčastejšie, určite môžeme zobrať najviac ako sa dá. A tak ďalej.

##Zložitosti

Načítanie vstupu má časovú zložitosť lineárnu od $n$, čo zapisujeme $O(n)$. Počas toho vieme aj postupne zvyšovať počítadlá písmen. Celý zvyšok riešenia už má konštantnú časovú zložitosť -- rôznych písmen je len 26, a teda na ich usporiadanie podľa počtu výskytov aj na ich následné spracovanie nám stačí konštantný počet krokov, nezávislý od veľkosti vstupu. Výsledná časová zložitosť je teda $O(n)$.

Pamäťová zložitosť je $O(1)$, teda konštantná. Vôbec si totiž nemusíme držať v pamäti celý vstup, stačí si pamätať iba 26 počítadiel a nejaké pomocné premenné.
",4
1a2b50e721a718b7,ksp,"# Och, tie darčeky!

Usáma dostal na Vianoce obrovskú kopu darčekov. A to vôbec nepreháňam! Bolo ich tak veľa, že ich ani nestihol začať rozbaľovať. Usáma totiž vie, že rozbaľovať darčeky nemôže len tak. Musí postupovať podľa špeciálneho, ním patentovaného postupu, ktorý je veľmi zložitý na prípravu.

Po skúsenostiach z predchádzajúcich Vianoc si popri práci zhotovil program, ktorý mu vie o každom darčeku celkom dobre predpovedať, koľko radosti získa z jeho otvorenia^[To viete, ak dostane od rodičov niečo veľkosti svetra, vie takmer na istotu povedať, že ide o sveter. Ale od niekoho iného môže ísť o niečo vskutku exotické.]. Podľa svojho programu si svoje darčeky usporiadal do radu s rastúcou predpovedanou radosťou, dokonca mu to tento rok vyšlo tak pekne, že každý darček mal inú predpovedanú radosť a boli to čísla od $1$ po počet darčekov. Z dĺžky tohto radu sa mu však zamotala hlava a rozhodol sa nechať si otváranie na ďalší deň.

Prišlo vytúžené ráno a Usáma celý naradostený vybehol z postele. Čakalo ho však nemilé prekvapenie. Jeho precízne zostrojený rad bol celý poprehadzovaný. K jeho radu darčekov sa totiž dostala jeho snúbenica Maru a preusporiadala ho podľa kto vie čoho^[Ženy.]. Rozhodol sa, že namiesto toho, aby darčeky začal otvárať preusporiadané, alebo že by medzi nimi pobehoval ako veverička na káve, zoradí si ich tak, aby sa ich poradie páčilo v každom momente aj Maru. Aby s tým nemal toľko roboty, rozhodol sa, že to celé docieli iba vymieňaním dvojíc darčekov.

Začal teda vymieňať dvojice darčekov a všimol si, že občas mu to Maru dovolí, ale občas ich hneď vymení späť. Po chvíli testovania si všimol, že Maru vadí, ak vymieňa darčeky na na určitých dvojiciach pozícií. Pre každú dvojicu pozícií si teda zistil, či mu Maru dovolí vymeniť darčeky na nej, alebo nie.

Keďže Maru nezaujímajú darčeky, ktoré vymieňa, ale len ich pozície, dá sa ľahko oklamať. Predstavme si, že na pozíciách $1$, $2$ a $3$ sú darčeky `A`, `B` a `C`, čo si môžeme značiť ako `(A, B, C)`. Usáma vie, že môže vymeniť darčeky na pozíciách $(1,2)$, $(2,3)$, ale v žiadnom prípade nemôže vymeniť $(1,3)$. Napriek tomu vie dostať stav `(C, B, A)`, akurát ho to bude stáť viac operácií. Najskôr totiž vymení prvý darček z druhým, potom druhý s tretím (v tomto okamihu vyzerá jeho rad ako `(B, C, A)`) a opäť prvý z druhým.

Bohužiaľ, napriek tomu sa jeho darčeky nemusia dať zoradiť do pôvodného stúpajúceho poradia. Rád by sa však k tomuto poradiu aspoň čo najviac priblížil. Pokúste sa mu pomôcť.

## Úloha

Usáma dostal $n$ darčekov. Postupnosť čísiel $1$ až $n$, kde sa každé číslo nachádza práve raz, nazveme permutácia. Na vstupe dostanete permutáciu $n$ čísiel, ktorá predstavuje rad v momente keď sa Usáma zobudil. Pre každú dvojicu pozícií sa naviac dozviete, či môžete vymeniť prvky na týchto pozíciách alebo nie.

Vašou úlohou je nájsť najmenšiu permutáciu, ktorú môžete vytvoriť z permutácie na vstupe len výmenou dovolených dvojíc. Permutácia $A$ je menšia ako permutácia $B$, ak má na prvej pozícii, kde sa tieto dve permutácie líšia, menšiu hodnotu.

Polovica bodov sa dá získať za riešenie, ktoré predpokladá, že ak sa dajú vymeniť darčeky na daných pozíciách nejakou postupnosťou výmen, tak sa dajú vymeniť aj priamo. Príklad z rozprávky túto vlastnosť nemá, keďže prvky na pozíciach $1$ a $3$ sa dajú vymeniť nejakou postupnosťou výmen, ale nie priamo.

## Formát vstupu

Na prvom riadku dostanete číslo $n$ ($1 \\leq n \\leq 1,000$) udávajúce počet čísel v permutácii. V druhom riadku bude $n$ čísel z rozsahu $1$ až $n$, každé práve raz, udávajúce počiatočnú permutáciu.

Nasleduje $n$ riadkov, v každom z nich $n$ číslic, každá buď 0 alebo 1, s nasledujúcim významom: Ak je v $i$-tom riadku a $j$-tom stĺpci 1, tak je možné priamo vymeniť darček na pozícii $i$ s darčekom na pozícii $j$. Môžete predpokladať, že číslo v $i$-tom riadku a $j$-tom stĺpci sa zhoduje s číslom v $j$-tom riadku a $i$-tom stĺpci. Taktiež môžete predpokladať, že v $i$-tom riadku a $i$-tom stĺpci bude vždy 1.

## Formát výstupu

Vypíšte jeden riadok a v ňom $n$ čísel, najmenšiu permutáciu, korú vie Usáma zostrojiť z pôvodnej, vymieňaním iba povolených dvojíc pozícií.

## Hodnotenie

Je päť sád vstupov.

Počet darčekov v týchto sadách je postupne 10, 50, 200, 500, 1000. V prvej, druhej a štvrtej sade navyše platí, že ak sú dve čísla vymeniteľné nejakou postupnosťou výmen, dajú sa vymeniť aj priamo.

## Príklady

```vstup
3
3 2 1
110
111
011
```

```vystup
1 2 3
```

_Darčeky 3 a 1 nemôže Usáma vymeniť priamo, ale môže ich vymeniť pomocou druhého darčeka._

```vstup
3
2 3 1
100
010
001
```

```vystup
2 3 1
```

_Tu si Usáma nijako neporadí, nemôže totiž nič vymieňať._

```vstup
4
2 3 1 4
1001
0110
0110
1001
```

```vystup
2 1 3 4
```
","# Och, tie darčeky!

Riešenie tejto úlohy pozostávalo z viacerých krokov. Najprv sa teda pozrieme, aké riešenie vám stačilo na polovicu bodov a nakoniec sa pozrieme na celý problém.

## Zjednodušená úloha

Ľahšou úlohou bolo vyriešiť problém, pokiaľ pre každú pozíciu vieme bez akýchkoľvek výpočtov povedať, s ktorými pozíciami ju vieme vymeniť. Celkom zjavne najmenšia permutácia vznikne tak, že na jej prvé miesto dáme najmenšie možné číslo. Podobne na každú ďalšiu pozíciu chceme dať najmenšie možné číslo, pričom niektorým číslam sme už priradili ich pozíciu.

To nám dáva priamočiary postup, ako našu permutáciu vygenerovať. Postupne spracujeme pozície zľava doprava. Pre každú pozrieme všetky pozície od nej ďalej, z nich vyberieme pozíciu s najmenším číslom vymeníme čísla na týchto dvoch pozíciach. Takto dostaneme riešenie úlohy v časovej zložitosti $O(n^2)$. Ak navyše riadky matice zo vstupu spracujeme priebežne, bude nám stačiť lineárna pamäťová zložitosť.

Teraz sa na to pozrieme z inej strany. Rozoberme si pozície na skupiny tak, že pozície v jednej skupine sú vymeniteľné každá s každou, ale s nijakou mimo tejto skupiny. Keď teraz začneme vypĺňať našu výslednú permutáciu od prvej pozície, čo môžeme spraviť, je pozrieť sa, do ktorej skupiny daná pozícia patrí a zo všetkých nepoužitých čísel tejto skupiny tam presunúť to najmenšie. Nakoniec si už len všimneme, že v riešení sme čísla vrámci jednej skupiny vlastne usporiadali podobným spôsobom, ako funguje minsort. Neskôr to využijeme.

## Grafy

Tu si rozoberieme, čo budeme rozumieť pod pojmom graf, cesta v grafe a komponent grafu. Ďalej sa pozrieme na prehľadávanie grafu, ktorým budeme hľadať komponenty. Ak sú vám tieto pojmy známe, odporúčam preskočiť túto podkapitolu.

Graf je štruktúra pozostávajúca z vrcholov a hrán, kde hrany spájajú dvojicu vrcholov. Prirovnať si to môžeme k nejakej cestnej sieti, kde vrcholmi budú mestá pospájané asfaltkami.

Postupnosť vrcholov, kde každé dva po sebe idúce vrcholy sú spojené hranou, začínajúcu vrcholom $a$ a končiacu vrcholom $b$, budeme volať cesta medzi $a$ a $b$. Množinu vrcholov, pre ktorú existuje cesta medzi ľubovoľnými dvoma vrcholmi tejto množiny, ale neexistuje žiadna cesta medzi vrcholom z tejto množiny a vrcholom mimo tejto množiny, budeme nazývať komponent grafu.

Ešte si popíšeme, ako zistiť, aké vrcholy ležia v tom istom komponente, ako nejaký zadaný vrchol grafu. Použijeme rekurzívnu funkciu, ktorá ako argument dostane vrchol, ktorý má spracovať a rekurzívne sa zavolá do všetkých ešte neprehľadaných vrcholov, ktoré s ním susedia. K zisteniu, či nejaký vrchol ešte nebol prehľadaný, bude naša funkcia používať jedno globálne pole.

## Permutácia ako graf

Tu sa najprv poriadne popozeráme, ako vlastne môžeme narábať s permutáciou v nezjednodušenej verzii úlohy. K tomu sa na ňu pozrieme ešte z iného uhla, predstavíme si to celé ako graf, ktorého vrcholmi budú pozície v našej permutácii a medzi dvoma pozíciami bude hrana, pokiaľ môžeme ich čísla priamo vymeniť.

Keď sa pozrieme na komponenty takéhoto grafu, zistíme, že vhodnou postupnosťou výmen sme schopní vytvoriť ľubovoľné preusporiadanie čísel v jednom komponente (a celkom zjavne do neho nedokážeme dostať číslo z iného komponentu). Ukážeme si, ako vymeniť ľubovoľné dve čísla v tomto komponente. Pomocou dostatočného počtu takýchto výmen by sme už dokázali bez problémov ľubovoľné rozloženie čísel naozaj zmeniť na ľubovoľné iné.

Vezmime si nejakú cestu medzi pozíciami, ktoré chceme vymeniť. Ak vymeníme čísla na prvej a druhej, potom na druhej a tretej a tak ďalej, až na predposlednej a poslednej pozícii z tejto cesty, docielime, že prvý prvok bude na konci, tam kde ho chceme mať a posledný bude na predposlednej pozícii. Potom môžeme podobne presunúť číslo z predposlednej pozície (čiže to, ktoré bolo pôvodne na konci) na prvú pozíciu, čím naozaj ostanú všetky okrem prvého a posledného čísla na svojej pozícii a prvé a posledné budú vymenené^[Nakreslite si to!].

Tu už len využijeme riešenie ľahšej podúlohy. Stačí nám prehľadaním zistiť, ktoré pozície sú v tom istom komponente a potom v každom komponente usporiadať čísla od najmenšieho po najväčšie, k čomu môžeme použiť ľubovoľný nanajvýš kvadratický algoritmus.

Celé to bude fungovať s časovou zložitosťou $O(n^2)$ a rovnakou pamäťovou zložitosťou.

Existuje ešte aj riešenie s lineárnou pamäťovou zložitosťou, ktoré sme po vás ale nevyžadovali. Mohli ste zaň dostať jeden bonusový bod. Základnou myšlienkou je vhodne si ukladať informáciu o komponentoch a informáciu o vymeniteľnosti pozícií spracovávať priebežne po riadkoch.
",5
1038f3df2b3f5d25,ksp,"# Oporné múry

Bude raz jeden dom. V tom dome bude bývať Samko. Keď ho postavia. A za tým domom bude kopec. Ten kopec tam dokonca je už teraz. A je to strmý kopec. A ako to už so strmými kopcami býva, vždy je pri ňom riziko zosuvu pôdy. Samkovi by sa, samozrejme, takýto zosuv nepáčil (keďže by mu mohol poškodiť jeho dom). Preto sa rozhodol (ešte pred stavbou svojho domu) postaviť na svahu niekoľko oporných múrov, ktoré svah spevnia a zosuvom zabránia.

Nechal si urobiť geodetický prieskum kopca, dlho nad ním hútal a nakoniec naplánoval niekoľko múrov. Každý z týchto múrov bude vodorovný -- pôjde po vrstevnici. Naplánované múry môžu mať rôzne dĺžky (nemusia byť na celú šírku svahu) a môžu byť v rôznych výškach (na rôznych vrstevniciach).

Plný entuziazmu si Samko naplánoval, v akom poradí jednotlivé múry postaví. Ešte v tom istom záchvate entuziazmu si tento plán nechal schváliť na stavebnom úrade. Neskôr, keď nadšenie trochu opadlo, si však uvedomil, že toto poradie možno nie je najšťastnejšie. Pri stavbe múru v strmom svahu sa vám totiž môže občas stať, že sa vám nejaký ten betónový kváder vymkne spod kontroly a skotúľa sa dolu kopcom. To je už samo o sebe trochu nepríjemné, oveľa horšie však je, ak cestou narazí na nejaký iný, už postavený múr (snáď netreba vysvetľovať prečo).

Samko má už plán stavby schválený na úrade a nemôže sa len tak rozhodnúť, že múry postaví v inom poradí. Môžete mu však aspoň povedať, pri stavbe ktorých múrov hrozí, že by mu uvoľnený kus betónu poškodil nejaký nižšie položený, skôr postavený múr. Pri týchto múroch si potom bude na svoje betónové kvádre dávať špeciálny pozor.

## Úloha

Pre účely tejto úlohy si svah budeme predstavovať ako naklonenú rovinu (uhol naklonenia nie je podstatný). Na popisovanie miest na svahu si zavedieme nasledovnú súradnicovú sústavu: vrstevnica tvoriaca úpätie svahu bude $x$-ová os a jedna zo spádnic bude $y$-ová os, pričom $y$-ová súradnica bude rásť s rastúcou nadmorskou výškou. Múry teda budú v našom súradnicovom systéme zodpovedať úsečkám rovnobežným s $x$-ovou osou.

Hovoríme, že múr $A$ _ohrozuje_ múr $B$, ak je možné z nejakej časti múru $A$ pustiť kameň tak, aby sa skotúľal a narazil do múru $B$ (pričom kamene sa kotúľajú po spádniciach). Formálne, múr $A$ ohrozuje múr $B$, ak je na vyššej $y$-ovej súradnici ako múr $B$ a ich kolmé projekcie na os $x$ majú prienik kladnej dĺžky (prienik v jednom bode teda nestačí).

Dostanete popis jednotlivých múrov a poradie, v akom ich Samko bude stavať. O múre $C$ povieme, že je _riskantný_, ak existuje nejaký múr $D$ taký, že $C$ ohrozuje $D$, ale múr $D$ bude postavený skôr než múr $C$. Pre každý múr rozhodnite, či je riskantný, alebo nie.

## Formát vstupu

Prvý riadok vstupu obsahuje jedno celé číslo $n$ ($1 \\leq n \\leq 100,000$) -- počet múrov. Nasleduje $n$ riadkov, každý z nich popisuje jeden múr. Popis jedného múru sa skladá z troch medzerami oddelených celých čísel $x\_{i,1}$, $x\_{i,2}$, $y_i$, ktoré znamenajú, že daný múr je úsečka s koncovými bodmi $(x\_{i,1},y_i)$ a $(x\_{i,2}, y_i)$. Pri každom múre bude pre tieto čísla platiť $-10^9 \\leq x\_{i,1} < x\_{i,2} \\leq 10^9$ a $0 \\leq y_i \\leq 10^9$. Navyše platí, že všetky múry sú navzájom disjunktné. Inými slovami, žiadne dva múry nemajú spoločný bod.

Múry si očíslujme $1, 2, \\dots, n$ v poradí, v akom sú uvedené na vstupe. Posledný riadok vstupu obsahuje medzerami oddelené čísla múrov v poradí, v akom ich Samko bude stavať. Každé z čísel $1, 2, \\dots, n$ sa v poslednom riadku vstupu vyskytne práve raz.

## Formát výstupu

Pre každý múr (v poradí, ako sú očíslované) vypíšte jeden riadok obsahujúci slovo `ANO` ak je daný múr riskantný, resp. `NIE`, ak nie je riskantný.

## Príklady

```vstup
5
1 6 1
6 9 6
-1 2 4
5 8 3
3 6 4
5 1 3 2 4
```

```vystup
NIE
NIE
ANO
ANO
NIE
```

_Po postavení všetkých múrov bude svah vyzerať nasledovne:_

_Múry budú postupne pribúdať takto:_

_Stavba múrov č. 5 a 1 bude bez rizika. Pri stavbe múru č. 3 hrozí poškodenie múru 1. Následná stavba múru č. 2 je opäť bez rizika. Nakoniec, pri stavbe múru 4 hrozí poškodenie múru 1. Riskantné sú teda múry č. 3 a 4._
","# Oporné múry

## Naivné riešenie

Jedno možné priamočiare riešenie je postupne simulovať stavanie jednotlivých múrov. Počas simulácie si budeme pamätať zoznam všetkých už postavených múrov. Vždy, keď postavíme nejaký múr $A$, overíme, či je riskantný. To urobíme jednoducho tak, že pre všetky múry postavené skôr než $A$ skontrolujeme, či ich $A$ ohrozuje.

Ostáva ešte doriešiť ako skontrolovať, či múr $A$ ohrozuje nejaký iný múr $B$.

Pozícia múru $M$ je daná trojicou čísel $x\_{M,1}, x\_{M,2}, y_M$. Aby sme overili, či nejaký múr $A$ ohrozuje iný múr $B$, potrebujeme podľa zadania skontrolovať dve veci:

1. Či je múr $A$ na vyššej $y$-ovej súradnici než $B$.
1. Či sa projekcie múrov na $x$-ovú os prekrývajú.

Prvá z týchto podmienok sa dá formálne napísať ako $y_A > y_B$ a druhá sa dá po kratšom zamyslení napísať ako $x\_{A, 2} > x\_{B, 1} \\land x\_{A, 1} < x\_{B, 2}$ (kde $\\land$ znamená logický AND). Obe tieto podmienky vieme teda overiť v konštantnom čase.

### Zložitosť

Keď staviame prvý múr, nemusíme kontrolovať nič. Keď staviame druhý, musíme overiť, či neohrozuje ten prvý. Keď staviame tretí, musíme urobiť dve overenia, atď. Dokopy teda budeme robiť $0 + 1 + 2 + \\dots + n-1 = \\frac{(n-1)(n)}{2}$ overení, či nejaký múr ohrozuje nejaký iný múr. To nám zaberie $O(n^2)$ času.

Okrem toho musíme ešte načítať vstup ($O(n)$ času) a pri stavaní každého múru ho pridať do zoznamu postavených (dokopy tiež $O(n)$ času). Celková časová zložitosť teda bude $O(n^2)$.

Pamäťová zložitosť je lineárna: pamätáme si vstup ($O(n)$ pamäte), zoznam už postavených múrov (tiež $O(n)$ pamäte) a ešte konštantný počet pomocných premenných.

## Vzorové riešenie

Podobne ako v predošlom riešení, budeme simulovať stavanie múrov a popri tom kontrolovať, či je práve stavaný múr riskantný. Budeme si však pamätať inú informáciu a kontrolu riskantnosti budeme robiť šikovnejšie.

Os $x$ (vrstevnicu na úpätí kopca) si môžeme nasekať na kúsky jednotkovej dĺžky. Pre každý takýto dielik sa potom môžeme pýtať otázku:

""Ak sa postavíme na tento dielik a pozrieme sa po spádnici smerom nahor, uvidíme priamo nad nami nejaký múr? Ak áno, ako vysoko bude najnižší takýto múr?""

Keďže všetky súradnice na vstupe sú celočíselné, odpoveď na túto otázku bude v rámci jedného dielika všade rovnaká. Mohli by sme si teda vytvoriť pole, v ktorom by sme si pre jednotlivé dieliky pamätali odpovede na našu otázku (výšku najnižšieho múru nad daným dielikom alebo nekonečno, ak taký múr neexistuje). Samozrejme, nemôžeme si pamätať _všetky_ dieliky na $x$-ovej osi (keďže tá je nekonečná). Našťastie, nám budú stačiť iba tie, nad ktorými má šancu byť nejaký múr (čo sú podľa obmedzení zo zadania dieliky ležiace v intervale $[-10^9, 10^9]$). To, že je to stále trochu veľa (dve miliardy dielikov), vyriešime neskôr.

Na začiatku simulácie sú teda v našom poli samé nekonečná (keďže ešte nič nie je postavené).

Keď staviame múr vo výške $y$ s $x$-ovými súradnicami koncov $x_1, x_2$, stačí sa nám do nášho poľa pozrieť na dieliky, ktoré ležia v intervale $[x_1, x_2]$. Ak na niektorom z týchto dielikov nájdeme číslo menšie než $y$, znamená to, že pod múrom, ktorý práve staviame, je už niečo postavené, a teda je riskantný. Ak bude na všetkých dielikoch číslo väčšie než $y$, potom náš múr nie je riskantný.

Následne ešte musíme naše pole aktualizovať: všetkým dielikom z intervalu $[x_1, x_2]$, ktoré si pamätali číslo väčšie než $y$ (prípadne nekonečno) zmeníme ich hodnotu na $y$.

Takto sme sa dopracovali k riešeniu, kde pri stavbe každého múru potrebujeme skontrolovať (a následne aktualizovať) nanajvýš dve miliardy prvkov poľa. To je ešte pomalšie než naivné riešenie, spotrebuje však o to viac pamäte. Dá sa to však zachrániť.

### Kompresia súradníc

Najprv vyriešme problém s príliš veľkým poľom. Uvedomme si, že nás v skutočnosti nezaujímajú presné $x$-ové súradnice múrov -- potrebujeme iba vedieť, ktoré dvojice múrov sa v $x$-ovom smere prekrývajú. Na to nám stačí vedieť, v akom poradí budú zaujímavé body (začiatky a konce múrov), ak ich budeme čítať zľava doprava.

Predstavme si, že by sme všetkým múrom zmenili $x$-ové súradnice začiatkov aj koncov na nejaké iné, tak, aby sa zachovalo pôvodné poradie, teda aby platilo:

- Ak bol nejaký bod (začiatok, alebo koniec múru) $R$ pôvodne naľavo od nejakého iného bodu $S$, aj v nových súradniciach bude $R$ naľavo od $S$.

- Ak bol bod $R$ na rovnakej $x$-ovej súradnici ako $S$, aj po novom budú na rovnakej $x$-ovej súradnici.

Dostali by sme síce trochu inú situáciu, ale principiálne by vyzerala rovnako -- tie isté dvojice múrov by sa prekrývali. To znamená, že aj riskantnosť múrov by bola rovnaká, teda zmenené zadanie by malo rovnaké riešenie, ako to pôvodné.

Presne to aj spravíme. Konkrétne to urobíme tak, aby všetky $x$-ové súradnice boli po novom z rozsahu $0$ až $2n-1$. To sa určite dá, keďže zaujímavých bodov je presne $2n$ a niektoré z nich ešte môžu byť na rovnakej $x$-ovej súradnici.

Technicky to bude vyzerať tak, že všetky začiatky a konce múrov (vždy s pribaleným číslom daného múru) si spolu utriedime podľa $x$-ovej súradnice. Následne ich všetky prejdeme zľava doprava a prečíslujeme (zmeníme im súradnice): doteraz najľavejšia $x$-ová súradnica bude odteraz 0, druhá najľavejšia bude 1, a tak ďalej. Pri tom si ešte musíme dávať pozor, aby sme bodom s rovnakou $x$-ovou súradnicou dali aj po novom rovnakú. Celá táto maškaráda nám zaberie $O(n \\log n)$ času, keďže musíme triediť (okrem toho robíme už len konštantný počet lineárnych prechodov).

Dostali sme sa do situácie, keď sú všetky $x$-ové súradnice z rozumne malého rozsahu, takže namiesto nášho dvojmiliardového poľa nám už stačí iba pole veľkosti $2n$. S takýmto poľom bude mať náš algoritmus časovú zložitosť $O(n^2)$, keďže pri stavaní jedného múru potrebujeme skontrolovať nanajvýš $2n$ prvkov poľa. Pamäťová zložitosť bude $O(n)$, teda v čase aj pamäti sme sa dostali na úroveň naivného riešenia.

### Intervalový strom

Teraz skúsme náš algoritmus zrýchliť. Všimnime si, že v našom poli robíme počas behu algoritmu dva druhy operácií:

- Nájdi v poli najmenšie číslo s indexom z intervalu $\[x_1, x_2)$.
- Všetky prvky s indexami z intervalu $\[x_1, x_2)$, ktoré sú väčšie než $y$, zmeň na $y$.

Skúsenejší riešitelia si pravdepodobne spomenú, že na takéto operácie existuje špeciálna dátová štruktúra -- intervalový strom. Konkrétne budeme potrebovať minimový intervalový strom s lazy propagation (keďže chceme meniť celý interval naraz). Táto dátová štruktúra dokáže simulovať pole, v ktorom obe uvedené operácie dokáže robiť v logaritmickom čase od počtu prvkov poľa. Ak túto dátovú štruktúru ešte nepoznáte, prečítajte si v našej Kuchárke najskôr o [základnom intervalovom strome](https://ksp.sk/kucharka/intervalovy_strom) a potom aj o [lazy intervalovom strome](https://ksp.sk/kucharka/lazy_intervalovy_strom).

### Zložitosť

Keď namiesto obyčajného poľa použijeme intervalový strom, budeme schopní postaviť jeden múr v čase $O(\\log n)$, keďže pri stavbe múru potrebujeme spracovať iba dve požiadavky do nášho intervalového stromu. Celá simulácia stavby nám teda bude trvať $O(n \\log n)$ času. Kompresia súradníc nám tiež trvala $O(n \\log n)$ času a načítanie vstupu je lineárne, celý algoritmus má teda časovú zložitosť $O(n \\log n)$.

Pamäťová zložitosť bude $O(n)$, keďže si pamätáme vstup a intervalový strom so zhruba $2 n$ listami.

## Iné riešenie

Iné riešenie, tiež v čase $O(n \\log n)$, dostaneme, ak v predošlom riešení vymeníme úlohy času a $y$-ovej súradnice. Múry by sme teda nespracovávali v poradí stavby, ale podľa $y$-ovej súradnice od najnižšiehio po najvyšší. V intervalovom strome si potom budeme pamätať odpovede na otázku ""Kedy najskôr bude nad týmto dielikom postavený múr?"", pričom vždy berieme do úvahy iba tie múry, ktoré sme už spracovali.

## Ešte iné riešenie (doplnil Mišof)

Predstavme si, že kým staviame prvú polovicu múrov, farbíme ich na modro, a keď staviame druhú polovicu múrov, tie už farbíme na červeno. Ak existuje nejaká dvojica múrov, z ktorých druhý ohrozuje prvý, tak sú len tri možnosti: tvoria ju dva modré múry, tvoria ju dva červené múry, alebo nejaký červený múr ohrozuje nejaký modrý múr

Naše nové riešenie bude založené na princípe *rozdeľuj a panuj*. Spravíme v ňom nasledovné:

1. Ak máme viac ako jeden modrý múr, rekurzívnym volaním nájdeme všetky riskantné múry medzi modrými múrmi.
1. Ak máme viac ako jeden červený múr, rekurzívnym volaním nájdeme všetky riskantné múry medzi červenými múrmi (čiže všetky červené múry, ktoré ohrozujú iný, skôr postavený červený múr).
1. Nejak šikovne pre každý červený múr zistíme, či neohrozuje nejaký modrý.

Ako vieme šikovne spraviť krok 3?

Všetky múry si usporiadame podľa výšky zdola hore. V tomto poradí ich následne spracujeme. Počas spracúvania si udržiavame zjednotenie už spracovaných modrých múrov. Na to nám stačí buď intervalový strom, alebo si napríklad môžeme toto zjednotenie pamätať ako usporiadanú množinu (set) disjunktných intervalov. No a vždy, keď spracúvame červený múr, pozrieme sa, či má neprázdny prienik so zjednotením dovtedy spracovaných modrých.

Akú to má dokopy časovú zložitosť? Podobá sa to tak trochu na MergeSort: tiež robíme dve rekurzívne volania na problém polovičnej veľkosti. MergeSort však navyše spraví len $O(n)$ práce, zatiaľ čo naše riešenie jej počas zametania v kroku 3 spraví až $O(n\\log n)$. A tento ""logaritmus navyše"" ostane aj vo výsledku: zatiaľ čo časová zložitosť MergeSortu výjde $O(n\\log n)$, tento náš algoritmus má časovú zložitosť $O(n\\log^2 n)$. Toto riešenie tiež stačilo na plný počet bodov.
",10
d1c620742bc33bb6,ksp,"# Yvettin Ementál Neschopnosti

Yvette sa na klávesnici pokazil medzerník. Hneď o tom aj napísala svojej kamarátke Xénii. Samozrejme, v rámci dobrých zvykov, bez diakritiky, interpunkcie a veľkých písmen:

```
ahojxenianeuverisalepokazilsamimedzernik
```

Lúštenie tejto správy Xénii chvíľku trvalo, no celkom sa jej to zapáčilo. Odpísala teda:

```
jeeejtojesrandapodmesipisatbezmedzier
```

Yvette lúštenie správy spočiatku veľmi nešlo. ""To je nad moje mentálne schopnosti,"" pomyslela si. Nakoniec však správu rozlúštila, a keďže nechcela Xéniu sklamať, odpovedala:

```
takdobrelendufamzetonebudenadmojementalneschopnosti
```

Táto správa Xéniu úprimne zmiatla. ""Nad môj Ementál Neschopnosti? Čo to je? Už som počula o Prsteni Neviditeľnosti, Opasku Sily, aj Papučiach Obratnosti, ale o Ementáli Neschopnosti som ešte nepočula.""

Po chvíli zmätku a dvoch telefonátoch dievčatá pochopili, že ak si budú písať bez medzier, občas sa nejaká správa bude dať rozdeliť na slová viacerými spôsobmi. Preto sa rozhodli, že pri písaní budú používať iba obmedzenú množinu slov, tak, aby sa im toto nemohlo stať. Ako však zistiť, či je nejaká množina slov dobrá?

## Úloha

Majme zoznam $k$ rôznych slov. Dve rôzne postupnosti slov zo zoznamu budeme volať _dvojičky_, ak zreťazením slov z jednej postupnosti vznikne rovnaký reťazec ako zreťazením slov druhej postupnosti. Napríklad, ak by náš zoznam obsahoval slová {`emental`, `mentalne`, `moj`, `moje`, `neschopnosti`, `schopnosti`}, postupnosti (`moje`, `mentalne`, `schopnosti`) a (`moj`, `emental`, `neschopnosti`) sú dvojičky. Slová sa môžu v rámci postupností aj opakovať, postupnosti však musia byť rôžne. Teda napríklad postupnosť (`moje`, `mentalne`, `schopnosti`, `moje`, `moje`) je dvojička s postupnosťou (`moj`, `emental`, `neschopnosti`, `moje`, `moje`), ale postupnosti (`moj`, `moje`) a (`moj`, `moje`) dvojičky nie sú, lebo nie sú rôzne.

Vašou úlohou bude pre zadaný zoznam slov rozhodnúť, či preň existujú nejaké dvojičky.

## Formát vstupu

Aby sme vám sťažili náhodné hádanie správnych odpovedí, v jednom vstupnom súbore bude niekoľko zadaní úlohy.

V prvom riadku bude jedno celé číslo $t$ ($1 \\leq t \\leq 10$) -- počet zadaní, ktoré máte vyriešiť. Ďalej je na vstupe $t$ zadaní, každé z nich má nasledujúci formát.

V prvom riadku zadania je jedno celé číslo $k$ ($1 \\leq k \\leq 200,000$) -- počet slov v zozname. Nasleduje $k$ riadkov, každý z nich obsahuje jeden neprázdny reťazec tvorený malými písmenami anglickej abecedy (`a`-`z`) -- jedno slovo zo zoznamu. Všetky tieto slová sú navzájom rôzne.

Súčet dĺžok všetkých slov vo vstupnom súbore (teda zo všetkých $t$ zadaní dokopy) označme $N$. Bude platiť $N \\leq 200,000$.

## Formát výstupu

Pre každé zadanie zo vstupu vypíšte (v rovnakom poradí) jeden riadok. Ak pre zadaný zoznam slov existujú dvojičky, riadok nech obsahuje iba slovo `ano`, ak neexistujú, riadok nech obsahuje iba slovo `nie`.

## Hodnotenie

Vaše programy budeme testovať na štyroch skupinách testovacích vstupov. Pre jednotlivé skupiny budú platiť nasledujúce obmedzenia:

| Skupina | 1 | 2 | 3 | 4 | |:------------------ | -------: | ---------: | ----------: | ----------: | | $1\\leq N\\leq$ | $100$ | $2,000$ | $200,000$ | $200,000$ | | $1\\leq k\\leq$ | $20$ | $100$ | $100$ | $200,000$ |

Súčet dĺžok všetkých slov v **jednom** zadaní označme $n$. Vo vašich riešeniach uvádzajte časovú zložitosť vášho algoritmu v závislosti od parametrov $n$ (celková dĺžka slov v zozname) a $k$ (počet slov v zozname), teda nie od parametrov $t$ a $N$.

Okrem toho uveďte aj odhad časovej zložitosti vášho algoritmu iba v závislosti od parametra $n$. Ak by teda napríklad váš algoritmus bežal v čase $O(n^2k^3)$, môžete uviesť, že beží v čase $O(n^5)$ (keďže $k \\leq n$ na každom vstupe).

## Príklad

```vstup
3
6
emental
mentalne
moj
moje
neschopnosti
schopnosti
4
korespondencny
seminar
z
programovania
4
aaa
aaab
bc
caaa
```

```vystup
ano
nie
ano
```

*Najkratšie dvojičky v poslednom zadaní sú postupnosti (`aaab`, `caaa`) a (`aaa`, `bc`, `aaa`).*
","# Yvettin Ementál Neschopnosti

Začnime jednoduchým pozorovaním: ak pre daný zoznam slov existujú nejaké dvojičky, určite existujú aj také dvojičky, ktoré začínajú rôznymi slovami, aj končia rôznymi slovami (túto vlastnosť budú spĺňať napríklad najkratšie dvojičky -- ak by mali rovnaké prvé slovo, mohli by sme toto slovo vynechať a dostali by sme kratšie dvojičky, rovnako, ak by mali rovnaké posledné slovo). Na vyriešenie úlohy nám teda stačí zistiť, či existujú dvojičky, ktorých prvé aj posledné slová sú rôzne. Všetky algoritmy v tomto vzoráku budú hľadať práve takéto dvojičky.

Dvojičky by sme mohli konštruovať nasledujúcim postupom:

1. Nájdeme v zozname dve slová $u, v$ také, že $u$ je prefixom $v$. Tieto dve slová si zapíšeme do dvoch riadkov (každé do jedného) tak, aby ich začiatky boli zarovnané pod seba. Platí teda, že ak sú dve písmená napísané nad sebou, sú to rovnaké písmená.

1. Kým platí, že naše riadky sú rôzne dlhé, robíme nasledujúci krok:

   2.1. Nájdeme v zozname nejaké vhodné slovo $w$ a dopíšeme ho na koniec kratšieho riadka. Slovo $w$ musí byť také, aby aj po jeho dopísaní platilo, že písmená, ktoré sú pod sebou, sú rovnaké.

1. Keď dospejeme k tomu, že oba riadky sú rovnako dlhé, našli sme dvojičky (slová, ktoré sme zapísali do prvého riadku, tvoria prvú z nich a slová, ktoré sme zapísali do druhého, tvoria druhú).

Pre zoznam slov {`emental`, `mentalne`, `moj`, `moje`, `neschopnosti`, `schopnosti`} by teda prvé tri kroky mohli vyzerať takto:

```
moj
moje

mojemental
moje

mojemental
mojementalne
```

Tento postup ešte nie je deterministický algoritmus -- nie je jasné, ako máme zvoliť počiatočné slová $u, v$, (ak by sme mali viac možností), ani ako máme v druhom kroku voliť slovo $w$.

Platí však, že ak dvojičky existujú, pri vhodných voľbách $u,v$ a $w$ ich našim postupom vieme zostrojiť. Naopak, ak neexistujú, potom potom sa nám to pri žiadných voľbách $u, v$ a $w$ nepodarí (buď sa zasekneme na tom, že v zozname nie je vhodné slovo, alebo sa nikdy nedostaneme z druhého kroku). Na vyriešenie našej úlohy nám teda stačí zistiť, či existujú vhodné voľby slov zo zoznamu, ktoré by viedli k nájdeniu dvojičiek.

Všetky možnosti volieb $u, v$ a $w$, vyskúšať nevieme, lebo ich môže byť nekonečne veľa (napríklad pre zoznam slov {`c`, `ca`, `aa`, `ab`, `ba` `bb`} sa náš postup v druhom kroku zacyklí, pričom si vždy môže vybrať z dvoch možných $w$). Namiesto toho založíme naše riešenie na nasledujúcich pozorovaniach.

To, či je v nejakom momente nášho postupu ešte možné doplniť naše dva riadky na dvojičky, závisí iba na rozdieli našich riadkov, teda na postupnosti písmen, o ktorú je dlhší riadok dlhší. Tento rozdiel si nazvime _stav_. Ak sme napríklad zatiaľ napísali

```
mojemental
moje
```

povieme, že sme v stave `""mental""`. Môžeme si všimnúť, že každý stav, od ktorého sa môžeme dostať, je sufixom nejakého slova zo zoznamu. To znamená, že rôznych možných stavov je $O(n)$.

Na celú úlohu sa môžeme pozerať ako na grafový problém: vrcholy sú stavy a hrana zo stavu $A$ do stavu $B$ vedie práve vtedy, keď v zozname existuje slovo $w$, ktorého napísaním by sme sa dostali zo stavu $A$ do stavu $B$. Tie stavy, do ktorých sa dá dostať prvým krokom nášho postupu, nazvime _začiatočné_. Naším cieľom je zistiť, či sa z nejakého začiatočného stavu dá dostať do stavu `""""` (prázdny reťazec), keďže tento stav zodpovedá tomu, že naše dva riadky sú rovnako dlhé.

## Prvé riešenie

Na grafe stavov urobíme [prehľadávanie do šírky](https://www.ksp.sk/kucharka/bfs). Graf si nebudeme konštruovať explicitne, ale podľa potreby za behu. Budeme si udržiavať množinu stavov, do ktorých sa dá dostať, ako množinu reťazcov. Okrem toho budeme mať aj frontu stavov, do ktorých sa dá dostať a ešte sme sa z nich nešírili.

Pre dvojicu slov $x, y$ takú, že $x$ je prefix $y$, budeme notáciou $y - x$ značiť slovo, ktoré dostaneme, keď zo slova $y$ zmažeme prefix $x$.

Na začiatku sa pre každú dvojicu slov $u, v$ zo zoznamu pozrieme, či $u$ nie je prefixom $v$. Ak je, pridáme do množiny dosiahnuteľných stavov, aj do fronty, slovo $v - u$. Týmto sme našli všetky začiatočné stavy.

Následne vyberáme stavy z fronty a z každého z nich sa šírime. Keď vyberieme z fronty nejaký stav $s$, prejdeme celý zoznam slov a hľadáme v ňom také, ktorým je $s$ prefixom, prípadne ktoré sú prefixom $s$.

- Keď nájdeme nejaké slovo $w$, ktorého je $s$ prefixom, znamená to, že zo stavu $s$ sa dá ísť do stavu $w - s$.
- Keď nájdeme nejaké slovo $w$, ktoré je prefixom $s$, znamená to, že z $s$ sa dá ísť do $s - w$.

V oboch prípadoch sa pozrieme, či tento nový stav (teda $w - s$, alebo $s - w$) už máme v množine objavených stavov. Ak nie, pridáme ho tam a pridáme ho aj do fronty nerozšírených stavov.

Takto pokračujeme, až kým sa nám nevyprázdni fronta, alebo kým neobjavíme stav `""""` (prázdny reťazec). Dvojičky existujú práve vtedy, ak sme počas prehľadávania objavili stav `""""`.

Tento algoritmus prehľadá graf stavov korektne, keďže ide iba o jemne exotickú implementáciu prehľadávania do šírky.

### Zložitosť

Pri hľadaní začiatočných stavov porovnávame každé slovo $v$ zo zoznamu s každým možným slovom $u$. Slová v zozname sú dokopy dlhé $n$, pre jedno $v$ teda toto porovnávanie teda zaberie $O(n)$ času. Pri porovnávaní nájdeme pre jedno $v$ nanajvýš $k$ vhodných slov $u$, pre ktoré vznikne začiatočný stav $v - u$. Každý z týchto začiatočných stavov je dlhý $O(n)$ a treba ho pridať (ak tam ešte nie je) do množiny dosiahnuteľných stavov, ktorá obsahuje $O(n)$ reťazcov dlhých $O(n)$. Ak množinu stavov implementujeme pomocou vyváženého vyhľadávacieho stromu (ako napríklad `std::set<std::string>` v C++), jedno vyhľadávanie/vkladanie do nej bude vyžadovať $O(\\log n)$ porovnaní trvajúcich $O(n)$. To znamená, že pridávanie jedného začiatočného stavu (resp. kontrola, že už bol objavený) trvá $O(n \\log n)$. Pridanie všetkých začiatočných stavov objavených pri danom $v$ teda bude trvať $O(kn \\log n)$. Jedno $v$ teda spacujeme v čase $O(kn \\log n + n) = O(kn \\log n)$. Všetky $v$ nám budú trvať $O(k^2n \\log n)$.

Pri rozširovaní sa z nejakého stavu $s$ je situácia podobná: musíme porovnať $s$ s každým možným $w$, čo nám zaberie $O(n)$ času. Pritom nájdeme $O(k)$ hrán, pre každú z nich musíme overiť, či sa nejaký nový stav dlhý $O(n)$ nachádza v množine objavených. To zaberie dokopy $O(kn \\log n)$. Na rozšírenie jedného stavu teda minieme $O(kn \\log n + n) = O(kn \\log n)$ času. Keďže možných stavov je $O(n)$, dokopy sa budeme rozširovať $O(n)$-krát, teda naše prehľadávanie do šírky bude trvať $O(kn^2 \\log n)$.

Keďže $k \\leq n$, časová zložitosť celého algoritmu je $O((kn^2 \\log n) + (k^2n \\log n)) = O(kn^2 \\log n)$. Ak by sme množinu stavov implementovali efektívnejšou dátovou štruktúrou, napríklad [písmenkovým stromom](https://en.wikipedia.org/wiki/Trie), zložitosť by bola $O(kn^2)$ (keďže v písmenkovom strome vieme slová dĺžky $n$ vyhľadávať/pridávať v $O(n)$). Trochu náročnejšou analýzou sa dá náš odhad zložitosti ešte spresniť na $\\Theta\\left(n^2 \\min\\left(k, \\sqrt{n}\\right)\\right)$.

## Lepšia reprezentácia stavov

Predošlé riešenie sa dá zrýchliť šikovnejšou reprezentáciou stavov. Vieme, že každý dosiahnuteľný stav je sufixom nejakého slova zo zoznamu. Dá sa teda popísať dvojicou čísel $(i, l)$, kde $i$ je index nejakého slova v zozname a $l$ je dĺžka sufixu.

Všetky operácie, ktoré so stavmi v našom algoritme robíme, vieme efektívne robiť aj s takouto reprezentáciou. Pri hľadaní začiatočných stavov vždy vieme, z ktorých slov $u, v$ jednotlivé stavy vznikajú. To znamená, že pre ne vieme v konštantnom čase vypočítať ich reprezentáciu. Pri šírení sa z nejakého stavu $(i, l)$ si skonštruujeme príslušný reťazec (sufix $i$-teho slova dlhý $l$) a ten porovnávame so slovami v zozname. Vždy, keď nájdeme nejakú hranu, vieme aj v konštantnom čase vypočítať reprezentáciu stavu, do ktorého vedie (keďže vieme, z akého slova daný stav vznikne).

Na reprezentáciu množiny dosiahnuteľných stavov nám stačí pamätať si pre každé slovo $t$ zo zoznamu jedno pole boolovských premenných rovnako dlhé ako $t$. Na $l$-tom indexe v tomto poli si budeme pamätať, či je stav zodpovedajúci sufixu slova $t$ dĺžky $l$ dosiahnuteľný. Keďže slová zo zoznamu sú dohromady dlhé $n$, celková dĺžka týchto boolovských polí bude tiež $n$. Overenie, či je nejaký stav v množine dosiahnuteľných, teraz vieme urobiť v čase $O(1)$, rovnako aj pridanie stavu do množiny dosiahnuteľných.

Všimnime si, že graf, ktorý teraz prehľadávame, je trochu iný, ako v predošlom riešení. Ak totiž dve slová zo zoznamu majú spoločný sufix, stav zodpovedajúci tomuto sufixu má až dve možné reprezentácie a my s ním pracujeme, akoby to boli dva rôzne vrcholy. Dá sa však ľahko ukázať, že cesta zo začiatočného stavu do stavu `""""` (prázdneho reťazca) existuje v našom grafe práve vtedy, keď existovala aj v pôvodnom. Navyše, pre náš upravený graf stále platí, že má $O(n)$ vrcholov.

Časovú zložitosť tohto riešenia odhadneme rovnakým spôsobom, ako pri predošlom riešení. Keďže sme výrazne zrýchlili operácie s množinou dosiahnuteľných stavov, časová zložitosť sa nám zlepší na $O(n^2)$.

## Rýchlejšie hľadanie hrán

V doterajších riešeniach sme si hrany nášho grafu konštruovali počas prehľadávania, podľa potreby. Skúsme si ich teraz explicitne skonštruovať vopred. Pre každý sufix $s$ každého slova zo zoznamu teda potrebujeme nájsť všetky slová $w$, také, že $s$ je prefixom $w$, alebo $w$ je prefixom $s$. Ak by sme to robili naivne, trvalo by nám to $O(n^2)$. Ide to však aj rýchlejšie, s pomocou [Knuth-Morris-Prattovho algoritmu](https://www.ksp.sk/kucharka/kmp/)^[Ak tento algoritmus nepoznáte, odporúčam v tomto momente prerušiť čítanie tohto vzoráku a prečítať si o ňom niečo. Zvyšok tohto vzoráku predpokladá, že KMP poznáte.].

Pre každú dvojicu slov $x, w$ zo zoznamu spustíme KMP s textom $x$ a vzorkou $w$. Ak je $w$ kratšie než $x$, možno nájdeme niekoľko výskytov $w$ v $x$. Každý z týchto výskytov vlastne znamená, že slovo $w$ je prefixom nejakého sufixu $s$ slova $x$. Príslušné hrany pridáme do grafu.

KMP si počas svojho behu udržiava informáciu o tom, aký najdlhší sufix prečítanej časti textu je zároveň prefixom vzorky. To znamená, že po dočítaní celého slova $x$ budeme vedieť, aký najdlhší sufix slova $x$ je zároveň prefixom slova $w$. Príslušnú hranu pridáme do grafu. Okrem toho potrebujeme nájsť aj všetky ostatné sufixy $x$, ktoré sú prefixami $w$. Tie vieme nájsť v čase lineárnom od ich počtu, s využitím informácie, ktorú sme si predrátali v rámci KMP -- stačí nám nasledovať spätné linky (to, čo v texte v Kuchárke voláme funkcia $\\mathrm{next}()$).

Takto sme našli všetky hrany zo sufixov slova $x$, ktoré využívajú slovo $w$, pričom nám to trvalo $O(|x| + |w|)$ času. Keď tento výpočet urobíme pre každú dvojicu $x, w$, budeme mať skonštruované všetky hrany v grafe. Dokopy spustíme KMP $k^2$-krát, pričom každé slovo zo zoznamu bude $k$-krát v roli slova $x$ a $k$-krát v roli slova $w$. Každé slovo $y$ teda do časovej zložitosti prispeje časom $O(k|y|)$. Keďže súčet dĺžok slov je $n$, celková časová zložitosť konštruovania grafu bude $O(kn)$.

Na hľadanie začiatočných vrcholov môžeme využiť náš čerstvo zostrojený graf. Pre každé slovo $v$ zo zoznamu sa pozrieme na stav, ktorý zodpovedá jeho najdlhšiemu sufixu (teda celému slovu $v$). Z tohto stavu povedie niekoľko hrán, pričom jedna pôjde do stavu `""""` (prázdny reťazec). Všetky ostatné hradny vedú do začiatočných stavov. Rozmyslite si, že takto nájdeme všetky začiatočné stavy (dokonca každý dvakrát).

Keďže náš graf má $O(n)$ vrcholov a z každého vedie nanajvýš $k$ hrán, prehľadávanie grafu bude trvať $O(kn)$, teda celý algoritmus nám beží v čase $O(kn)$. Ak by sme chceli odhadnúť zložitosť nášho algoritmu iba v závislosti od $n$, môžeme využiť, že $k \\leq n$, teda náš algoritmus beží v čase $O(n^2)$. V skutočnosti sa však počet slov dá odhadnúť aj tesnejšie: keďže všetky slová musia byť rôzne, bude ich nanajvýš $O(\\frac{n}{\\log n})$, teda náš algoritmus beží v čase $O\\left(\\frac{n^2}{\\log n}\\right)$.

## Počet hrán v grafe

Graf, ktorý sme v predošlom algoritme zostrojili, mal $O(n)$ vrcholov a mohol mať až rádovo $\\frac{n^2}{\\log n}$ hrán. Naozaj sa pritom dajú zostrojiť vstupy, pre ktoré bude mať graf $\\Theta\\left(\\frac{n^2}{\\log n}\\right)$ hrán. Zdá sa teda, že naše riešenie sa už nedá zlepšiť.

V skutočnosti však všetky ""zlé"" vstupy, pre ktoré má graf veľa hrán, využívajú fakt, že ak má veľa slov rovnaký sufix a veľa iných slov má taký prefix, v grafe sa pospájajú ""každé s každým"". Ak prejdeme naspäť ku grafu, kde každý reťazec mohol mať iba jeden vrchol (bez ohľadu na počet slov, ktorých je sufixom), najväčší možný počet hrán sa výrazne zníži.

Najprv potrebujeme zmeniť spôsob, ako reprezentujeme vrcholy grafu. Všetky slová zo zoznamu si napíšme odzadu. Nad takýmito odzadu napísanými slovami teraz postavme písmenkový strom. Každý vrchol písmenkového stromu zodpovedá nejakému reťazcu, z ktorého po otočení dostaneme sufix jedného, alebo viacerých slov zo zoznamu. Zároveň každý vrchol písmenkového stromu zodpovedá inému reťazcu. Vrcholy písmenkového stromu nám teda dobre reprezentujú stavy, pričom každý možný stav je reprezentovaný práve raz.

Koľko hrán môže mať náš graf teraz? Hrany si rozdeľme na dva typy:

- _vnútorné hrany_ sú také, ktoré vznikli zo stavu $s$ s použitím slova $w$ kratšieho než $s$ a vedú do stavu $s - w$.
- _vonkajšie hrany_ sú také, ktoré vznikli zo stavu $s$ s použitím slova $w$ dlhšieho (alebo rovnako dlhého) ako $s$ a vedú do stavu $w - s$.

Keď sa pozrieme na nejaký konkrétny stav $s$, vedie z neho toľko vnútorných hrán, koľko je v zozname slov, ktoré sú prefixom $s$. Všetky tieto slová sú určite rôzne (lebo slová v zozname sú rôzne) a tým pádom rôzne dlhé (lebo rôzne prefixy slova $s$ musia byť rôzne dlhé). Keďže slová v zozname sú dokopy dlhé $n$, rôzne dlhých slov v ňom môže byť nanajvýš $O\\left(\\sqrt{n}\\right)$. To znamená, že z každého vrcholu vedie nanajvýš $O\\left(\\sqrt{n}\\right)$ vnútorných hrán. Zároveň platí, že ich z každého vrcholu vedie nanajvýš $k$. Celkový počet vnútorných hrán je teda $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$.

Vezmime si teraz nejaké číslo $l$ a pozrime sa na všetky stavy dĺžky $l$ (v hĺbke $l$ v našom písmenkovom strome). Tieto stavy budeme volať _stavy $l$-tej úrovne_. Počet vonkajších hrán vedúcich zo stavov $l$-tej úrovne označme $o_l$. Na to, aby z nejakého stavu $s$ z $l$-tej úrovne viedla nejaká vonkajšia hrana, musí v zozname existovať nejaké slovo $w$ také, že $s$ je prefixom $w$. Keďže každé slovo má nanajvýš jeden prefix dĺžky $l$, každé slovo zo zoznamu môže byť v roli $w$ pre nanajvýš jeden zo stavov $l$-tej úrovne. Platí teda $o_l \\leq k$. Ba čo viac, v roli $w$ môžu byť iba slová dlhé aspoň $l$. Ak si počet slov zo zoznamu, dlhých aspoň $l$, označíme ako $k_l$, platí $o_l \\leq k_l$.

Počet vonkajších hrán v našom grafe vieme spočítať ako

$$o_1 + o_2 + \\dots + o_n\\text{.}$$

Vieme pritom, že platí

$$o_1 + o_2 + \\dots + o_n \\leq k_1 + k_2 + \\dots + k_n\\text{.}$$

Navyše platí

$$k_1 + k_2 + \\dots + k_n = n\\text{,}$$

keďže každé slovo je zarátané v práve toľkých $k_i$, koľko má písmen. Vonkajších hrán je teda nanajvýš $n$. Dokopy má teda náš graf $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$ hrán.

## Ešte rýchlejšie hľadanie hrán

Náš nový graf je redší, bude sa teda dať rýchlejšie prehľadať. Hľadanie hrán nám však stále trvá $\\Theta(nk)$ času. To sa dá zrýchliť tým, že namiesto spúšťania KMP $k^2$-krát, použijeme [Aho-Corasickovej algoritmus](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm), ktorý bude stačiť spustiť $k$-krát.

Vo všetkých behoch Aho-Corasickovej algoritmu budeme používať rovnakú množinu vzoriek: všetky slová zo zoznamu. Predrátanie potrebných informácií pre vzorky (písmenkového stromu so spätnými linkami) nám teda stačí urobiť len raz. V tomto momente v našom algoritme vystupujú dva písmenkové stromy -- jeden nad obrátenými slovami zo zoznamu, ktorého vrcholy sú zároveň vrcholmi grafu, ktorý budujeme, a druhý nad pôvodnými slovami zo zoznamu, využívaný v Aho-Corasickovej algoritme.

Pre každé slovo $x$ zo zoznamu spustíme Aho-Corasickovej algoritmus s textom $x$ a celým zoznamom slov ako vzorkami. Vždy, keď Aho-Corasickovej algoritmus nájde výskyt nejakého slova v slove $x$, pridáme do grafu príslušnú vnútornú hranu. Keď Aho-Corasickovej algoritmus dočíta celé $x$, budeme vedieť, aký najdlhší sufix slova $x$ je prefixom jedného, alebo viacerých slov zo zoznamu. Tento sufix označme $t$. Nájdeme všetky slová zo zoznamu, ktorých prefixom je $t$ (o chvíľu si ukážeme ako) a príslušné vonkajšie hrany pridáme do grafu. Následne nájdeme druhý najdlhší sufix $x$, ktorý je prefixom nejakých slov zo zoznamu (v konštantnom čase, nasledovaním spätnej linky v Aho-Corasickovej strome) a urobíme preň to isté. Takto pokračujeme, až kým nenastane jedna z dvoch možností:

1. Prešli sme všetky zaujímavé sufixy slova $x$. V tomto momente sú všetky hrany, ktoré vedú zo sufixov $x$, objavené.
1. Prišli sme na nejaký sufix $s$, ktorý je zároveň sufixom nejakého iného, už spracovaného slova. To znamená, že hrany vedúce zo stavu $s$, aj všetkých kratších sufixov slova $x$ sú už objavené a spracovávanie slova $x$ môžeme ukončiť.

Je dôležité, že v druhom prípade ihneď prestaneme pracovať. Inak by sme mohli vonkajšie hrany vedúce z jedného stavu objavovať veľakrát a vôbec by nám nepomohlo, že graf, ktorý konštruujeme, je riedky. Pri pridávaní vnútorných hrán tiež môžeme kontrolovať, či pridávaná hrana neviedie zo skôr spracovaného stavu, aby sme sa vyhli duplicitnému pridávaniu hrán (pri analýze zložitosti budeme predpokladať, že to kontrolujeme. Zložitosť by sa však nezhoršila, ani keby sme to pre vnútorné hrany nerobili).

Zostáva vymyslieť, ako pre zadaný reťazec $t$ nájsť všetky slová zo zoznamu, ktorých je prefixom. Reťazcu $t$ zodpovedá vrchol v Aho-Corasickovej strome. Všetkým slovám zo zoznamu, pre ktoré je $t$ prefixom, zodpovedajú nejaké vrcholy Aho-Corasickovej stromu, ktoré sú v podstrome pod $t$. Stačí nám teda tento podstrom prehľadať (napríklad do hĺbky) a nájsť v ňom všetky vrcholy, ktoré zodpovedajú celému slovu zo zoznamu. Pritom si treba dať pozor na to, že podstrom pod $t$ môže byť veľký, aj keby v ňom bolo iba jedno slovo. V takom prípade si ho nemôžeme dovoliť prehľadávať naivne, lebo by to trvalo veľmi dlho.

Preto urobíme takzvanú kompresiu ciest. Vrchol Aho-Corasickovej stromu budeme považovať za _zaujímavý_, ak má aspoň jednu z týchto dvoch vlastností:

- Končí v ňom nejaké slovo zo zoznamu
- Má aspoň dve deti

Nezaujímavé vrcholy sú teda také, v ktorých nekončí žiadne slovo a majú práve jedno dieťa. Pre každý nezaujímavý vrchol $V$ si na začiatku algoritmu predpočítame, do akého prvého zaujímavého vrcholu $U$ prídeme, ak z vrcholu $V$ pôjdeme po strome nadol. Keďže z nezaujímavých vrcholov sa dá ísť nadol vždy práve jedným spôsobom, vrchol $U$ je jednoznačne určený. Toto predrátanie vieme urobiť v čase $O(n)$, šikovným prehľadávaním do hĺbky. Následne vždy, keď pri prehľadávaní nejakého podstromu Aho-Corasickovej stromu prídeme do nejakého nezaujímavého vrcholu, skočíme rovno do najbližšieho zaujímavého vrcholu. Takto zaručíme, že čas prehľadávania podstromu bude lineárny od počtu nájdených slov, keďže prehľadáme nanajvýš toľko nezaujímavých vrcholov, ako zaujímavých a v minimálne polovici zaujímavých vrcholov končia slová (to vyplýva z toho, že strom má viac listov, než vetvení).

### Zložitosť

Na začiatku si potrebujeme vybudovať oba naše písmenkové stromy a predpočítať si na nich všetko potrebné. To nám zaberie $O(n)$ času. Následne spúšťame Aho-Corasickovej algoritmus, ktorý musí postupne prečítať texty s celkovou dĺžkou $n$. Samotné čítanie mu teda zaberie $O(n)$ času. Okrem čítania slov ale robíme aj iné činnosti: pridávame vnútorné hrany a hľadáme a prídávame vonkajšie hrany. Všimnime si, že všetky činnosti, súvisiace s pridávaním hrán, mali časovú zložitosť lineárnu od počtu nových hrán, ktoré pridali do grafu. Keďže graf má $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$ hrán, činnosti súvisiace s pridávaním hrán zaberú dohromady $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$ času. Nakoniec ešte náš graf v čase $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$ prehľadáme. Celková časová zložitosť nášho algoritmu je teda $O\\left(n \\min\\left(\\sqrt{n}, k\\right)\\right)$. Ak ju vyjadríme bez použitia $k$, dostaneme $O\\left(n \\sqrt{n}\\right)$.
",10
a51bb55670d10236,ksp,"# Ako si posadáme?

Krízový štáb KSP musí zasadnúť, no vzhľadom na aktuálnu epidémiu, nikto nikomu neverí. Nikto predsa nechce nikoho nakaziť a ani nece byť nakazený. Teda nie zase každý každému. Niektorí niekomu predsa len veria. Napríklad takému Krtkovi nikto neverí, lebo stále niekam behá, chodí na všetky stretká a stretáva veľa ludí. Naopak Samovi verí takmer každý, lebo všetci vedia, že celý deň sedí za počítačom a niečo kódi. Aby bola na zasadnutí krízového štábu dobrá atmosféra, chceme, aby mal každý ľudí, ktorím verí hneď vedľa seba.

## Úloha

Krízový štáb má $n$ členov a zasadá za okrúhlym stolom. Títo členovia majú dokopy $m$ požiadaviek tvaru $x y$ čo znamená, že člen číslo $x$ verí členovi číslo $y$. Dokážeme usadiť všetkých členov tak, aby každý člen mal všetkých ľudí, ktorím verí priamo vedľa seba?^[Ak napríklad niekto nikomu neverí, je vlastne jedno kto pri ňom sedí.]

## Formát vstupu

Na prvom riadku sa nachádzajú dve čísla $n$ a $m$, ($1\\leq n,m \\leq 100,000$) počet členov krízového štábu a počet ich požiadavok. Nasleduje $m$ riadkov tvaru $x_i y_i$, ($0\\leq x_i,y_i\<n, x_i \\not = y_i$) ktoré hovoria, že člen číslo $x_i$ verí členovi číslo $y_i$.

## Formát výstupu

Vypíšte jeden riadok so slovom `ano`, ak sa dá usadiť všetkých členov tak, aby bola na zasadnutí dobrá atmosféra alebo `nie`, ak sa to nedá.

## Príklady

```vstup
2 1
0 1
```

```vystup
ano
```

*Krizový štáb má dvoch členov a jeden z nich verí tomu druhému, takže keď ich posadíme vedľa seba, všetky podmienky budú splnené.*

```vstup
4 3
0 1
0 2
0 3
```

```vystup
nie
```

*Člen číslo 0 verí trom ďalším členom, ale priamo vedľa seba môže mať len dvoch ľudí, takže nevieme splniť všetky jeho požiadavky zároveň.*

```vstup
5 3
0 2
0 1
3 0
```

```vystup
nie
```

*Ak má vedľa 0 sedieť 1 aj 2, už nemôže sedieť 3 vedľa 0.*
","# Ako si posadáme?

Prvá vec, ktorú si treba uvedomiť je, že ak $x$ chce sedieť vedla $y$, tak to znamená, že vedľa seba musia sedieť. Rovnako ako keď chce sedieť $y$ vedľa $x$. Na poradí v tejto dvojici teda nezáleží a treba si dať pozor, ak sú na vstupe obe poradia. Ďalšie jednoduché pozorovanie je, že každý sa môže nachádzať najviac v dvoch rôznych požiadavkach. Sedieť vedla neho predsa môžu len dvaja ľudia. Ak to tak nie je, vieme, že požiadavky nesplníme. Ak je však splnená táto podmienka, môžu nastať nasledovné dva prípady. Buď požiadavky na seba nadvezujú a skončia na človeku, ktorý sa nachádza len v jednej požiadavke, teda napríklad:

```
0 1
1 2
2 3
```

Alebo na seba nadvezujú a tvoria cyklus:

```
4 5
5 6
6 7
7 4
```

Úsekov oboch typov môže byť viac. Ak nájdeme viac úsekov prvého typu, tak nám to nevadí. Problém nastáva pri druhom type. Nezáleží na tom či by boli cykly prepojené alebo nie, nikdy by sme nevedeli splniť všetky podmienky (buď by mal jeden človek sedieť vedľa viac ako 2 ľudí alebo by museli sedieť za 2 stolmi). Teda až na jeden špeciálny prípad, kedy sú v tomto cykle úplne všetci a vtedy vypisujeme `ano`.

## Ako na to

Prvý krok je, správne si uložiť vstup. Klasická dátová štruktúra pri podobných úlohách sa volá zoznam susedov. Budeme mať teda dvojrozmerné pole (zoznam zoznamov, vektor vektorov či rovno zoznam setov), nazveme ho susedia. V tomto poli bude na indexe $i$ zoznam všetkých, ktorí chcú alebo, s ktorými chce sedieť človek $i$.

Následne budeme hľadať, či je tam nejaký cyklus. To síce nie je nič ťažké, ale pár desiatok riadkov to zaberie. Zvolíme si jedného človeka (to znamená postupne každého :P) a zapamätáme si, že pri ňom začíname. Vieme, že má jedného alebo dvoch susedov. Jedného si zvolíme (neskôr aj druhého) a ideme si označovať cestu, ktorou nás bude viesť (každého navšíveného suseda si označíme ako videného). Každý ďalší človek ku ktorému prídeme, bude mať ako suseda toho, od ktorého sme vyšli a ešte jedného (alebo žiadneho) suseda. Ak žiadneho, tak cesta skončila a je to OK, lebo cyklus sme nenašli. Ak ešte má suseda, tak pokračujeme. Keď budeme takto pokračovať a stane sa, že narazíme na človeka, s ktorým sme začínali, vieme, že je to cyklus.

## Časová a pamäťová zložitosť

Máme $n$ ľudí a $m$ požiadaviek. Víme však, že každý môže mať najviac dve požiadavky, takže môžeme povedať že $m$ je rádovo to čo $n$. Náš program teda vyzerá tak, že začíname postupne u každého človeka (to je zatiaľ $O(n)$) a ideme označovať ""cestu"" jeho susedov. Tu by sa mohlo zdať, že to môže byť zase $n$ krokov, ale treba si uvedomiť, že samotné označenie človeka stačí robiť každému iba raz. Teda ak by sme mali označovať cestu, a narazíme pri tom na niekoho už označeného, tak s tým rovno aj prestaneme, lebo sme to predsa už spravili. Teda ak náš prvý cyklus narazí na niekoho označeného, vlastne nič nerobí. Teda je to stále iba $O(n)$.

Pamätáme si zase len niekoľko polí veľkost $n$, teda aj pamäťová zložitosť je $O(n)$
",4
650feee530014ac1,ksp,"# Zapeklitá situácia

Život banditu na divokom západe je náročná robota. Raz musí bandita vystrašiť ľudí v meste, inokedy sa zas pobiť v salóne. Je to makačka. Takýto život však má aj svoje výhody. Napríklad dnes sa banditom podaril mimoriadny úlovok -- vykradli celý trezor banky Krvopotne Sporené Peniažky.

No keď utekali z mesta na chrbtoch svojich koní, začali sa im pred očami sypať zlaté mince a rodiť podlý plán hodný pravého banditu. Len čo vo svojom úkryte zosadli zo sedla, každý vytiahol svoj revolver a namierili ho na svojho najmenej obľúbeného kolegu. O jedného človeka menej v úkryte predsa znamená viac peňazí pre zvyšok!

Ako tam tak stáli, začali rozmýšľať. Ani jeden z nich nechce riskovať a vystreliť na niekoho iného, než na koho už má namierené. Tí lakomejší z nich začali dokonca špekulovať. ""Ak zastrelím toho, na koho mám namierené až po tom, čo vystrelí on, tak mi zostane viac zlata!""

Koľko najmenej banditov môže prestrelku prežiť ak už má každý z nich vybraný svoj terč? Zistite poradie, v akom majú strieľať, aby sa každému preživšiemu ušlo čo najviac zlata.

## Úloha

Dostanete zadanú situáciu -- o každom banditovi viete, na koho mieri. O celej bande banditov viete nasledovné:

- Žiadni dvaja banditi nevystrelia naraz.

- Keď bandita vystrelí, tak jeho cieľ okamžite zomrie.

- Mŕtvy bandita už nestrieľa.

- Každý bandita vystrelí _len na svoj pôvodný cieľ_. Ak jeho cieľ už zabil niekto iný, tak bandita síce môže strieľať, no jeho strela nespraví nič.

Vašou úlohou je nájsť takú postupnosť strieľania, po ktorej zostane nažive najmenej banditov.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $n$ ($1 \\leq n \\leq 1,000,000$) -- počet banditov. Banditov očíslujeme celými číslami od $1$ po $n$, povedzme že od najškaredšieho.

Na ďalšom riadku dostanete postupnosť $n$ celých čísel $c_1\\dots c_n$ ($1\\leq c_i\\leq n$). Platí, že bandita s číslom $i$ mieri na banditu s číslom $c_i$.

Môžete predpokladať, že žiadny bandita nemieri sám na seba.

## Formát výstupu

Na prvý riadok vypíšte jedno číslo -- počet banditov, ktorí zostanú nažive.

Na druhý riadok vypíšte číslo $k$ -- počet výstrelov, ktoré padli.

Na tretí riadok vypíšte $k$ medzerou oddelených čísel -- postupnosť banditov v poradí, v akom strieľali. (Vypisujte aj tých banditov, ktorí vystrelili a nikoho nezabili, ale **ne**vypisujte banditov, ktorí zomreli skôr ako mohli vystreliť.)

Ak existuje viacero postupností, po ktorých zostane nažive najmenší počet banditov, vypíšte ľubovoľnú z nich.

## Príklad

```vstup
5
3 3 4 3 2
```

```vystup

2
4
3 2 1 5
```

_Všimnite si, že aj keď bandita 1 strieľal do mŕtveho banditu 3 zbytočne, tento výstrel sa mohol vyskytovať vo výsledku. Rovnako korektné riešenia sú napríklad aj ""3 2 5"" a ""3 1 5""._
","# Zapeklitá situácia

Nad touto úlohou sa bolo treba zamyslieť, možno si nakresliť pár príkladov a odpozorovať niekoľko vlastností, ktoré nám pomôžu ju vyriešiť. No najprv z rozprávky vybaľme trocha terminológie. Banditi a ich mierenie nám predstavuje vrcholy a hrany orientovaného grafu, v ktorom z každého vrchola vychádza práve jedna hrana.

## Úvodné pozorovania

Je jasné, že ak sa náš graf skladá z viacerých komponentov, tie sa navzájom neovplyvňujú, lebo medzi nimi nevedie hrana označujúca strieľanie. Môžeme preto úlohu riešiť iba pre jeden súvislý komponent. Aj keď vo výslednom riešení túto skutočnosť nemusíme priamo použiť, zjednoduší nám jeho vymýšľanie.

Ďalej si môžeme všimnúť, že v každom komponente bude aspoň jeden šťastný bandita, ktorý prežije. Niekto v komponente totiž strieľa ako posledný a na to, z pochopiteľných dôvodov, musí byť nažive. Samozrejme, týmto výstrelom nevie zabiť sám seba.

Po chvíli kreslenia môžeme odpozorovať, že každý komponent v sebe obsahuje aspoň jeden cyklus. Ak totiž začneme v ľubovoľnom vrchole, ktorý si označíme $v_0$ a prechádzame sled vychádzajúcich hrán, tak postupne navštevujeme vrcholy $v_1, v_2, \\dots$ Keďže z každého vrchola vychádza práve jedna hrana, a vrcholov máme len konečne veľa, týmto spôsobom navštívime vrchol, v ktorom sme už boli (teda pre nejaké $j > i: v_j = v_i$), a teda nájdeme cyklus.

## Riešenie pre jeden komponent

Najskôr sa vrhnime na najjednoduchší prípad - jednoduchá kružnica. Na nej platí, že na každého banditu mieri práve jeden iný bandita.

Pozrime sa, ako by vyzerala optimálna streľba. Keďže všetky vrcholy na kružnici sú rovnocenné a niekto musí začať strieľať, tak nech začne bandita $c$ výstrelom na $d$. Teraz ale bandita $b$, ktorý naňho mieril, nemá stlačením spúšte čo pokaziť a tak vystrelí. Teraz však môže bez problémov vystreliť bandita $a$. Ten už si môže vydýchnuť, lebo naňho mieriaci $d$ už bol zastrelený, $a$ teda prežije. Lepšie takýto graf už nevieme vyriešiť, lebo aspoň jeden bandita nám musí zostať nažive. Ľahko vidieť, že tento postup môžeme použiť aj na väčšie kružnice, ako aj najmenší možný prípad (dvaja na seba mieriaci banditi).

V samotnom programe takéto riešenie vieme vyrobiť tak, že si najskôr nájdeme jedného banditu na takejto kružnici (v našom príklade by to bol $a$). Z neho obehneme kružnicu po hranách, pričom si budeme vrcholy ukladať do pomocného vektora, a zastavíme keď narazíme na pôvodný vrchol. V našom príklade by v ňom zostali hodnoty $[a, b, c, d]$. Keď sa na tento vektor pozrieme od konca, získame správnu postupnosť výstrelov. Treba si však dať pozor na posledného banditu ($d$), ktorý nevystrelí, ale je zastrelený ako prvý. Jeho teda vypisovať nechceme.

Nuž a čo ak komponent nie je len obyčajná kružnica? V takom prípade komponent vyzerá ako cyklus, do ktorého vedie niekoľko stromov (na obrázku je takýto strom vyznačený zelenou). V obyčajnom cykle nám musel zostať jeden bandita nažive, lebo strieľal ako posledný a už ho nemal kto ďalší zastreliť. Teraz však môžeme využiť to, že do kružnice mieri niekto iný.

Pozrime sa znova na náš obrázok a vezmime si riešenie predchádzajúcej časti. Vtedy sa nám postrieľali banditi $b$, $c$, $d$ a nažive nám zostal $a$. Tentokrát však máme banditu $e$, ktorý ho môže zastreliť, a jeho zas môže zastreliť bandita $f$ atď. Na kružnici teda neprežije nikto. Kto ale prežije na strome?

Vrcholy stromu, ktoré majú len jednu hranu nazývame _listami_. Je zjavné, že každý bandita, ktorý je v liste, prežije -- nikto naňho totiž nemieri. Ďalej si ukážeme, že vieme nájsť postupnosť výstrelov, v ktorej zastrelíme každého iného banditu v strome.

Označme si vrchol, ktorým sa strom napája na kružnicu ($e$) ako _koreň_ stromu. Pre každý list v strome vedie práve jedna cesta z listu do koreňa. Ak si vyberieme ľubovoľnú takúto cestu a postrieľame na nej postupne všetkých banditov (samozrejme, okrem listu), rozpadne sa nám strom na niekoľko menších stromov a stále bude platiť, že banditi, na ktorých nikto nemieri sú len pôvodné listy. Zmenšili sme strom na niekoľko menších a opakovaním tohto postupu nám zostanú len stromy s jedným vrcholom -- pôvodné listy -- preživší.

Naprogramovať sa to dá pomerne jednoducho. Vyberieme si náhodný list ($f$) a postrieľame banditov na ceste ku koreňu. Rovnako ako na kružnici si môžeme uložiť postupnosť vrcholov na ceste do poľa a pole potom obrátiť a pridať ku výslednej postupnosti. Strom sa nám rozpadne na dva menšie stromy -- $f, h \\rightarrow g$.

Ak by sme teraz chceli postrieľať banditov v podstrome, tiež by sme vystrieľali cestu od niektorého listu ku koreňu (teda napríklad na ceste $h, g$). Môžeme si ale uvedomiť, že táto cesta leží na ceste od listu ku koreňu aj v pôvodnom strome (teda, $h, g$ je súčasťou $h, g, e$). V implementácii si teda vôbec nemusíme pamätať menšie stromy, stačí pospúšťať cesty (streľby) z každého listu do koreňa a vždy zastreliť len tých banditov, ktorí ešte žijú.

Dokonca nemusíme vedieť ani ktoré vrcholy sú koreňmi. Jednoducho spustíme streľbu z listu a keď sa strom napojí na kružnicu, vystrieľa ju celú. Ďalšie postupnosti výstrelov už kružnicu nenavštívia, lebo strieľame len dovtedy, kým na ceste nenarazíme na mŕtveho banditu.

## Výsledné riešenie

Naše riešenie teda vyzerá tak, že prejdeme cez všetky listy a postrieľame cestu, ktorá z nich vychádza, a následne prejdeme cez všetky kružnice.

Už potrebujeme len zistiť, ktoré vrcholy sú listy a ktoré sú na kružnici. O listoch vieme, že nebudú mať žiadne vstupné hrany, takže takže nám stačí spočítať si vstupné hrany každého vrcholu pri načítaní vstupu. O vrcholoch na kružnici zase vieme, že majú práve jednu vstupnú hranu. Tu už ale neplatí, že každý vrchol s jednou vstupnou hranou leží na kružnici (napríklad vrchol $g$). Avšak každý z takýchto vrcholov zastrelíme pri strieľaní od listov. Stačí nám teda najskôr prejsť vrcholy a strieľať od listov, a potom ich prejsť ešte raz a strieľať len živé vrcholy s jednou vstupnou hranou.

Pamäťová zložitosť bude $O(n)$. Pre každého banditu si pamätáme len jeho cieľ, počet naňho mieriacich banditov a či je ešte nažive.

Časová zložitosť je tiež $O(n)$. Pri strieľaní listov sa na každý vrchol pozrieme najviac dvakrát. Raz, keď sa pozrieme či to nie je list a raz, keď ho zastrelíme. Obdobne pri strieľaní kružnice.
",5
6ca339e8c8339ffb,ksp,"# Šialená jazda

Niektorý KSP-áci^\[[https://www.ksp.sk/organizatori](https://www.ksp.sk/organizatori)\] práve končia magisterské štúdium. Už len tento fakt je celkom šialená jazda. Medzi týmito KSP-ákmi je aj Jaro. Jaro teraz každý večer poctivo trávi na farme (serverovej) a počíta kaktusy. Dáva to zmysel? (Ne)bojte sa, po piatich rokoch vysokej školy bude.

Jaro už má toho všetkého dosť a rozhodol sa, že si pôjde vyvetrať hlavu. Normálny človek by išiel na futbal alebo na kofolu, Jaro sa ale rozhodol, že sa pôjde prevetrať na kolotoč. Ako nástroj svojho plánu si zvolil ruské kolo.

Na zľavomate vyhrabal kupón a už aj stál pred kolotočom. Hneď aj pochopil, prečo bola na tento kolotoč taká veľká zľava. Konštrukciu mal hrdzavú, farbu opadanú, otáčal sa podozrivo rýchlo, a ešte aj kabínky mal povešané kade-tade.

Jaro si teraz musí jednu z týchto kabíniek vybrať.

Jeho mentálne sily sú už ale na dne a chcel by vás poprosiť o pomoc.

## Úloha

Celú situáciu si môžeme predstaviť v dvoch rozmeroch (výška a šírka). Každá kabínka sa na začiatku nachádza v nejakom bode roviny. Kolotoč sa otáča rovnomerným otáčavým pohybom okolo stredu, ktorý je v bode $[0,0]$. Jaro by si chcel vybrať kabínku, v ktorej sa bude najdlhšie cítiť *nad vecou*, t. j. takú, ktorá bude počas jednej otáčky kolotoča najdlhší čas vyššie ako všetky ostatné kabínky. Zistite, ktorá to je!

## Formát vstupu

V prvom riadku je číslo $n$, $(1 \\leq n \\leq 10^6)$ -- počet kabíniek na kolotoči. Nasleduje $n$ riadkov, $i$-ty z nich obsahuje čísla $x_i$ $y_i$ ($-10^5 \\leq x_i, y_i \\leq 10^5$) -- súradnice $i$-tej kabínky. Môžete predpokladať, že žiadne dve kabínky nemajú rovnaké súradnice a všetky súradnice sú celočíselné.

## Formát výstupu

Vypíšte súradnice najlepšej kabínky. Ak je takých viac, vyberte tú s najmenšou $x$-ovou súradnicou. Ak je aj takých viac, vyberte tú s najmenšou $y$-ovou súradnicou.

## Hodnotenie

Pre jednotlivé testovacie sady platia nasledujúce obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ------:| ------:| ------:| ------:| | $n \\leq$ | $10^3$ | $10^4$ | $10^5$ | $10^6$ |

## Príklady

```vstup
5
-1 -1
1 -1
-1 1
1 1
0 0
```

```vystup
-1 -1
```

_Na vstupe je štvorec, každá kabínka bude najvyššie štvrtinu času, okrem strednej, ktorá bude vždy v strede._

```vstup
8
-1 0
1 0
0 1
0 -4
0 0
1 1
2 2
1 -1
```

```vystup
0 -4
```
","# Šialená jazda

Pred čítaním vzorového riešenia odporúčame prečítať si v KSP Kuchárke články o geometrii, konkrétne [článok o skalárnom súčine](https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin/) a [článok o konvexnom obale](https://www.ksp.sk/kucharka/konvexny_obal).

## Konvexný obal

Prvé pozorovanie potrebné na vyriešenie tejto úlohy je nasledujúce: na to, aby sa mohla kabínka dostať nad všetky ostatné, musí ležať na konvexnom obale všetkých kabíniek. Ak neleží, znamená to, že v každom momente je nad ňou nejaká hrana konvexného obalu. Aspoň jeden koniec tejto hrany je vtedy vyššie ako daná kabínka. Na začiatku si teda môžeme zostrojiť konvexný obal všetkých kabíniek a tie kabínky, ktoré nie sú jeho vrcholmi, môžeme rovno zahodiť.

## Najlepší bod

Keď už máme konvexný obal, stačí nám o každom jeho vrchole zistiť, ako dlho bude najvyššie. Vezmime si ľubovoľný vrchol $B$ z nášho konvexného obalu. Vrchol, ktorý je na obale pred vrcholom $B$ označme $A$ a nasledujúci vrchol na obale označme $C$. Stred, okolo ktorého sa celý kolotoč točí, označme $S$. Bod $B$ začína byť najvyššie vtedy, keď je hrana $BC$ vo vodorovnej polohe, a prestáva vtedy, keď sa do vodorovnej polohy dostane hrana $AB$. Uhol, o ktorý sa kolotoč otočí medzi týmito dvoma stavmi, je uhol ktorý zvierajú kolmice na tieto strany prechádzajúce bodom $S$ (na obrázku červená a modrá priamka). Kolotoč sa otáča konštantnou *uhlovou* rýchlosťou, veľkosť tohto uhla je teda priamo úmerná času, počas ktorého bude bod $B$ najvyššie. Najlepší je teda bod, ktorý má tento uhol maximálny.

Uhol, ktorý sa snažíme maximalizovať, si označme $\\alpha$. Zo súčtu vnútorných uhlov štvoruholníka na nasledujúcom obrázku vyplýva, že uhol $|\\measuredangle ABC|$ je rovný $180^\\circ - \\alpha$. Preto nám stačí nájsť taký vrchol konvexného obalu, pri ktorom je najmenší vnútorný uhol. Vnútorné uhly konvexného mnohouholníka sú vždy menšie než $180^\\circ$. Z toho vyplýva, že veľkosť vnútorného uhla je jednoznačne určená jeho kosínusom. Teraz nám stačí nájsť vrchol, pri ktorom je vnútorný uhol s najväčším kosínusom. A kosínus vnútorného uhla ľahko vyrátame pomocou skalárneho súčinu.

## Časová a pamäťová zložitosť

Časová zložitosť výpočtu konvexného obalu je $O(n\\log n)$. Po tomto výpočte už len v lineárnom čase prejdeme body z konvexného obalu a nájdeme najlepší z nich. Pamäťová zložitosť je $O(n)$.
",8
de462e8f53ecdd32,ksp,"# Astrálne kamene

Bola už hlboká noc, keď sa Jožko prebudil zo spánku. Sníval sa mu veľmi živý sen, z oblohy padali asteroidy, plné prerôznych krásnych kameňov^[Kamene sú tu s nami už od doby KAMENnej a podnietili náš rozvoj v oblasti života. Bez nich by sme tu neboli, ale aj tak mám pocit, že nedostavajú také uznanie ako si zaslúžia. Kamene sú v mnohých ohľadoch (napr. tvrdosť, vytrvalosť, dĺžka života, zmysel pre humor, chuť, ...) omnoho nadradenejšie ako my.]. Nadšený, úplne zabudol, že to bol iba sen, vyskočil z postele a vybehol von. Nočná obloha bola jasná, hviezdy svietili... a, čo to? Zreteľne padala hviezda. Jožko, ešte v papučiach, sa za ňou rozbehol, keď sa v tej tme potkol a spadol. Pozrel sa na zem a, čo nevidí? Kameň! To nemôže byť náhoda. Ako sa zahľadel zas na oblohu všimol si ďalší, zreteľne padajúci asteroid. Už nečakal a rozbehol sa za ním. V svetle mesiaca uvidel dopadnutý kameň, ešte krajší ako predchádzajúci, ale ako sa poň načahoval, rozplynul sa mu pred očami.

Zvláštne, pomyslel si Jožko. Skúšal zabehnúť ešte za pár kameňmi, ale polovicu nestihol, rozplynuli sa. Keďže je Jožko zvedavý chlapec, hneď sa rozhodol vyskúmať, ako to je s tými kameňmi. Napriek tomu, že bola hlboká noc, hackol sa do satelitných dát a vypočítal kedy, kde a aký^[niektoré kamene sú lepšie ako iné] kameň dopadne. Ostávajú posledné hodiny noci a Jožko sa zas vyberá na lov kameňov. Zaujímalo by ho, s akým úlovkom vie skončiť.

## Úloha

Svet si vieme predstaviť ako priamku.

Na zem postupne spadne $n$ ($n \\leq 500,000$) kameňov, $i$-tý z nich v čase $t_i$, na mieste $x_i$ a má hodnotu $v_i$. Dva kamene môžu spadnúť na rovnaké miesto, alebo v rovnakom čase (nie však obe naraz). Pre jednoduchosť všetky časy sú v celých sekundách a súradnice v celých metroch. Kamene ostanú na mieste presne sekundu a potom sa rozplynú.

Jožko vie bežať jeden meter za sekundu. Na začiatku (v čase nula) stojí na súradnici $p$. V prípade, že bude zbierať kamene optimálne, aký najväčší súčet hodnôt, ktorý vie získať?

## Formát vstupu

Na prvom riadku sú dve medzerami oddelené čísla: $n$, počet kameňov a $p$, Jožkovú začiatočnú pozíciu.

V druhom riadku je $n$ medzerami oddelených čísiel, $t_1$ až $t_n$, časy dopadu jednotlivých kameňov.

V treťom riadku je $n$ medzerami oddelených čísiel, $x_1$ až $x_n$, miesta dopadu jednotlivých kameňov.

A na štvrtom riadku je $n$ medzerami oddelených čísiel, $v_1$ až $v_n$ - hodnoty jednotlivých kameňov.

Je zaručené že dva kamene nedopadnú na rovnaké miesto v rovnaký čas.

## Formát výstupu

Vypíšte dva riadky: na prvom, dve medzerami oddelené čísla - počet kameňov, ktoré Jožko v optimálnom prípade pozbiera a súčet ich hodnôt.

Na druhom riadku vypíšte čísla kameňov (číslo kameňa je jeho pozícia vo vstupe, číslované od nuly) ktoré má Jožko pozbierať, oddelené medzerou.

Ak existuje viac riešení, vypíšte ľubovoľné z nich.

## Hodnotenie

Vaše programy budeme testovať na štyroch skupinách testovacích vstupov. Pre jednotlivé skupiny budú platiť nasledujúce obmedzenia:

| Skupina | 1 | 2 | 3 | 4 | |:----------------------------- | --------: | ---------: | ------------: | ------------: | | $1\\leq n\\leq$ | $5,000$ | $100,000$ | $200,000$ | $500,000$ | | $0\\leq p, x_i, t_i\\leq$ | $10^9$ | $5,000$ | $250,000$ | $10^9$ |

Vo všetkých vstupoch, $0 < v_i \\leq 10^9$

## Príklad

```vstup
3 0
60 40 50
0 35 40
3 1 1
```

```vystup
1 3
0
```

```vstup
6 3
7 3 5 3 4 8
10 0 2 4 5 4
20 3 9 5 7 8
```

```vystup
3 22
2 5 3
```

*Jožkovi sa oplatí najskôr vziať kameň, ktorý spadne v tretej sekunde na mieste jedna, potom prebehnúť na doľava na kameň s hodnotou 9. Napokon sa prejde dva metre doprava a zoberie kameň s hodnotou 8. Takto získa kamene s hodnotou 22. Ak by sa rozhodol zobrať kameň s hodnotou 20, potom nevie zobrať iný kameň.*

```vstup
3 0
0 1 2
1 2 3
100 100 100
```

```vystup
0 0
```

*Jožko žiaľ nestihne dobehnúť pre žiadny z kameňov.*
","# Astrálne Kamene

## Málo kameňov

Ak je kameňov málo, vieme úlohu previesť na nasledovný podproblém:

Ak Jožko zoberie $i$-tý kameň, koľko najviac bodov vie odvtedy získať?

Riešenie je dynamické programovanie: Utrieďme si kamene podľa času dopadu a spracujme ich od najneskoršieho po najskorší. Pre každý už spracovaný kameň si zapamätáme hodnotu $\\text{best}\_i$ - koľko najviac bodov vie získať Jožko od momentu keď zoberie tento kameň. Túto hodnotu pre $i$-tý kameň spočítame nasledovne: pozrime sa na všetky kameňe ktoré dopadli neskôr (pre ne sme už hodnotu spočítali). Takto zistíme ktoré má Jožko šancu zobrať a hodnota $\\text{best}\_i$ je súčet hodnoty $i$-teho kameňa a maxima hodnôt pre dosiahnuteľné kamene.

Napokon si už len treba vybrať ktorým kameňom začneme. Na to stačí prejsť všetky kameňe a odpoveďou je maximum z $\\text{best}\_i$.

Na zrekonštruovanie sekvencie si pre každý kameň stačí pamätať ktorý ďalší Jožko vezme.

Toto riešenie má časovú zložitosť $O(n^2)$, pamäťovú $O(n)$ a stačí na získanie $2$ bodov z prvej sady.

## Veľa kameňov, v malom časopriestore

Čo keď je kameňov veľa, ale sú roztrúsené po malom časopriestore? V druhej sade sa kameňe môžu vyskytovať iba prvých $5000$ metrov a sekúnd. To je pomerne málo a vieme na tom založiť druhé riešenie dynamickým programovaním:

Pozrime sa na podproblém: Ak Jožko stojí v čase $t$ na súradnici $x$, aký najväčší súčet vie odvtedy (vrátane) dosiahnuť?

Spracujme hodnoty od neskorších časov ku skorším. Všimnime si, že na keď je Jožko na nejakej časopriestorovej súradnici, sú tri možnosti kde skončí o sekundu neskôr: buď sa posunie o jedno miesto doľava ($x-1$), o jedno doprava ($x+1$), alebo ostane na mieste. Pre každú súradnicu sa tak stačí pozrieť na tri ďalšie a z nich vziať maximum (a prípadne pričítať hodnotu kameňa, ak tam, kde stojíme, nejaký je).

Riešenie - maximálny súčet hodnôt ktoré vie pozbierať, je hodnota pre súradnicu $t=0$, $x=p$.

Rovnako ako v predchádzajúcom riešení, kamene ktoré Jožko vezme zrekonštruujeme tak, že že si pre každú súradnicu zapamätáme kde viedol optimálny krok.

Pre spočítanie zložitosti, označme $X$ maximum z priestorových súradníc a $T$ maximum časových súradníc. Časová aj pamäťová zložitosť je $O(XT)$ a toto riešenie stačí pre ďalšie dva body z druhej sady.

## Vzorové riešenie

Vzorové riešenie má myšlienku podobnú prvému riešenie hrubou silou - pre každý kameň si položíme otázku: aký najväčší súčet hodnôt môže Jožko získať od momentu ako zoberie $i$-tý kameň?

V riešení na prvú sadu sme si všetkých kandidátov po jednom prezreli, a vybrali maximum. Vyzerá to tak, že by to chcelo nejaký spôsob, ako rýchlo zistiť maximum z vhodnej množiny kameňov.

Predstavme si situáciu geometricky v časopriestore a zaznačme si z ktorých kameňov sa dá dostať na ktoré.

Všimnime si, že jednoduché pravidlo ako ""ako ďalší kameň môžme vziať akýkoľvek, čo padne neskôr"" nefunguje, napríklad na obrázku kameň B zo štartovnej pozície nie je dosiahnuteľný. Ak nájdeme pekné súradnice, v ktorom kritérium ""viem zobrať tento kameň začínajúc na pozícii $(x, t)$"" sa dá vyjadriť ako interval problém by sa výrazne zjednodušil.

Na druhý pohľad si vieme všimnúť, že výsek časopriestoru do ktorého sa vieme od nejakého kameňu dostať je pravouhlý a ak kameň 1 leží vo výseku kameňa 2 a kameň 2 leží vo výseku kameni 3, tak kameň 1 leží vo výseku kameňa 3. Skúsme obrátiť súradnice o $45$ stupňov:

Môžme si všimnúť, že premenením súradníc na $(a, b)$

$$ a = \\frac{(x-p)+t}{2} $$

$$ b = \\frac{t-(x-p)}{2} $$

Aby sme sa vyhli desatinným číslam, môžme vynechať delenie dvomi -

Dostaneme súradnice, v ktorých sa z $(a, b)$ vieme dostať na všetky body $(s, t)$ kde $s \\leq a$ a $t \\leq b$.

Teraz vieme úlohu riešiť pomocou intervalového stromu: spracujme kamene v poradí najskôr od najväčšieho $a$ a potom od najväčšieho $b$. Pri spracovaní kameňa na pozícii $(a, b)$ sa pozrieme do intervalového stromu na pozície od $b$ väčšie a v logaritmickom čase zistíme ktorý kameň je optimálne vziať a koľko tak získame (potrebujeme obe tieto informácie). Následne uložíme informáciu o kameni na $b$-tú pozíciu do intervaláča.

Akú časovú zložitosť má toto riešenie? $b$-súradnica, ktorou indexujeme v intervaláči je ohraničená $T$-najväčším vyskytujúcim sa časom. Vytvoriť intervalový strom má lineárnu časovú i pamäťovú zložitosť, následné spracovanie každého kameňa $\\log T$ čas. Celková časová zložitosť je tým pádom $O(T + n\\log T)$. Toto riešenie by vyriešilo druhú a tretiu sadu a získalo by tak 4 body.

Pozorný čitateľ sa už isto čuduje? Nehovoril posledný nadpis vzorové riešenie? Pravdou je, že sme pri ňom už veľmi blízko - problém je veľkosť intervaláča - možný rozsah súradníc je rádovo viac, ako počet kameňov. Valná väčšina pozícií v intervalovom strome ostáva nevyužitá, ale spôsobuje TLEtie programu.

Riešenie na tento problém sa volá *kompresia súradníc*. Namiesto používanie $b$ na indexovanie, prečíslujme súradnice ešte raz: zaujíma nás iba relatívne poradie (ktoré kamene majú nižšiu/vyššiu $b$ súradnicu), takže nová druhá súradnica číslo ""koľko z všetkých kameňov má nižšiu $b$-súradnicu ako ja?"". Toto číslo sa dá zistiť utriedením podľa $b$-súradnice v $O(n\\log n)$ čase.

Prečíslovanie spôsobí, že intervaláč bude mať veľkosť $O(n)$ a teda sa časová zložitosť upraví na $O(n\\log n)$, pamäťová na $O(n)$ a riešenie prejde na všetkých sadách.
",10
cbdab7c90545cdba,ksp,"# Interpunkčné párovanie

Igor a Ignác sú, ako inak, dvojičky. Nepoznajú nudu, keďže odmalička sa vo všetkom predbiehajú. Ten začal prvý rozprávať, tamten prvý napočítal do desať, jeden zahral na klavíri Ódu na radosť, druhý nakreslil slušnú trojbodovú perspektívu, atď. Ešte aj v škole sa im zapáčilo rovnaké dievča. Renáta mala ale oči pre iného a bratia sa tak dlho na seba nehnevali.

""Počuj, Ignác,"" začal včera jeden z bratov. ""Ukážem ti zátvorkovú šifru, ktorú som dnes vymyslel. Napíšem nejaký zátvorkový reťazec z (, ), [, ], { a }, v ktorom práve jedna zátvorka nemá pár.""

""Krása\\dots"" odvetil Ignác.

""Čakaj, to ešte nie je všetko. Nemám to úplne domyslené, ale ak je možné chýbajúcu zátvorku do reťazcu doplniť tak, aby bol správne ozátvorkovaný, hodnota správy je $1$, inak je to $0$,"" objasnil Igor.

""Eh, je pravda, že pomocou $1$ a $0$ by sme vedeli po bitoch posielať ľubovoľné správy, ale bolo by to dosť nepraktické. Pravdaže, ak by sme dokázali v jednom reťazci uchovať väčšie číslo, ktorým by sa dala reprezentovať komplexnejšia informácia, dosť by sa používanie tejto šifry zjednodušilo,"" navrhuje Ignác.

""Ako by sa to dalo spraviť?""

""Rovnako, ako si to vymyslel, ale trošku zložitejšie. Namiesto toho, či sa chýbajúca zátvorka dá vložiť do reťazca, spočítame, na koľko rôznych pozícií sa dá vložiť, pričom vždy bude možne zátvorku správne vložiť.""

""Výborne! A keďže zátvorky sú párové interpunkčné znamienka, dáme šifre aj taký názov.""

""No dobre.""

I keď chlapci už majú program, ktorý dokáže zakódovať nejakú správu do Interpunkčného párovania, nezvýšil sa im už žiaden čas, aby vytvorili dešifrovací program. Ešteže existujú šikovní KSPáci, ktorí im s tým pomôžu.

## Úloha

Na vstupe je reťazec zo zátvoriek (, ), [, ], { a }. Tento reťazec bol najprv správne ozátvorkovaný, no práve jedna zátvorka z neho zmizla. Zistite, na koľko rôznych miest môžeme chýbajúcu zátvorku doplniť tak, aby bolo ozátvorkovanie korektné. Napríklad [{]} je nesprávne ozátvorkovanie. Tak isto aj )\[{}\]( alebo ({)}. Naopak ({}[]), {\[[]\]()}{} alebo []{}() sú správne ozátvorkovania.

## Formát vstupu

V prvom riadku vstupu je číslo $1 \\leq t \\leq 1,000$ udávajúce počet reťazcov. Nasleduje $t$ riadkov. V každom riadku sa nachádza reťazec $n$ znakov zátvoriek (, ), [, ], { a }. Práve jedna zátvorka v reťazci chýba. Platí: $n = k + 1$ a $0 \\leq k \\leq 2,000$.

## Formát výstupu

Vypíšte jedno celé číslo: počet miest v reťazci, kam vieme korektne vložiť chýbajúcu zátvorku.

## Príklady

```vstup
4
{[{]}
[(){}
[(([]())]
[
```

```vystup
1
3
6
1
```
","# Interpunkčné párovanie

Keďže z reťazca bola podľa zadania odstránená práve jedna zátvorka, chceme zistiť, aká. Nájsť chýbajúcu zátvorku vieme tak, že jednoducho prejdeme celý reťazec a spočítame výskyty jednotlivých zátvoriek. Typ zátvorky, ktorého početnosť v reťazci je o $1$ menšia ako početnosť jeho párového typu, chýba. Okay, inými slovami, ak sme zistili, že je v reťazci, napríklad, $n\\times$ `(` a $(n - 1)\\times$ `)`, vieme, že chýba `)`.

## Pomalé riešenie a overenie správnosti uzátvorkovania reťazca

Dobre, máme chýbajúcu zátvorku. Čo s ňou? Skúsme ju vložiť na všetky možné pozície a spočítajme, pri koľkých týchto pokusoch vznikne správne uzátvorkovaný reťazec. Ako ale vieme zistiť, či je reťazec správne uzátvorkovaný?

Použijeme zásobníkový automat. Každá otváracia zátvorka, napr. `(`, musí mať niekde vpravo od seba svoju zatváraciu, `)`. A to nie len-tak niekde. Teda, zamerajme sa skôr na to, čo musí platiť v intervale medzi týmto párom zátvoriek.

Musí sa tu nachádzať správne uzátvorkovaný (korektný) podreťazec alebo viac takýchto podreťazcov vedľa seba. Napríklad: `( {[]()} [] )`. Medzi vonkajšími `()` sa nachádzajú dva korektné podreťazce: `{[]()}` a `[]`.\
Z tohto sa nám už črtá akési rekurzívne pravidlo, že každý korektný podreťazec, ohraničený párom zátvoriek (v správnom smere), obsahuje $0$ alebo viac korektných podreťazcov vedľa seba. Napríklad `[]` je korektný podreťazec, ktorý obsahuje $0$ podreťazcov v sebe; a `{[]()}` obsahuje `[]()`, atď.

Ako teda vieme použiť zásobníkový automat? Povedzme, že prechádzame reťazec po znakoch zľava. Ak nájdeme otváraciu zátvorku, pridáme si ju do zásobníka a ideme ďalej. Ak nájdeme zatváraciu zátvorku, musí to byť práve párová zátvorka k zátvorke na vrchu zásobnika. Ak to platí, otváraciu zátvorku zo zásobnika vyberieme. Znamená to, že uzátvára zátvorku, ktorá sa otvorila ako posledná a nebola ešte uzavretá. Nemôže sa stať, že sa otvorí, napr. `(` a hneď za ňou sa zatvorí `]`. Vtedy by bol reťazec nekorektný.

Napríklad: `( {[]()} [] )` - na začiatku sme našli prvú `(`, potom sme skontrolovali niekoľko ďalších párov, ktoré boli kompletné (otvorili sa a zatvorili bez toho, aby sa ""pretínali"", napr. `{[}]`, a teraz sme našli poslednú `)`, ktorá je zatváracia k tej prvej, čiže ""uzátvára zátvorku, ktorá sa otvorila ako posledná z tých, čo ešte neboli uzavreté"". Z toho je jasné, že nás ten stred (podreťazec medzi krajnými zátvorkami) nezaujíma.

Takáto kontrola prejde celý reťazec iba raz. Vyberať z a vkladať do zásobnika vieme v konštantnom čase. Preto vieme povedať, že časová zložitosť jedného overenia reťazcu dĺžky $n$ je $O(n)$.

Pamätať si potrebujeme iba zásobník, ktorý plníme len zo vstupného reťazca, preto jeho veľkosť určite nepresiahne veľkosť vstupného reťazca, čo je rovnako $O(n)$.

Správnosť stringu v tomto riešení ale overujeme pre každú možnú pozíciu chýbajúcej zátvorky, ktorých je $n + 1$. To nám dokopy dáva časovú zložitosť $O(n^2)$.

Dá sa to rýchlejšie? Pýtal by som sa, ak by sa nedalo?

## Niečo lepšie

Naozaj musíme skúšať doplniť chýbajúcu zátvorku na všetky miesta v reťazci? Vieme nejako zistiť kam najskôr a kam najneskôr môžeme doplniť chýbajúcu zátvorku? Áno.

Skúsme zásobníkovým automatom overiť správnosť reťazca zo vstupu aj keď vieme, že je pokazený. Akú ďalšiu informáciu si z toho ale vieme vziať?

Na vstupe je toto: `[(([]())]{}`. Pustíme na to zásobníkový automat (popísaný vyššie). Ten sa zasekne na tretej zátvorke od konca, keďže na vrchu zásobníka je `(`, ale na vstupe sa nachádza `]`. Má zmysel doplniť chýbajúcu zátvorku niekam za túto `]`?

Uvedomme si: Ak doplníme chýbajúcu zátvorku hocikam za miesto zaseknutia, pri spustení automatu pre overenie sa automat zasekne znova na rovnakom mieste a k novo doplnenej zátvorke sa ani nedostane, lebo chybná časť reťazca zostala nezmenená. Týmto sme vlastne našli hranicu, pokiaľ má zmysel skúšať doplniť chýbajúcu zátvorku. Tak isto vieme spustiť automat aj z opačnej strany a zasekne sa na `(` prvej z ľava.

Tým pádom nám zostalo `[(_(_[_]_(_)_)_]{}`, kde `_` znázorňuje miesto, kam má zmysel skúsiť doplniť zátvorku. Teraz môžeme na každé `_` skúsiť doplniť zátvorku a overiť korektnosť reťazca.

Je to určite zaujímavá myšlienka, no pri takomto použití je toto len jemná optimalizácia. Časová zložitosť tohto vylepšenia je aj tak stále $O(n^2)$, takže sme veľmi potenciál týchto ""hraníc"" nevyužili. Ako teda túto informáciu využiť naplno?

## Vzorové riešenie

Dokážeme zistiť, či zátvorku môžeme doplniť na dané miesto, bez toho, aby sme museli overiť korektnosť reťazca? Hm\\dots Áno!

Dobre, zásobníkovým automatom sme zistili, kde najskôr a kde najnekôr, mohla vzniknút chyba. Chyba znamená, že nejaká zátvorka sa otvorila a nezatvorila. Je to jasné? Pri prechode automatom sme narazili na miesto, kde sme chceli zavrieť nejakú zátvorku, ale zistili sme, že ešte iná nebola zavretá, a tým pádom sa to celé pokazilo. (Ak chýba otváracia zátvorka, vieme rovnakú úvahu aplikovať na reťazec z opačnej strany)

Ako vieme tento pokazený reťazec opraviť? Zavrieme túto nezatvorenú zátvorku. To sa zdá byť celkom jednoduché a toto zdanie nie je ďaleko od pravdy.

Ako by sme ""zavreli"" zátvorku? (Spomeňme si na štvrtý odsek tohto vzoráku) Doplníme zatváraciu zátvorku niekam vpravo od prvej otvorenej v nájdenom intervale (prvá zátvorka bude určite práve opačná k chýbajúcej) tak, aby sa v ich vnútri nenachádzalo nič alebo nejaký korektný podreťazec. Ak by sme do vnútra zátvoriek uzaverli nekorektný podreťazec, celý reťazec by bol nekorektný a preto by daná pozícia doplnenej zátvorky nepripadala do úvahy.

Napríklad, zostal nám interval `[()` a chýba nám v reťazci `]`. Môžeme ju doplniť takto: `[]()` alebo takto: `[()]`, ale nie takto: `[(])`. Ak by bol interval `[[()]`, máme $4$ možnosti, kam dať chýbajúcu `]`: `[][()], [[]()], [[()]]` a `[[()]]`.

Všimnime si, že poslednú a predposlednú možnosť rátame ako dve, aj keď v konečnom výsledku vyzerajú rovnako. To preto, lebo nás zaujíma, kam dáme chýbajúcu zátvorku, nie koľko rôznych reťazcov môže vzniknúť. Chápeme, že všetky zátvorky sú unikátne a je teda rozdiel, či doplníme chýbajúcu zátvorku na posledné alebo predposledné miesto.

Je tak zrejmé, že zátvorku chceme dpolniť, buď hneď za jej opačnú (ak tá nie je vo vnútri iných zátvoriek, čo znamená, že je tento podreťazec korektný a pridaním ďalšej zátvorky by sa určite pokazil), alebo medzi nimi nechať nejaký ""uzavretý"" korektný reťazec/reťazce.

""Uzavretý"" korektný reťazec znamená, že ho obkolesujú zátvorky iného typu, ako chýbajúca. To znamená, že doň nemôžeme nič vložiť, lebo by sme ho pokazili.

Poslednou časťou skladačky je tak identifikovanie ""uzavretých"" korektných podreťazcov v skúmanom intervale. Vieme ľahko zistiť, že takýto podreťazec začína tým, že prečítame otváraciu zátvorku iného typu, akého je chýbajúca. Ako potom zistiť, pokiaľ až tento uzavretý podreťazec siaha? Vieme zase použiť zásobníkový automat\\dots Vieme, že podreťazec je korektný. Tým pádom končí, keď sa zásobník automatu vyprázdni.

Takto dokážeme jedným prechodom intervalu nájsť, a teda aj spočítať, miesta, kam je možné doplniť chýbajúcu zátvorku.

## Zložitosti

Pre nájdenie hraníc intervalu potrebujeme pustiť zásobníkové automaty z oboch strán. Vkladanie a vyberanie zo zásobníka má konštantnú časovú zložitosť, takže časová zložitosť nájdenia hraníc pri $n$ znakoch je $O(n)$. Nájdenie a spočítanie vhodných miest trvá jeden prechod nájdeneho intervalu, čo je tiež $O(n)$. Preto aj výsledná časová zložitosť je $O(n)$.

Potrebujeme si zjavne pamätať celý reťazec, aby sme ho mohli prejsť z oboch strán. Okrem toho si niekedy pamätáme obsah nejakého zásobníka, ktorý plníme len zo vstupného reťazca, preto jeho veľkosť určite nepresiahne veľkosť vstupného reťazca. Preto hovoríme $O(n)$.

Keďže máme $t$ reťazcov o dĺžkach $n_1, n_2\\dots n_t$, vieme časovú zložitosť odhadnúť pomocou sumy: $O(\\sum\_{i=1}^t n_i)$ a pamäťovú pomocou maxima: $O(MAX(N))$, kde $N = {n_1, n_2\\dots n_t}$.
",6
36c18de3b5aa3809,ksp,"# Obchodnícke obtiaže

KSPáci radi čítajú a keďže veľa času trávia na Matfyze, čítajú hlavne tam. A ako KSPáci postupne starli a odchádzali do veľkého sveta, ich knihy zostali. No kníh stále pribúdalo a čoskoro zaplnili väčšinu políc, poličiek, skríň a zásuviek.

Po tom, čo Askara pri hľadaní zošívačky zasypala knižná séria *Moderný design pre Windows 95*, sa KSPáci rozhodli, že sa kníh zbavia. Vyhadzovať knihy je škoda, preto dumali, dumali, až vydumali skvelý nápad -- predajú ich! Tak sa aj stalo, že sa o týždeň konal veľký výpredaj. Uložili knihy do veľkej veže a nechali Matúša, nech predáva.

Matúš je šikovný chlapec a vie, ako sa zákazníci správajú. Zákazníci sú pomerne leniví, nechce sa im prehrabovať v kope a nedajbože robiť rozhodnutia. Len čo prídu za Matúšom, pozrú sa aká kniha je na vrchu kopy, spýtajú sa Matúša, koľko kniha stojí a ak sú s cenou spokojní, kúpia si ju.

Matúš im samozrejme ponúkne najvyššiu cenu, akú sú ochotní zaplatiť. Jednak aby čo najviac zarobil a dvak aby sa zbavil všetkých kníh. Ponúknutá najvyššia cena je jednoducho súčin bohatosti zákazníka a skutočnej hodnoty knihy.

Avšak, bola by veľká škoda, keby si bohatí zákazníci kúpili lacnú knihu a chudobní zákazníci kúpili veľmi hodnotnú knihu, lebo by KSP (a Matúš) nič nezarobilo. Tak mu v hlave vznikol ďalší skvelý nápad. Môže trocha ovplyvňovať, aké knihy si zákazníci kúpia. Veď má predsa dve ruky! Keď napríklad chce, aby si zákazník kúpil tretiu knihu zhora, vie chytiť vrchnú do ľavej ruky a ďalšiu do pravej ruky. No nie je to génius?

\\medskip

Deň sa skončil, všetky knihy sa predali a Matúš teraz rozmýšľa, či predával optimálne. Od vás chce preto vedieť, koľko najviac peňazí mohol zarobiť.

## Úloha

Máme $n$ kníh, ktoré si príde kúpiť $n$ kupcov. Na vstupe sú zadané hodnoty kníh $h_1 \\dots h_n$ (od vrchu kopy nadol) a bohatosti kupcov $b_1 \\dots b_n$ (v poradí, v ktorom prichádzajú do obchodu).

Každý kupec si kúpi práve jednu z vrchných troch kníh, pričom $i$-ty kupec zaplatí za $j$-tu knihu $b_i \\cdot h_j$ peňazí.

Koľko najviac peňazí vieme zarobiť, ak ponúkame zákazníkom knihy optimálne?

## Formát vstupu

V prvom riadku je číslo $n$ -- počet kníh.

V druhom riadku je $n$ čísel $h_i$ -- hodnoty kníh, $1\\leq h_i\\leq 1,000$.

V treťom riadku je $n$ čísel $b_i$ -- bohatosti kupcov, $1\\leq b_i\\leq 1,000$.

Pre jednotlivé sady vstupov platia nasledovné obmedzenia na počet kníh.

| Číslo sady | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |---------------| ----:| ----:| ---:| ----:| ----:| ----:| ----:| ----:| | Maximálne $n$ | 5 | 10 | 20 | 40 | 100 | 200 | 400 | 500 |

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno celé číslo -- najväčšiu sumu, za ktorú vieme knihy predať.

## Príklad

```vstup
4
16 6 2 10
3 8 12 9
```

```vystup
336
```

*Prvému človeku s bohatosťou $3$ Matúš zodvihne dve knihy, vezme knihu s hodnotou $2$ a zaplatí na ňu $6$. Druhému zodvihne jednu, čiže si vezme knihu $6$ za $48$, tretiemu nezodvihne žiadnu a posledný už nemá na výber.*
","# Obchodnícke obtiaže

Najskôr sa pozrieme na jednoduchšie algoritmy, ktoré vás mohli pri riešení tejto úlohy napadnúť, následne si predstavíme dynamické programovanie a nakoniec v ňom nájdeme malý trik ku vzorovému riešeniu.

##Jednoduché algoritmy

Prvá vec, ktorá nás napadne pri ľubovoľnej úlohe, je brute force. Ten však bude príliš pomalý. Navyše pri tejto úlohe je aj jeho implementácia netriviálna, takže je jednoduchšie sa zamyslieť nad rýchlejším riešením.

Ďalší jednoduchý prístup sú greedy algoritmy. No či už vyberáme pre zákazníka najlacnejšiu alebo najdrahšiu knihu, dá sa nájsť protipríklad, na ktorom nezvolíme optimálnu stratégiu. Poďme sa teda pozrieť na myšlienkovo náročnejšie riešenie, ktoré ale už bude korektné.

##Dynamické programovanie

Táto úloha sa dá celkom príjemne riešiť pomocou dynamického programovania -- dynamiky. Dynamika je algoritmus, v ktorom zo stavov, ktoré už poznáme, postupne počítame ďalšie, až kým sa nedostaneme ku výsledku.

V tejto úlohe bude naším stavom počet už predaných kníh a vrchné tri knihy na kope. Informácia, ktorú pre tento stav chceme vedieť, je maximum peňazí ktoré vieme mať vtedy zarobených. Medzi týmito stavmi sa presúvame predajom kníh. Pri každom predaji predáme jednu knihu (konkrétneho zákazníka vieme určiť z počtu predaných kníh) a namiesto nej do trojice známych kníh dáme ďalšiu knihu z kopy. Týmto nám vznikol nový stav. Ak už sme taký stav niekedy dosiahli, tak si porovnáme zarobené peniaze a zapamätáme si maximum.

Implementovať to budeme pomocou štvorrozmerného poľa, kde jedna súradnica bude počet predaných kníh, ďalšími tromi budú vrchné tri knihy na kope, a hodnota jedného políčka budú peniaze zarobené v danom stave.

Samotný algoritmus bude postupne prechádzať všetky políčka (stavy). Pre dané políčko si vypočíta stav, ktorý mu vznikne predajom prvej knihy, a na políčko tohto nového stavu skúsi uložiť peniaze, ktoré by takto zarobil. No čo ak sa na toto políčko už dostal predtým? Preto sa najskôr pozrie, či už na danom políčku nie je uložená väčšia hodnota, ako by zapisoval. Ak áno, tak nespraví nič, pretože by prepisoval optimálnejšie riešenie. V opačnom prípade zapíše novú hodnotu. To isté zopakuje pre druhú a tretiu knihu.

Keďže si pamätáme štvorrozmerné pole, kde každá zo súradníc môže mať veľkosť až $n$, pamäťová zložitosť bude $O(n^4)$. A keďže všetky tieto políčka počas výpočtu prechádzame, tak aj časová zložitosť bude $O(n^4)$.

Už máme skoro vzorové riešenie, ale $n^4$ je predsa len príliš pomalé a na najväčších vstupoch nestíha. Skúsme teda naše riešenie trochu zoptimalizovať.

##Zlepšenie zložitosti

Pozrime sa bližšie na predaj jednej knihy. Zákazník príde, kúpi si jednu z vrchných troch kníh a odíde. Keďže sa jedna z vrchných troch kníh zobrala, štvrtá kniha z kopy sa ""presunula"" na tretie miesto. Toto sa deje pri každej kúpe knihy^[Až na okrajový prípad, keď sú na kope menej ako štyri knihy.]. Treťou knihou na kope bude teda po ľubovoľných $k$ nákupoch vždy $k+3$-tia v pôvodnej kope.

Nám si teda stačí pamätať len túto tretiu knihu a celkový počet kníh si z nej budeme vedieť ľahko. Celkovo teda máme tri vnorené cykly, čo nám dáva časovú a aj pamäťovú zložitosť $O(n^3)$.

##Vzorové riešenie

Pamäťová zložitosť $O(n^3)$ však stále nestačí na plný počet bodov, skúsme ju teda trochu orezať.

Pri predchádzajúcej optimalizácií sme využili fakt, že tretia kniha na kope sa nám pri každom predaji zmení na tú pod ňou. Tento fakt nám ale dáva viac, než sme využili. Vďaka tomu totiž vieme, že zo stavov, kde tretia kniha je $k$-ta sa vieme dostať jedným predajom len do stavov, kde tretia kniha je $k+1$-vá. A naopak, do stavov kde tretia kniha je $k$-ta sa vieme dostať len zo stavov, kde tretia kniha je $k-1$-vá. Keďže potrebujeme len stavy $k-1$, nemusíme si pamätať všetky predchádzajúce. Stačí nám, keď si v jednom riadku poľa budeme pamätať už vypočítané stavy a do druhého budeme zapisovať novovypočítané stavy. No a keď ich dorátame, tak nám stačí len vymeniť riadky a počítať ďalej.

Tým, že si v jednom momente pamätáme stavy len pre dva prípady tretej knihy na kope, sme práve odobrali ďalšie $n$ z pamäťovej zložitosti. Pamäťová zložitosť teda bude $O(n^2)$.
",8
acf96ac2221d4162,ksp,"# Obrovská rekonštrukcia

Ako už viete z tretej úlohy v predošlej sérii^[https://www.ksp.sk/ulohy/zadania/1259/], starosta Kocúrkova plánuje rekonštrukciu autobusových zástávok.

Na pripomenutie, Kocúrkovo je jedna dlhá ulica pozdĺž ktorej je postavených $n$ autobusových zastávok. Každá autobusová linka má dve konečné zastávky, medzi ktorými jej autobusy jazdia hore-dolu, pričom stoja aj na každej zastávke po ceste. Keďže Kocúrkovo je Kocúrkovo, môže sa stať, že niektorá linka začína aj končí na rovnakej zastávke (a teda autobus iba stojí na tejto zastávke).

Z politických dôvodov (o ktorých sa môžete dočítať v zadaniach minulej série) starosta chce, aby od začiatku rekonštrukcie čo najdlhšie platilo, že každý deň sa na každej linke rekonštruuje aspoň jedna zastávka.

Starosta vyhlásil verejnú súťaž a dostal veľa ponúk. Teraz potrebuje zistiť, ktorá z nich je najlepšia. Pomôžete mu ohodnotiť jednotlivé ponuky?

Ponuka o každej zastávke hovorí, ktorý deň sa má rekonštruovať. _Kvalita_ ponuky je najmenšie číslo dňa, v ktorý sa na niektorej linke nebude rekonštruovať ani jedna zastávka.

## Úloha

Na vstupe dostanete jednu ponuku rekonštrukcie -- pre každú zastávku dostanete deň, v ktorý sa podľa tejto ponuky má rekonštruovať. Ďalej dostanete zoznam všetkých liniek aj s ich konečnými zastávkami. Vypočítajte (a vypíšte) kvalitu tejto ponuky. Inými slovami, pre danú postupnosť dní a zoznam liniek vypíšte najmenšie číslo dňa, v ktorý sa na niektorej linke nerekonštruuje žiadna zastávka.

## Formát vstupu

V prvom riadku vstupu sú dve medzerou oddelené celé čísla $n$ a $m$ ($1 \\leq n,m \\leq 1,000,000$) -- počet zastávok a počet autobusových liniek.

Zastávky si očíslujme číslami $1$ až $n$ od začiatku Kocúrkova po jeho koniec.

V druhom riadku vstupu je $n$ medzerou oddelených čísel $d_1, d_2, \\dots, d_n$ ($0 \\leq d_i \\leq 10^9$), kde $d_i$ udáva číslo dňa od začiatku rekonštrukcie, kedy sa bude rekonštruovať zastávka číslo $i$. Rekonštrukcia začína dňom číslo $0$.

Nasleduje $m$ riadkov, v každom z nich sú dve medzerou oddelené čísla $z_i$ a $k_i$ -- čísla konečných zastávok $i$-tej linky. Platí, že $1 \\leq z_i \\leq k_i \\leq n$.

## Formát výstupu

Vypíšte jediné číslo -- najmenšie číslo dňa, v ktorý sa na niektorej linke nerekonštruuje žiadna zastávka.

## Príklad

```vstup
5 3
0 1 0 1 0
1 3
2 5
4 5
```

```vystup
2
```

_V dni číslo $0$ a $1$ sa na každej linke niečo rekonštruuje. V deň číslo $2$ sa však už nerekonštruuje nič, takže dokonca pre každú linku platí, že sa tam nič nerekonštruuje._

```vstup
5 4
0 1 2 1 1
1 3
2 3
1 4
3 5
```

```vystup
0
```

_Na linke $2$ $3$ sa nič nedeje v deň číslo $0$._
","# Obrovská rekonštrukcia

Pozrieme sa, ako sa dá táto úloha riešiť hrubou silou, a pomocou niekoľkých dôležitých pozorovaní sa dostaneme ku vzorovému riešeniu.

## Bruteforce

Jednoduchý bruteforce môžeme naprogramovať tak, že budeme robiť presne to, čo hovorí zadanie. Pre každú linku sa pozrieme aké najmenšie číslo na nej chýba, (napríklad tak že sa pre každé číslo pozrieme na celý interval a hľadáme či tam je) a vypíšeme najmenšie z nich. Takéto riešenie má časovú zložitosť $O(m\\cdot n^2)$ a dostane dva až tri body.

## Vzorové riešenie

Môžeme si všimnúť, že náš bruteforce robí veľa krát to isté. Najme, ak sa intervaly prekrývajú, alebo dokonca opakujú. Niektoré prípady sa dajú vyriešiť jednoducho. Napríklad, ak sa nejaký interval presne zopakuje, môžeme si pamätať aký bol výsledok a druhý krát sa naň len pozrieť. Tiež nie je zložité vyriešiť prípady, keď je jeden interval celý obsiahnutý v inom. Vtedy stačí zistiť riešenie pre vnútorný, lebo vonkajší obsahuje všetko to čo vnútorný (možno niečo viac).

Na plný počet to však stále nestačí. Musíme vyriešiť aj prípady, keď sa intervaly čiastočne prekrývajú. Spravíme to tak, že si budeme jeden interval posúvať a postupne pri tom pokryjeme každý interval, ktorý v sebe nemá obsiahnutý žiaden menší interval.

Koniec nášho intervalu budeme posúvať od začiatku po koniec, a vždy sa pozrieme iba na najmenší z intervalov, ktoré končia na tomto políčku. Všetky ostatné čo na ňom končia ho celý obsahujú. Môžeme si všimnúť, že ak sa v jednom kroku pozeráme na interval, ktorý začína na políčku $z$, ďalej nás zaujímajú len intervaly, ktoré začínajú ďalej. Ak narazíme na interval ktorý nezačína ďalej, znamená to, že obsahuje celý interval na ktorý sme sa už pozerali.

Ak ďalší začína ďalej, potrebujeme začiatok z predošlého kola posunúť. Spravíme to tak, aby sme rovno zistili výsledok pre nový interval. Budeme si pamätať pre každé číslo, koľko krát sa nachádza v našom intervale, a pri posúvaní ľavého konca ich budeme z tade vyhadzovať (pri posúvaní pravého pridávať). Takto budeme vždy vedieť, aké čísla sú v intervale, na ktorý sa práve pozeráme. Stále však nevieme, či tam nejaké číslo chýba. Preto si budeme okrem toho pamätať aj koľko rôznych čísel tam je. Ak zistíme, že pole je dlhšie ako počet rôznych čísel, znamená to, že tam nejaké chýba. Tiež to znamená, že v ďalšom výpočte nás nemusia zaujímať čísla od neho väčšie, a preto môžeme pole v ktorom si ich pamätáme skracovať, kým naša podmienka nezačne platiť (počítame len čísla ktoré boli do teraz v každom intervale). Ak pri tom vyhodíme nejaké číslo ktoré sa v intervale nachádzalo, musíme aj zmenšiť počet rôznych čísel ktorý si pamätáme.

Keď takýmto spôsobom prejdeme celé pole a všetky intervaly, stačí nám vypísať počet rôznych čísel, lebo v každom intervale na ktorý sme sa pozerali, ich aspoň toľko je.

Časová zložitosť takéhoto riešenia je $O(m+n)$, pretože začiatok aj koniec intervalu na ktorý sa práve pozeráme posúvame iba doprava, a to sa dá najviac $n$ - krát. Keď nesedí počet rôznych čísel, pole vždy len zmenšujeme, čo sa tiež dá najviac $n$ - krát.

Pamäťová zložitosť je $O(n)$, pretože pre každé políčko v poli nám stačí pamätať si začiatok najkratšieho intervalu, ktorý na ňom končí.
",6
5fa6b00a2f90840e,ksp,"# Egyptské pyramídy

Neferjerry vyšla na balkón jej luxusného sídla. Do tváre jej hneď udrela všade prítomná horúčava Egypta. Rozpálený suchý vzduch bol narušený iba údermi vejárov jej otrokov. Pomaly sa presunula k lehátku skrytom v tieni, ľahla si naň a nechala sa kŕmiť bobuľkami hrozna. Život hlavného architekta faraónov bol plný prepychu a pohodlia.

V poslednom čase ju však trápilo nové zadanie. Postaviť obrovskú Cheopsovu pyramídu bola hračka. Naplniť skrytú hrobku Tutanchamóna kliatbami bola výzva, ale nič čo by nezvládla. To čo však od nej žiadal Tutanjanón bolo takmer nemožné.

Všetci predsa vedia, že pyramída sa stavia z obrovských kamenných blokov tvaru kocky. Z nich sa tvorí $h$ poschodí pyramídy. Najspodnejšie poschodie je štvorec, ktorého jedna strana má $x$ blokov, najvrchnejšie poschodie je tvorené jediným blokom. Zvyšné poschodia sú následne pekne vycentrované na stred pyramídy. A doteraz bolo zvykom, že tieto poschodia boli takisto štvorcové.

Nový faraón si však zmyslel, že vôbec nebude vadiť ani keď to budú ""takmer štvorce"". A namiesto toho aby ju nechal navrhnúť najkrajšiu takúto pyramídu, rozhodol sa vybrať si ju náhodne. Neferjerry preto povedal, aby zistila, koľko rôznych pyramíd by mohla postaviť, aby vedel, z čoho si vyberá. A hoci kopy pergamenov zapísaných výpočtami sa zväčšujú, Neferjerry nie je o nič bližšie k riešeniu.

Rozmýšľajúc sa pozrela na vás, ako ju ovievate a kŕmite hroznom. Však na čo mať otrokov (čítaj riešiteľov KSP), ak nie na špinavú prácu a nudné výpočty. Rukou prešla po koženom biči, ktorý jej ležal pri nohách a s úsmevom sa otočila na vás: ""Mám pre vás úlohu...""

## Úloha

Vašou úlohou bude zistiť počet pyramíd, ktoré Neferjerry môže postaviť faraónovi Tutanjanovi. Tieto pyramídy musia spĺňať nasledovné podmienky:

- vrchné poschodie je tvorené jedným blokom
- pyramída má práve $h$ poschodí
- spodné poschodie je tvorené $x \\times x$ blokmi
- každé poschodie je v oboch rozmeroch aspoň o dva bloky kratšie ako poschodie pod ním (to spôsobí, že keď ich vycentrujeme na stred, tak každé poschodie bude vo všetkých štyroch smeroch aspoň o jeden blok kratšie ako to pod ním a pyramída bude pekná)
- každé poschodie musí byť ""takmer štvorec"" -- to je taký obdĺžnik, v ktorom je absolútna hodnota rozdielu jeho šírky a dĺžky najviac 3 (všimnite si, že štvorec je tiež ""takmer"" štvorec)

Dve pyramídy považujeme za rôzne ak sa líšia vo veľkosti aspoň jedného poschodia z pohľadu od Cheopsovej pyramídy. To znamená, že pyramída, ktorej tretie poschodie má veľkosť $3\\times 4$ je rozdielna od pyramídy, ktorej tretie poschodie má veľkosť $4 \\times 3$.

Keďže počet takýchto pyramíd môže byť naozaj veľký, vypíšte zvyšok tohto čísla po delení $1,000,000$.

## Formát vstupu

Vstup je tvorený dvoma číslami $h$ a $x$ ($2 \\leq h \\leq 2,000$, $3 \\leq x \\leq 5,000$) -- prvé určuje výšku pyramídy a druhé veľkosť najspodnejšieho poschodia. Vo všetkých vstupoch platí, že $x \\geq 2\\cdot h - 1$, teda vždy sa dá postaviť aspoň jedna taká pyramída.

V jednotlivých sadách navyše platia nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:------------------- | ----:| -----:| -----:| --------:| ---------:| ----------:| ----------:| ----------:| | $h \\leq$ | $2$ | $10$ | $100$ | $2000$ | $500$ | $1,000$ | $2,000$ | $2,000$ | | $x \\leq$ | $15$ | $50$ | $500$ | $500$ | $1,500$ | $3,500$ | $5,000$ | $5,000$ |

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet pyramíd, ktoré spĺňajú všetky uvedené podmienky, modulo $1,000,000$.

## Príklad

```vstup
3 7
```

```vystup
9
```

_Vrchné aj spodné poschodia sú jednoznačne určené. Stredné poschodie môže mať nasledovné veľkosti: $5\\times 5$, $5\\times 4$, $5\\times 3$, $4\\times 5$, $4\\times 4$, $4\\times 3$, $3\\times 5$, $3\\times 4$, $3\\times 3$._

```vstup
12 23
```

```vystup
1
```

_Každé poschodie musí byť štvorec o dva menší ako poschodie pod ním._

```vstup
7 20
```

```vystup
397944
```
","# Egyptské pyramídy

Zopakujme si zadanie úlohy. Máme spočítať počet pyramíd, ktoré majú $h$ poschodí, vrchné je veľkosti $1\\times 1$, spodné $x\\times x$ a poschodia medzi sú ""takmer štvorce"", teda ich šírka a dĺžka sa nelíši o viac ako 3. Navyše sa poschodia postupne od spodu zužujú, presnejšie, šírka aj výška každého poschodia je aspoň o 2 menšia ako poschodia priamo pod ním.

Vždy, keď riešime problém s počítaním možností mali by sme sa zamyslieť, či nevieme využiť dynamické programovanie. Pri tejto technike si najskôr sformulujeme problém a následne skúšame vypočítať jeho riešenie na základe jemu podobných podproblémov.

Nie vždy je vhodné si ako problém zobrať úlohu zadania, skôr by malo platiť, že pomocou zvoleného problému vieme ľahko na zadanie odpovedať. V tomto prípade je to však pomerne ľahké a priamo zo zadania vyplýva nasledovná otázka: *Koľkými spôsobmi vieme postaviť korektnú pyramídu výšky $n$, ktorej spodné poschodie má veľkosť $w\\times h$?*

Keďže pyramídy nemusia mať vždy štvorcové podstavy, problém sme si trochu zovšeobecnili na podstavy $w \\times h$. Stále však vieme ľahko odpovedať na pôvodnú otázku, stačí, keď nastavíme $w = x$ a $h = x$.

Ďalším krokom je zistiť, či vieme na túto otázku odpovedať pomocou výsledkov pre jednotlivé podproblémy. Čo to vlastne ten podproblém je? Je to pôvodná otázka, do ktorej dosadíme iné, menšie parametre. Teda napríklad, koľko je pyramíd výšky $n-1$ s veľkosťou základne $4\\times 3$. Aby sme nemuseli našu otázku vždy rozpisovať, označme si počet pyramíd výšky $n$ so základňou $w \\times h$ ako $P(n, w, h)$.

Náš pôvodný problém je nájsť hodnotu $P(n, x, x)$. Ako takéto pyramídy vyzerajú? Ich spodné poschodie je veľké $x \\times x$ a potom sú tam poukladané zvyšné poschodia. Tieto zvyšné poschodia však tvoria korektnú pyramídu výšky $n-1$. Jediné čo nevieme je, akú podstavu tieto menšie pyramídy majú. Uvedomme si však, že napríklad, každú pyramídu výšky $n-1$, ktorej podstava je $(x-2) \\times (x-2)$ vieme postaviť na poschodie $x \\times x$ a dostať tak pyramídu, ktorú hľadáme. Tým pádom, hodnota $P(n, x, x)$ obsahuje všetky možnosti $P(n-1, x-2, x-2)$.

A to je už skladanie podproblémov. Vidíme, že ak vypočítame $P(n-1, x-2, x-2)$, táto hodnota nám pomôže pri výpočte hľadaného $P(n, x, x)$. No ale $P(n-1, x-2, x-2)$ je ten istý problém, len trochu menší, na jeho riešenie preto môžeme použiť ten istý postup. A to je základnou myšlienkou dynamického programovania.

Ak chceme vypočítať $P(n, x, x)$, musíme zistiť, aké všetky pyramídy veľkosti $n-1$ vieme položiť na poschodie $x \\times x$. Ich výšku poznáme, stačí teda skúsiť všetky možnosti pre podstavu. Z toho plynie nasledovný jednoduchý program. Odporúčam si ho prečítať, ak ste sa s dynamickým programovaním ešte nestretli. Pekne ukazuje, aká jednoduchá je to technika, keď si položíte správnu otázku.

Vo vyššie uvedenom programe si všimnite dve dôležité veci. Jednak, naša rekurzia musí mať ukončenie. To je väčšinou určené podproblémom, ktorý vieme vyriešiť ručne. V našom prípade pyramída výšky 1 s podstavou $1 \\times 1$, ktorá je naozaj len jedna. Takisto si však treba dať pozor na prípady, ktoré už k riešeniu nevedú. Druhým pozorovaním je, že aby sme dookola nepočítali tie isté veci, pamätáme si už vypočítané výsledky v poli `Mem[]`. Táto technika sa volá memoizácia a výrazne zrýchľuje väčšinu rekurzívnych funkcií. Naozaj jediné čo s `Mem[]` robíme je, že si do tohto poľa vkladáme vypočítané hodnoty a ak sa pýtame na niečo, čo už máme zapamätané, vrátime namiesto toho túto hodnotu.

Aká je časová zložitosť nášho programu. Pri takomto type rekurzií sa to v skutočnosti odhaduje pomerne ľahko. Stačí zistiť koľko rôznych podproblémov môžeme riešiť a ako dlho nám trvá riešenie jedného z nich. Možných podproblémov je $n \\cdot x \\cdot x$ -- všetky možnosti pre výšku, šírku a dĺžku pyramídy. Výpočet jednej možnosti je pritom $x \\cdot x$, pretože musíme vyskúšať všetky možnosti pre šírku a dĺžku podstavy o poschodie vyššie. Celková zložitosť je preto $O(nx^4)$.

## Zapojenie ""takmer štvorcov""

Naše riešenie je príliš pomalé, je však zrejmé, že to tak vôbec nemusí byť a veľa vecí sme si zbytočne zjednodušili. Napríklad sme nijak nevyužili fakt, že jednotlivé poschodia musia byť takmer štvorce. Skúšame preto úplne zbytočné možnosti ako $P(10, 9, 3)$. Síce vieme spočítať počet takýchto pyramíd, ale na čo nám sú, ak podstavu $9 \\times 3$ nikdy nevieme použiť? Toto platí o rekurziách a dynamikách aj všeobecne. Keď sa ich snažíme zrýchliť, vždy si treba klásť otázku, či niečo nepočítame dvakrát, poprípade zbytočne.

Zapojenie takmer štvorcov ovplyvňuje dve miesta v kóde -- počítanie možných podstáv pre nižšie pyramídy a samotný počet a tvar podproblémov. Začnime tým prvým. V predchádzajúcom riešení sme pre pyramídu výšky $n-1$ skúšali všetky možné šírky a dĺžky pre podstavu. My však vieme, že ich rozdiel môže byť najviac 3. Ako v riešení vyskúšať všetky takéto veľkosti? Uvedomme si, že stále chceme skúšať každú možnú šírku, k danej šírke však už neskúšame všetky dĺžky, ale iba tých 7 zaujímavých -- o 3 menšiu až o 3 väčšiu ako šírka. Toto zrýchli počítanie možností na $O(x)$, keďže 7 je iba malá konštanta.

Druhú úpravu musíme spraviť priamo vo formáte podproblému, nechceme počítať a vôbec dovoľovať podproblémy, ktoré nás nezaujímajú. Jeden z dôvodov je napríklad aj ten, že sa nám tým zmenší veľkosť nášho poľa `Mem[]`, čo je dôležité, pretože vytvoriť pole nejakej veľkosti trvá rovnako veľa času. Ak by sme teda tieto podproblémy nepočítali, ale mali by sme pre ne vytvorené miesto v pamäti, vôbec by sme si nepomohli. Náš problém si preto preformulujeme na *Koľkými spôsobmi vieme postaviť korektnú pyramídu výšky $n$, ktorej spodné poschodie má šírku $w$ a dĺžku o $dx$ inú?* Pričom samozrejme $dx$ môže mať iba hodnoty $-3$ až $3$.

Ako sa zmenila časová zložitosť našeho riešenia? Počet podproblémov je už iba $n \\cdot 7x$ -- určíme si výšku, šírku a dĺžka už môže mať iba jednu zo 7 možností na základe šírky. A jeden podproblém vypočítame v čase $7x$ -- skúsime každú šírku a iba 7 okolitých dĺžok. Výsledné riešenie má teda zložitosť $O(n \\cdot x^2)$.

K implementácii tohto riešenia ešte dodajme, že je ťažké si pole indexovať zápornými číslami, preto $dx$ nebude nadobúdať hodnoty $-3$ až $3$ ale $0$ až $6$. Počet hodnôt je rovnaký, sú kladné, je však na nás, aby sme sa v nich nedoplietli a správne ich používali.

## Rýchlejšie počítanie jedného podproblému

Predchádzajúce riešenie však stále nie je dostatočne rýchle. Nie je však veľa vecí, ktoré by sme vedeli zmeniť. Počet podproblémov už veľmi nezmeníme, predsa len, musíme si pamätať výšku a veľkosť základne. To znamená, že treba zrýchliť výpočet jedného podproblému. Pri aktuálnom riešení postupne skúšame všetky o jedno nižšie pyramídy, ktoré sa zmestia na zadanú podstavu. Bohužiaľ, my poznáme odpoveď iba pre konkrétnu veľkosť podstavy a preto musíme robiť všetky tie skúšania. Čo by sa ale stalo, keby sme namiesto toho vedeli odpovedať na nasledovný problém: *Koľkými spôsobmi vieme postaviť korektnú pyramídu výšky $n$, ktorej **spodné poschodie je nanajvýš** $w$ široké a $w + dx$ dlhé?* Označme si túto hodnotu $T(n, w, dx)$. Potom predsa platí, že $P(n, w, dx) = T(n-1, w-2, dx)$, pretože sa viem rovno dozvedieť počet pyramíd, ktoré viem dať na podstavu $w \\times (w + dx)$.

No dobre, ale pomohli sme si vôbec? Lebo sme si iba vytvorili nový dynamický problém, ktorý však stále potrebujeme vedieť vypočítať. Ako však uvidíme, vyriešiť tento problém je o niečo jednoduchšie. Takže ešte raz, hľadáme počet pyramíd výšky $n$, ktorých podstava je nanajvýš $w \\times (w+dx)$. Medzi ne určite patria pyramídy, ktorých podstava je presne takto veľká. A tých vieme, že je $T(n-1, w-2, dx)$. Následne už len potrebujeme pripočítať pyramídy, ktorých podstava je menšia. Menšia môže byť v šírke alebo dĺžke. Čo keby ich šírka bola najviac $w-1$? Potom počet takýchto pyramíd je $T(n, w-1, dx+1)$ -- sú vysoké $n$ poschodí, ich šírka je $w-1$ a ich dĺžka je rovnaká ako pred tým, čo spôsobí, že $dx$ sa zväčší o 1 (lebo $w$ sa o 1 zmenšilo). A keď chceme pyramídy, ktoré majú kratšiu dĺžku, dostaneme hodnotu $T(n, w, dx-1)$. No a hodnoty $T()$ zahŕňajú všetky **nanajvýš** takto veľké pyramídy, nemusíme preto skúšať všetky možné veľkosti podstavy.

Toto avšak nie je všetko, musíme si uvedomiť chybu v našom riešení. Hodnoty $T(n, w-1, dx+1)$ a $T(n, w, dx-1)$ obsahujú totiž niekoľko rovnakých pyramíd. Presnejšie, každá pyramída výšky $n$, ktorej podstava je nanajvýš $(w-1) \\times (w+dx-1)$ spadá pod obe tieto čísla, pretože takto veľké podstavy sú rovnako nanajvýš veľké ako podstavy $(w-1) \\times (w+dx)$ a aj podstavy $w \\times (w+dx-1)$. No dobre, ale tieto pyramídy sú práve pyramídy $T(n, w-1, dx)$ a ak sme ich započítali dvakrát, tak ich potrebujeme raz odpočítať. To nás dostáva k výslednému vzorcu:

$$T(n, w, dx) = T(n-1, w-2, dx) + T(n, w-1, dx+1) + T(n, w, dx-1) - T(n, w-1, dx)$$

Malá poznámka na záver. Tento vzorec je dobrý, ale občas nemusí byť úplne pravidvý. Totiž podstavy $(w-1) \\times (w+dx)$ nemusia už byť platné, lebo ich rozdiel je priveľký. V takom prípade túto hodnotu nepripočítavame, čím nám nevzniknú duplikáty a teda nechceme ani odčítavať $T(n, w-1, dx)$. To sú však skôr implementačné detaily, na ktoré si treba dať pozor, keď sa však budete zamýšľať nad tým, čo píšete a čo tie veci znamenajú, ľahko sa im vyhnete.

Vo výsledku hodnoty $P()$ ani nepotrebujeme počítať, celú úlohu vieme vyriešiť pomocou hodnôt $T()$. A aká je zložitosť? Počet podproblémov $T()$ je stále $n \\cdot 7x$. Akurát ich počítanie sa zrýchlilo, pretože nám stačí vypočítať vyššie uvedený vzorec, čo trvá konštantne veľa času. Celková časová zložitosť je $O(nx)$. Pamäťová zložitosť je totožná počtu podproblémov, teda tiež $O(nx)$. Túto by sme vedeli síce zmenšiť, ak by sme použili dynamické programovanie namiesto rekurzie s memoizáciou, takéto riešenie však nebolo vyžadované.
",8
583ec3103962fb0f,ksp,"# i-Build

Denis sa v lete vybral na brigádu do továrne na kreatívne detské hračky, ktorú vlastní známa americká technologická firma. Zakladatelia tejto značky prišli s nápadom používať pri výrobe hračiek pre deti praktické a život zachráňujúce materiály. Napríklad, časti ich stavebnice sú vyrobené zo špeciálnej hmoty, ktorá pohlcuje radiáciu a tým chráni a lieči deti.

Stavebnica sa skladá z hranolov s rozmermi $1,cm$, $1,cm$ a $n,cm$. Hranoly stavebnice sa ukladajú vždy len rovnobežne na seba, čím vytvárajú akési veže tak, ako je to znázornené na obrázku (pohľad z boku).

Platia pri tom tieto pravidlá:

- Vrch veže (hranol, na ktorom už nie je položený iný hranol) je kocka s rozmermi $1,cm$, $1,cm$ a $1,cm$.
- Hranol $a$ položený na hranole $b$ je kratší než hranol $b$.
- Medzi podstavami (spodkami) veží je medzera $1,cm$.
- Medzi koncom hranola a podstavou veže je $1,cm$.

Denis má k dispozícii len istý opis stavebnice. Každý hranol má svoje číslo $x$ ($0 \\leq x < n$), pričom $n$ je počet hranolov v stavebnici. Denis dostane len zoznam $n-1$ dvojích hranolov $a$ a $b$, ktoré sa dotýkajú (jeden je položený na druhom). To sa dá reprezentovať ako stromový graf ako na obrázku, pričom jeho koreň je v najdlhšom hranole a ten má vždy číslo $0$.

Denisovou úlohou je presne zistiť, koľko centimetrov kubických hmoty je potrebných na výrobu konkrétnej stavebnice. Pomôžete mu?

## Formát vstupu

Na prvom riadku vstupu je číslo $t$ udávajúce počet stavebníc. Nasleduje popis $t$ stavebníc. Na prvom riadku stavebnice je číslo $n$, ktoré hovorí o počte hranolov. Nasleduje $n-1$ dvojíc hranolov $a$ a $b$, ktoré znamenajú, že hranoly $a$ a $b$ sa dotýkajú.

Platí $1 \\leq t \\leq 500$ a $1 \\leq$ súčet $n \\leq 200,000$.

## Formát výstupu

Pre každú stavebnicu vypíšte jedno celé číslo udávajúce objem stavebnice v $cm^3$ ($cm^3$ nevypisujte).

## Príklady

```vstup
2
7
0 1
2 0
0 3
2 4
5 2
6 3
3
1 2
1 0
```

```vystup
25
9
```

_Na vstupe sú dve stavebnice. Prvá z nich je zobrazená aj na obrázku vyššie. Druhá z nich je jednoduchšia - je to pyramída výšky $3$, kde najspodnejší hranol $0$ má dĺžku $5$, na ňom hranol $1$ má dĺžku $3$ a vrchný hranol $2$ má dĺžku $1$. To je dokopy objem $9cm^3$._
","# i-Build

## Objem, obsah alebo dĺžka?

""Stavebnica sa skladá z hranolov s rozmermi $1,cm$, $1,cm$ a $n,cm$.""

Síce máme zistiť objem staebnice, zaujíma nás len jeden rozmer každého dieliku, keďže tie zvyšné dva sú stále konštantné $1,cm$ a $1,cm$. Zaujímajú nás teda len dĺžký všetkých hranolov. Tiež vieme, že súčet dĺžok hranolov sa rovná súčtu objemov hranolov, čiže celkovému objemu stavebnice, keďže prierez každého hranolu je štvorec s rozmermi $1,cm$ a $1,cm$.

Dobre. Aké dĺžky majú hranoly stavebnice? Pripomeňme si pravidlá:

- Vrch veže je kocka s rozmermi $1,cm$, $1,cm$ a $1,cm$.
- Medzi podstavami (spodkami) veží je medzera $1,cm$.
- Medzi koncom hranola a podstavou veže je $1,cm$.

## Príklad

Hranoly si rozdelíme na kocky s rozmermi $1,cm$, $1,cm$ a $1,cm$. Postupne budeme do stavebnice pridávať nové časti a ukážeme si, ako sa podľa toho menia dĺžky hranolov.

Najprv mala stavebnica len jednu malú vežu, čiže jeden hranol (oranžový) o dĺžke $1,cm$. Potom sme ale naň pridali ešte jeden hranol (zelený) a vytvorili tak vežu o výške $2$. Tým pádom sa spodný hranol predĺžil na $3,cm$. Prečo konkrétne?

Predstavme si, že sme najprv priložili zelenú kocku tak, aby vľavo od nej ešte bola medzera $1,cm$ na oranžovej kocke. Tým pádom je z ľavej strany splnené tretie pravidlo - medzi koncom spodného hranol a zeleným hranolom je $1,cm$.

Zelená kocka by teraz ale levitovala vo vzduchu, pod ňou by ostalo prázdne miesto. Preto pod celú dĺžku zleného hranola dáme modré kocky. A aby sme splnili tretie pravidlo aj z pravej strany, pridáme ešte jednu kocku vpravo.

Teraz sa v stavebnici objavila nová (zelená) veža. Je uložená na už existujúcom hranole (oranžový), ktorý sa predĺžil o modrú časť. Všimnime si, že modrá časť má dlžku zase šírky podstavy novej veže a jednu krajnú kocku naviac.

## Dĺžka hranola

Takže akú dlžku má hranol stavebnice? Vždy aspoň $1,cm$. Pre každý hranol na ňom prirátame jeho dĺžku a $1,cm$ za kocku vpravo, aby medzi koncom spodného a horného hranola bola medzera $1,cm$ alebo aby existovala medzera $1,cm$ medzi dvoma susednými vežami. Z toho nám teda vychádza akýsi vzorec: 1 + súčet dĺžok podstáv (šírok) veží + počet veží.

Ak si túto stavebnicu predstavíme ako strom, kde každý vrchol je jeden hranol stavebnice, a rozdelíme si ho na podstromy, tak šírka každého podstromu závisí od jeho podstromov. Každý podstrom reprezentujúci vežu má nejakú šírku, čiže dĺžku hranola v jeho koreni -- dĺžku podstavy.

## Rekurzia

Keďže vo ""vzorci"" na výpočet dĺžky jedného hranola používame šírky veží na ňom (dĺžky ďalších hranolov), ktoré závisia od dĺžok ďalších hranolov nad nimi atď., vidíme tu akýsi rekurzívny princíp.

Na to aby sme zistili dĺžku koreňa nejakého podstromu, musíme najprv zrátať dĺžky jeho synov a ich synov atď.

Táto rekurzia ale musí mať konečnú hĺbku. Pre ktoré hranoly/vrcholy vieme určiť ich dĺžku bez potreby spúšťania ďalšej rekurzie? Hmm... Listy tohto stromu, čiže vrcholy veží, majú vždy dĺžku $1,cm$. To sedí aj podľa nešho vzorca. Ak na hranole nie sú žiadne ďalšie hranoly, má dĺžku $1,cm$.

Keďže je zaručené, že graf stavebnice na vstupe bude strom, a vieme, že každý strom určite má listy, máme istotu, že vytvorená rekurzia sa nezacyklí.

## Zložitosti

Takouto rekurziou (alebo prehľadávaním stromu do hĺbky) navštívime každý vrchol práve raz, čiže časová zložitosť tohto riešenia je tak lineárna $O(n)$, kde $n$ je počet vrcholov grafu, počet hranolov v stavebnici.

Pamäťová zložitosť tohto riešenia je tiež lineárna $O(n)$, keďže nám stačí pamätať si zoznam susedov pre daný graf. Vieme, že strom s $n$ vrcholmi má $n - 1$ hrán.
",5
119321de4d7c2575,ksp,"# Korman je gurmán

Máme tu ďalší problém. Andrej má narodeniny a k nim dostal veľký počet darčekov. Keďže si vždy na narodeniny prial len a len veľkú sladkú čokoládu a mamka už nemohla počúvať to jeho večné fňukanie, tak sa rozhodla, že mu kúpi tú najväčšiu, akú v meste majú.

Mamka si myslela, že čokoláda všetko vyrieši a bude pokoj. Ale nevyriešila. Andrej je gurmán a jeho gurmánske požiadavky sú známe už v ďalekej Číne, možno aj ďalej. Andrej jednoducho nemôže zjesť čokoládu ako normálny človek. On si čokoládu rozdelil na _kocky_, kde každá kocka má svoju sladkosť. Tieto kocky následne uložil do jedného dlhého radu na stole.

Andrej chce teraz zjesť všetky kocky zaradom zľava doprava. Pritom chce, aby každá ďalšia kocka, ktorú zje, bola sladšia alebo rovnako sladká ako predchádzajúca. Andrej je ešte k tomu veľmi lenivý a jediné, čo vie spraviť, je zobrať nejakú kocku čokolády a dať ju na začiatok radu. S touto požiadavkou šiel k mamke, aby mu povedala, koľko preložení treba urobiť, aby boli kocky usporiadané. Lenže mamka ho už má plné zuby a keďže nevedela čo spraviť, zavolala na linku prvej pomoci KSP a žiadá vás o pomoc.

## Úloha

Na vstupe máte číslo $n$ a pole čísel veľkosti $n$. Vašou úlohou je vypočitať, koľko najmenej operácií je potrebných na usporiadanie poľa od najmenšieho čísla po najvačšie. Jediná operácia, ktorú máte povolenú, je zobrať nejaké čislo v poli a preložiť ho na začiatok. Zaujíma nás len počet týchto preložení.

## Formát vstupu

Na prvom riadku vstupu sa nachádza celé číslo $n$ ($1 \\leq n \\leq 1,000,000$) -- počet kociek čokolády. Na druhom riadku sa nachádza $n$ čísel $s_1, s_2, \\dots s_n$, kde $s_i$ označuje sladkosť $i$-tej kocky. Pre každé $i$ platí $0 \\leq s_i \\leq 10^9$.

Vaše riešenie otestujeme na štyroch testovacích sadách. V prvých dvoch sadách máte zaručené, že na vstupe sa budú vždy nachádzať čísla od $1$ po $n$, každé práve raz. Za riešenie, ktoré vyrieši takúto podúlohu, viete získať až polovicu bodov.

## Formát výstupu

Na jediný riadok výstupu vypíšte najmenší možný počet preložení potrebných na to, aby boli kocky usporiadané od najmenej sladkej po najsladšiu. Výstup ukončite znakom nového riadku.

## Príklady

```vstup
5
5 1 2 3 4

```

```vystup
4
```

_Najprv preložíme na začiatok kocku so sladkosťou 4. Potom kocku so sladkosťou 3, potom 2, a nakoniec 1. Urobili sme 4 preloženia._

```vstup
6
1 1 1 1 1 1
```

```vystup
0
```

_V tomto prípade netreba prekladať nič._

```vstup
10 
1 5 6 50 12 3 499 5000001 3 3
```

```vystup
7
```
","# Korman je gurmán

Našou úlohou je usporiadať pole čísel od najmenšieho po najväčšie len pomocou toho, že budeme čísla prenášať na začiatok poľa. Presnejšie povedané, chceme zistiť, na koľko najmenej takýchto operácií sa dá naše pole usporiadať.

V tomto vzoráku si v prvej časti predstavíme základné pozorovania potrebné pre vyriešenie tejto úlohy -- popisy vašich riešení by mohli obsahovať aspoň hrubo zvýraznené myšlienky. V druhej časti si ukážeme, ako sa dá jednoducho vypočítať riešenie v čase $O(n)$, ak vstup obsahuje len čísla $1$ až $n$ a ako sa dá toto riešenie zovšeobecniť pomocou triedenia na ľubovolné pole a dostať riešenie v čase $O(n \\log n)$. Ak vás zaujíma len optimálne riešenie, môžete po prečítaní prvej časti preskočiť na poslednú časť, kde si ukážeme, ako získať časovú zložitosť $O(n)$ pomocou zásobníka.

## Myšlienka riešenia

Prvé pozorovanie, ktoré nám pomôže pri riešení, je, že každé pole dĺžky $n$ vieme usporiadať s použitím $n$ operácií. Najprv presunieme na začiatok najväčšie číslo, potom druhé najväčšie, potom tretie, atď. Na konci postupu tak preložíme na začiatok najmenšie číslo a dostaneme usporiadané pole.

Pri takomto postupe ale robíme niektoré operácie zbytočne. Môžeme si všimnúť, že **najväčšie číslo nikdy prekladať nemusíme**. Ak totiž preložíme ostatných $n - 1$ čísel, najväčšie číslo bude na konci poľa -- teda tam, kde má byť.

Podobne si môžeme všimnúť, že ak je druhé najväčšie číslo naľavo od najväčšieho, ani toto číslo presúvať nemusíme, lebo keď vykonáme zvyšných $n - 2$ operácií (presunieme na začiatok tretie najväčšie, štvrté najväčšie, ..., najmenšie) tak bude pole usporiadané. Túto úvahu môžeme zovšeobecniť.

Predpokladajme, že $k$ najväčších čísel je na vstupe v správnom poradí ($k$-te najväčšie je naľavo od $(k-1)$-vého najväčšieho, to je naľavo od $(k-2)$-hého, ...). Potom nám stačí postupne presunúť zvyšných $n-k$ čísel, teda urobíme $n-k$ operácií.

Ak je naše $k$ najväčšie možné (teda $(k+1)$-vé najväčšie číslo je už napravo od $k$-teho), tak sa pole nedá utriediť na menej ako $n-k$ operácií. Niekedy totiž musíme presunúť $(k+1)$-vé najväčšie číslo, aby sme ho dostali naľavo od $k$-teho. A potom **budeme už musieť preložiť aj všetky menšie čísla** aby sme ich dostali pred neho. To znamená, že každé z $n-k$ najmenších čísel musíme aspoň raz presunúť.

Zoberme si ako príklad postupnosť: $5, 6, 3, 7, 2, 1, 4$. Tri najväčšie čísla sú v správnom poradí ($5$ je naľavo od $6$ a $6$ od $7$), teda najväčšie možné $k$ je $3$. Číslo $4$ niekedy určite presunúť musíme, aby sme ho dostali naľavo od $5$. Potom musíme na začiatok popresúvať aj všetky menšie čísla: $3, 2, 1$.

Na vyriešenie úlohy nám teda stačí nájsť najväčšie také $k$, že $k$ najväčších čísel je na vstupe v správnom poradí, a potom vypísať hodnotu $n - k$. Otázkou stále zostáva, ako zistiť hodnotu $k$.

V polovici vstupných sád platilo, že na vstupe sa nachádza $n$-prvkové pole čísel $1$ až $n$. Pri takýchto vstupoch vieme hneď povedať, že najväčšie číslo bude $n$, druhé najväčšie $n-1$, atď.

Mohli by sme teda pre každé číslo od $n$ po $1$ zisťovať, či sa naľavo od neho nenachádza väčšie číslo, čím by sme dostali algoritmus s časovou zložitosťou $O(n^2)$.

Efektívnejšie však bude priamo zostrojiť postupnosť $k$ najväčších čísel. Pole raz prejdeme sprava doľava a postupne budeme hľadať čísla od najväčšieho po najmenšie. Aktuálne hľadané číslo si označíme ako `hladane_cislo`. Najprv hľadáme číslo $n$. Vždy keď nájdeme `hladane_cislo`, ďalej hľadáme najväčšie menšie číslo, teda `hladane_cislo` zmenšíme o $1$. Takto pokračujeme až kým neprídeme na začiatok poľa. Popritom si počítame, koľkokrát sme našli a zmenšovali `hladane_cislo` -- tento počet je naše hľadané $k$.

Takéto riešenie má časovú aj pamäťovú zložitosť $O(n)$, lebo len raz prejdeme celé pole a v pamäti držíme len jedno pole dĺžky $n$ a zopár jednoduchých premenných.

## Využitie tej istej myšlienky pre pole ľubovoľných čísel

Predošle riešenie fungovalo len ak pole malo čísla od $1$ po $n$, lebo sme predpokladali, že maximum je $n$, druhé najväčšie číslo je $n - 1$ atď. Ak máme v poli ľubovoľné čísla, nevieme, ktoré je najväčšie, druhé najväčšie atď.

Riešenie pre čísla od $1$ po $n$ však vieme jednoducho upraviť. Trik spočíva v tom, že si vytvoríme ešte jedno pole, nakopírujeme doň čísla zo vstupu a usporiadame ho vzostupne. Ak veľmi nepoznáte triediace algoritmy, odporúčame prečítať si o nich [v kuchárke a v odkazoch z nej](https://www.ksp.sk/kucharka/triedenie/). Pri riešení tejto úlohy nám bude stačiť vedieť, že pole $n$ prvkov vieme efektívne usporiadať v čase $O(n \\log n)$.

Pomocou usporiadaného poľa už vieme rýchlo zisťovať, aké je $i$-te najväčie číslo -- maximum je na indexe $n-1$ (ak pole indexujeme od 0), druhé najväčšie na indexe $n-2$, atď. Vieme teda použiť rovnaký algoritmus ako v predošlom riešení s jednou drobnou zmenou: prezeraný prvok poľa neporovnávame s hodnotou v premennej `hladane_cislo` ale s prvkom utriedeného poľa s indexom `index_hladaneho_cisla`. V riešení teda znova prechádzame vstupné pole od konca a ak je prezerané číslo práve to hľadané, zmenšíme ukazovateľ `index_hladaneho_cisla` o $1$.

Optimálne triedenie má časovú zložitosť $O(n\\log n)$, a po utriedení vykonávame len algoritmus z predošlej časti, ktorý beží v lineárnom čase $O(n)$. Celkovo je teda časová zložitosť $O(n\\log n + n) = O(n \\log n)$. Pamäťová zložitosť je $O(n)$, lebo potrebujeme 2 polia dĺžky $n$.

## Optimálne riešenie

Keďže pri riešení úlohy musíme minimálne prečítať celý vstup, žiadne riešenie nemôže byť rýchlejšie ako $O(n)$. Ak teda vymyslíme algoritmus s lineárnou zložitosťou, budeme si istí, že je najlepší možný (ak porovnávame algoritmy [asymptotickou časovou zložitosťou](https://www.ksp.sk/kucharka/zlozitost1/)).

Predošlé riešenie nám spomaľovalo triedenie, ktoré sme potrebovali na to, aby sme vedeli určiť hľadané $i$-te najväčšie číslo. Ak mierime na zložitosť $O(n)$, musíme sa triedeniu vyhnúť a ideálne vyriešiť úlohu len jedným prechodom cez pole.

Vráťme sa v úvahách späť k myšlienke ""niekde v poli bude usporiadaná podpostupnosť niekoľkých najväčších čísel a práve tieto čísla nemusíme presúvať"". V predošlých riešeniach sme najprv zistili, ktoré sú to tie najväčšie čísla a potom sme konkrétnu postupnosť odzadu hľadali vo vstupnom poli. Pokúsme sa teraz začať prechádzať pole od konca, bez toho, aby sme vedeli čo hľadáme. Priebežne si budeme udržovať kandidátsku podpostupnosť -- postupnosť najväčších doteraz videných čísel, ktoré boli vzájomne dobre usporiadané. Na uchovávanie kandidátskej podpostupnosti použijeme [zásobník](https://www.ksp.sk/kucharka/stack_queue_deque/).

Vstupné pole budeme prechádzať sprava doľava, a postupne si budeme čísla vkladať do zásobníka. Predtým, než vložíme nové číslo $x$ do zásobníka, z jeho vrchu postupne odstránime všetky čísla, ktoré sú menšie ako $x$. To nám zabezpečí, že v zásobníku budú čísla usporiadané -- na spodku bude najväčšie doteraz videné číslo. Keď prejdeme celé pole, tak na spodku bude najväčšie číslo. Druhý prvok odspodu bude najväčšie číslo, ktoré bolo naľavo od maxima. Tretí prvok odspodu bude najväčšie číslo, ktoré bolo ešte viac naľavo, atď.

Zásobník teda bude obsahovať niekoľko najväčších, dobre usporiadaných čísel, no môže obsahovať aj čísla, ktoré musíme presúvať. Pozrime sa na príklad $1, 5, 3, 7, 2, 6, 8, 4$. Po prejdení celého poľa ostane v zásobníku podpostupnosť $1, 5, 7, 8$. Číslo $6$ ale musíme pri usporiadavaní preložiť na začiatok a tak budeme musieť preložiť aj $5$ a $1$, ktoré zostali v zásobníku. Na to, aby sme dostali našu žiadanú postupnosť nehybných čísel, musíme teda zo zásobníka odstrániť všetky čísla, ktoré sú menšie ako najväčšie odstránené číslo.

Môžeme si všimnúť, že čísla odstránené zo zásobníka počas prechodu poľa sú vlastne tie čísla, ktoré bolo nutné presunúť, lebo naľavo od nich sa nachádzalo nejaké väčšie číslo. Čísla odstránené zo zásobníka na záver sú tie čísla, ktoré bolo nutné presunúť, lebo sa pred nich dostalo nejaké väčšie číslo.

Celkový počet potrebných presunov je teda počet čísel odstránených zo zásobníka, alebo jednoducho $n$ mínus počet čísel v zásobníku.

Toto riešenie bude mať časovú zložitosť $O(n)$, lebo prechádzame celé pole len raz a každé číslo do zásobníka vložíme práve raz a odstránime ho najviac raz. Pamäťová zložitosť zostáva $O(n)$, keďže potrebujeme len pole dĺžky $n$ a zásobník dĺžky najviac $n$. Za toto riešenie ste mohli dostať plný počet bodov.
",4
9ee3ae4c29409f93,ksp,"# O Žabovej krutovláde

Kde bolo tam bolo, žil raz jeden krutý vládca, ktorý sa volal Žaba. Ľuďom sa pod jeho nadvládou žilo ťažko. Od východu slnka až po jeho západ museli všetci tvrdo pracovať na jeho poliach, dbať o vyváženosť stromov v jeho záhrade, starať sa o čistotu na jeho hrade^[Známe aj ako garbage collection.], plniť všetky príkazy, ktoré mu napadli, ... A to všetko bez nároku na nejakú odmenu.

Spod Žabovej nadvlády sa dalo dostať iba tak, že ste si získali jeho rešpekt. A to sa oficiálne robilo tak, že Žaba vám dal programátorskú úlohu a dve hodiny času. Ak ste ju vyriešili v časovom limite, boli ste voľní, a mohli ste emigrovať do susednej krajiny. Ak nie, tak vás Žaba nechal slávnostne popraviť.

Erik sa rozhodol vyskúšať svoje štastie. Žaba mu zadal nasledujúcu úlohu: ""Na vstupe dostaneš reťazec pozostávajúci z cifier $0$ až $9$. Tvojou úlohou je vypočítať, aké číslo by sme dostali, ak by sme sčítali všetky jeho súvislé podreťazce, modulo $10^9 + 7$.""

Erik si s úlohou nevie rady. Naštastie, v dnešnej modernej dobe majú ľudia schopnosť telepatie^[Známe aj ako internety.]. Pomôžte mu!

## Úloha

*Súvislým podreťazcom* daného reťazca $s$ v tejto úlohe nazývame ľubovoľný neprázdny reťazec, ktorý vznikne odstránením niekoľkých (nula alebo viac) znakov zo začiatku a niekoľkých znakov z konca reťazca $s$. Dva súvislé podreťazce reťazca $s$ považujeme za rôzne, ak sa líšia v počte znakov, ktoré sme pri ich vytvorení odstránili zo začiatku, alebo z konca reťazca $s$ (aj keby inak vyzerali úplne rovnako). Napríklad reťazec `baca` má $10$ súvislých podreťazcov: `b`, `a`, `c`, `a`, `ba`, `ac`, `ca`, `bac`, `aca`, `baca` (všimnite si, že reťazec `a` rátame dvakrát).

Na vstupe dostanete reťazec znakov, ktorý obsahuje len cifry $0, 1, \\ldots, 9$. Znaky sa môžu ľubovoľne opakovať a reťazec môže začínať aj ľubovoľným počtom núl. Vašou úlohou je vypočítať súčet všetkých jeho súvislých podreťazcov. Výsledok môže byť veľmi veľké číslo, vypíšte preto jeho zvyšok po delení $10^9 + 7$.

## Formát vstupu

Na jedinom riadku vstupu je reťazec $s$, ktorý obsahuje aspoň $1$ a najviac $10^6$ znakov z rozsahu `0` až `9`.

## Formát výstupu

Vypíšte jedno číslo: súčet všetkých súvislých podreťazcov, modulo $10^9 + 7$.

## Príklad

```vstup
123
```

```vystup
164
```

*$1 + 2 + 3 + 12 + 23 + 123 = 164$*

```vstup
001
```

```vystup
3
```

```vstup
4369383968
```

```vystup
353343059
```

```vstup
447723168365033648256648424988
```

```vystup
42233771
```
","# O Žabovej krutovláde

bodyprogram=8}

Na začiatok chceme upozorniť, že v tomto vzoráku indexujeme reťazce od nuly, teda reťazec dĺžky $n$ začína indexom $0$ a končí indexom $n-1$.

## Počítanie s veľkých číslami

V tejto úlohe budeme často počítať s veľmi veľkými číslami (najväčšie z nich budú rádovo miliónciferné). Počítanie s veľkými číslami je problematické: v mnohých programovacích jazykoch (Java, Pascal, C++) sa nám takéto veľké čísla nezmestia do premennej a aj v jazykoch s neobmedzene veľkými celočíselnými premennými (Python) je výpočet s takýmito veľkými číslami pomalý.

Konečný výsledok (súčet všetkých podreťazcov) však nepotrebujeme vypočítať presne -- stačí nám vypočítať jeho zvyšok po delení $10^9 + 7$. Ak pre nejaké celé čísla $a, b$ a kladné celé číslo $m$ chceme vypočítať hodnotu $$(a+b) \\bmod m\\text{,}$$ nič sa s výsledkom nestane, ak $a$ a $b$ dopredu vymodulujeme $m$. Formálne povedané, platí: $$(a+b) \\bmod m = ((a \\bmod m) + (b \\bmod m)) \\bmod m\\text{.}$$ Podobné tvrdenie platí aj s násobením namiesto sčítania: $$(a \\cdot b) \\bmod m = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\text{.}$$

Keďže sa všetky naše výpočty budú skladať iba zo sčítaní a násobení, môžeme aj každý medzivýsledok našich výpočtov modulovať číslom $10^9 + 7$. To nám zaručí, že nebudeme musieť narábať s veľkými číslami, nakoľko budú medzivýsledky zaručene menšie ako $m$.

## Hrubá sila

Najjednoduchšie riešenie je postupne prejsť všetky súvislé podreťazce, premeniť si každý z nich zo stringu na celé číslo a to pripočítať k celkovému výsledku.

Pri premene podreťazca na celé číslo môžeme použiť nasledujúci postup. Na začiatku premeníme prvú (najľavejšiu) cifru podreťazca na celé číslo, ktoré si uložíme do premennej. Potom pokračujeme v čítamí nášho podreťazca zľava doprava a pri každej ďalšej cifre najprv prenasobíme našu premennú desiatimi, potom k nej pripočitáme túto cifru podreťazca a nakoniec premennú zmodulujeme $10^9 + 7$.

Každý súvislý podreťazec je jednoznačne určený svojím začiatkom a svojím koncom. Prejdeme teda všetky možné začiatky (v poradí zľava doprava) a pre každý začiatok prejdeme všetky možné konce (tiež v poradí zľava doprava). Dokopy teda musíme spracovať $O(n^2)$ podreťazcov (kde $n$ je dĺžka vstupného reťazca). Pri spracovávaní jedného podreťazca spravíme $O(n)$ operácii, keďže začíname jednociferným číslom a postupne to navyšujeme až na potenciálne $n$-ciferné číslo. Výsledná časová zložitosť je preto $O(n^3)$. Čo sa týka pamäťovej zložitosti, tak tá je $O(n)$. Máme totiž len jeden reťazec dĺžky $n$ a nejaké pomocné premenné, ktorých je konštantný počet.

## Trochu porozmýšľajme

Ak trocha porozmýšľame, tak zistíme, že sme veľa vecí počítali zbytočne. Napríklad, ak máme reťazec `12345`, tak sme začali podreťazcami `1`, `12`, `123` atď. Hodnotu každého podreťazca (modulo $10^9+7$) sme počítali odznovu, čo je zbytočné. Ak sme už vypočítali hodnotu podreťazca `123` a chceme k celkovému výsledku pripočítať podreťazec `1234`, nebudeme to počítať znova od jednotky, ale vynásobíme predchádzajúce číslo $10$, pripočítame $4$ a zmodulujeme $10^9 + 7$.

Týmto sa nám časová zložitosť zníži na $O(n^2)$, keďže zbytočne nepočítame každé číslo odznova. A pre každý začiatok spracujeme všetky konce v čase $O(n)$. Pamäťová zložitosť ostáva $O(n)$.

## Ide to aj lepšie

Vzorové riešenie už vyžaduje trošku iný pohľad na vec. Nebudeme sa snažiť čo najoptimálnejšie prejsť všetky súvislé podreťazce, ale zistíme, akou hodnotou daná cifra na indexe $i$ v reťazci prispieva do konečného výsledku, a tú započítame.

Pozrime sa na príklad, kedy nejaká cifra na $i$-tej pozícií má pre rôzne súvislé podreťazce, v ktorých sa nachádza, rôzne hodnoty. Napríklad pre reťazec `1532` má cifra `5` v podreťazci `532` hodnotu $500$, v podreťazci `53` hodnotu $50$ atď.

Všimnime si, že prvá cifra v prípade reťazca `1532` je `1` a môže mať najvyššiu hodnotu $1000$. A čím prechádzame na cifry viac vpravo, tým sa nám najvyššia hodnota zmenšuje. Pre cifru `5` máme maximum $500$, pre cifru `3` máme maximum $30$ atď. Taktiež si ale musíme všimnúť, že keď prechádzame na cifry viac vpravo, tak sa nám aj zvyšuje výskyt každej hodnoty o $1$. Vo vyššie uvedenom príklade pre cifru `1` máme hodnoty $1$, $10$, $100$, $1000$, všetky iba raz. Pre cifru `5` máme už len hodnoty $500$, $50$ a $5$, ale každú dvakrát, lebo hodnotu $500$ máme v podreťazcoch `1532` a `532`, hodnotu $50$ v podreťazcoch `153` a `53`, hodnotu $5$ v podreťazcoch `15` a `5`. Teraz vieme, že čím ideme viac vpravo tak sa nám maximum najväčšieho možného čísla zmenšuje, ale počet výskytov sa zväčší o 1 pre každú hodnotu.

Takže pre cifru $c$ na pozícii $i$ vypočítame jej prispenie do celkového výsledku ako $$(i+1) \\cdot \\underbrace{111 \\ldots 11}\_{n-i} \\cdot c.$$

Pri výpočte sa nám tým pádom zíde pole veľkosti $n$, kde na $i$-tom indexe bude číslo tvorené $(i+1)$ jednotkami. To číslo ale musíme tiež zmodulovať $10^9 + 7$, keďže najvyššie možné môže byť až $n$-ciferné. Pole vytvoríme jednoducho tak, že definujeme prvý prvok (na indexe $0$) ako $1$ a ďalšie už počítame ako $$(10 \\cdot \\text{predchádzajúci prvok} + 1) \\bmod {10^9 + 7}.$$

Zhrnieme si, čo presne robíme. Najprv si vytvoríme pole dĺžky $n$, kde na $i$-tom indexe poľa máme číslo tvorené $(i+1)$ jednotkami. Potom prechádzame cyklom celý reťazec a pre každú cifru s pomocou tohto poľa vypočítame jej prispenie do celkového výsledku ako $$(i+1) \\cdot \\underbrace{111 \\ldots 11}\_{n-i} \\cdot c.$$

Medzivýsledky, samozrejme, vždy zmodulujeme $10^9 + 7$.

Časová zložitosť je v tomto prípade len $O(n)$, keďže pomocné pole vieme vytvoriť v čase $O(n)$ a okrem toho stačí len raz prejsť celý reťazec. Pamäťová zložitosť je rovnaká ako pri predchádzajúcich riešeniach, čiže $O(n)$.

Úloha ešte má aj riešenie s pamäťovou zložitosťou $O(1)$, za ktoré sa udeľoval jeden bonusový bod. Neuvádzame ho tu, ale záujemcov podporujeme v tom, aby sa naň pokúsili prísť :)
",4
189e430597da877c,ksp,"# A nech sú moje hady v suchu

Viete čo mačky naozaj nemajú rady? Vodu. A viete aké zviera nemá rado mačky? Predsa hady. Ty, ako správny hadonoš^\[Človek, ktorý nosí hady. Nemýľte si to s `hadonos`, to je nos, ktorý vyzerá ako had.\], ktorý má svoje hady veľmi rád, by si chcel svojim hadom dopriať pokoj od mačiek. Po daždi sa to dá veľmi jednoducho. Na niektorých miestach Tvojho pozemku po daždi ostane stáť voda, a to sú miesta, kam môžeš dať svojich hadov a budú mať pokoj od mačiek. Teraz by si ale chcel zistiť, koľko vodou zatopených políčok ostane na tvojom pozemku po daždi.

## Úloha

Pre jednoduchosť uvažujme, že Tvoj pozemok je dvojrozmerný. Má iba šírku a výšku. Každé miesto na Tvojom pozemku je súvislý stĺpec zeme od výšky $0$ až po výšku terénu v danom mieste. Pôda na Tvojom pozemku je nepriepustná a vždy naprší dostatočné množstvo vody aby zaplnilo všetky miesta kde môže ostať voda. Vypíš súčet plôch tých políčok Tvojho pozemku, kde po napršaní ostane voda.

## Formát vstupu

Na prvom riadku vstupu je číslo $n$ označujúce šírku pozemku. Platí $1\\leq n \\leq 50,000$. Nasleduje jeden riadok obsahujúci $n$ medzerou oddelených celých čísel $v_i$, výšky terénu v poradí zľava doprava. Platí, že $0 \\leq i < n$ a $0 \\leq v_i \\leq 220,000$

## Formát výstupu

Vypíšte jedno číslo, počet políčok, ktoré po daždi ostanú zatopené vodou. Nezabudnite za číslom vypísať znak konca riadku.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:---------------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $20$ | $21,000$ | $35,000$ | $50,000$ | | $0 \\leq v_i \\leq$ | $50$ | $50,000$ | $200,000$ | $220,000$ |

Všimnite si že vstupné a výstupné údaje sa nemusia zmestiť do 32 bitovej premennej, odporúčame preto použiť 64 bitovú premennú (napr. `long long` v C++).

## Príklad

```vstup
12
0 1 0 2 1 0 1 3 2 1 2 1
```

```vystup
6
```

_Označme `X` zem a `O` vodu a pre lepšiu ilustráciu `-` nulovú výšku terénu. V takejto krajine sa po napršaní udrží 6 vody:_

```
       X
   XOOOXXOX
 XOXXOXXXXXX 
------------
```

```vstup
3
1 1 1
```

```vystup
0
```

*Tu sa nemá kde zachytiť voda a teda žiadne políčko neostane po daždi zatopené.*
","# A nech sú moje hady v suchu

## Hlavná myšlienka

Koľko vody (aký vysoký stĺpec vody) sa na jednom mieste^\[Pod slovom `miesto` v tomto vzoráku myslíme jedno z $n$ (šírka pozemku) miest na pozemku.\] pozemku udrží? Predstavme si najnižšie políčko^\[Pod slovom `políčko` v tomto vzoráku myslíme jedno políčko z dvojrozmernej mriežky výška $\\times$ šírka pozemku.\] nad zemou na nejakom mieste na pozemku. Ak sú niekde na obidve strany od neho políčka so zemou, tak voda, ktorá naprší na toto políčko, neodtečie a toto políčko ostane zatopené. To isté platí aj pre každé ďalšie políčko nad ním. Čo v prípade, ak máme políčko, od ktorého je len na jednu stranu políčko so zemou? V takomto prípade sa tam voda neudrží, ale odtečie druhou stranou.

To znamená, že ak si nájdeme najvyššie miesto napravo a naľavo od nejakého miesta na pozemku, tak na tomto mieste pozemku sa udrží toľko vody, aký je rozdiel medzi výškou terénu nižšieho z týchto miest a miesta, na ktorom sme. Ak toto urobíme pre všetky miesta a sčítame množstvá vody, tak získame odpoveď -- koľko vody sa udrží na celom pozemku.

Všetky nasledujúce riešenia počítajú odpoveď takýmto spôsobom, líšia sa len v tom, ako šikovne, a teda ako rýchlo, to robia.

## Priamočiare riešenie

Najjednoduchšie riešenie je, že prejdeme všetky miesta na pozemku. Pre každé miesto najprv prejdeme všetky miesta na jednu a potom na druhú stranu. Takto pre obe strany nájdeme miesto s maximálnou výškou. Pre jedno miesto na pozemku má takéto prehľadanie zložitosť $O(n)$, a kedže to potrebujeme urobiť pre $n$ miest, tak nám to celkovo zaberie $O(n^2)$ času. Pamäťová zložitosť je $O(n)$, lebo okrem vstupného poľa dĺžky $n$ a niekoľko málo premenných si nič iné nemusíme pamätať. Za takéto riešenie ste mohli získať $2$ body.

## Lepšie riešenie

Lepšie riešenie, za $4$ body, ste mohli získať využitím pozorovania, že v riešení hrubou silou robíme jednu veľmi podobnú vec veľakrát. Touto vecou je (ak prechádzame miesta na pozemku zľava doprava) zisťovanie najvyššieho miesta naľavo. Predstavme si, že sme na nejakom mieste $i$ na pozemku. Najvyššie miesto naľavo je buď také, aké bolo najvyššie miesto naľavo od miesta $i-1$, alebo je to samotné miesto $i-1$. Takto pri prechádzaní celého pozemku vieme pre každé miesto získať najvyššie miesto naľavo od neho v konštantom čase (porovnaním dvoch čísel). Najvyššie miesto napravo ale stále zisťujeme v zložitosti priemerne $O(n/2)$. Celkovo sme teda zložitosť zlepšili na $O(n(n/2))$, čo síce asymptotickú zložitosť nezlepší (Tá je stále $O(n^2)$), ale stačí to na získanie $4$ bodov. Pamäťová zložitosť tohto riešenia je $O(n)$, lebo opäť si okrem vstupného poľa dĺžky $n$ a niekoľko málo premenných nemusíme pamätať nič iné.

## Vzorové riešenie

Vzorové riešenie využíva predchádzajúcu myšlienku. Ak prechádzame pozemok zľava doprava, ľahko (v konštantnom čase) vieme pre každé miesto zistiť najvyššie miesto naľavo od neho. Ak ale prechádzame pozemok sprava doľava, tak vieme pre každé miesto ľahko zistiť najvyššie miesto napravo od neho. Keď prejdeme celý pozemok, raz sprava a raz zľava, tak získame pre každé miesto informáciu o najvyššom mieste naľavo a napravo od neho. Obidva tieto prechody (raz zľava doprava a raz sprava doľava) budú v zložitosti $O(n)$. Následne musíme prejsť celý pozemok, pre každé miesto porovnať tieto dve hodnoty a vybrať menšiu z nich. To pre $n$ miest trvá $O(n)$ času. Celkovo nám teda toto riešenie zaberie $O(n+n)$ času na predpočítanie najvyšších miest a potom $O(n)$ času na prejdenie pozemku a sčítanie hodnôt. Spolu je to teda asymptoticky $O(n)$. Pamäťová zložitosť tohto riešenia je stále $O(n)$, lebo okrem vstupného poľa dĺžky $n$ si pamätáme len konštantne veľa ($2$) polí dĺžky $n$ a niekoľko málo premenných.
",2
c6069fb900475e31,ksp,"# Ázijec a továreň na čokoládu

Keď si Baklažán nedávno vychutnával tabuľku svojej obľúbenej čokolády, objavil v nej zlatý lístok, ktorý mu garantoval návštevu Wonkovej továrne na čokoládu. So skupinou ďalších detí sa nadšený vydal do útrob obrovského komplexu. A že ho tam čakalo prekvapení -- spievajúci trpaslíci, veveričky lúskajúce orechy, žuvačky každej chuti, riečna sieť tečúcej čokolády...

Deti, ktoré našli zlatý lístok sú však rozmaznané, nenásytné, pyšné a Willimu Wonkovi lezú poriadne na nervy. A Baklažán tomu tiež veľmi nepomáha, občas totiž odmieta pochopiť, čo sa mu snažíte povedať. Preto keď už tretíkrát odpovedal na Willyho otázku, či chce jahodovú alebo malinovú čokoládu, áno, Willy sa nahneval a zhodil ho do burácajúcej čokoládovej rieky.

Baklažán sa však tak ľahko nevzdáva. Rozhodol sa doplávať na ďaľšiu zastávku Wonkovej exkurzie. Otázka však je, či to stihne. Každý úsek riečnej siete je síce rovnako dlhý, tečie v ňom však rôzne hustá čokoláda. Platí, že preplávanie úseku s hustotou $w$ bude Baklažánovi trvať čas $w$. Jeho cieľom je dostať sa na plánované miesto stretnutia čo najrýchlejšie.

Plávanie v čokoláde má však ešte jednu veľkú (ne)výhodu. Chcete ochutnať každý druh čokolády, v ktorej plávate. Baklažán vie, že ak ochutná viac ako $c$ čokolád, dostane hyperglykemický šok a do cieľa už nedopláva. Môže teda preplávať cez najviac $c$ úsekov. Naviac, plávanie s plným bruchom je čoraz ťažšie a ťažšie. Chcel by preto, aby hustota čokolád, v ktorých pláva, celý čas stúpala, aby sa mu plávalo ľahšie^[Niečo, niečo, fyzika, niečo, niečo, vztlak...].

## Úloha

Riečnu sieť tečúcej čokolády si môžete predstaviť ako graf, ktorý má $n$ vrcholov (očíslovaných od 1 po $n$) a $m$ orientovaných hrán. Každá hrana predstavuje jeden úsek rieky a má priradené číslo $w_i$ -- hustotu daného úseku. Platí, že na preplávanie úseku s hustotou $w_i$ je potrebný čas $w_i$.

Vaše riešenie musí odpovedať na $q$ otázok. Každá otázka je tvorená troma celými číslami $a_i$, $b_i$ a $c_i$ -- ako najrýchlejšie sa vie Baklažán dostať z vrcholu $a_i$ do vrcholu $b_i$, ak môže preplávať cez najviac $c_i$ úsekov a hustoty úsekov musia počas celej plavby stúpať?

## Formát vstupu

Prvý riadok vstupu obsahuje tri celé čísla $n$, $m$ a $q$ ($2 \\leq n \\leq 150$, $0 \\leq m \\leq 3,000$, $1 \\leq q \\leq 1,000$) -- počet vrcholov a hrán grafu a počet otázok, na ktoré musíte odpovedať.

Nasledujúcich $m$ riadkov popisuje hrany grafu. Každá hrana je popísaná troma číslami $x_i$, $y_i$ a $w_i$. Táto trojica reprezentuje orientovanú hranu z vrchola $x_i$ do vrchola $y_i$ s hustotou $w_i$. Medzi dvojicou vrcholov môže viesť aj viacero hrán, dokonca aj v tom istom smere. Platí, že $1 \\leq x_i, y_i \\leq n$ a $1 \\leq w_i \\leq 3,000$. Naviac, žiadne dve hrany nemajú rovnakú hustotu $w_i$.

Každý z nasledujúcich $q$ riadkov obsahuje tri čísla $a_i$, $b_i$ a $c_i$, ktoré popisujú otázky, na ktoré máte odpovedať -- ako najrýchlejšie sa vie Baklažán dostať z vrchola $a_i$ do vrchola $b_i$ ak môže použiť najviac $c_i$ hrán, ktorých hustoty postupne stúpajú? Pre každú otázku platí, že $1 \\leq a_i \\neq b_i \\leq n$ a $0 \\leq c_i \\leq m$.

Úloha má 8 sád testovacích vstupov. Pre jednotlivé sady navyše platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ a $8$ | |:-------------:|:-----:|:-----:|:---------:|:-----:|:---------:|:-----:|:---------:| | $n \\leq$ | $8$ | $20$ | $20$ | $50$ | $50$ | $150$ | $150$ | | $q \\leq$ | $1$ | $1$ | $1000$ | $1$ | $1000$ | $1$ | $1000$ |

## Formát výstupu

Pre každú otázku vypíšte na samostatný riadok odpoveď v poradí, v akom sa otázky objavili na vstupe. Pokiaľ Baklažán nevie splniť zadanie niektorej otázky, vypíšte `-1`.

## Príklady

```vstup
6 10 3
1 2 2
2 1 11
2 3 3
1 3 7
1 6 5
6 4 4
4 5 6
3 5 1
4 2 10
3 4 8
1 4 2
1 4 3
2 5 5
```

```vystup
15
13
-1
```

_Ak sa chceme dostať z vrchola 1 do vrchola 4 použitím najviach dvoch hrán, máme iba jednu možnosť, ísť cez vrchol 3. Cesta cez vrchol 6 totiž nespĺňa podmienku, že hustota hrán má postupne rásť._

_Z vrchola 2 sa do vrchola 5 nevieme dostať bez toho aby sme neporušili podmienku zo zadania._
","# Ázijec a továreň na čokoládu

Prvý krok k riešeniu je vždy poriadne si prečítať zadanie a zistiť, čo od nás vlastne chce. V tomto prípade je tento krok obzvlášť dôležitý, lebo zadanie je pomerne komplikované. Skúsme si teda spoločne zopakovať, čo je našou úlohou.

Na vstupe máme orientovaný graf, ktorého každá hrana má kladnú váhu $w_i$. Postupne dostaneme $q$ otázok, každá má tvar: Aká je najkratšia cesta medzi vrcholmi $a_i$ a $b_i$, ktorá ide cez najviac $c_i$ hrán a váhy týchto hran navyše celú dobu stúpajú?

## Hľadanie cesty s obmedzeným počtom hrán

Keďže úloha obsahuje pomerne veľké množstvo parametrov, na ktoré si musíme dávať pozor, skúsme si ju zjednodušiť. Napríklad, pre začiatok nemusíme uvažovať o tom, že hrany na výslednej ceste musia rásť. A takisto sa nezaoberajme tým, že máme viacero otázok. Ak dokážeme úlohu vyriešiť pre jednu otázku, prinajhoršom tento postup $q$ krát zopakujeme.

Nová úloha, ktorú riešime preto znie: **Nájdite dĺžku najkratšej cesty medzi vrcholmi $\\boldsymbol{x}$ a $\\boldsymbol{y}$, ktorá neobsahuje viac ako $\\boldsymbol{c}$ hrán.**

Takéto zadanie vyzerá oveľa jednoduchšie. Máme predsa presne daný začiatok aj koniec a poznáme aj počet hrán na ceste, ktorú hľadáme. Mohli by sme sa teda pokúsiť siahnuť po niektorom z klasických algoritmov na hľadanie najkratších ciest -- Dijkstrov algoritmus, poprípade prehľadávanie do šírky. Obom však niečo chýba, Dijkstra sa nepozerá na počet hrán v ceste a prehľadávanie do šírky zase nepracuje s váhami hrán. Navyše, keď sa pozrieme do zadania, vidíme, že hodnoty $n$ a $m$ sú pomerne malé. Možno teda vôbec nepotrebujeme tak rýchle riešenie.

Pozrime sa na to inak. Čo by sa stalo, keby sa $c=0$? Úloha by bola zrazu veľmi jednoduchá. Ak môžeme prejsť po 0 hranách, z vrchola $x$ sa dostaneme akurát do vrchola $x$ tým, že sa nepohneme. A keby bolo $c=1$? V tom prípade by sme z $x$ mohli prejsť po jednej hrane. Vedeli by sme sa teda pozrieť na všetky hrany, ktoré z $x$ vedú a to by nám ukázalo vrcholy, do ktorých sa vieme dostať. Naviac, ak by do jedného vrchola viedlo z $x$ viacero hrán, vybrali by sme tú kratšiu.

A čo s $c=2$? V tom prípade by sme sa museli pozrieť na vrcholy, do ktorých sme sa vedeli dostať z $x$ na jednu hranu a pridať hranu ďalšiu. Opäť by sme teda získali všetky vrcholy, do ktorých sa vieme dostať z $x$ s pomocou 2 hrán. Naviac vieme zistiť aj najkratšiu dĺžku ciest do týchto vrcholov.

V tomto momente by malo byť jasné, že tento postup vieme zovšeobecniť. Ak poznáme najkratšie cesty s $k$ hranami, ktoré vedú z vrchola $x$, tak ich vieme použiť na vypočítanie najkratších ciest s $k+1$ hranami.

Pozrime sa na to ešte trochu bližšie. Majme dvojrozmerné pole `dlzka[][]`, pričom na indexe `dlzka[p][r]` si pamätáme **dĺžku najkratšej cesty vedúcej z vrchola $\\boldsymbol{x}$ do vrchola $\\boldsymbol{p}$, ktorá prejde cez práve $\\boldsymbol{r}$ hrán**. Ostáva už len vypočítať túto hodnotu. Zoberme si nejakú hranu, ktorá vedie z vrchola $p'$ do vrchola $p$ a má dĺžku $w$. Potom môžeme povedať, že `dlzka[p][r] = w + dlzka[p'][r-1]`. Teda ak k dĺžke najkratšej cesty z vrchola $x$ do vrchola $p'$, ktorá vedie cez $r-1$ hrán pripočítame ďalšiu hranu, ktorá z $p'$ vedie do vrchola $p$ a má dĺžku $w$, dostaneme cestu z $x$ do $p$.

Táto cesta síce nemusí byť najkratšia, ak ale zoberieme všetky hrany, ktoré vedú do vrchola $p$ a zoberieme minimum z týchto hodnôt, určite nájdeme najkratšiu cestu z $x$ do $p$, ktorá ide cez $r$ hrán.

Takéto riešenie vieme dokonca veľmi jednoducho naprogramovať. Stačia nám na to dva `for`-cykly. Vonkajší bude určovať, koľko hrán chceme použiť -- teda najskôr 1, potom 2, 3... a vnútorný cyklus bude prechádzať cez všetky hrany a postupne ich skúsi pridať k cestám o jedno kratším.

V tejto časti si môžeme položiť ešte jednu otázku. Vieme, že hodnota $c \\leq m$. Môžeme mať však najkratšiu cestu, ktorá prechádza cez $m$ hrán? Odpoveď je, že nie. Dokonca nemôžeme mať najkratšiu cestu, ktorá prechádza cez viac ako $n-1$ hrán. Uvedomme si totiž, že v najkratšej ceste sa nám nikdy neoplatí vrátiť do toho istého vrchola. Ak by sme to spravili, tak by bolo predsa lepšie vynechať tú časť cesty, v ktorej sme sa iba vracali do už predtým navštíveného vrchola a radšej pokračovať ďalej. Každá hrana najkratšej cesty teda musí ísť do nového, ešte nenavštíveného vrchola, a teda môže mať dĺžku najviac $n-1$. Časová zložitosť nášho programu je teda zatiaľ $O(nm)$.

## Riešenie viacerých otázok

Vyriešili sme prvú časť úlohy, je na čase pridať si späť podmienky, ktoré sme odstránili. Začnime tým, že musíme vyriešiť $q$ otázok. Ako sme si už spomínali vyššie, najľahší spôsob je proste zopakovať vyššie uvedený proces $q$ krát. Otázok však môže byť až 1000, čo je pomerne dosť. Naviac si uvedomme, že vyššie uvedený spôsob počítal viac ako len najkratšiu cestu z $x$ do $y$.

Vyššie uvedenný program spočítal pre začiatočný vrchol $x$ najkratšie cesty všetkých dĺžok do všetkých zvyšných vrcholov a uložil ich do poľa `dlzka[][]`. Ak teda dostaneme dve otázky, ktoré majú rovnaký začiatočný vrchol, neoplatí sa nám toto pole počítať od začiatku, lebo výsledok bude ten istý. Iba sa budeme musieť pozrieť do iných políčok tohto poľa.

Naviac, vrcholov je iba 150, takže túto tabuľku budeme musieť prepočítavať najviac 150 krát. Aj to je však mierne ošemetné. Predsa len si musíme otázky rozdeliť podľa počiatočného vrchola a potom to vo vhodných momentoch prepočítať. Na to sme príliš leniví. Pridajme nášmu poľu teda ešte jeden rozmer. Hodnota `dlzka[x][y][r]` bude teda dĺžka najkratšej cesty z vrchola $x$ do vrchola $y$, ktorá prejde cez práve $r$ hrán.

Takúto tabuľku si vieme spočítať dopredu v čase $O(m\\cdot n^2)$. Ako z nej však zistíme odpoveď na zadanú otázku? Otázky, ktoré dostávame sa pýtajú na cesty **s najviac $\\boldsymbol{c_i}$ hranami**. Pre zadané $a_i$ a $b_i$ sa teda musíme pozrieť na všetky hodnoty $dlzka[a_i][b_i][j]$ pre $0 \\leq j \\leq c_i$ a vybrať z nich tú najmenšiu. Odpovedanie na jednu otázku by nám teda trvalo čas $O(n)$.

Vieme to však spraviť aj lepšie. Uvedomme si, že na začiatku si vypočítame celé pole `dlzka[][][]`. No a správna odpoveď pre $a_i$, $b_i$ a $c_i$ je vždy minimom z hodnôt $dlzka[a_i][b_i][j]$ ($0 \\leq j \\leq c_i$). Môžeme si tieto minimá preto pre každú dvojicu vrcholov $(a, b)$ vypočítať dopredu. Stojí nás to síce čas $O(n^3)$, ten sa však ľahko schová do časovej zložitosti $O(m\\cdot n^2)$^[Samozrejme, musíme predpokladať, že $m \\geq n$. Takýto predpoklad je však rozumný, pretože inak by sme nemali súvislý graf a náš algoritmus by sme vedeli zopakovať na každom komponente zvlášť.], ktorou počítame pole `dlzka[][][]`.

Odpoveď na každú otázku vieme teda získať v čase $O(1)$ jedným pozretím do tabuľky.

## Rast váhy hrany na ceste

Ostáva nám vyriešiť poslednú podmienku zadania. Hrany v našich cestách musia postupne rásť.

Pozrime sa najskôr na to, ako funguje naše doterajšie riešenie. Pre zvolený začiatok cesty sa postupne pokúša pridať ďalšie a ďalšie hrany, pričom skúša pridať všetky možné hrany. Vo vzorovom riešení však nemôžeme skúšať všetky hrany. V okamihu ako na nejakej ceste použijeme hranu s váhou $w$, nemôžeme k tejto ceste pripájať ľahšie hrany. Opačne, ak chceme použiť nejakú hranu s váhou $w$, môžeme túto hranu pripojiť iba na cestu, ktorá sa skladá z iba ľahších hrán.

Náš algoritmus by sme teda chceli upraviť tak, aby sme v momente, keď pridávame hranu s váhou $w$, už mali vypočítané všetky cesty z kratších hrán. Naviac aj tieto cesty musia spĺňať podmienku o raste váh hrán. To ale znamená, že hrany musíme spracovávať v poradí od najľahšej po najťažšiu.

Celé riešenie teda vyzerá nasledovne. Usporiadame si hrany podľa váhy. Následne v tomto poradí hrany spracovávame. V každom kroku vyskúšame aktuálnu hranu pripojiť na každú možnú cestu, ktorú zatiaľ máme. Tieto cesty sa pritom dajú reprezentovať pomocou začiatočného vrchola $x$, koncového vrchola $y$ a počtu hrán, ktoré obsahujú. V okamihu, keď sme túto hranu vyskúšali pridať na každé miesto, pokračujeme s ďalšou hranou a k tejto sa už nevraciame.

Uvedomme si, že v okamihu keď začneme spracovávať nejakú hranu, máme už vypočítané všetky cesty skladajúce sa z ľahších hrán. Neskôr túto hranu už použiť nemusíme (a nemôžeme), každá nová cesta totiž musela vzniknúť pridaním ťažšej hrany a k tej ju nemôžeme pridať.

Najkrajšie je, že naše riešenie sa ani veľmi nezmení. Jediné čo musíme spraviť je, že presunieme cyklus, ktorý prechádza všetkými hranami, na najvyššiu úroveň. To bude totiž predstavovať to, že hrany spracovávame jednu po druhej.

Časová zložitosť našeho riešenia je $O(m\\log m + m\\cdot n^2 + q)$. Pamäťová zložitosť je $O(n^3)$, keďže si musíme pamätať pole `dlzka[][][]`.
",8
223d0b924c504cea,ksp,"# Dohrajte hru

Baklažán a Buj sa hrajú hru. Zoberú balíček kariet a rozdelia ho na kôpky. Každá karta má na sebe napísané číslo predstavujúce body. Potom striedavo ťahajú z kôpok, pričom hráč na ťahu si vždy zvolí z ktorej kôpky odoberie kartu. Aby to nebolo príliš zložité, tak sa dohodli, že Baklažán bude brať kartu iba z vrchu a Buj iba zo spodu. Hra sa končí vtedy, keď sa minú karty a vyhráva ten s najväčším súčtom bodov.\
Obaja majú ale veľa povinnosti v škole. Chceli by vás teda poprosiť aby ste zopár hier odohrali za nich. Odkazujú, že by obaja hrali optimálne.

## Úloha

Zistite koľko bodov bude mať Baklažán a Buj po skončení hry ak obaja budú hrať optimálne. Hru vždy začína Baklažán.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ $(1 \\leq n \\leq 100)$, počet kôpok kariet. Za ním nasleduje $n$ riadkov. V každom nasledujúcom riadku je číslo $s\_{i}$ $(1 \\leq s\_{i} \\leq 100)$ označujúce počet kariet v $i$-tej kôpke. Za ním nasleduje $s\_{i}$ čísel $c\_{1}, c\_{2}, ..., c\_{s\_{i}}$, hodnoty kariet od vrchu kôpky až po spodok. Pre ľubovolné $c\_{k}$ platí, $(1 \\leq c\_{k} \\leq 1000)$.

\\medskip

_Čiastočné body môžete získať v sade 1, kde je vždy počet kôpok rovný $1$. Pre sadu 2 platí, že počet kôpok je $2$._

## Formát výstupu

Na výstup vypíšte dve čísla. Počet bodov Baklažána a počet bodov Buja po ukončení hry.

## Príklady

```vstup
2
1 100
2 1 10
```

```vystup
101 10
```

_Baklažán si zobral katru 100, Buj 10 a nakoniec Baklažán 1._

```vstup
1
9 2 8 6 5 9 4 7 1 3
```

```vystup
30 15
```

_Baklažán by si zobral karty 2, 8, 6, 5, 9 a Buj 3, 1, 7, 4._

```vstup
3
3 1 3 2
2 8 7
3 5 4 6
```

```vystup
18 18
```

_Hra by mohla prebiehať napríklad takto:_\
_Baklažán zoberie kartu z tretej kôpky (skóre 5:0)_\
_Bui zoberie kartu z druhej kôpky (skóre 5:7)_\
_Baklažán zoberie kartu z druhej kôpky (skóre 13:7)_\
_Bui zoberie kartu z tretej kôpky (skóre 13:13)_\
_Baklažán zoberie kartu z tretej kôpky (skóre 17:15)_\
_Bui zoberie kartu z prvej kôpky (skóre 17:15)_\
_Baklažán zoberie kartu z prvej kôpky (skóre 18:15)_\
_Bui zoberie kartu z prvej kôpky (skóre 18:18)_
","# Dohrajte hru

## Prvá sada (jedna kôpka)

Na riešenie prvej sady, kde bola iba jedna kôpka, stačilo striedavo simulovať Baklažánove a Bujove ťahy. Takéto riešenie pobehá v lineárnom čase (neskôr ukážeme, že vieme mať dokonca konštantnú pamäť).

## Riešenie pre viacero kôpok

Tu je situácia podstatne ťažšia. Je veľmi veľa možností ako vie hra prebiehať a nestíhame preskúšať každú. Prvá vec, čo si treba uvedomiť je, že sa nestačí pozerať len na prvú/poslednú kartu na kôpke. Takáto karta môže mať veľmi malú hodnotu, ale môže odkryť karty, ktoré sa veľmi oplatia zobrať.

Ďalšia vec, ktorú si vieme všimnúť je, že porebujeme rozlišovať medzi 2 typmi kôpok -- _párnymi_ a _nepárnymi_. Zamyslime sa nad párnymi kôpkami.

### Kôpky s párnym počtom kariet

Ako tu vyzerá optimálna hra? Všimnime si, že žiaden hráč nemôže získať kartu, ktorá je vo vzdialenejšej polke kôpky. Prečo?

1. Bujovi stačí ťahať z tej istej kôpky, z ktorej bral Baklažán.
1. Baklažánova stratégia je podobná. Ak Buj potiahne kartu z inej kôpky ako on, Baklažán sa prispôsobí a zoberie z tej kôpky, čo Buj.

Čo sme týmto zistili? Predstavme si, že existuje optimálne riešenie pre jedného z hráčov, s tým, že v nejakom momente zoberie kartu zo vzdialenej polky kôpky. My sme ale dokázali, že obaja hráči vedia takémuto prípadu zabrániť. To znamená, že v optimálnom riešení Baklažán získa vrchnú polku kôpky a Buj spodnú.

### Kôpky s nepárnym počtom kariet

Teraz sa pozrime na nepárne kôpky. Zjavne aj tu platí tá istá stratégia, akurát, čo s kartou v prostriedku kôpky? Keď popremýšľame, vieme ukázať, že Buj nevie zabrániť Baklažánovi získať najlepšiu strednú kartu spomedzi nepárnych kôpok. Podobne, ak Baklažán túto kartu zoberie, nevie zabrániť Bujovi zobrať druhú najdrahšiu. A toto vieme zovšeobecniť -- Baklažán a Buj si postupne poberú karty v nepárnych kôpkach.

### Celé riešenie dokopy

Na začiatku načítame vstup, pripočítame Baklažánovi skóre za vrchné polky kôpok, Bujovi za spodné. Potom, zoberieme prostredné karty v nepárnych kôpkach, utriedime ich a striedavo rozdelíme medzi Baklažána a Buja. Časová zložitosť takéhoto riešenia je $O(n \\cdot s + n \\cdot \\log(n))$, pamäťová $O(n \\cdot s)$, kde $n$ je počet kôpok a $s$ je maximálny počet kariet v kôpke.

### Ide to aj rýchlejšie a úspornejšie

V skutočnosti si vôbec nemusíme pamätať všetky kôpky. Stačí, keď ich budeme spracuvávať jednu po druhej. Párnu rovno spracujeme a z nepárnych si uložíme prostredný prvok. Tie na konci usporiadame a rozdelíme chalanom. Týmto sme zlepšili pamäťovú zložitosť z $O(n \\cdot s)$ na $O(n + s)$ lebo máme $s$ kariet v kôpke a môžeme dostať $n$ nepárnych kôp.

Časovú zložitosť vieme zlepšiť usporiadaním prostredných kariet pomocou [counting sortu](https://sk.wikipedia.org/wiki/Counting_sort), keďže hodnoty jednotlivých kariet sú do $1000$. Pretože counting sort triedi v linárnom čase od počtu triedených prvkov, teda v $O(n)$, výsledná časová zložitosť bude $O(n \\cdot s)$. Prípadne vieme spraviť tesnejší odhad -- zložitosť bude lineárna od počtu všetkých kariet na vstupe. Keďže musíme vždy prečítať celý vstup, takéto riešenie má dokonca najlepšiu možnú asymptotickú zložitosť spomedzi všetkých programov riešiacich túto úlohu.

Ešte jedna finta nakoniec. Vďaka tomu, že vieme koľko kariet má každá kôpka, kôpky si nemusíme pamatať. Vieme ich spracovať postupne po kartách a pamätať si len Bujove a Baklažánove skóre. Pamäťová zložitosť bude potom $O(n)$.
",4
1bdb832b8b333854,ksp,"﻿# Čakove deti

Ako všetci vieme tak Čak Norris má dvojičky - Čaka a Čakinku. Prázdniny už skončili a obaja tak už musia chodiť do školy. Dokonca už dostali aj prvú domácu úlohu. Majú dokázať, že Zem je plochá. Inými slovami majú ukázať, že to je prauda.

Ich tatko, starý Norris kedysi dávno vytesal všetky všeobecne známe praudy na neďalekú skalu. Čak a Čakinka by boli radi ako on a preto domácu úlohu vypracujú práve na túto skalu.

Čakinka je však lenivá, nechce sa jej chodiť až ku skale. Avšak je aj výnimočne bystrá a má skvelé dedukčné schopnosti. A tak ako správny súrodenci si s touto neľahkou úlohou pomôžu. Ich stratégia je nasledovná.

Čak bude behať ku skale a vytesávať novo zistené praudy. Cestou naspäť si niekoľko z už vytesaných práud zapamätá. Dobehne domov ku Čakinke povie jej čo si pamätá a bystrá Čakinka z toho odvodí neaký ďalší výrok (po tomto odvodení sa už aj tento výrok stáva praudou). Čak následne beží ku skale a aj tam tento výrok vytesá, ak tam ešte nie je. Celý cyklus opakujú kým na skale ešte nie je vytesané Zem je plochá.

Čak však nemá moc dobrú pamäť vie si pamätať len obmedzený počet výrokov, keď beží naspať od skaly. Pomôžte im a zistite koľko pamäte Čakovi stačí. Teda zistite koľko výrokov si musí vedieť Čak naraz pamätať (na jednej ceste od skaly domov) aby boli schopný splniť domácu úlohu alebo vypíšte, že to nie je možné bez ohľadu na jeho pamäť.

## Úloha

Vo všeobecnosti existuje $n$ výrokov, ktoré si očíslujeme od $0$ po $n-1$. Výrok číslo 0 je ""Zem je plochá"" a tento dostali za domácu úlohu Čak a Čakinka dokázať.

Ďalej máme $m$ odvodzovacích pravidiel, pričom $i$-te z nich pozná Čakinka v tvare $a\_{i,0}, ..., a\_{i,k_i}$. Čo znamená, že ak sú výroky $a\_{i,0}, ..., a\_{i,k\_{i-1} }$ prauda, tak aj výrok $a\_{i,k_i}$ je prauda.

A na záver máme na skale vytesaných $l$ výrokov, ktoré sú všeobecná prauda (netreba ich odvádzať).

Zistite najmenší počet výrokov, ktoré si musí Čak pamätať naraz počas cesty domov, pokiaľ Čakinka vie odvádzať len z výrokov, ktoré si Čak pamätá. Alebo vypíšte, že by nám nestačila žiadna pamäť.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $m$ ($1\\leq m,n\\leq 1,100,000$) udávajúce počet možných výrokov a počet odvodzovacích pravidiel.

Nasleduje $2m$ riadkov. V nepárnych riadkoch je počet výrokov $k_i$ v odvodzovacej formuly, a v párnych samotné čísla výrokov v odvodzovacom pravidle $a_0, ..., a\_{k,i}$. Pritom môžete predpokladať, že $\\sum\_{i=0}^{m-1} k_i\\leq 2,000,000$.

Na záver je vo vstupe počet všeobecných práud $1 \\leq l \\leq n$. V poslednom riadku sú ich čísla.

## Formát výstupu

Na výstup vypíšte jediné číslo a to najmenšiu možnú pamäť, pre ktorú vieme dokázať výrok ""Zem je plochá"". Ak to nie je možné pre žiadnu pamäť vypíšte $-1$.

## Príklady

```vstup
3 2
1
1 0
2
1 2 0
2
1 2
```

```vystup
1
```

*Zjavne si stačí zapamätať všeobecnú praudu $1$ a potom už len použijeme prvé odvodzovacie pravidlo*

```vstup
4 3
2
1 2 3
2
1 3 2
2
2 3 0
1
1
```

```vystup
-1
```

*Na dokázanie plochosti zeme potrebujeme najprv dokázať praudu 2 a 3. Na dokázanie praudy 2 však potrebujeme praudu 3, a na dokázanie praudy 3 potrebujeme zasa praudu 2. V tejto čudesnej, fiktívnej realite teda zem plochá asi nieje.*
","# Čakove deti

Skúsme najprv vyriešiť jednoduchšiu verziu úlohy. Pokúsme sa len overiť, či sa zo všeobecných práud (ďalej ich budeme volať axiómy) dá odvodiť výrok $0$.

Naše riešenie sa bude inšipovať myšlienkami pri prehľadávaní grafov. Budeme si udržovať množinu už dokázaných výrokov a takisto frontu výrokov, ktoré postupne budeme spracovávať (už dokázaných). Ku každému pravidlu si budeme navyše pamätať počet predpokladov (výrokov, ktoré treba mať dokázané aby sme vedeli dokázať nové tvrdenie) ktorésúuž dokázané.

Začneme tým, že označíme všetky axiómy za pravdivé a všetky si ich uložíme do našej fronty. Budeme postupne spracovávať výroky z fronty. Keď budeme spracovávať výrok $v$, ktorý sa nachádza ako predpoklad v odvodzovacích pravidlách $a_1,...,a_k$. Pre každý z týchto výrokov zvýšime počítadlo dokázaných predpokladov. A pokiaľ sme už dokázali všetky predpoklady môžeme prehlásiť za pravdivý aj jeho dôsledok (výrok ktorý sme dokázali týmto odvodzovacím pravidlom). A zároveň tento novo dokázaný výrok pridáme do fronty.

Až sa nám raz vyprázdni fronta budeme mať dokázané všetky dokázateľné výroky a teda jednoducho overíme, či medzi ne patrí aj výrok 0.

Všimnime si, že celý algoritmus by mal časovú zložitosť $O(n+ \\sum\_{i=0}^{m-1} k_i)$. Kde $n$ je počet výrokov a $k_i$ počet predpokladov v $i$-tom odvodzovacom pravidle. Každý výrok totiž len raz pridáme do fronty a každý predpoklad si teda len raz označíme za splnený.

## Jednoduché zaklincovanie

Ak chceme vyriešiť pôvodnú úlohu, stačí vyskúšať všetky možné pamäte Čaka, vyfiltrovať, ktoré odvodzovacie pravidlá si vie zapamätať a vždy spustiť vyššie spomínaný algoritmus. Ba čo dokonca viac, my tú správnu najmenšiu vyhovujúcu pamäť vieme binárne vyhľadať. Vtedy časová zložitosť nášho riešenia pri správnej implementácii vedie ku $O((n+ \\sum\_{i=0}^{m-1} k_i) log (max k_i))$

## Vzorák

Vzorák namiesto spúšťania prehľadávania zakaždým od znova bude prehľadávať postupne, najprv pomocou najmenších odvodzovacích pravidiel a potom pomocou väčších. Zabezpečíme to tým, že namiesto jednej fronty ich budeme používať $max k_i$. Algoritmus bude podobný ako pôvodný. Axiómy pridáme do fronty číslo $0$. Teraz budeme postupne spracovávať frontu ako vyššie. Avšak ak dokážeme všetky predpoklady niektorého odvodzovacieho pravidla, tak namiesto pridania dôsledku do rovnakej fronty pridáme ho do fronty s poradovým číslom podľa počtu potrebovaných predpokladov. Keď sa nám vyprázdni aktuálna fronta skontrolujeme, či sme už dokázali výrok $0$. Ak áno, môžeme vypísať poradové číso ukončenej fronty. Ak nie, tak začneme spracovávať frontu s poradovým číslom o jedna väčším.

Celé to bude mať časovú zložitosť $O(n+ \\sum\_{i=0}^{m-1} k_i)$. Keďže podobne ako vyššie, každý výrok bude v niektorej fronte maximálne raz (ak už je výrok pravdivý nepridávame ho do fronty aj keď sme ho odvodili znova). Zbytok algoritmu je rovanký ako vyššie. Pamäťová zložitosť bude $O(n+ \\sum\_{i=0}^{m-1} k_i)$, keďže si musíme pamätať všetky odvodzovacie pravidlá a k nim to, koľko z predpokladov už bolo odvodených, a takisto fronty, v ktorých bude dokopy najviac $n$ prvkov (každý výrok maximálne raz).
",8
15e642e0b16ffacc,ksp,"# [Obezlička](http://slovnik.azet.sk/pravopis/slovnik-sj/?q=obezli%C4%8Dka)

Romanko, ako správny maturant, využil Vianočné prázdniny naplno. Posledný týždeň školy mu síce všetci učitelia pripomínali, ako dôležité je sa cez prázdniny venovať štúdiu, ale však čo -- na to bude dosť času neskôr -- pred Vianocami sa predsa ide nakupovať! No a po Vianociach si predsa tiež Romanko nebude kaziť náladu školou. Oveľa príjemnejšie je cez deň spať a v noci hrať počítačové hry. A po Silvestri? To je predsa perfektný týždeň na lyžovačku!

Na konci prázdnin si teda Romanko po veľmi ""produktívne"" strávenom čase pozrel, aké domáce úlohy to vlastne cez ne mal stihnúť. Otvoril si svoj zápisníček a so zhrozením zistil, že je tam práce skoro na tri týždne (aká to náhoda, všakže?). Najťažšou úlohou je veľký projekt z informatiky. Čo teraz bude robiť? Ak svoj projekt z informatiky nespraví, bude mať len dve možnosti: odísť zo školy a zamestnať sa ako vývojár webových stránok, alebo dajako uprosiť svoju učiteľku informatiky, aby ho nechala prejsť s odretými ušami. V momentálnom stave však, napriek Romankovým vynikajúcim presvedčovacím schopnostiam, jeho projekt určite stačiť nebude.

Romanko si však spásonosne spomenul, že kedysi, keď namiesto vypracovávania dôležitých esejí riešil programátorské úlohy na [SPOJi](https://www.spoj.com/), mu pán profesor Demáček za každú vyriešenú úlohu napísal na vyvesenú tabuľu malé, bezvýznamné plus. Tieto pluská ale občas neboli vôbec malé (čím ťažšiu úlohu Romanko vyriešil, tým väčšie plus mu profesor napísal) a nemuseli by byť ani bezvýznamné -- mohol by predsa svoju učiteľku presvedčiť, aby mu ich uznala ako bonusové body z programovania!

Utekal teda do Školského Výpočtového Laboratória a uprel pohľad na tabuľu s pluskami. Och, nie! Nejaký darebák ju nenávratne počmáral. Čo bude teraz robiť? Počmárané pluská mu učiteľka v žiadnom prípade neuzná! So slzami na krajíčku a niektorými cezeň si skleslo sadol na zem a prehodnocoval svoje životné rozhodnutia. Našťastie ste práve okolo Romanka išli vy. Vypočuli ste si jeho príbeh, a dali ste mu návrh -- ak vám dá zvyšné horalky, ktoré ušetril pri [podplácaní trpaslíkov](https://www.ksp.sk/ulohy/zadania/1240/), tak mu pomôžete spočítať, koľko plusiek ostalo na tabuli nepočmáraných. Romanko samozrejme nemal príliš na výber, a pristúpil na vaše podmienky.

## Úloha

Tabuľa v Školskom Výpočtovom Laboratóriu je štvorcová a má stranu dĺžky $n$ milimetrov. Pre potreby úlohy si ju vieme predstaviť ako mriežku pozostávajúcu z $n$ riadkov. V každom riadku je $n$ štvorčekových políčok o veľkosti $1 \\times 1$ milimeter a každé z týchto políčok môže byť popísané alebo nepopísané.

**Nepočmárané plus veľkosti $v$** je štvorec so stranou dĺžky $2v + 1$ milimetrov, v ktorom je celý stredný riadok a stredný stĺpec popísaný, a všetky ostatné políčka v ňom sú nepopísané.

Za nepočmárané plus veľkosti $v$ dostane Roman $v$ bonusových bodov.

Každé nepočmárané plus veľkosti aspoň 2 obsahuje vo svojom strede menšie nepočmárané pluská. Za tieto menšie pluská však Roman už ďalšie body pochopiteľne nedostane.

Roman vám ukázal počmáranú tabuľu. Pomôžte mu zistiť, koľko bonusových bodov vie získať!

## Formát vstupu

V prvom riadku je číslo $n (1 \\leq n \\leq 2,000)$ -- veľkosť tabule. Nasleduje $n$ riadkov, každý presne $n$ znakov dlhých -- obrázok tabule. Znak `'#'` predstavuje popísané políčko, znak `'.'` nepopísané políčko.

## Formát výstupu

Vypíšte jediné číslo -- počet bonusových bodov, ktoré Roman vie získať, a znak nového riadku.

## Príklad

```vstup
3
.#.
###
.#.
```

```vystup
1
```

_Takto vyzerá nepočmárané plus veľkosti 1. Romanko zaň dostane 1 bonusový bod._

```vstup
8
...#....
...#....
...#....
########
...#....
...#..#.
...#.###
...#..#.
```

```vystup
3
```

_V pravom dolnom rohu je nepočmárané plus veľkosti 1. Štvorec s ľavým horným rohom na druhom políčku druhého riadku a s pravým dolným rohom na 6. políčku 6. riadku je nepočmárane plus veľkosti 2. Romanko teda vie získať najviac $1+2=3$ body._

_Štvorec s rohmi na políčkach $(1,1)$ a $(7,7)$ je počmárané plus, keďže v pravom dolnom rohu mu zavadzajú popísané políčka menšieho pluska._
","# Obezlička

Stručný obsah podčlánkov je nasledovný:

- Hrubá sila: riešenie overovaním všetkých štvorcových plôch z ich ľavého horného rohu $O(n^5)$.
- Dá sa to aj múdrejšie: overovanie štvorcov zo stredu $O(n^4)$.
- Pozrime sa na to bližšie: správny odhad časovej zložitosti riešenia $O(n^2)$.

## Hrubá sila

V tomto najjednoduchšom riešení by sme sa postupne chceli pozrieť na všetky štvorcové oblasti tabule, zistiť, ktoré z nich sú nepočmáranými pluskami a na základe toho zistiť, koľko bodov Roman dostane.

Každý štvorec (každé plusko) je na tabuli určený jeho **ľavým horným rohom a dĺžkou strany**. Ak si teda fixne zvolíme jedno políčko $(i,j)$, chceme postupne skúšať dĺžky strany $3,5,7,...$ (teda štvorce s ľavým horným políčkom $(i,j)$ a pravým dolným políčkom postupne $(i+2,j+2),(i+4,j+4),...$)

Ak máme vybraný štvorec s rohovými políčkami $(i,j)$ a $(i+x,j+x)$, vieme ľahko overiť, či je tento štvorec nepočmáraným pluskom. Stačí prejsť jeho všetky políčka v cykle a overiť, že tie, ktoré sú v strednom riadku (teda $(i+x/2,j), (i+x/2,j+1), (i+x/2,j+2), ..., (i+x/2,j+x)$) alebo v stredom stĺpci (teda $(i, j+x/2), (i+1, j+x/2), ... (i+x, j+x/2)$) musia byť popísané (`#`), a ostatné nepopísané (`.`).

Ako ale zistiť počet bonusových bodov? V zadaní sa písalo: ""Za plus veľkosti $v$ dostane Roman $v$ bodov, no každé plus veľkosti aspoň 2 obsahuje vo svojom strede menšie pluská a za tie už Roman body nedstane.""

Pre správny výpočet výsledku nám však stačí len zistiť počet štvorcov, ktoré sú pluskami. Neveríte?

Ak je na tabuli plusko veľkosti 1, nájdeme práve jeden štvorec (so stranou dĺžky 3), ktorý ho obsahuje. Ak je plusko veľkosti 2, vytvára tak na tabuli dve štvorcové oblasti, ktoré sú pluskami -- jedna oblasť je štvorec so stranou dĺžky 5 a druhá oblasť je menší štvorec so stranou dĺžky 3, v strede väčšieho štvorca. Plusko veľkosti 3 nám vytvorí 3 štvorcové oblasti ktoré sú pluskami atď. Trik je v tom, že v tomto riešení dáme každému štvorcu, ktorý je pluskom len **jeden bod**. Väčšie pluská preto ohodnotíme presne toľkými bodmi, ako si to vyžadovalo zadanie.

Políčok je na tabuli $n^2$ a dĺžka strany každého štvorca môže byť rádovo až $n$. Overiť, či je štvorec nepočmárané plus nám v najhoršom prípade trvá toľko krokov ako je jeho obsah, čo je v najhoršom prípade $n^2$. Dokopy je teda počet krokov zhora ohraničený $n^2 \\cdot n \\cdot n^2$, teda časová zložitosť bude $O(n^5)$.

Pamätať si pritom musíme celú tabuľu, takže potrebná pamäť bude kvadratická v závislosti od rozmeru tabule -- $O(n^2)$.

Riešenie vieme ešte zlepšiť niekoľkými trikmi. O veľa štvorcoch napríklad veľmi rýchlo zistíme, že sú počmárané; vtedy môžeme rovno prestať kontrolovať zvyšok štvorca. Dá sa ukázať, že toto vylepšenie zníži časovú zložitosť na $O(n^4)$. Takisto sa ľahko môže stať, že veľa štvorcov na tabuli spĺňa jednu z podmienok (každý štvorec na prázdnej tabuli má všetky nie-stredné riadky a stĺpce správne, a každý štvorec na úplne popísanej tabuli má všetky stredné riadky a stĺpce správne). Aby nás takéto vstupy menej trápili, mohli by sme napríklad na začiatok vyskúšať zopár náhodných políčok v strednom riadku/stĺpci a niekoľko náhodných políčok mimo, či naše plusko nekazia. Existuje viacero takýchto podobných vylepšení, ktoré mohli riešenie urýchliť, a získať teda trochu viac bodov na testovacích vstupoch. Napriek tomu takéto optimalizácie väčšinou nemenia časovú zložitosť algoritmu, keďže pri odhade časovej zložitosti uvažujeme ten najhorší možný prípad.

## Dá sa to aj múdrejšie?

Vyššie uvedené riešenie sa síce dalo všelijakými ad-hoc trikmi vylepšovať, nevie sa však nijak zbaviť základnej myšlienky, že pre každé z $n^2$ políčok skúša rádovo $n$ dĺžok strán štvorcov, a tie (v najhoršom prípade) celé prekontroluje. Pre $n$ blížiace sa k $2000$ je teda riešenie príliš pomalé.

Zväčšovanie štvorcov z ľavého horného rohu má principiálne ten problém, že ak zmeníme dĺžku strany štvorca, ktorý chceme overiť, veľa políčok v ňom bude zohrávať inú úlohu. Popísané políčka, ktoré nám pri jednej dĺžke strany zavadzali, môžu byť pri ďalšej dĺžke strany práve tými potrebnými políčkami v strednom riadku alebo stĺpci, a naopak. Kvôli tomu musíme pri zmene dĺžky strany štvorca prakticky všetky políčka znova overovať. Jednoduchšie povedané, vždy keď zmeníme dĺžku strany štvorca ktorý chceme overiť, a vždy keď zmeníme políčko, ktoré skúšame ako ľavý horný roh, zahadzujeme všetku doteraz získanú informáciu, a preto musíme overovať veľa políčok, aby sme zistili, či nový štvorec je alebo nie je nepočmárané plus.

Vieme nejakým spôsobom upraviť náš prvý algoritmus tak, aby sme využili predošlé informácie, ktoré máme z overovania menších štvorcov?

Vieme -- stačí si štvorec definovať pomocou súradníc jeho stredného políčka a dĺžky jeho strany. Opäť budeme teda overovať všetky štvorce -- najprv si zvolíme stred štvorca $(i, j)$ a potom budeme zväčšovať jeho dĺžku strany $v = 3, 5, 7, ..., n$. Keď vieme, že štvorec so stranou dĺžky $v$ je nepočmárané plus, a chceme overiť štvorec so stranou dĺžky $v+1$, máme už zaručené, že celé ""vnútro"" je správne, a stačí nám teda overiť ""nové"" políčka -- teda okraje štvorca. Keď ale zistíme, že štvorec je počmárané plusko, všetky väčšie štvorce s týmto stredom budú tiež počmárané a môžeme tak prestať overovať štvorce s týmto stredom.

Ako vieme zatiaľ zhora odhadnúť zložitosť tohto riešenia? Pre každé políčko, ktorých je $n^2$, máme cyklus ktorý beží (v teoretickom, najhoršom možnom prípade) najviac $n$-krát, a zakaždým kontroluje nové políčka štvorca, teda okraj štvorca. Ten má rádovo $n$ políčok. Dokopy teda dostávame horný odhad $O(n^2 \\cdot n \\cdot n) = O(n^4)$.

## Pozrime sa na to bližsie

Napriek tomu, že náš odhad $O(n^4)$ je správny (algoritmus skutočne urobí na tabuli so stranou $n$ najviac rádovo $n^4$ operácií), tento odhad **nie je tesný**. V tejto časti si ukážeme, že v skutočnosti je vyššie popísaný algoritmus omnoho rýchlejší.

Pri políčkach, ktoré nie sú stredom žiadneho nepočmáraného plus, naše overovanie skončí veľmi rýchlo -- najneskôr po skontrolovaní prvých deviatich políčok, teda v konštantnom čase. Overovanie takýchto políčok teda **dokopy** zaberie $O(n^2)$ času.

Keď skúšame políčko, ktoré je stredom nepočmáraného plus s ramenom $v$ (ale už nie väčšieho), skontrolujeme štvorec so stranou $2v+1$, čo nám zaberie $(2v+1)^2$ krokov. Následne ešte skúsime plusko zväčšiť, ale nepodarí sa nám to a prestaneme. V najhoršom prípade teda prejdeme všetky políčka štvorca so stranou $2v+3$. Dokopy teda urobíme rádovo $v^2$ krokov.

Inak povedané, ak sú na tabuli pluská veľkostí $v_1,v_2,...,v_k$ (pričom počítajme len tie najväčsie; nepočítajme tie, ktoré sú v strede väčšieho pluska), na ich overenie bude tento program potrebovať rádovo ${v_1}^2 + {v_2}^2 + ... + {v_k}^2$ krokov.

Teda náš algoritmus vykoná rádovo toľko operácií, koľko je súčet plôch nepočmáraných plusiek na tabuli. Má teda zložitosť opísateľnú ako $O(n^2 + \\mbox{plocha plusiek})$ ($O(n^2)$ kvôli načítaniu vstupu a políčkam, ktoré nie sú stredom žiadneho pluska). A toto je pre náš algoritmus veľmi prospešné -- pluská si totiž, z hľadiska algoritmu, navzájom zavadzajú. Chceme už vlastne len dokázať, že nepočmárané pluská sa nevedia ľubovoľne prekrývať a na tabuli ich teda bude relatívne málo.

Zoberme si teda ľubovolné políčko $(i,j)$. Pozrieme sa naň toľkokrát, do koľkých nepočmáraných plusiek patrí. Ak je na $(i,j)$ znak `#`, môže to byť buď stred pluska (teda patrí do práve jedného), alebo byť hornou/dolnou stranou stredného stĺpca, resp. ľavou/pravou stranou stredného riadku. V tejto situácii môže zároveň patriť do najviac jedného ďalšieho nepočmáraného pluska.

Na tomto obrázku sú farebne vyznačené tie `#`, ktoré patria do dvoch nepočmáraných plusiek (a teda náš algoritmus sa na ne pozrie dvakrát). Žiadnu mriežku však ako okraj platného pluska nebude skúšať viac ako dvakrát.

Podobná úvaha platí aj pre nepopísané políčka -- každé nepopísané políčko môže patriť do najviac štyroch nepočmáraných plusiek (do ľavej hornej časti jedného, pravej dolnej časti druhého, ...).

Na tomto obrázku sú farbene vyznačené tie bodky, ktoré patria do viacerých nepočmáraných plusiek. Pritom všetky patria do práve dvoch plusiek s výnimkou bodky v úplnom strede obrázku, ktorá patrí do všetkých štyroch plusiek.

Keďže pri overovaní jedného pluska sa na každé jeho políčko pozrieme len raz, a každé políčko v najhoršom prípade patrí do štyroch rôznych nepočmáraných plusiek, vyplýva z toho, že na každé políčko tabule sa pri overovaní pozrieme najviac štyrikrát. Políčok je $n^2$, a teda časová zložitosť je $O(n^2)$.

Opäť si pamätáme celú tabuľu, teda pamäť je stále $O(n^2)$
",6
2e5dcba8af6969d8,ksp,"# Taktická záchrana

Kde bolo tam bolo, v $n$ posteliach si nažívajú mnohofarebné ploštice. Ich spokojnú existenciu však narušil príchod Klubu: Stop Plošticiam. A zrejme už detekovali prítomnosť ploštíc a idú ich posteľ-po-posteli vyhubiť! Centrálny Mozog Ploštíc^[entita ovládajúce ploštice] už pripravuje evakuáciu -- obetuje ploštice v prvej vyhadzovanej posteli a evakuuje medzitým ostatné (kým je Klub zamestatný deratizáciou tej postele). Problém je, Centrálny Mozog Ploštíc nevie ktorá posteľ bude deratizovaná ako prvá, a preto by sa rád pripravil na všetky možnosti. Menovite, chcel by vedieť, pre každú posteľ, aké farby ploštíc sa zachránia. Ďalší problém je, že Centrálny Mozog Ploštíc neviem aké farby ploštíc žijú na akej posteli. Jediné, čo vie robiť, je sa pozrieť na nejakú množinu postelí, a zistiť aké farby ploštíc sú prítomné na nejakej z nich. Pozor! Deratizéry sa blížia, a Centrálny Mozog nemá veľa času pýtať sa!

## Úloha

Táto úloha je *interaktívna*. Namiesto klasického vstupy a výstupu sa váš program bude pýtať otázky a dostávať na ne odpovede.

Existuje $63$ farieb ploštíc, a $n$ postelí kde sa ploštice nachádzajú. Farby ploštíc na $i$-tej posteli si vieme reprezentovať celým číslom $p_i$ -- prítomnosť ploštíc $j$-tej farby je indikovaná tým, či $j$-tý bit v binárnej reprezentácii čísla $p_i$ je $1$ (ak je $0$, ploštice danej farby sa tam nenachádzajú).

V tejto úlohe váš program pomáha Centrálnemu Mozgu Ploštíc. Vašou úlohou je zistiť, pre každú z postelí, aké farby ploštíc sa nachádzajú na ostatných posteliach. Konkrétne to chcete zistiť pomocou pýtania sa niekoľko (čo najmenej) otázok typu ""aké farby ploštíc sú v tejto množine postelí"".

## Formát vstupu

Na prvom riadku vstupu je číslo $t \\leq 100$ udávajúce počet sád.

Pre každú zo sád dostanete na novom riadku číslo $1 \\leq n\\leq 1000$ -- počet postelí.

Na každú vašu otázku dostanete odpoveď -- celé číslo ktorého binárny zápis reprezentuje prítomnosti farieb, na novom riadku.

Po každej vašej odpovedi na danú sadu, nasleduje nová sada.

## Formát výstupu

**Otázky** sa vás program pýta v nasledujúcom formáte: pre jednu otázku, na jednom riadku vypíšte `?` (otáznik), nasledovaný medzerou a celým číslom $0\\leq m\\leq n$, veľkosť množiny na ktorú sa chcete opýtať. Potom nasleduje $m$ medzerou oddelených čísel $1\\leq i_1, \\dots, i_m \\leq n$ -- čísla postelí v množine na ktorú sa pýtate.

Pre vypísanie **výsledku** pre aktuálnu sadu, vypíšte jediný riadok, začínajúci `!` (výkričníkom) nasledovaný $n$ číslami oddelenými medzerou -- $i$-té z nich reprezentuje aké farby ploštíc sa nachádzajú na všetkých posteliach *okrem $i$-tej*.

Aby testovanie fungovalo ako má, **je nutné**, aby sa po vypísaní tipu výstup presunul z pamäte na štandardný výstup pomocou príkazu `cout.flush()` v C++ alebo `sys.stdout.flush()` v Pythone. Pre iné jazyky hľadajte ekvivalent k príkazu `flush`.

Testovač je *adaptívny* a teda rozloženie ploštíc na posteliach môže závisieť od otázok vášho programu. Je garantované, že všetky odpovede sú konzistentné s nejakým rozložením ploštíc po posteliach.

### Varovanie

V prípade, že váš program vypíše výstup v zlom formáte, testovanie skončí s nula bodmi. V tomto prípade váš program vie dostať verdikt ""Prekročeny časový limit"".

## Hodnotenie

Hodnotenie v tejto úlohe bude špeciálne a bude záležať na počte otázok, ktoré ste sa opýtali. Existuje jediný vstup, na ktorom bude váš program testovaný. Body dostanete, len ak na všetky testovacie sady odpoviete správne.

- Plný počet dostaanete, ak váš program na každú sadu odpovie správne s použitím nanajvýš $13$ otázok

- $6$ bodov vie váš program získať ak na každú sadu odpovie správne s použitím nanajvýš $2\\lceil \\log n \\rceil$ otázok (kde $n$ je počet postelí v tej sade)

- $4$ body dostane váš program ak na každú sadu odpovie správne s použitím nanajvýš $2\\lceil \\sqrt n \\rceil$ otázok

- Nanajvýš $2$ body dostanete, ak na každú sadu odpovie váš program správne s použitím nanajvýš $n / 2 + 2$ otázok

- Najviac $1$ bod vie získať riešenie, ktoré nikdy nepoužije viac otázok ako je postelí.

## Príklady

```
>>> 1
>>> 3
<<< ? 1 1
>>> 1
<<< ? 1 2
>>> 2
<<< ? 1 3
>>> 4
<<< ! 6 5 3
```

_Pre jednoduchosť je vstup aj výstup spolu. "">>>"" a ""\<<\<"" sú v príklade len na prehľadnosť. V tomto prípade na $i$-tej posteli žijú práve ploštice $i$-tej farby, takže ak si Klub vyberie prvú posteľ, zachránia sa ploštice farieb $2$ a $3$, ak si Klub vyberie druhú posteľ zachránia sa ploštice farieb $1$ a $3$, a ak si vyberú tretiu posteľ, zachránia sa ploštice farieb $1$ a $2$._
","# Taktická Záchrana

## Prvé technické detaily

Pred tým, ako sa pustíme do riešenia úlohy, pozrime sa na to, ako si reprezentujeme druhy ploštíc v posteliach a ako s touto reprezentáciou pracovať.

V zadaní sú ploštice v nejakej posteli reprezentované cez celé čísla - presnejšie cez ich binárny zápis. Ak čísla $a$ a $b$ reprezentujú ploštice v dvoch posteliach. Farby, ktoré sa nachádzajú na niektorej z nich, sa dajú zistiť pomocou *binárneho ORu* -- a to ako `a | b` (aj v pythone aj v C++). Táto operácia vráti číslo ktoré má na $i$-tom bite jednotku práve vtedy, ak má aspoň jedno z čísel $a$ a $b$ na $i$-tom bite jednotku.

## Jednoduché riešenie

Vybavený potrebnou mechanikou, poďme sa pustiť do riešenia úlohy. Ak vieme stav každej postele, vieme zistiť pre každú posteľ, aké farby ploštíc sa zachránia, ak práve táto bude napadnutá -- jednoducho si vypočítame OR ostatných postelí. Takto vieme odpovedať na jednu testovaciu sadu pomocou $n$ otázok v $O(n^2)$ čase pomocou a $O(n)$ pamäti. A tak vieme získať $1$ bod.

Toto riešenie vieme zrýchliť pomocou OR-ekvivalentu prefixových a suffixových súčtov: prefixových a suffixových OR-ov. Vieme si v $O(n)$ čase spočítať pre každé $1\\leq i\\leq n$, aké farby ploštíc sú na posteliach $1, 2, \\dots, i - 1$ a aké farby ploštíc sú na posteliach $n, n - 1, \\dots, i + 1$ a následne vypísať OR týchto dvoch hodnôt (všimnite si, že na vypočítanie prvej hodnoty pre pozíciu $i$ z hodnoty pre pozíciu $i-1$ stačí konštantný čas a nápodobne pre druhú hodnotu z hodnoty pre $i+1$).

## Menej otázok: pokrývame postele

Na viac bodov sa musíme vedieť nespýtať na každú posteľ separátne. Ako na to?

Položme si otázku inak. Pre aké otázky vieme vyskladať odpoveď?

Predstavme si, že sa spýtame na $k$ množín postelí. Označme ich ako $S_1,\\dots, S_k$ a dostaneme odpovede $a_1, \\dots, a_k$. Kedy vieme zistiť z týchto otázok informáciu ""aké farby ploštíc ostanú, ak bude prvá zasiahnutá posteľ $i$""? Nemôžeme použiť informácie zo žiadnej množiny ktorá obsahuje $i$ - inak nevieme, či farba ploštíc je na posteli $i$ alebo aj na inej posteli z množiny. Pozrime sa teda na všetky množiny neobsahujúce $i$. Ak je každá iná posteľ (okrem $i$) obsiahnutá v niektorej z týchto množín, všetky jej farby ploštíc budú obsiahnuté v OR-e odpovedí pre tieto postele.

Takže dostávame podmienku: na to aby sme vedeli odpovedať s pomocou otázok na množiny $S_1, \\dots, S_k$, musí pre každý pár rôznych postelí $i\\neq j$ existovať množina, v ktorej nie je posteľ číslo $i$, ale nachádza sa v nej posteľ $j$.

Ako ale takúto množinu skonštruovať?

### $n/2 + 2$ otázok

Hint, ako vyriešiť úlohu na dva body je v počte otázok: $n / 2$ naznačuje, že by sme si mohli rozdeliť postele na dvojice -- postele $1, 2$, postele $3, 4$, až $n - 1, n$^[Ak je $n$ nepárne, môžeme sa spýtať na $n$ ako množinu s jediným prvkom, nezhorší nám to počet otázok] (na obrázku môžme vidieť rozdelenie pre $n = 8$). Takéto rozdeliene nám ale ešte úplne úlohu nevyrieši.

Pre každú z postelí, zjednotenie množín, ktoré ju neobsahujú, obsahujú všetky postele okrem jej dvojice. Chceli by sme teda pridať nejaké (najviac dve) množiny, pomôcou ktorých by sme vedeli ""rozlíšiť"" aj postele v jeden dvojici. Na to nám stačí si uvedomiť dve veci:

1. Je v poriadku, ak sú informácie o nejakej posteli ""pridané dvakrát"" (keďže nepočítame počet výskytov rôznych farieb, len či sú alebo nie sú)

1. V každej dvojici je jedna párna a jedna nepárna posteľ

Teda nám stačí sa navyše spýtať na množinu všetkých párnych a na množinu všetkých nepárnych postelí (ako môžme vidieť na obrázku dole pre $n = 8$).

Vieme ľahko skontrolovať, že táto voľba množín spĺňa horeuvedenú podmienku: pre každé dve rôzne postele - buď nenasledujú priamo za sebou (a teda nie sú v rovnakej dvojici) alebo majú rozličnú paritu.

Skonštruovať odpoveď pre každú posteľ vieme pomocou $n / 2$ otázok, a tak dostaneme časovú zložitosť $O(n^2)$ a pamäťovú $O(n)$.

### Vieme zlepšiť toto riešenie?

V predchádzajúcom riešení sme rozdelili postele na po sebe idúce dvojice, a následne podľa zvyšku po delení dvoma. Ale číslo dva nie je v tomto prípade špeciálne! Mohli by sme nápodovne použiť trojice, štvorice, resp. akékoľvek $k$-tice. Rovnakou stratégiou ako pre dvojice, vieme získať pre $k$-tice odpoveď pomocou $n / k + k$ otázok.

Ak sa s týmto výrazom pohráte, zistíte, že najmenej otázok ($2\\rceil\\sqrt(n)\\lceil$) nám výjde pre $k$ rovné $\\sqrt(n)$ (zaokrúhlené na najbližšie celé číslo). Takéto zlepšenie nám dá $4$ body a zlepší časovú zložitosť na $O(n\\sqrt{n}))$ a pamäťovú na $O(n)$.

### Ešte menej otázok

Skupinkovaciu metódu sme už očividne zlepšili ako sa dalo, ale ešte stále nemám plný počet bodov. Mohli však by sme sa inšpirovať na lepšie riešenie?

Vráťme sa späť ku rozdeleniu postelí na dvojice. Toto rozdeľovanie je zjavne neefektívne, keďže potrebujeme lineárne množstvo množín, aby sme pokryli všetky postele. Čo keby sme sa v jednej množine spýtali na polovicu dvojíc a v druhej na druhú polovicu dvojíc. Takto stále očividne nevieme rozoznávať všetky postele. Odpoveďou je: rozdelenie dvojíc na polovice viacerými spôsobmi.

Limit $2\\log n$ v zadaní nám vie napríklad napovedať nasledovné množiny:

- všetky párne postele, všetky nepárne postele
- každá párna dvojica, každá nepárna dvojica
- každá párna štvorice, každá nepárna štvorica
- ...
- prvá polovica postelí, druhá polovica postelí^[rozmyslite si, ak $n$ nie je mocnina dvojky]

Na obrázku môžeme vidieť množiny pre $n = 16$. Ako prvé si všimnime, že takto dostaneme $2\\lceil\\log n\\lceil$ otázok. Po druhé, tieto množiny nám vedia vyskladať všetky odpovede -- predstavme si, že chceme odpoveď na $i$-tú posteľ (teda, ktoré farby sú na ostatných posteliach). Pozrime sa na binárny zápis čísla $i$. Ten nám presne povie ktoré query máme skombinovať. Ak má $i$^[číslujme tu postele od nuly] na $j$-tom bite $1$, poto chceme použiť odpoveď pre *párne* $2^i$-tice a v opačnom prípade odpoveď pre *nepárne* $2^i$-tice. Keďže rôzne postele majú rôzne binárne zápisy a v každom ""leveli"" otázok sa každá posteľ nachádza v presne jednej z množín, vieme tak rozlišovať každú dvojicu postelí.

Takto dostaneme teda riešenie v časovej zložitosti $O(n\\log n)$ s pamäťou $O(n)$, ktoré vie získať $6$ bodov (pre $n = 1000$ použije $20$ otázok).

### Vzorové riešenie

Narozdiel od predchádzajúcich riešení, vo vzorovom si množiny necháme vygenerovať programom, ale nie na základe jednoduchého vzoru.

Pozrime sa na množiny z pohľadu postelí: v ktorých množinách z $k$ opýtanych množín sa bude nahádzať posteľ $i$?

Zjavne dáva zmysel, aby každá posteľ bola v približne rovnakom počte množín. V predchádzajúcom riešení bola každá posteľ v polovici množín, čo keby sme sa týmto princípom inšpirovali?

Vzorové riešenie potrebuje použiť najviac $13$ množín, mohli by sme zariadiť aby každá posteľ bola v $6$ z nich?

Existuje $\\binom{13}{6} = 1716$ rôznych spôsobov, akým je možné vybrať $6$ z $13$ množín, do ktorých nejaká posteľ bude patriť. Keďže to je menej, ako všetkých postelí, ktoré vieme na vstupe dostať, vieme pre každú vybrať unikátny výber množín, v ktorých bude zaradená. Takto teda vieme nájsť pre každú dvojicu postelí množinu, v ktorej prvá posteľ je a druhá nie je (keďže všetky postele sú v rovnakom počte množín).

Teda na dokončnie riešenia nám treba len vymyslieť ako ho implementovať -- odporúčam použiť `next_permutation` v C++, alebo knižnicu ` itertools` v pythone. Keď si množiny generujeme, vieme si rovno zapísať, ktorú množiny treba OR-ovať, aby sme získali výsledok pre tú-ktorú posteľ. Toto riešenie použije $13$ otázok a vieme ho implementovať v čase a pamäti $O(n)$.

V skutočnosti, ak by $n$ nebolo horne ohraničená, potrebovali by sme rádovo $\\log n$ otázok -- vieme ukázať, že menej než $2\\log n$ postačí, ale potrebujeme aspoň $\\log n$^[žiaľ presný počet nie je pekná funkcia], takže časová zložitosť je v skutočnosti $O(n\\log n)$.
",6
69cccf38c1feed58,ksp,"# Zblúdilá krava

Každý vie, aký je Denis farmár. Na svojom pozemku chová veľa rôznych zvieratiek, ako napríklad psíka Toma, zopár kôz a stádo kráv. Psík Tom má náročnú úlohu -- stráži kravy, aby sa netúlali mimo Denisov pozemok (sám Denis ich nestráži, radšej pozerá futbal na svojom iPade). Tom nie je zrovna inteligentný pes. Napriek tomu je schopný postrážiť všetky zvieratká okrem kravy Rysule. Tá je veľmi múdra, a často sa jej podarí Toma prechytračiť a opustiť pozemok. Všimla si totiž, že ak sa pohybuje iba vertikálne alebo horizontálne, tak ju Tom nezbadá. Potom chudák Denis musí Rysuľu hľadať a často pritom zmešká druhý polčas. Keďže sa blíži Liga majstrov, Denis si nemôže dovoliť zmeškať zápas kvôli Rysuli. Musí preto oplotiť svoj pozemok.

Denis sa rozhodol, že zabije dve muchy jednou ranou. Vyženie všetky zvieratá na pastviny, a kým sa budú pásť, on bude stavať plot. Zabudol ale, že Rysuľa mu bude chcieť ujsť, a on už nechce dopustiť aby mu zase zdrhla.

Denis sa naučil techniku Assembler, to znamená, že jeho **runtime** (beh) je nekonečne rýchly. Plot ale stavia pomaly, konkrétne tak rýchlo, ako sa Rysuľa pohybuje.

## Úloha

Denisov pozemok je obdĺžnik $r \\times s$ políčok. Na jednom z týchto políčok sa na začiatku pasie krava Rysuľa, ktorá mu chce z neho ujsť. Každú sekundu sa stanú nasledovné dve veci (v takomto poradí):

- Denis postaví kus plota o dĺžke strany jedného políčka. Tento kus oddelí niektoré okrajové políčko jeho pozemku od vonkajšieho sveta (v prípade rohového políčka ho oddelí iba z jednej strany). Keďže Denis behá nekonečne rýchlo, môže túto časť plota postaviť kdekoľvek, nezávisle na tom, kde bol v predošlej sekunde.

- Rysuľa sa pohne o jedno políčko v jednom zo štyroch základných smerov. Ak je Rysuľa na kraji pozemku a nebráni jej plot, môže z neho takýmto spôsobom ujsť.

Denis vyhrá, ak sa mu podarí oplotiť celý pozemok (teda postaviť všetkých $2 (r+s)$ častí plotu) bez toho, aby z neho Rysuľa ušla. Rysuľa vyhrá, ak sa jej podarí ujsť z pozemku skôr, než ho Denis celý oplotí.

## Táto úloha je interaktívna!

V tejto úlohe si váš program zahrá proti nášmu programu. Váš program bude hrať za Denisa, náš za Rysuľu.

Váš program bude striedavo vypisovať ťahy, ktoré chce urobiť a načítavať ťahy, ktoré urobí ten náš, až kým niektorý program nevyhrá.

## Formát vstupu

Na začiatku hry dostanete na vstupe rozmery mapy a začiatočnú pozíciu kravy. V prvom riadku budú dve medzerou oddelené celé čísla $r$ a $s$ ($1 \\leq r,s \\leq 20,000$) -- rozmery Denisovho pozemku. V ďalšom riadku sú čísla $x$ a $y$ -- počiatočná pozícia kravy Rysule.

Následne môžete urobiť svoj prvý ťah a vypísať ho na výstup. Po každom ťahu, ktorý urobíte (a vypíšete), dostanete na vstupe náš ďalší ťah. Ten bude mať formu dvojice čísel $x$ a $y$ -- pozícia, kam sa Rysuľa pohla. Platí $1 \\leq x \\leq s$ a $1 \\leq y \\leq r$. Ak sa Rysuli podarí ujsť, váš program sa to už nedozvie (aj tak by s tým už nemal čo robiť).

Rozmery mapy a počiatočná pozícia kravy budú vždy také, že existuje víťazná stratégia pre Denisa. To znamená, že váš program by mal byť schopný vyhrať bez ohľadu na to, ako dobre bude hrať ten náš.

V jednotlivých sadách testovacích vstupov navyše platí:

| číslo sady | obmezenie na $r$, $s$ | Rysuľa | |:----------:|:----------------------------|:----------------------------------------------------| | 1 | $1 \\leq r, s \\leq 100$ | Rysuľa sa nepokúsi ujsť z pozemku (na získanie | | | | bodov ho stačí korektne oplotiť). | | 2 | $1 \\leq r, s \\leq 1000$ | Rysuľa najviac raz príde na okraj pozemku. Ak vtedy | | | | narazí na plot, vzdá to a už sa nepokúsi utiecť. | | 3 | $1 \\leq r, s \\leq 1000$ | Rysuľa sa zo všetkých síl snaží ujsť. | | 4 | $1 \\leq r, s \\leq 20,000$ | Rysuľa sa zo všetkých síl snaží ujsť. |

Môžete predpokladať, že vstup je korektný a Rysuľa sa vždy pohne práve o 1 políčko.

## Formát výstupu

Po každom načítaní pozície Rysule vypíšte, ktorú časť pozemku chcete oplotiť. Keďže rohy pozemku sa dajú oplotiť z dvoch strán, pomôžeme si trikom. Zväčšíme Denisov pozemok o 1 políčko z každej strany. Krajné políčka budú ""oplocovať"" pôvodné Denisove pastviny. Takto navyše vieme každej časti plotu priradiť jednoznačné súradnice. Ak chcete napríklad oplotiť políčko $[1,1]$ zľava, vypíšte: `0 1`.

*(Dávajte si pozor na korektnosť vášho výstupu. Ak vypíšete súradnice plotu, ktorý neexistuje, alebo je už postavený dostanete `""WA - Zlá odpoveď""`.)*

## Flushovanie

Programovacie jazyky štandardne používajú výstupný buffer (väčšinou 512 bajtov), a až po jeho zaplnení program vypíše jeho obsah. Flushovanie vlastne znamená vypísanie (vyprázdnenie) tohto buffera.

Vždy, keď vypíšete svoj ťah, musíte ešte flushnúť výstupný buffer. Inak sa váš ťah v skutočnosti nevypíše a nedostane sa k nášmu programu. V konečnom dôsledku potom dostanete hlášku `""TLE - Prekročený časový limit""`.

#### Ako flushovať?

Ak programujete v C/C++ a používate `printf()`, na to aby ste flushli jeho buffer použite `fflush(stdout)`, ak používate `cout`, buffer sa flushuje automaticky po vypísaní konca riadku pomocou `cout<<endl`. Ak programujete v Pythone, používajte `print(vystup, flush=True)`. Ak programujete v Pascale použite `flush(output)`

## Príklady

```vstup
9 9 
5 5
6 5
7 5
8 5

... ďalších 32 riadkov
```

```vystup
0 1
10 5
10 1

... ďalších 33 riadkov
```

_Denis najprv postavil plot na ľavej strane rohového políčka $[1,1]$. Krava sa rozbehla doprava. Denis postavil plot napravo od políčka $[9, 5]$, kam má Rysuľa namierené. Rysuľa sa opäť pohla doprava. Po ďalších 34 ťahoch sa Denisovi podarilo oplotiť celý pozemok._
","# Zblúdilá krava

Táto úloha bola iná ako ostatné. Pomáhali ste Denisovi v jeho probléme, pričom váš program načítaval postupne pozície Rysule, a vypisoval, ktorý plot sa má postaviť. Na vyriešenie tejto úlohy sme potrebovali vymyslieť ""nepriestrelnú"" stratégiu, ktorá nedovolí Rysuli ujsť.

## Kedy vyhrá Rysuľa

Skúsme sa na úlohu pozrieť z pohľadu Rysule. Ona sa snaží ujsť, avšak my jej staváme prekážky (ploty), cez ktoré nevie prejsť.

Základné pozorovanie je, že okrajových políčok pastviny je $2 (r + s) - 4$ a plotov, čo musíme postaviť je $2 (r + s)$. Vyplýva to z toho, že rohové políčko musí byť oplotené z dvoch strán.

Jedna z možných stratégií pre Rysuľu je rozbehnúť sa k najbližšiemu okraju pozemku. Ak sa jej nepodarí utiecť cez prvé okrajové políčko, na ktoré príde (lebo ho Denis stihne oplotiť), začne bežať po obvode pozemku. Ak sa jej počas toho naskytne možnosť ujsť (Denis nestihne postaviť nejakú časť plota včas), využije ju.

Predpokladajme na chvíľu, že sa Rysuľa bude správať podľa tejto stratégie. Na to, aby Denis vyhral, musí stihnúť dokončiť plot najneskôr v momente, keď Rysuľa stúpi na posledné obvodové políčko, kde dovtedy nebola. Ak by totiž aj počas nasledujúceho Rysulinho ťahu bola v plote diera, znamenalo by to, že Rysuľa cez túto dieru mohla ujsť, keď okolo nej šla.

Keďže Denis na oplotenie celého pozemku potrebuje $2 (r + s)$ ťahov, môže vyhrať jedine v prípade, že Rysuľa bude na dobehnutie k okraju pozemku a následnú prechádzku po jeho obvode potrebovať aspoň $2 (r+s)-1$ ťahov (keďže Denis začína, po $2(r+s)-1$-vom Rysulinom ťahu bude nasledovať $2(r+s)$-tý Denisov ťah). Ak sa Rysuľa svojím tretím ťahom dostane na okrajové políčko, prechádzku po obvode dokončí svojím $2(r+s)-2$-hým ťahom (obvod má $2(r+s)-4$ políčok a prvé dva ťahy ešte nejde po obvode), takže Denis nemá šancu stihnúť postaviť plot.

To znamená, že ak sa Rysuľa vie na 3 alebo menej ťahov dostať na okrajové políčko, má zaručený spôsob ako ujsť.

## Kedy vyhrá Denis

Už sme zistili, že Denis nevie vyhrať, ak Rysuľa začína 3 alebo menej políčok od okraja a je inteligentná. Stačí mu, aby začínala 4 tahy od okraja? Stačí, lebo môže hrať napríklad podľa nasledovnej stratégie:

V prvých štyroch ťahoch Rysuľa Denisovi určite neujde, keďže na štyri ťahy sa stihne dostať maximálne na okrajové políčko. Denis za tieto štyri ťahy postaví jednu časť plotu v každom rohu. Potom každé políčko bude potrebovať už len jedno oplotenie. A teda vždy keď sa Rysuľa dostaví na nejaké okrajové políčko, Denis jej tam postaví plot.

*(Keďže zadanie hovorí, že vždy vieme zabrániť Rysuli ujsť, tak najmenšie pastviny majú rozmery $9 \\times 9$ a Rysuľa začína v ich strede)*

## Implementácia

Úloha je vcelku prísna na to čo vypíšeme. V každom ťahu musíme niečo postaviť, nemôžme postaviť plot tam kde už je postavený a tiež si musíme dať pozor aby súradnice ktoré vypisujeme boli naozaj na okraji pastviny.

Najprv musíme vyriešiť rohy pastviny. Tieto pozície budeme poznať hneď ako načítame rozmery pastviny. Vieme potom vybrať jednu časť z každého rohu (rozmyslite si prečo treba z každého), a tú oplotiť. Potom začneme v nejakom krajnom políčku, a bude oplocovať pažravo dookola. Keď sa Rysuľa dostaví na kraj, prerušíme pažravé stavanie, a postavíme plot pri políčku na ktorom sa nachádza. Ak by bola taká hlúpa a opustila kraj, tak pokračujeme v pôvodnom pažravom stavaní.

Ostáva už len vyriešiť ako si pamätať už postavené ploty? Najjednoduchšie je pouziť v C++ `set` alebo `unordered_set` (tu si musíte vytvoriť vlastnú hashovaciu funkciu), ale dajú sa tieto údaje počítať aj v obyčajnom **poli**.

## Zložitosť

Časová zložitosť algoritmu je $O(r + s)$ ak použijeme unordered_set alebo pole, a $O((r+s) \\cdot log(r+s))$ ak použijeme set, kedže musíme oplotiť celú pastvinu, a odpoveď ktorú časť plotu postaviť vieme zodpovedať v čase $O(1)$. Pamäťová zložitosť tohto algoritmu je tiež $O(r + s)$, keďže je potrebné pamätať si už postavené ploty.
",4
9dbb87aed6d155e8,ksp,"# Opitý za volantom

V Krajine samých pijanov sú čoraz častejšie pristihnutí vodiči za volantom pod vplyvom alkoholu. To, či je to spôsobené lepšou kvalitou policajnej hliadky, alebo či to súvisí s parádnym hitom vinárskeho trhu s názvom ""pangalaktický dunihlav"", je pre všetkých záhadou.

Situácia v krajine ale začína byť vážna -- ľudia sa štítia pitia alkoholu, pretože sa boja, že by mohli skončiť za volantom následkom čoho začína celá ekonomika upadať.

Časom si policajné hliadky všimli, že sa vodiči často sťažujú na dopravné značky -- buď ich nie je dobre vidno, alebo sú im otočené chrbtom, alebo ich v spoločensky unavenom stave nestihnú zaregistrovať^[čo je samozrejme chyba dopravnej značky].

Prišli teda s nasledujúcim famóznym nápadom: každý vodič bude mať úžasné zariadenie. Vodič sa môže v prípade potreby zariadenia spýtať na všetky dopravné obmedzenia, ktoré sa ho momentálne týkajú. Stačí stlačiť veľké priateľské tlačidlo _PODLIEHAM PANIKE_ a zariadenie vypíše zoznam všetkých predpisov.

## Úloha

Na jednej dlhej ceste platia na rôznych úsekoch rôzne dopravné obmedzenia. Každé dopravné obmedzenie je určené jeho začiatkom, koncom a poradovým číslom. Pozície na ceste sú reprezentované celými číslami.

Ak sa vodič nachádza na pozícii $p$, dopravné obmedzenie so začiatkom $l$ a koncom $r$ sa ho týka práve vtedy, keď $l \\leq p < r$.

Dostanete zoznam začiatkov a koncov $n$ obmedzení a následne $q$ otázok. Otázka je jedno číslo -- pozícia vodiča na ceste. Pre každú otázku vypíšte zoznam všetkých obmedzení, ktoré sa vodiča týkajú.

Otázky je nutné spracovať online -- nemôžete spracovať ďalšiu otázku, kým nezodpoviete tú aktuálnu.

## Formát vstupu

Na prvom riadku vstupu je počet dopravných obmedzení -- $n \\leq 5 \\cdot 10^5$. Nasleduje $n$ riadkov, na $i$-tom z nich je popis dopravného obmedzenia s poradovým číslom $i$.

Popis dopravného obmedzenia pozostáva z dvoch celých čísel $l, r$ -- jeho začiatok a koniec. Platí $0 \\leq l, r \\leq 2n$.

Nasleduje číslo $q \\leq 2n$ -- počet otázok. Na každom z ďalších $q$ riadkov je jedno celé číslo $p$. Nech $m$ je aktuálna maska (ktorej výpočet je popísaný v nasledujúcom odseku). Potom pozícia vodiča je $p \\oplus m$ (bitový xor $p$ a $m$, v C++ `p^m`).

## Formát výstupu

Pre každú otázku $p$ vypíšte najprv počet dopravných obmedzení $d$, ktoré sa vodiča týkajú. Následne vypíšte do toho istého riadku čísla $a_1, a_2, \\ldots, a_d$ -- poradové čísla týchto dopravných obmedzení v ľubovoľnom poradí. Čísla oddeľte jednou medzerou, a za posledným číslom ukončite riadok.

Pre prvú otázku je hodnota masky $m = 0$.

Pre ostatné otázky vypočítame hodnotu masky nasledovne: nech $m'$ je hodnota masky na predchádzajúcej otázke, a nech odpoveď na ňu bola $d~ a_1~ a_2~ \\ldots ~ a_d$. Potom aktuálnu hodnotu masky vypočítame ako $m = m' \\oplus a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_d$.

**Je zaručené, že počet čísel na správnom výstupe nebude presahovať $5 \\cdot 10^5 + q$.**

## Príklady

```vstup
4
5 7
3 4
1 2
0 6
8
5
7
6
7
3
3
3
2
```

```vystup
2 0 3
1 3
1 0
0
2 1 3
2 2 3
1 3
1 3
```
","# Opitý za volantom

V prvej časti vzoráku si ukážeme, ako sa postupným zlepšovaním vieme dopracovať k optimálnemu riešeniu pomocou checkpointov. Ku koncu si ukážeme pomalšie, ale pomerne rýchle riešenie pomocou intervalového stromu a pre fajnšmekrov aj optimálne riešenie, ktoré používa karteziánsky strom.

Výstraha: Odporúčame vám čítať vzorák od začiatku. Jednotlivé sekcie na seba niekedy netriviálne nadväzujú. Pri odhadoch časových zložitostí sa budú vyskytovať hlavne písmenká $n =$ počet obmedzení, $q =$ počet otázok a $o =$ veľkosť výstupu. Ak nebude uvedené inak, pamäťová zložitosť je $O(n)$.

## Priamočiare $O(n + qn + o)$

Na začiatku načítame všetky dopravné obmedzenia a uložíme si ich v skoro ľubovoľnej dátovej štruktúre -- pole, vektor, spájaný zoznam,... Čokoľvek, čo nám umožňuje prejsť všetkými prvkami.

Keď sa neskôr vodiči pýtajú na dopravné obmedzenia, ktoré sa ich týkajú, jednoducho pre každé dopravné obmedzenie zistíme, či sa vodič nachádza v jeho aktívnej zóne. Ak áno, obmedzenie si zapamätáme. Na konci všetky zapamätané dopravné obmedzenia vypíšeme v požadovanom formáte.

Pre každú otázku prechádzame zoznam všetkých obmedzení, čiže najpomalšia časť algoritmu si vyžaduje čas $O(qn)$.

## Neskúšajme obmedzenia začínajúce za pozíciou vodiča $O(n + qn + o)$

Všimnime si, že nemá zmysel skúšať dopravné obmedzenia, ktorých začiatok je na ceste neskôr ako pozícia vodiča. Môžeme tak vyskúšať nasledujúce vylepšenie:

Na začiatku si všetky obmedzenia utriedime podľa pozície ich začiatku. Na otázky potom vieme odpovedať efektívnejšie -- ak je panikáriaci vodič na pozícii $p$, postupne overujeme obmedzenia v poradí, ako sú utriedené. Keď narazíme na obmedzenie začínajúce na $l > p$, vieme, že ďalej nemá zmysel skúšať.

Ak všetky obmedzenia pokrývajú len krátke úseky cesty a vodič spanikáril skoro na konci cesty, tento algoritmus začne pekne poporiadku testovať obmedzenia, ktoré začínajú na začiatku cesty. Väčšina obmedzení však vďaka ich zanedbateľnej dĺžke nebude aktívna. V najhoršom prípade tak stále môžeme potrebovať pre každú otázku prechádzať väčšinu obmedzení, hoci výstup môže byť pomerne malý.

## Neskúšajme obmedzenia začínajúce za a končiace pred pozíciou vodiča $O(n^2 + q + o)$

Čo ak by si ale algoritmus pamätal len obmedzenia, ktoré boli aktívne iba malý kúsok pred vodičovou pozíciou $p$? Povedzme, že tie, čo boli aktívne na pozícii $q \\leq p$. Potom by algoritmus nemusel skúšať obmedzenia končiace pred pozíciou $q$. Stačí mu vyskúšať len obmedzenia aktívne na $q$ a obmedzenia začínajúce v intervale $(q, p\\rangle$.

Keď predchádzajúcu myšlienku dotiahneme do totálneho extrému, dostaneme algoritmus, ktorý po načítaní dopravných obmedzení pre každú pozíciu vypočíta, ktoré obmedzenia sú na nej aktívne.

Ako to spravíme? Tak, ako to robia ľudia za volantom:

Na cestu si umiestnime značky dvoch typov -- začiatok dopravného obmedzenia a jeho koniec. Pri každej značke si tiež pamätáme poradové číslo obmedzenia, ku ktorému sa vzťahuje. Dopravné značky si utriedime podľa ich pozícií. Následne simulujeme jazdu od začiatku cesty po jej koniec, pričom si udržujeme množinu aktívnych obmedzení. Keď sa posunieme o $1$ pozíciu vpred, pozrieme sa na všetky dopravné značky na novej pozícii, a podľa nich upravíme množinu aktívnych obmedzení -- pridáme alebo odstránime obmedzenie z množiny. Následne si pre danú pozíciu uložíme všetky aktívne obmedzenia.

Celkové množstvo toho, čo si algoritmus zapamätá, môže ale byť až $O(n^2)$ -- napríklad, keď máme $n$ obmedzení, a $i$-te z nich je aktívne na intervale $\\langle i, i + n)$. Množinu aktívnych obmedzení si tak stačí pamätať v jednoduchom poli, kde pridanie a odobranie záznamu bude trvať $O(n)$. Ak by sme nepotrebovali ukladať aktívne obmedzenia pre každú pozíciu, vieme množinu upravovať v čase $O(\\log{n})$, keď množinu implementujeme ako binárny vyhľadávací strom (`std::set` v C++). Túto optimalizáciu budeme používať v ďalších zlepšeniach algoritmu.

Keď už pre každú pozíciu vieme, ktoré obmedzenia sú na nej aktívne, každú otázku vieme spracovať v čase $O(1 + \\mbox{veľkosť výstupu})$. Pamäťová zložitosť je $O(n^2)$.

## Niečo prijateľnejšie $O(n\\sqrt{n} + q\\sqrt{n}\\log{n} + o\\log{n})$

Nebudeme si ukladať aktívne obmedzenia pre každú pozíciu, ale iba pre niektoré. Opäť simulujeme jazdu od začiatku cesty po jej koniec. Pozíciu, pre ktorú sa rozhodneme uložiť si aktívne obmedzenia, nazveme **checkpoint**. Ako prvý checkpoint zvolíme začiatok cesty. Keď sa potom posúvame vpred, štandardne si udržujeme množinu aktívnych obmedzení. Ak sme od posledného checkpointu videli aspoň $\\sqrt{n}$ značiek, uložíme si pre túto pozíciu aktívne obmedzenia a prehlásime ju za nový checkpoint. Pre každý checkpoint si pamätáme najviac $n$ obmedzení a ľahko vidno, že checkpointov je rádovo $\\sqrt{n}$. Preto toto predspracovanie vieme spraviť v čase $O(n\\sqrt{n})$.

Ako odpovedáme na otázky? Keď je panikáriaci vodič na pozícii $p$, nájdeme najbližší checkpoint, ktorý je pred alebo na pozícii $p$. To vieme spraviť napríklad tak, že si pamätáme zoznam všetkých checkpointov utriedený podľa ich pozície, a binárne v ňom vyhľadáme v čase $O(\\log{\\sqrt{n}}) = O(\\log{n})$.

Všetky obmedzenia aktívne v checkpointe vložíme do množiny (v čase $O(a\\log{n})$, kde $a$ je počet týchto obmedzení). Následne sa posúvame vpred, kým nie sme za pozíciou $p$ a podľa značiek upravujeme množinu. Vieme, že značiek bude najviac $\\sqrt{n}$, takže toto spravíme v čase $O(\\sqrt{n}\\log{n})$. Nakoniec ešte vypísanie časti výstupu trvá $O(v)$.

Dokopy potrebujeme na jednu otázku čas $O(\\log{n} + a\\log{n} + \\sqrt{n}\\log{n} + v)$. Podľa nasledujúceho pozorovania to prevedieme do krajšieho tvaru, v ktorom už nebude vystupovať $a$.

## Pozorovania o lokálnosti

Nech na pozícii $p$ je aktívnych $a$ obmedzení, a na úseku $(p, q\\rangle$ je $s$ značiek. Potom na pozícii $q$ je aktívnych aspoň $a - s$ a najviac $a + s$ obmedzení.

Cestou od najbližšieho checkpointu k pozícii vodiča narazíme na najviac $\\sqrt{n}$ značiek, teda $a - \\sqrt{n} \\leq v$, odkiaľ dostávame horný odhad pre $a$: $a \\leq v + \\sqrt{n}$. Dosadením dostaneme odhad času na jednu otázku $O(\\sqrt{n}\\log{n} + v\\log{n})$. Pamäťová zložitosť je $O(n\\sqrt{n})$.

## Lepšie? Lepšie. $O(n\\sqrt{n} + q\\sqrt{n} + o)$

Zamyslime sa nad tým, prečo sme mali v predchádzajúcom riešení v časovej zložitosti tak veľa logaritmov. Pri každej otázke na pozíciu $p$ sme museli zostrojiť množinu, a potom ju upravovať. Pritom nás ale vôbec nezaujíma obsah množiny na pozíciách iných ako $p$. Ide to teda spraviť aj lepšie -- zostrojíme si zoznam všetkých kandidátov -- obmedzení, ktoré by mohli byť aktívne na $p$. Tých je $O(a + \\sqrt{n})$. Pre každého kandidáta vieme v konštantom čase povedať, či je aktívny na pozícii $p$.

Dostaneme tak oveľa prijateľnejší čas na jednu otázku $O(\\log{n} + a + \\sqrt{n} + v) = O(\\sqrt{n} + v)$.

## Celé sa to dá v $O(n + q + o)$

Na prvý pohľad vyzerá táto časová zložitosť nedosiahnuteľne -- veď na upravovanie množiny aktívnych obmedzení potrebujeme $O(n\\log{n})$ času a hľadanie najbližších checkpointov nám trvá $O(q\\log{n})$! Ukážeme si teda najprv, ako tieto veci vieme robiť rýchlejšie.

Pri udržiavaní množiny, nás nezaujíma jej obsah na pozíciách, ktoré nie sú checkpoint. Predstavme si teda, že poznáme všetky aktívne obmedzenia pre checkpoint na pozícii $p$, a nasledujúci checkpoint položíme na pozíciu $q$. Ako vypočítame množinu aktívnych obmedzení pre $q$? Tak, ako sme v predchádzajúcom riešení odpovedali na otázky -- vyskúšame všetky obmedzenia aktívne na $p$, a všetky obmedzenia začínajúce v $(p, q\\rangle$.

Časová zložitosť zostrojenia jedného checkpointu je teda $O(a + b)$, kde $a$ je počet obmedzení aktívnych v predchádzajúcom checkpointe a $b$ je počet obmedzení začínajúcich v $(p, q\\rangle$. Keď takto zostrojíme všetky checkpointy, dostaneme časovú zložitosť $O(c + n)$, kde $c$ je počet obmedzení zapamätaných v checkpointoch (súčet $a$-čok).

Nakoniec, hľadanie najbližšieho checkpointu vieme robiť rýchlejšie vďaka tomu, že všetky pozície sú od $0$ po $2n$. Pre každú pozíciu zistíme, ktorý checkpoint je najbližšie. Ak označme najbližší checkpoint pre pozíciu $x$ ako `P[x]`, ľahko vidno, že ak pozícia $p$ je checkpoint, tak `P[p] = p`, inak `P[p] = P[p-1]`. Stačí nám teda raz vypočítať pole `P` v $O(n)$.

## A stačí na to táto jednoduchá úprava

Všetky prerekvizity už máme, a dostávame sa tak k jadru celého riešenia -- k rozumnému umiestňovaniu checkpointov. Prvý checkpoint umiestnime štandardne na začiatok cesty. Ako umiestňujeme nasledujúce checkpointy? Označme $a$ počet obmedzení v predchádzajúcom checkpointe. Vydáme sa z neho smerom dopredu, pričom si počítame počet značiek, ktoré sme cestou videli. Keď tento počet presiahne $\\frac{a}{2}$, našu pozíciu prehlásime za nasledujúci checkpoint.

A to je celé! Iba drobnou úpravou odmocninového riešenia dostaneme optimálne lineárne. Patrí sa ale dokázať, že je to naozaj lineárne.

Zamyslime sa nad tým, koľko si toho v checkpointoch pamätáme. V prvom checkpointe si pamätáme všetky obmedzenia začínajúce na pozícii $0$, ktorých je najviac $n$. Pre každý ďalší checkpoint máme z pozorovania o lokálnosti nasledujúci odhad:

Nech predchádzajúci checkpoint na pozícii $p$ má $a$ aktívnych obmedzení, a aktuálny checkpoint je na pozícii $q$ a má $b$ aktívnych obmedzení. Na intervale $(p, q\\rangle$ je $s \\geq \\frac{a}{2}$ značiek. Potom $b \\leq a + s \\leq 3s$.

Teda počet zapamätaných obmedzení v aktuálnom checkpointe je rádovo **najviac toľko, koľko značiek sme stretli cestou z predchádzajúceho checkpointu**. Každá značka sa ale zrejme nachádza najviac v jednom úseku `(pozícia checkpointu, pozícia nasledujúceho checkpointu>`. Značiek je $O(n)$, takže celkovo si vo všetkých checkpointoch pamätáme $O(n)$ obmedzení a tak vieme spočítať všetky obmedzenia v checkpointoch v čase $O(n)$.

Nakoniec sa zamyslíme, ako dlho nám trvá odpovedať na otázku. Nech je panikáriaci vodič na pozícii $p$ a najbližší predošlý checkpoint je na $q$. Označme $a$ počet obmedzení v $q$. Vieme, že na intervale $(q, p\\rangle$ je $s < \\frac{a}{2}$ značiek. Podľa pozorovaní o lokálnosti vieme, že počet obmedzení v $p$ je aspoň $a - s > a - \\frac{a}{2} = \\frac{1}{2} a$. Ak teda označíme veľkosť výstupu pre túto otázku $v$, platí $v > \\frac{1}{2} a$. Počet skúšaných kandidátov je $a + s \\leq \\frac{3}{2} < 3v = O(v)$. Takže na každú otázku vieme odpovedať v čase $O(1 + v)$.

Potrebujeme teda čas $O(n)$ na predpočítanie a čas $O(q + o)$ na odpovedanie -- dokopy $O(n + q + o)$.

## Čestné uznania...

...získavajú nasledujúce riešenia. Prvé je založené na intervalovom strome, beží v čase $O(n\\log{n} + q\\log{n} + o)$ a bolo obľúbené medzi riešiteľmi. Druhé je takisto optimálne, a založené na karteziánskom strome.

## Riešenie intervalovým stromom

Na pozícii $l$ si budeme pamätať všetky obmedzenia, ktoré začínajú na pozícii $l$. Nad takýmto poľom zostrojíme nasledovný intervalový strom -- v každom intervale si pamätáme všetky obmedzenia, ktoré majú začiatok v tomto intervale. Navyše si ich pamätáme usporiadané podľa pozície konca obmedzenia. Takýto intervalový strom vieme ľahko zostrojiť -- ak už vieme, aké obmedzenia začínajú v intervale $\\langle l, s)$ a v akom poradí končia, a rovnakú informáciu máme aj pre interval $\\langle s,r)$, tak tieto dva intervaly vieme spojiť v lineárnom čase do intervalu $\\langle l,r)$. (Podobne, ako to robí *merge sort*.)

Keď chceme odpovedať vodičovi na pozícii $p$, chceme vlastne nájsť všetky obmedzenia začínajúce v $\\langle 0, p+1)$, ktorých koncový bod je $> p$. Rozložíme teda štandardne interval $\\langle 0, p+1)$ na $O(\\log{n})$ intervalov, ktoré zodpovedajú vrcholom v našom strome. Pre každý z týchto intervalov vieme, ktoré obmedzenia v ňom začínajú, a v akom poradí končia. Tak začneme tými, ktoré končia najneskôr, a postupne ich skúšame, kým nenájdeme prvé obmedzenie končiace na $r \\leq p$. Ďalej vieme, že nemá zmysel skúšať.

Časová zložitosť jednej odpovede je teda $O(\\log{n} + v)$ -- potrebujeme $O(\\log{n})$ času na rozklad na jednotlivé intervaly, a v každom spravíme aspoň jednu operáciu. Čas na zostrojenie intervaláča je $O(n\\log{n})$ -- dokopy máme čas $O(n\\log{n} + q\\log{n} + o)$. Pamäťová zložitosť je $O(n\\log{n})$ -- na každej úrovni intervalového stromu si totiž pamätáme všetky obmedzenia, a úrovní je $O(\\log{n})$.

## Karteziánske riešenie

Veríme, že čitateľ si sám doplní znalosti o tom, čo to je karteziánsky strom, a ako sa zostrojuje. Najlepšie predtým, než sa pustí do čítania tohto riešenia.

Každé dopravné obmedzenie môžeme interpretovať ako bod v rovine -- ak začína na pozícii $l$ a končí na $r$, tak mu bude zodpovedať bod so súradnicami $l, r$. Predstavme si pre začiatok, že žiadne dve obmedzenia nezačínajú ani nekončia na tej istej pozícii. Nech je vodič na pozícii $p$, a už máme zostrojený karteziánsky strom nad bodmi s $x$-súradnicou $\\leq p$. Ako nájdeme odpoveď?

Jednoducho -- začneme v koreni karteziánskeho stromu, spracujeme ho, a prípadne sa posunieme do jeho ľavého a pravého syna. Čo to znamená ""spracovať"" a ""posunúť"" ? Vieme, že body v ľavom aj v pravom podstrome majú $y$-súradnicu menšiu ako spracovávaný vrchol. Takže ak aktuálne spracovávaný vrchol nevyhovuje (zodpovedá nejakému obmedzeniu $l, r$ pre $r \\leq p$), tak nemá zmysel pokračovať so synom. Ak vyhovuje, tak ho pridáme do zoznamu aktívnych obmedzení, a pokračujeme so synmi. Ľahko vidno, že takto spravíme rádovo $O(1 + v)$ operácii.

Vidíme teda, že by sme chceli nejaký perzistentný karteziánsky strom. To vieme dosiahnuť nasledovne -- štandardne pomocou zásobníku zostrojujeme karteziánsky strom nad poľom. Každý vrchol niekedy pridávame do stromu. Pozrime sa na tento moment -- pridávaný vrchol je najpravejší vrchol stromu, takže môže mať iba ľavého otca. Toho si v danom vrchole zapamätáme.

Ako teraz odpovedáme panikáriacemu vodičovi na pozícii $p$ ? Predpokladajme, že existuje obmedzenie začínajúce na $p$, a označme jemu zodpovedajúci vrchol $a_0$. Spracujeme jeho ľavý podstrom, a nájdeme ľavého otca $a_0$. Nech to je $a_1$, spracujeme ľavý podstrom $a_1$, nájdeme ľavého otca $a_1$, a opakujeme. A tak ďalej, až kým nenarazíme na niekoho, kto už ľavého otca nemá.

Ľahko vidno, že takto sme naozaj spracovali náš strom v takom stave, v akom bol po pridaní vrcholu $p, p$. Konštrukcia stromu z poľa trvá $O(n)$, a odpovedanie trvá dokopy $O(q + o)$ -- dokopy $O(n + q + o)$. Ešte potrebujeme rozšíriť naše riešenie o technické detaily. Konkrétne, keď obmedzenia môžu začínať aj končiť na rovnakej pozícii, a keď nemusí pre každú pozíciu $p$ existovať obmedzenie začínajúce na $p$. Prenechávame čitateľovi.
",10
114e9855148a7e92,ksp,"# Ochrana pred povodňami

Na obdĺžnikovom ostrove síce nebývajú povodne veľmi často, ale keď prídu, je to úplná katastrofa. Zaplavené sú lesy, lúky, námestia, domy a paneláky do výšky prvého poschodia. Takisto všade pláva množstvo odpadkov a opustených domácich zvieratiek. Obdĺžnikový ostrov sa totiž nachádza v strede obdĺžnikového jazera do ktorého vteká nie-až-tak-obdĺžniková rieka, ktorá pramení vo vzdialených trojuholníkových horách.

Pred rokom sa preto začalo s výstavbou protipovodňových ochranných múrov. Väčšina obyvateľov sa aktívne zapája a občas postaví štvorcový kúsok múru.^[Ministerstvo vodohospodárstva prepláca náklady na výstavbu.] Ľudia si väčšinou stavajú múry vo svojom okolí, no niektorí podnikaví jedinci ich stavajú aj tam, kde ich netreba -- napríklad v oblastiach, ktoré sú už celé obohnané múrom -- alebo tam, kde sú absolútne zbytočné -- napríklad osamotený metrový kus múru v strede poľa. A samozrejme, aj takéto aktivity im budú preplatené.

Ministerstvo má záznamy o každom kúsku múra, ktorý bol kedy postavený a Klub skeptických publicistov by ich rád preveril. Chcú o každom kúsku múru zistiť, aký prospešný bol pre spoločnosť a objaviť prípadné škandály v tejto kauze.

## Úloha

Ostrov si môžeme predstaviť ako obdĺžnik rozdelený na $w \\times h$ štvorčekov. Každý štvorček môže byť buď prázdny, alebo na ňom môže byť postavená časť protipovodňovej ochrany.

Voda dokáže tiecť ôsmimi smermi a priteká na každé políčko na okrajoch ostrova. Samozrejme, voda nevie zaplaviť políčko, na ktorom je postavená protipovodňová ochrana.

Dostanete rozmery ostrova a pozície, kde sa postupne stavajú múry. Na začiatku je ostrov prázdny. Vašou úlohou je po postavení každého kúsku múra povedať, aká plocha je chránená pred vodou.

## Formát vstupu

Na prvom riadku vstupu dostanete dve celé čísla $w$ a $h$ ($1 \\leq w,h \\leq 2,000$), pričom $w$ je šírka a $h$ výška obdĺžnikového ostrova.

Na druhom riadku je číslo $n$ ($1 \\leq n \\leq w \\times h$) -- počet štvorcových kúskov protipovodňového múru, ktoré budú postavené.

Každý z nasledujúcich $n$ riadkov obsahuje dve čísla $x_i$ a $y_i$ ($1 \\leq x_i \\leq w$, $1 \\leq y_i \\leq h$), ktoré označujú pozíciu, na ktorú bude postavený $i$-ty kúsok múra.

## Formát výstupu

Vypíšte $n$ takých riadkov, že v $i$-tom riadku bude jedno celé číslo -- plocha územia, ktoré je chránená protipovodňovým múrom po postavení $i$-teho kúsku. To znamená počet takých políčok, na ktoré nevie pritiecť voda.

## Príklad

```vstup
4 4
10
1 1
1 2
1 3
2 1
2 3
3 1
3 2
3 3
2 2
3 4
```

```vystup
1
2
3
4
5
6
7
9
9
10
```

*Prvých 8 kúskov múra ochráni pred povodňami územie veľkosti $3 \\times 3$. Deviaty štvorček nemá vôbec žiadny účinok, lebo políčko $(2,2)$ už bolo chránené. Desiaty kúsok neuzavrie žiadne územie a teda prispeje len svojou plochou.*
","# Ochrana pred povodňami

Najprv si popíšeme myšlienkovo jednoduchšie riešenie, kde po pridaní každej steny prehľadáme celú mapu odznova a ukážeme si zopár vylepšení tohto riešenia. Nakoniec si ukážeme vzorové riešenie -- offline -- načítame celý vstup, spočítame riešenie a vypíšeme celý výstup.

## Viacnásobné prehľadávanie

S využitím prehľadávanie do šírky (BFS -- breadth-first-search) alebo prehľadávania do hĺbky (DFS -- depth-first-search) sa dá vymyslieť jednoduché, funkčné riešenie, ktoré mohlo získať na testovači aspoň 3 body.

V takomto riešení si udržujeme mapku celého ostrova ako dvojrozmerné pole. V nej máme zaznačené, ktoré políčka sú voľné a na ktorých je múr. Postupne načítavame vstup a po pridaní každého kúska múru spustíme prehľadávanie od okrajov mapy. Označíme/navštívime tak všetky políčka zaliate vodou. Spočítame si počet zaliatych políčok $z$ a výstup programu, počet chránených políčok, bude: $w \\cdot h - z$.

Pri každom prehľadávaní navštívime každé políčko mapy najviac raz, teda časová zložitosť jedného prehľadávania bude $O(w \\cdot h)$. Prehľadávanie púšťame po načítaní každého z $n$ múrov, teda celková časová zložitosť bude $O(n \\cdot w \\cdot h)$.

Mierne zlepšenia^[Ktoré nezmenia asymptotickú časovú zložitosť pre všeobecný prípad.] môžu byť napríklad:

- spúšťať prehľadávanie len ak sú okolo múru iné múry -- len vtedy vieme uzavrieť nejakú oblasť ochranným múrom
- spúšťať prehľadávanie len ak uzavrieme súvislý komponent múrov
- spúšťať prehľadávanie od miesta, kde sme postavili múr -- ak nájdeme okraj, táto časť prehľadávala územie nechránené pred vodou. Ak okraj nenájdeme, prehľadali sme územie ochránené pred vodou.
- \\dots

Takýmto spôsobom sa na testovači dalo získať až 5 bodov.

## Vzorové riešenie

Na predošlom riešení si môžeme všimnúť, že robíme tú istú prácu stále odznova. Políčka zaliate vodou prehľadávame v každom kroku. Aby sme dosiahli lepšiu časovú zložitosť, nemôžeme si dovoliť prehľadávať celú mapu veľakrát. Chceli by sme teda vedieť použiť údaje z minulosti.

Ale ako? Keď uzavrieme múr -- ochránime územie vnútri. Chceli by sme vedieť, aké je toto územie veľké. Po predošlom prehľadávaní je ale vonkajšok aj vnútro múru označené ako voda, čo nám vôbec nepomôže.

Čo ak by sme to robili odzadu? Čo ak by sme múry namiesto pridávania odoberali? Územie vonku múru môže byť označené ako VODA, územie vnútri ako CHRANENE. Ak odstránime stenu, vieme spustiť prehľadávanie na políčkach označených ako CHRANENE a spočítať, koľko políčok bolo vnútri -- koľko ich bude zaliatych vodou. Nevieme teda múr stavať, ale vieme ho rýchlo búrať.

Presne toto aj urobíme. Vyriešime úlohu odzadu. Presnejšie, načítame celý vstup, vypočítame všetky riadky riešenia a vypíšeme ich v opačnom poradí, ako sme ich počítali.

Opäť budeme mať dvojrozmernú mapu a na nej bude každé políčko buď STENA, VODA alebo CHRANENE.

Všetky políčka mapy najprv nastavíme ako CHRANENE. Načítame si celý vstup a do mapy zaznačíme všetky STENY.

Pomocou jedného prehľadávania od okrajov mapy potom zaplavíme všetko územie, ktoré sa dá, VODOU. Prehľadávanie navštívi všetky zaplavené políčka, a tak prvá odpoveď (posledná vypísaná.) bude $w \\cdot h - zaplavene$.

Následne spracúvame vstup odzadu. Odstránime stenu^[Najskôr ale skúste povedať váš tip: kto je za stenou? Priateľ z detstva? Bývalá láska? Niekto komu ste pomohli? Odstránime stenu?] a pokiaľ stena susedila s vodou, spustíme prehľadávanie z tohto miesta po políčkach CHRANENE. Zaplavíme tak všetko územie, ktoré bolo doteraz vnútri múru.

Odpoveď v každom kroku je $w \\cdot h - zaplavene$. Ak stena nesusedila s vodou, zostane odpoveď rovnaká ako v predošlom kroku, lebo veľkosť zaplaveného územia sa vtedy nezmení. Výstupy vypíšeme v opačnom poradí ako sme ich vypočítali.

V tomto algoritme každé políčko mapy navštívime prehľadávaním práve raz^[Na konci algoritmu je mapa prázdna -- každé políčko je VODA.] a tak je jeho časová zložitosť len $O(w \\cdot h)$.

Úloha sa dá naprogramovať aj trocha jednoduchšie, tu môžete vidieť stručnejšiu implementáciu algoritmu.
",9
61084b7357de82d3,ksp,"# Polovica párna

Za posledné obdobie mal Kúl Spolok Pandemiológov naozaj kopu práce. Popri bežných povinnostiach zvládali rozbehnúť nový výskum zameraný na boj s vírusmi. Po niekoľkých mesiacoch tvrdej driny sa dostavili veľmi dobré výsledky. Vytvorili metódu, podľa ktorej dokážu na vírus jednoducho vytvoriť spoľahlivú vakcínu, a tak ho zneškodniť. Spôsob je veľmi jednoduchý. Každý vírus má svoje charakteristické číslo $n$. Na to, aby našli vakcínu k danému vírusu stačí nájsť $n$ takých prirodzených čísel, že prvých $n/2$ čísel je parných a druhých $n/2$ nepárnych. Zároveň musí platiť, že súčet prvej polovice je rovný súčtu druhej polovice. Kým ale celý KSP odišiel na konferecie prezentovať tento úžasný vynález, tebe nechali na starosť kopu vírusov, na ktoré máš nájsť vakcínu...

## Úloha

KSP ti nechalo $t$ vírusov, a ty máš pre každý z nich povedať či naň existuje vakcína. Ak existuje, tak takú nejakú vakcínu máš vypísať. Pre všetky čísla $n_i$, pre ktoré existuje vakcína máš vypísať presne $n_i$ medzerou oddelených čísel takých, že súčet prvej polovice čísel sa rovná súčtu druhej polovice. Všetky čísla musia byť unikátne a všetky čísla v prvej polovici musia byť párne a v druhej nepárne. Takýchto možností je samozrejme veľa a môžete vypísať ľubovoľnú z nich.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $t$, ($t \\leq 100$), ktoré označuje počet vírusov. Nasleduje $t$ riadkov, na každom je práve jedno párne číslo $n_i$, ($n_i \\leq 10,000$), ktoré označuje vírus.

## Formát výstupu

Pre každé $n_i$ na samostatný riadok vypíšte ""ano"" alebo ""nie"", podľa toho či sa dá urobiť pole dĺžky $n_i$ také, že spĺňa podmienky zo zadania. V prípade ak vypíšete ""ano"", na nový riadok vypíšte aj toto pole. Teda, vypíšete $n_i$ medzerou oddelených čísel $a\_{i,j}$. Dodržte aby $0 < a\_{i,j} < 1,000,000$, a každé číslo bolo unikátne (nachádzalo sa v Tebou vypísanej postupnosti čísel len raz).

## Príklad

```vstup
5
10
2
4
8
6
```

```vystup
nie
nie
ano
2 4 1 5
ano
2 6 4 8 5 3 1 11 
nie
```

*Samozrejme, toto nie sú jediné možnosti, ktoré mohli byť vypísané za ""ano"". Napríklad za prvým ""ano"" rovnako mohlo byť aj ""6 10 11 5"", alebo ""4 2 5 1"".*
","#Polovica párna

Poďme si najprv povedať, kedy a prečo vieme, resp. nevieme na danú vakcínu nájsť vírus. Prečo by sa vlastne taký vírus nemal dať urobiť? Veď vieme predsa na obe strany dať (takmer) ľubovolné čísla, nie? V sampli ale poľahky nájdeme nejaké prípady, ktoré spája to, že sa na daný vírus nedá nájsť vakcína. Čo majú spoločné?

Aby sme na to prišli, tak musíme použiť trošku matematiky. Totiž, nech sčítame akýkoľvek počet párnych čísel, výsledok bude vždy párny. Pri nepárnych číslach záleží na počte sčítavaných čísel. Ak sčítame nepárny počet nepárnych čísel, výsledok bude nepárny (napr. $3+3+3 = 9$), ale ak sčítame párny počet nepárnych čísel, tak výsledok bude párny ($3+3 = 6$).

Z toho vyplýva, že ak dostaneme úlohu vypísať nepárny počet párnych čísel, a nepárny počet nepárnych čísel tak, aby sa ich súčet rovnal, tak sa to nedá. Pretože, kým súčet párnych bude vždy párny, súčet nepárnych bude nepárny (lebo ich je nepárny počet). Takto sme našli prípad, kedy sa vakcína na vírus nedá nájsť. Čo ale ostatné prípady? Ak máme vypísať párny počet párnych a párny počet nepárnych čísel, tak sú súčty oboch častí párne, a nie je nič, čo by nám bránilo vytvoriť dve skupiny s rovnakým súčtom.

Teraz, keď už vieme, kedy sa to dá, a kedy nie, je riešenie úlohy jednoduché. Ak sa to nedá, teda ak $n/2$ je nepárne, tak vypíšeme ""nie"".

Vo všetkých ostatných prípadoch vypíšeme ""ano"", a vypíšeme takú postupnosť čísel, ktorá spĺňa podmienky zo zadania. Napríklad začneme postupne vypisovať párne čísla, presne toľko, koľko treba ($n/2$), a počítame si ich súčet. Potom vypíšeme o jedno nepárne menej ($n/2 - 1$), ako treba (zase si počítame súčet), a na koniec vypíšeme také číslo, koľko je rozdiel súčtov (prečo bude nepárne sme si povedali v prvom odstavci).

Vzorový kód si nepočíta súčty, ale robí to trochu trikovejšie, a to tak, že ak je prvé párne $2$, a prvé nepárne $1$, tak s každou dvojicou (jedným párnym, jednám nepárnym) sa zvýši rozdiel medzi súčtami o $1$.
",1
f6f5ae337c2cc3e8,ksp,"﻿# Cypriánove záhyby

Viki nosí rôzne kusy oblečenia, ktoré majú veľa záhybov. A na čo sú dobré záhyby? Tam sa predsa plošticiam dobre schováva. Ploštica Cyprián takto raz naskočil na Viki a prešiel dokola po celom jej Kabáte, aby našiel všetky záhyby. Cyprián je iba ploštica, takže nevníma tretí rozmer a svoju trasu si vie zakresliť na papier. Ciprián navyše ide stále dopredu, až kým sa nevráti na pôvodné miesto. Zvládne si prí tom zapisovať iba to, aké kroky robí. Teda, či ide rovno, alebo sa otáča doprava, alebo doľava. Teraz by potreboval vašu pomoc, aby zistil, koľko miesta je v záhyboch.

## Úloha

Na vstupe dostanete popis Cypriánovej trasy. Táto trasa sa nikde nepretína (nekrižuje samú seba) a končí tam, kde začala. Vašou úlohou je zistiť, koľko miesta je v záhyboch. Záhyb je každá obdĺžniková oblasť, ktorá je aspoň z dvoch _protiľahlých_ strán ohraničená trasou (teda napríklad hore a aj dole).

Na nasledovnom obrázku sú miesta v záhyboch vyznačené sivou.

## Formát vstupu

Na jedinom riadku vstupu sa nachádza reťazec písmen `R` `L` `P` ktoré postupne znamenajú `rovno`, `doľava`, `doprava`.

Dĺžka reťazca nepresiahne $10^5$. Ak si počiatočnú pozíciu označíme ako $(0,0)$ tak súradnice bodov na trase v absolútnej hodnote nepresiahnu $3,000$. V reťazci sa nikdy nanachádzajú za sebou dve otočenia (teda `L` alebo `P`).

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo -- celkovú plochu záhybov.

## Príklady

```vstup
RRRPRRRPRRRPRRRP
```

```vystup
0
```

*Trasa na vstupe vyzerá ako štvorec.*

```vstup
RRRRRRPRRRRPRRPRRLRRLRRRPRRPRRRRR
```

```vystup
4
```
","# Cypriánove záhyby

Na vyriešenie tejto úlohy bolo potrebné zistiť, kolko štvorčekov sa nachádza ""v záhyboch"". Existuje na to viacero spôsobov. Jeden z nich je zistiť obsah útvaru na vstupe, potom ho akosi obaliť z vonka, zistiť obsah vrátane záhybov a vypísať ich rozdiel. My si ale ukážeme implementačne jednoduchšie riešenie.

## Vstup

Prvá vec, ktorú musíme spraviť asi pri ľubovolnom riešení tejto úlohy, je rozumne načítať vstup. Potrebujeme nejakým spôsobom preložiť reťazec na čísla, teda súradnice. Dobrý spôsob je začať na súradniciach `5000, 5000`, aby bolo všetko kladné, a potom si len pamätať aktuálnu pozíciu a smer, a podla vstupu updatovať a ukladať.

## Hladanie záhybov

Aby sme si úlohu zjednodušili, predstavme si, že políčko je v záhybe, iba ak je ohraničené z hora a z dola. S takouto zmenou môžeme potom vstup spracovať po stĺpcoch, nezávysle na sebe. V každom stĺpci si zoradíme horizontálne pohyby od hora dole a následne iba prejdeme tento zoznam. Prvý pohyb znamená vonkajšiu hranicu, teda začína ohraničenú oblasť. Druhý prechod musí teda ukončovať ohraničenú oblasť, čiže začína záhyb. Tretí zase ukončuje záhyb a tak ďalej až po posledný. Prechodov je určite párny počet, lebo rovnako veľa smeruje doprava, ako do ľava. Každá ohraničená oblasť je teda aj z dola uzavretá.

Takýmto spôsobom vieme identifikovať políčka, ktoré sú vertikálnym smerom v záhyboch. Ak rovnaký postup zopakujeme po riadkoch, nájdeme všetky políčka v záhyboch.

## Opakujúce sa políčka

Jediný problém tohoto riešenia je, že niektoré políčka zarátame dvojmo - aj pre riadok, aj pre stĺpec. Vzhľadom na veľkosť vstupu toto môžeme vyriešiť jednoducho tak, že si jednotlivé políčka (ich súradníce), vložíme do setu a už len vypíšeme veľkosť tohoto setu. V prípade jazykov, ktoré rýchlo pracujú s poľami, stačí tieto súradnice vyznačovať v dvojrozmernom poli a na konci spočítať.

## Časová a pamäťová zložitosť

Dĺžka vstupného reťazca $n$ nám v tomto prípade až tak veľa nehovorí, no pri najmenšom ho musíme načítať. Zadanie nám však dáva oveľa menšie ohraničenie, a to na veľkosť súradníc $m$. Do celkovej časovej zložitosti teda započítame $O(n)$ za načítanie vstupu a pri najhoršom $O(m^2)$ za prechádzanie mriežky po riadkoch a stĺpcoch. Spolu je to teda $O(n+m^2)$ za predpokladu, že ak použijeme set, tak je to hash-set a predpokladáme, že má konštantné operácie.

Pamäťovú zložitosť môžeme odhadnúť rovnako, pretože si ukladáme pretransformovaný vstup, ktorý je v princípe rovnako veľký ako pôvodný a tiež si ukladáme všetky políčka, ktoré sú v záhyboch, čo je najviac $O(m^2)$.
",9
e768787e0df711fd,ksp,"# Extrémny smrad

Za niekoľko desaťročí jeho existencie prišli do Kolosea stovky miliónov divákov. Múry Kolosea tento nápor znášajú veľmi dobre -- stoja rovnako pevné a majestátne, ako keď bolo Koloseum nové. Horšie je to s čalúnenými sedačkami. Tie sú už nechutne špinavé a mnohé z nich aj nepríjemne páchnu.

Predavač lístkov Mikix si všimol, že ľudia uprednostňujú miesta, kde je menší smrad. Preto sa Mikix rozhodol, že smrad na jednotlivých miestach zohľadní v cene lístkov.

## Úloha

Sektor, v ktorom Mikix predáva lístky, má tvar štvorca s $n$ radmi po $n$ sedadiel. Každé sedadlo páchne s nejakou intenzitou, ktorú budeme v tejto úlohe reprezentovať celým číslom (čím väčšie číslo, tým väčší smrad). To, aký silný zápach cítime, keď na sedadle sedíme, však závisí aj od okolitých sedadiel. Konkrétne, vždy cítime najsmradľavejšie sedadlo vo štvorci $k \\times k$ sedadiel so stredom^[číslo $k$ je nepárne] v sedadle, na ktorom sedíme.

Mikix chce pre každé sedadlo vo svojom sektore určiť, aký silný smrad je na danom mieste cítiť. Pre každé sedadlo $S$ teda zistite intenzitu zápachu najsmradľavejšieho sedadla vo štvorci $k \\times k$ okolo sedadla $S$.

## Formát vstupu

Na prvom riadku sa nachádzajú dve kladné celé čísla $n$ a $k$ oddelené medzerou, označujúce veľkosť sektora a veľkosť okolia, v ktorom je cítiť zápach. Číslo $k$ je pritom nepárne. Nasleduje $n$ riadkov a v nich $n$ medzerami oddelených celých čísel $0 \\leq a\_{i,j} \\leq 10^9$ -- intenzity zápachu jednotlivých sedadiel.

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:------:|:------:| | $n,k \\leq$ | $40$ | $100$ | $400$ | $1,000$ |

## Formát výstupu

Vypíšte $n$ riadkov a v každom z nich $n$ čísel oddelených medzerami. V $i$-tom riadku ako $j$-te číslo vypíšte intenzitu zápachu najsmradľavejšieho sedadla, ktoré je cítiť zo sedadla $(i,j)$.

## Príklady

```vstup
3 1
1 2 3
4 5 6
7 8 9
```

```vystup
1 2 3
4 5 6
7 8 9
```

_Cítime iba sedadlo, na ktorom sedíme._

```vstup
3 3
1 2 3
4 5 6
7 8 9
```

```vystup
5 6 6
8 9 9
8 9 9
```

_Teraz cítime už aj bezprostredne okolité sedadlá._
","# Extrémny smrad

Našou úlohou bolo pre každú stoličku určiť silu zápachu aký je cítiť, keď si na ňu sadneme. Matematicky preložené: pre každé políčko v štvorci zo vstupu sme mali nájsť najväčšie číslo nachádzajúce sa v štvorci $k\\times k$ so stredom v danom políčku

## Priamočiare riešenie

Urobíme presne to, čo sa od nás žiada. Pre každé políčko prejdeme všetky políčka v okolí $k\\times k$. A vyberieme to najväčšie a to si zapamätáme. Takéto riešenie bude mať časovú zložitosť $O(n^2 k^2)$, keďže pre každé z $n^2$ políčok sme museli skontrolovať celé okolie $k\\times k$.

Toto riešenie nie je optimálne, keďže sa na rovnaké políčka zo vstupu pozeráme strašne veľa ráz, poďme sa ale najprv pozrieť na jednoduchšiu verziu úlohy.

## Jednorozmerná verzia

Čo ak by sme na vstupe dostali len jeden dlhý riadok a hľadali by sme najväčšie číslo v okolí $k$ políčok?

Jedným z riešení je postupne prechádzať pole zľava doprava, pričom vo vhodnej dátovej štruktúre si budeme stále pamätať posledných $k$ prvkov, ktoré sme videli. V každom kroku do štruktúry pridáme ďalší prvok, vyhodíme najstarší prvok (ktorý je už mimo okolia) a zapíšeme maximum z prvkov, ktoré máme v štruktúre.

Potrebujeme teda nejakú dátovú štruktúru, kde si budeme uchovávať posledných $k$ prvkov a budeme vedieť povedať maximum z nej a robiť operáciu pridania prvku a odobratia najstaršieho prvku. Taká dátová štruktúra, ktorá vie odoberať najstarší prvok a pridávať nový prvok je napríklad fronta. Vo fronte máme prvky vždy zoradené podľa času, kedy prišli. Problém je ale s nájdením maxima.

Všimnime si však, že si nemusíme vždy pamätať všetky z posledných $k$ prvkov. Zaujíma nás totiž iba maximum z ukladaných prvkov, teda ak vieme, že niektorý prvok už určite nebude maximum v žiadnej $k$-tici, môžeme ho z fronty vymazať. Napríklad keď pridávame prvok do fronty, tak môžeme všetky menšie prvky z fronty vymazať, keďže ich z fronty vyhodíme skôr (sú staršie) a sú menšie, teda nikdy nebudú maximom.

Čo nám to pomôže? Ak budeme dôsledne vyhadzovať z fronty všetky prvky, ktoré sú menšie, než ten práve pridávaný, bude mať naša fronta zaujímavú vlastnosť: jej prvky budú zoradené podľa veľkosti zostupne. Ak je totiž prvok $A$ vo fronte pred prvkom $B$, znamená to, že $A$ je vo fronte dlhšie. To ale znamená, že $A$ ,,prežil'' pridávanie prvku $B$, teda určite nie je menší ako $B$.

Keďže prvky sú zoradené zostupne, vieme ľahko nájsť maximum (je to prvý prvok). Keď pridávame nový prvok, potrebujeme nájsť (a vyhodiť) všetky prvky, ktoré sú menšie. Tieto prvky budú na konci fronty (lebo čísla vo fronte sú zoradené zostupne), teda ich ľahko nájdeme a budú sa aj ľahko vyhadzovať.

Okrem toho ešte potrebujeme v každom kroku vyhodiť prvok, ktorý sme pridali pred $k$ krokmi (ak tam ešte stále je). Ak je tento prvok stále vo fronte, musí to byť najstarší prvok fronty, a teda je určite na začiatku fronty.

S našou frontou teda budeme robiť nasledovné operácie:

- Čítanie z konca fronty a vyhadzovanie prvkov z konca fronty (keď vyhadzujeme z fronty všetky čísla menšie než prvok, ktorý sa chystáme pridať).
- Pridávanie prvkov na koniec fronty (keď pridávame nový prvok z poľa do fronty).
- Čítanie prvkov zo začiatku fronty (keď zisťujeme maximum prvkov vo fronte).
- Kontrolovanie a mazanie prvkov zo začiatku fronty (keď vyhadzujeme príliš staré prvky).

Obyčajná fronta ale nepodporuje mazanie z konca fronty, preto budeme musieť použiť obojsmernú frontu (v C++ `deque`). Tá dokáže robiť všetky spomínané operácie v konštantnom čase.

### Zložitosť

Môže sa nám stať, že ak chceme pridať nejaký prvok, musíme zmazať celú frontu (lebo všetky prvky vo fronte sú menšie), čo môže byť až $k$ prvkov. Jeden krok algoritmu teda môže trvať až $\\Theta(k)$ času a takýchto krokov robíme $O(n)$, teda celý algoritmus má časovú zložitosť $O(n k)$.

Časová zložitosť nášho algoritmu sa však dá odhadnúť aj tesnejšie. Ak sa pozrieme na algoritmus ako celok, vidíme, že každý prvok pridáme do fronty maximálne raz a maximálne raz ho odtiaľ aj vyhodíme. Všetky vyhadzovania dokopy nám teda zaberú iba $O(n)$ času (aj keď niektoré z nich môžu byť pomalé), teda časová zložitosť celého algoritmu je $O(n)$.

## Dvojrozmerná verzia

Teraz sme už iba krok od riešenia. Predstavme si, že pre každý riadok vyriešime 1D verziu. Teraz máme na každom políčko najväčšie číslo v okolí $1\\times k$. Predstavme si, že teraz na tomto upravenom poli budeme zase riešiť 1D úlohu ale tentokrát po stĺpcoch. Takto nájdeme vlastne maximum z $k$ obdĺžnikov veľkosti $1\\times k$ pod sebou, čo je vlastne maximum zo štvorca $k\\times k$, presne ako sme chceli. Teda celková časová zložitosť je $O(n^2)$ keďže sme vyriešili 1D úlohu na všetkých $n$ riadkoch a potom $n$ stĺpcoch. Pamäťová zložitosť bude tiež $O(n^2)$ keďže si musíme pamätať celý pôvodný sektor s hodnotami smradu.
",8
d72124dfa05ab7fa,ksp,"# Ako Marianka blúdila

Predstavte si dom. Velikánsky dom na kopci s ešte väčšou záhradou. Skoro až taký zámok. No, tak presne v takom dome býva Samo. Tento dom má veľa izieb a rôznych pozoruhodností vnútri aj vonku. Jednou z nich je napríklad obrovské bludisko zo živého plotu v záhrade.

Možno to znie ako z rozprávky, veľký dom, záhrada; čiže veľa zábavy. Ale Samo je jedináčik, jeho rodičia šli na týždeň na dovolenku a on ostal doma úplne sám. To už nie je taká zábava. Tak si jedného dňa pozval Marianku na návštevu.

Tú, hneď ako prišla, očarilo bludisko v záhrade. Chcela ho vyskúšať, no bála sa, že sa stratí a už sa odtiaľ nedostane. Samo jej povedal, že aj keby chodila uplne náhodne, dostane sa von v konečnom čase. To ju síce veľmi neohúrilo, no hneď nato jej navrhol, nech si vždy zapíše ktorým smerom spravila krok. Keď potom bludisko prejde, môžu si spolu z tohoto popisu zostrojiť mapku a spočítať, kolko krát Marianka spravila zlé rozhodnutie (teda išla jedným smerom, ale kratšie by to mala iným).

Marianka sa nakoniec predsalen odhodlá a vydá sa do bludiska s tým, že si bude zapisovať svoju cestu na papier. Prešiel nejaký čas, Marianka bola vonku z bludiska a spolu so Samom objavujú ďalšie pozoruhodnosti Samovho domu. Na papier s Mariankinou trasou z bludiska zabudli. Ale vás ako zvedavých čitateľov tohto príbehu zaujíma, koľkokrát Marianka v bludisku zle odbočila.

## Úloha

Na vstupe dostanete popis Mariankinej cesty bludiskom. Celú mapu bludiska ale nepoznáme. O dvoch políčkach vieme že sú priechodné teda iba vtedy, ak tade Marianka niekedy prešla. Teda aj ak sú susedné, môže medzi nimi ešte byť živý plot. Vašou úlohou je na základe tohoto popisu povedať, koľkokrát Marianka zle odbočila. To znamená, koľkokrát spravila taký krok, že iným smerom by to mala bližšie do cieľa. Ak teda počas cesty napríklad prechádza cieľom, prvý krok smerom od cieľa nepovažujeme za zlý, nakoľko žiadnym iným smerom by sa ku cieľu tiež nepriblížila.

## Formát vstupu

Na prvom riadku vstupu je jedno číslo $n$ ($1\<n\<10^5$) -- počet Mariankiných krokov v bludisku. Nasleduje $n$ riadkov, kde na $i$--tom riadku sú súradnice $x_i$ a $y_i$ ($-10^5\<x_i, y_i\<10^5$), označujúce bod, na ktorý sa Marianka posunula. Pre každé po sebe idúce súradnice platí, že sa líšia v práve jednej súradnici o 1 (teda krok je jedným zo 4 smerov).

Prvé súradnice sú vždy $(0,0)$ a posledné súradnice značia cieľ.

## Formát výstupu

Vypíšte jedno celé číslo -- počet miest, na ktorých Marianka zle odbočila.

## Príklad

```vstup
7
0 0
0 1
0 2
0 1
0 0
0 -1
-1 -1
```

```vystup
2
```

Prvé dva Mariankine kroky išli zlým smerom, no potom už išla priamo do cieľa.

```vstup
7
0 0
-1 0
-2 0
-2 1
-1 1
-1 0
-1 -1
```

```vystup
2
```

Marianka spravila koliečko. 3. a 4. krok išli zlým smerom -- bližšie by bolo ísť naspäť.
","# Ako Marianka blúdila

Cestu, ktorou Marianka prechádza, si môžeme predstaviť ako graf. Políčka sú vrcholy a hrana je medzi nimi práve vtedy, ak medzi nimi Marianka niekedy prešla. Formát vstupu je na grafy pomerne nezvyčajný, ale stačí si uvedomiť, že táto cesta je len akýsi zoznam hrán ktoré sa môžu opakovať. Aby sa nám lepšie pracovalo, graf si potrebujeme uložiť ako zoznam susedov. Ak na to použijeme mapu, nemusíme sa ani trápiť nejakým očíslovaním vrcholov ale môžeme si ich pamätať rovno podľa súradníc.

Teraz ešte potrebujeme zistiť, ako ďaleko je ktorý vrchol od cieľa, aby sme vedeli povedať, či išla Marianka správnym smerom. Na to nám poslúži štandardné [prehľadávanie do šírky](https://www.ksp.sk/kucharka/bfs/).

Ako posledný krok už len prejdeme cestu tak, ako bola na vstupe a pre každý krok zistíme, či bol správnym smerom, teda či vzdialenosť od ciela je pre nasledujúce políčko najmenšia z pomedzi susedných políčok.

## Časová a pamäťová zložitosť

Veľmi ľahko môžeme nahliadnuť, že jediný netriviálny cyklus v tomto riešení je BFS, o ktorom však vieme že má lineárnu zložitosť, teda aj celková časová zložitosť je $O(n)$ od počtu krokov na vstupe. Pamäťová zložitosť je tiež $O(n)$, pretože si potrebujeme pamätať celý vstup, a ukladáme si ho efektívne.
",6
2256e22fccf6063c,ksp,"﻿# Organizácia Kapustnice

Ako každý rok, aj teraz sa konala KSP kapustnica. Paulinka sa rozhodla, že ku každému správnemu vianočnému posedeniu patria torty a nejaké preto upiekla, doniesla a rozložila na stôl.

Torty sú servírované na jednom dlhom stole a vedúci sa pre ne zoradili do radu. Každý vedúci sa hýbe v rade zľava doprava, kým sa nedostane k voľnej torte, potom si vezme tortu a odíde z radu zjesť tortu.

Paulinka si ale všimla, že nenapiekla správny počet toriet. Chcela by pridať nejaké torty, a/alebo zavolať pár vedúcich zo Suši, nech si tiež dajú torty. Chcela by to ale urobiť čo najrýchlejšie, nech aj ona si môže užívať kapustnicu. Pomôžte jej!

## Úloha

Vedúci a torty si vieme predstaviť ako reťazec z písmen ""V"" -- reprezentujúcich vedúcich v rade, a ""T"" -- reprezentujúcich torty na stole. Pre jednoduchosť, nemôže sa stať, že je torta a vedúci na rovnakom mieste.

Vedúci zje najbližšiu nezjedenú tortu napravo od neho (napr. ak je na pozícii 5, potom vie zjesť torty na pozíciách od 6 vyššie) -- pokiaľ ju už niekto pred ním nezjedol.

Paulinka by chcela pridať na stôl (medzi existujúce torty a vedúcich) niekoľko ďalších tort (čo najmenej) a/alebo zavolať nejakých Suši vedúcich (čo najmenej) -- na *hocijaké* miesto v rade tak, aby každý vedúci skončil s presne jednou tortou.

Vypíšte, ako torty, resp. nových vedúcich zaradiť do radu - teda zistite, ako by mohla vyzerať situácia, aby pridaných toriet+vedúcich bolo spolu čo najmenej.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($1 \\leq n \\leq 10^6$) udávajúce dĺžku reťazca na vstupe (počet vedúcich plus počet tort).

V druhom riadku vstupu sa nachádza reťazec z písmen ""V"" a ""T"" reprezentujúci počiatočnú situáciu pri stole.

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|---------:|---------:|---------:| | $1 \\leq n \\leq$ | $1000$ | $10^6$ | $1000$ | $10^6$ |

V prvých dvoch sadách navyše stačí, aby tvoj program vrátil *ľubovoľné* správne riešenie, počet pridaných toriet a vedúcich nemusí byť nutne najmenší.

## Formát výstupu

Vypíš jeden riadok a v ňom reťazec z písmen ""V"" a ""T"" reprezentujúci, ako by mala Paulinka upraviť situáciu, aby každý dostal *práve jednu* tortu.

## Príklady

```vstup
5
VTVTT
```

```vystup
VTVTVT
```

*Stačí pridať jedného vedúceho, ktorý zje tortu navyše. Ďalšie správne riešenie je napríklad VVTVTT*

```vstup
6
TVVVTT
```

```vystup
VTVTVVTT
```
","# Organizácia Kapustnice

## Ľubovoľné správne riešenie

Pozrime sa najskôr na prípad, že nám netreba minimalizovať počet pridaných tort a vedúcich, ale stačí nám ľubovoľné správne riešenie. Všimnime si, že nezáleží, ako ďaleko sa vedúci pohne, aby získal tortu, ale stačí, aby nejakú získal. Taktiež, všetky torty sú rovnaké, takže nezáleží na tom, ktorú tortu zje ktorý vedúci.

Jednoduché riešenie je napríklad nasledovné: ku každému vedúcemu dáme tortu a ku každej torte dáme vedúceho (bez ohľadu na to, či by tá torta mohla byť zjedená v originálnom rozostavení, resp. či by ten vedúci nejakú tortu mohol v originálnom rozostavení zjesť). Toto riešenie vieme naprogramovať v čase $O(n)$ s konštantnou pamäťou (stačí si nám pamätať, či je práve na rade vedúci alebo torta).

Všetky takéto riešenia budú mať tvar `VTVTVT...` -- môžeme vidieť, že každý vedúci zje presne jednu tortu a každá torta bude zjedená.

## Vzorové riešenie

Predchádzajúce riešenie je jednoduché, ale vždy pridáva $n$ nových tort a vedúcich, a to aj vtedy, keď to netreba. Ako to zlepšiť?

Základná myšlienka je dať pred tortu vedúceho len vtedy, ak by táto torta ostala nezjedená, a dať vedúcemu tortu len vtedy, ak by žiadnu v originálnom rozostavení nedostal.

Skúsme nasimulovať, čo by sa stalo pri originálnom rozostavení vedúcich a tort. Predstavme si, že postupne prechádzame stôl zľava doprava a udržiavame si premenné $dv$ -- ""doterajší počet vedúcich"" a $dt$ -- ""doterajší počet tort"".

Ako prvé si všimnime, že ak $dv>=dt$, potom každá torta je zjedená. Hodnota $dv-dt$ udáva počet ešte nenajedených vedúcich (do danej pozície na stole) (vždy, keď príde torta, počet nenajedených vedúcich sa zníži, vždy, keď príde vedúci, počet nenajedených vedúcich sa zvýši).

Podobne, ak máme také rozostavenie tort a vedúcich, že každá torta bude zjedená, tak vždy bude platiť $dv>=dt$ (ak máme pred nejakou pozíciou viac tort ako vedúcich, všetky torty pochopiteľne nemôžu byť zjedené).

Poďme najskôr pridať vedúcich. Všimnime si, že ak pridáme $v$ vedúcich na začiatok, potom sa počet nenajedených vedúcich (na každej pozícii) zvýši o $v$.

Počet nezjedených tort na nejakej pozícii vieme vyrátať ako $dt-dv$. Nech najväčšia hodnota, ktorú $dt-dv$ v nejakom bode nadobudne, je $nt$. To znamená, že musíme pridať určite aspoň $nt$ vedúcich, aby nám nikdy neostali nezjedené torty. Vieme ich všetkých napríklad pridať na začiatok. Potom bude počet nezjedených tort všade zmenšený o $nt$ a teda nikdy nám neostanú nezjedené torty. Ak by sme pridali menej než $nt$ vedúcich, v nejakom bode by nám ostali nezjedené torty, preto toto je najlepšie, čo vieme spraviť.

Čo s tortami? Všimnime si, že ak nám nikdy neostanú nezjedené torty, hodnota $dv-dt$ po prejdení celého vstupu je presne počet vedúcich, ktorí nedostali tortu. Nazvime túto hodnotu $nv$. Tá nám vlastne hovorí, o koľko je pri stole viac vedúcich ako tort. Očividne musíme pridať aspoň $nv$ tort -- ak by sme pridali menej, potom by pri stole bolo menej tort ako vedúcich, takže určite nebudú všetci vedúci najedení. Taktiež si všimnime, že nám stačí pridať všetkých $nv$ tort na koniec stola. Takto sa k nim všetci zostávajúci nenajedení vedúci určite dostanú.

Takže si to zhrňme: prejdeme postupne stôl a počítame si, koľko vedúcich a tort sme zatiaľ videli. Zapamätáme si, akú najväčší počet nezjedených toriet ($dt-dv$) sme videli. Ak je tento počet kladný, pridáme taký počet vedúcich na začiatok. Následne sa pozrieme, koľko nenajedených vedúcich ($dv-dt$) nám na konci ostalo, a pridáme k tomu počet pridaných vedúcich ($nt$). Toto číslo nám povie, koľko tort treba pridať na koniec. Časová aj pamäťová zložitosť je $O(n)$, keďže raz prejdeme vstupom, a potrebujeme si ho pamätať, aby sme mohli vypísať výstup.
",2
1f010f28f586c268,ksp,"﻿# Všetkých nás nezastavia!

Všetci vieme, že mimozemštania existujú. Dokonca už aj navštívili Zem. Presnejšie povedané, havarovali do nej. Toto miesto je bežne známe ako [Area 51](https://en.wikipedia.org/wiki/Area_51). Žiaľ, mimozemštanov sa zmocnilo americké letectvo. Oni si ale zaslúžia byť voľní! Poďme ich zachrániť!

Dvojičky Matty a Robrets pomocou [eventu na Facebooku](https://en.wikipedia.org/wiki/Storm_Area_51,_They_Can't_Stop_All_of_Us) zohnali milióny ochotných ľudí. Ich tímu sa už podarilo preniknúť do tajnej americkej základne, stačí im už len odtiaľ vyniesť mimozemšťanov. Každý človek unesie maximálne dvoch mimozemštanov -- jedného v každej ruke. Ale s mimozemšťanom pod pazuchou sa ťažšie beží. Mimozemštanov preto potrebujú rozdeliť tak, aby ten, čo bude niesť najväčšiu záťaž, toho niesol čo najmenej. Preniknutie do základne bolo veľmi náročné, a počítať sa im už nechce. Preto im musíte pomôcť vy!

## Úloha

V Area 51 je $m$ mimozemšťanov. Na to, aby sme ich zachránili, máme $n$ ľudí. Každý človek unesie maximálne dvoch mimozemšťanov. Každý mimozemšťan má nejakú konkrétnu hmotnosť $H_i$ udanú v miligramoch.

Mimozemšťanov musíme rozdeliť medzi jednotlivých ľuďí tak, aby maximálna hmotnosť ktorú má niektorý človek niesť, bola najmenšia možná.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $m$ ($1\\leq m\\leq 2n\\leq 200,000$) udávajúce počet ľudí a mimozemšťanov.

V druhom riadku je $m$ čísiel $H_i$ ($1\\leq H_i\\leq 1,000,000,000$) udávajúcich hmotnosti mimozemšťanov v miligramoch.

## Formát výstupu

Pre každého z $n$ ľudí vypíšte jeden riadok obsahujúci dve čísla -- hmotnosti mimozemšťanov v jednotlivých rukách. Ak má človek niektorú ruku prázdnu, vypíšte hmotnosť 0.

*Môžete vypísať ľubovoľné správne riešenie.*

## Príklady

```vstup
3 4
5 1 6 7
```

```vystup
7 0
0 6
1 5
```

_Najťažší náklad nesie prvý človek, a to $7mg$_

```vstup
3 6
1 2 2 3 3 4
```

```vystup
2 3
4 1
3 2
```

_Všetci nesú rovnakú hmotnosť, a to $5mg$._
","# Všetkých nás nezastavia!

Najprv sa zamyslime nad tým, ako vyriešiť prípad $n=2$, $m=4$, teda pre dvoch ľudí a štyroch mimozemšťanov. Označme si hmotnosti mimozemšťanov $a \\leq b \\leq c \\leq d$. Akými spôsobmi ich môžeme rozdeliť medzi dvoch ľudí? Sú iba tri rôzne možnosti: $a+b$ a $c+d$; $a+c$ a $b+d$; alebo $a+d$ a $b+c$. Všimnite si, že všetky ostatné rozdelenia sú zhodné s jedným z týchto rozdelení.

Rozdelenie $a+b$ a $c+d$ zjavne nie je najlepšie, keďže $c+d$ je väčšie alebo rovné ako každý iný súčet. Stačí nám teda porovnať iba rozdelenie $a+c$ a $b+d$ s rozdelením $a+d$ a $b+c$. V prvej možnosti vidíme, že človek s $b+d$ má najťažší náklad, keďže $b+d \\geq a+c$, lebo $b \\geq a$ a zároveň $d \\geq c$. Ak ale túto hmotnosť porovnáme s tretím rozdelením, zistíme, že tretie rozdelenie je výhodnejšie, keďže $b+d \\geq a+d$ (lebo $b \\geq a$) a zároveň $b+d \\geq b+c$ (lebo $d \\geq c$). Najvýhodnejšie rozdelenie týchto štyroch mimozemšťanov teda je $a+d$ a $b+c$.

Teraz skúsme vyriešiť prípad $n=3, m=6$; označme si hmotnosti mimozemšťanov $a \\leq b \\leq c \\leq d \\leq e \\leq f$. Podobným uvažovaním ako vyššie vieme ukázať, že prvý človek musí niesť hmotnosť $a+f$. Zvyšných mimozemšťanov potom musíme rozdeliť rovnakým postupom ako pre $n=2, m=4$, teda na $b+e$ a $c+d$.

Takto vieme pokračovať a dokázať, že pre ľubovoľné zadanie $m=2n$ musíme mimozemšťanov rozdeliť na najťažšieho s najľahším, druhého najťažšieho s druhým najťažším, tretieho najťažšieho s tretím najľahším, atď.

Ako môžeme toto riešenie zovšeobecniť na ľubovoľné $m \\leq 2n$? Mohli by sme uvažovať nad tým, koľko ľudí bude mať koľko voľných rúk, a priradiť im najťažších mimozemšťanov, a zvyšok vyriešiť ako vyššie. Pri tomto riešení sa ale dá ľahko zabudnúť na prípad $m\<n$. A ako ste sa mnohí sami presvedčili, program ktorý správne rieši iba $m \\geq n$, mohol dostať len 2 body. Oveľa jednoduchšie je predstaviť si, že v každej voľnej ruke je mimozemšťan s hmotnosťou $0$. Všimnite si, že celkovú hmotnosť, ktorú nesie daný človek to neovplyvní, a môžeme potom využiť vyššie popísané riešenie pre $m=2n$.

Výsledný program teda najprv načíta hmotnosti $m$ mimozemšťanov, doplní ich o $2n-m$ mimozemšťanov s hmotnosťou $0$, utriedi podľa hmotnosti, a vypíše pre každého človeka doteraz nepriradeného najťažšieho a najľahšieho mimozemšťana.

## Odhad časovej a pamäťovej zložitosti

Keďže v tomto riešení musíme utriediť mimozemšťanov (vrátane nulových) podľa hmotnosti, časová zložitosť nemôže byť menšia než $O(n \\log n)$, keďže takú zložitosť má triedenie. Pamätáme si pri tom $n$ hmotností mimozemšťanov, teda pamäťová zložitosť je lineárna $O(n)$. Tento príklad sa dal riešiť aj so zanedbateľne lepšími zložitosťami $O(n + m \\log m)$ čas a $O(m)$ pamäť tak, že si neuložíme nuly pre prázdne ruky, no nie je to potrebné na získanie plného počtu bodov.

## Vzorový kód
",2
75d1f717cbb548bd,ksp,"# Lajno nazmar nevyjde

Leto bolo upršané, rastlinám sa darilo. Zvieratá mali čo pod zub, hovnivály kotúľali. Toľko toho nakotúľali, až nevedia, čo s tým. Je im to ľúto len tak všetko prebytočné spláchnuť do záchoda, alebo nechať do ďalšieho leta splesnivieť. Zhodli sa teda, že potrebujú mrazák. Nie ale iba taký obyčajný. Obrovský. Mnohoposchodový.

Rôzne poschodia ale vyžadujú rôzne veľa času na stavbu. Totiž, v niektorých výškach viac fúka, inde je väčšia zima. Hovniválka Elka letmým pohľadom do vzduchu odhadla, koľko času bude potrebného na postavenie ktorého poschodia mrazáku. Konkrétne zistila, že na postavenie $i$-teho poschodia bude potrebného $c_i$ času.

Hovniválka Elka vie, že ak jeden hovnivál buduje guličku $m$ minút, tisíc hovniválov postaví guličku za $m/1000$ minút. To, samozrejme, platí aj o stavbe mrazáku. Ak na $i$-tom poschodí bude pracovať $h_i$ hovniválov, tak toto poschodie dokončia za $c_i/h_i$ času.

Keďže hovnivál má iba také tenké nožičky, rýchlo sa mu unavia. Každý teda zvládne pomôcť postaviť iba jedno poschodie mrazáku. Poschodie sa ale nedá začať stavať, kým nie je dostavané to predchádzajúce, to predsa dá rozum. Hovniválka Elka chce každého z $H$ hovniválov poslať na práve jedno poschodnie. Chce to spraviť tak, aby bol celkový čas stavania mrazáku čo najkratší.

Ako najrýchlejšie vedia hovnivály postaviť mrazák?

## Úloha

Máme $H$ hovniválov, ktorí chcú postaviť $n$-poschodový mrazák. Hovniválka Elka chce priradiť každému z $H$ hovniválov nejaké poschodie, na ktorom bude pomáhať so stavbou.

Na každom poschodí, samozrejme, musí pracovať aspoň jeden hovnivál.

Ak je na $i$-tom poschodí $h_i$ hovniválov, stavba $i$-teho poschodia zaberie $c_i/h_i$ času.

Vašou úlohou je zistiť, ako najrýchlejšie vie byť mrazák postavený.

## Formát vstupu

Na prvom riadku vstupu sú čísla $n$ -- počet poschodí mrazáku a $H$ -- počet hovniválov. Platí, že $n \\leq H$.

Nasleduje $n$ riadkov. Na $i$-tom z nich je číslo $c_i$ -- základný čas potrebný na stavbu $i$-teho poschodia. Platí, že $1 \\leq c_i \\leq 100,000$.

## Formát výstupu

Vypíšte jedno číslo -- najkratší čas, za ktorý je možné mrazák postaviť.

Vaša odpoveď bude uznaná, ak sa od správnej odpovede nebude odlišovať o viac, ako $1$.

## Hodnotenie

Sú 3 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3, 4 | |:--------------- |-----: | ---------: | ---------: | | $1 \\leq n \\leq$ | $8$ | $100,000$ | $100,000$ | | $1 \\leq H \\leq$ | $20$ | $100,000$ | $10^{12}$ |

## Príklad

```vstup
3 7
6
2
8
```

```vystup
6.667
```
","# Lajno nazmar nevyjde

Snáď ste sa len nenechali zmiasť číslom tejto úlohy. Riešenie je možno jednoduchšie, ako by ste čakali.

## Dôležité pozorovanie

Pozrime sa, čo sa stane, ak sme na $i$-te poschodie pridali hovnivála. Nech na tom poschodí bolo doteraz $a_i$ hovniválov. Stavba tohto poschodia by im zabrala $\\frac{c_i}{a_i}$ času. Po pridaní jedného hovnivála im stavba zaberie $\\frac{c_i}{a_i + 1}$ času. Týmto pridaním sme teda ušetrili $\\frac{c_i}{a_i} - \\frac{c_i}{a_i + 1} = \\frac{c_i}{a_i(a_i + 1)}$.

Môžeme teda rozmiestňovať chrobáky pažravo. Najskôr dáme po jednom na každé poschodie. Následne vždy dáme hovnivála na to poschodie, kde ušetrí najviac času. Toto vieme spraviť v čase $O(H \\log n)$ napríklad pomocou maximovej haldy. V halde budú všetky poschodia a bude utriedená podľa času, ktorý ušetríme pridaním chrobáka na dané poschodie.

## Zrýchlenie

Keďže chrobákov je naozaj veľa, potrebujeme niečo zrýchliť. Zaveďme si parameter $x$. Tento parameter budeme binárne vyhľadávať. Pre $x$ budeme vedieť zrátať nasledovné. Koľko chrobákov vieme pridávať na poschodia, kým sa náš časový zisk (ten zlomok) stane menší ako $x$. Budeme chcieť nájsť také $x$, pre ktoré použijeme $H$ hovniválov.

Pre poschodie $i$ vieme zrátať počet hovniválov $a_i$ na ňom ako $x = \\frac{c_i}{a_i(a_i + 1)}$. Toto vieme vypočítať kvadratickou rovnicou. Keď teda v binárnom vyhľadávaní kontrolujeme dané $x$, tak prejdeme všetky poschodia. Na každé dáme nanajvýš $a_i$ hovniválov (tých z kvadratickej rovnice). Ostane nám teda rozmiestniť posledných nanajvýš $n$. Tých ale vieme doriešiť skôr spomínaným pažravým spôsobom pomocou haldy.

Časová zložitosť tohto riešenia je v závislosti od implementácie zhruba $O(n(\\log C + \\log H + \\log n))$, kde $C$ je maximum z $c_i$. Pamäťová zložitosť je $O(n)$.
",10
aac572b461bcc76a,ksp,"# Opačné čítanie

S jeseňou okrem chladného počasia a padania listov prichádza aj nový školský rok a Adam musel opäť nastúpiť do školy. Keďže sa do školy vrátiť nechcel, vymýšlal všelijaké výhovorky, aby mohol zostať doma (napr. strčil teplomer do teplého čaju; presviedčal rodičov, že je stále august; schoval sa pod posteľ; ...). Tie sa mu však neprepiekli a do školy išiel aj tak.

Ako tam sedel, už na druhej vyučovacej hodine, uvedomil si, že to napokon nie je až také zlé. Čo ale čert nechcel, cez veľkú prestávku si spolužiaci začali robiť srandu z jeho štíhlej stavby tela. Na lavici mu pristál papierik so slovami `Madam Adam`. Adama to trošku rozhodilo a spýtal sa učiteľky, či by sa dalo ísť domov. Učiteľka mysliac, že sa pýtal na záchod, ho s úsmevom na perách pustila.

Po príchode domov si ešte raz otvoril papierik s odkazom. Ako sa naň pozeral, uvedomil si zaujímavú vec -- `madamadam` sa číta rovnako spredu aj zo zadu. Takáto vlastnosť sa Adamovi veľmi zapáčila a vymyslel si takých slov viac. Ba dokonca, vymyslel ku takýmto slovám zaujímavú úlohu.

## Úloha

Adam vymyslel `n` stringov s `k` znakmi, ktoré sa čítajú rovnako spredu aj zo zadu. String obsahuje znaky `a-z`, `A-Z` a `0-9`. Okrem toho, v každom stringu je každý unikátny znak **maximálne dvakrát**. Vašou úlohou je zistiť, koľkými rôznymi spôsobmi sa dajú vymazať znaky zo stringu, aby sa nečítal rovnako spredu aj zo zadu.

## Formát vstupu

Na prvom riadku vstupu je číslo `n`, ktoré reprezentuje počet otázok. Potom nasleduje `n` riadkov a na každom z nich je string dĺžky `k`.

## Formát výstupu

Na každý riadok vypíšte číslo, koľkými rôznymi spôsobmi vieme vymazať znaky v stringu, aby sa nedal prečítať rovnako spredu aj zo zadu. Keďže odpoveď môže byť veľmi veľká, vypisujte ju modulo $10^9 + 7$.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:--------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $10$ | $100$ | $1,000$ | $10,000$ | | $1 \\leq k \\leq$ | $10$ | $25$ | $75$ | $125$ |

## Príklad

```vstup
1
AbbA
```

```vystup
6
```

_Po vymazaní znakov zo stringu `AbbA` je týchto 6 možných stringov, ktoré sa nečítajú rovnako spredu aj zo zadu: `Abb`, `Ab`, `Ab`, `bbA`, `bA`, `bA`. Na prvý pohľad sa zdá, že stringy `Ab` a `Ab` sú rovnaké, lenže jeden string obsahuje znak `b` na prvom indexe a druhý obsahuje znak `b` na druhom indexe, čiže sú rôzne. Tak isto aj `bA` a `bA`._

```vstup
2
DaL00LaD
bysAsyb
```

```vystup
210
98
```

_Zo stringu `DaL00LaD` sa dajú vymazať znaky 210 spôsobmi a zo stringu `bysAsyb` sa dajú vymazať znaky 98 spôsobmi, aby sa nečítali rovnako spredu aj zo zadu._
","# Opačné čítanie {bodypopis=12 bodyprogram=8 vzorak=""Marianka"" mail=""marianna.hronska@trojsten.sk""}

## Pomalé riešenie

Najjednoduchšie riešenie tejto úlohy je vyrobiť si všetky možnosti premazaných substringov, ktoré zodpovedajú zadaniu. Akonáhle máme tieto substringy, tak cez každý prejdeme `for` cyklom, ktorý sa pozerá na znaky z obidvoch koncov substringu. Ak sa znaky spredu aj zozadu zhodujú, tak substring preskočíme. Ak sa nejaký/é znak/y nezhodoval/i, tak si započítame $+1$ do možností. Takto prejdeme cez všetky možné substringy a zistíme koľko z nich sa nečíta rovnako spredu aj zozadu.

## Rýchle riešenie

Lepší prístup k tejto úlohe je zistiť si celkový možný počet substringov a od neho odčítať počet tých substringov, ktoré sa čítajú rovnako spredu aj zozadu. Celkový počet substringov je $2^k$, pretože máme dokopy `k` znakov v stringu a každý z nich bude alebo nebude v substringu. Teraz ešte treba zistiť, čo od toho odčítať.

Existujú dva druhy stringov, ktoré nám vedia prísť na vstupe -- párnej a nepárnej dĺžky. Najskôr sa budeme venovať stringom párnej dĺžky. Tie pozostávajú z dvojíc rovnakých znakov na opačných stranách stringu. Keď vymažeme nejaké znaky zo stringu, tiež máme dve možnosti novovzniknutého substringu -- bude párnej alebo nepárnej dĺžky. Pozrime sa na všetky substringy párnej dĺžky. Predstavme si, že v strede stringu je zrkadlo. Keďže string sa dá čítať rovnako spredu aj zozadu, tak ľavá a pravá polovica vyzerajú rovnako, len zrkadlovo -- `DaL0|0LaD`. Ak vymažeme znaky tak, že nám stále ostane párny počet znakov v substringu, tak vieme jednoducho zistiť, koľko je takých, ktoré sa čítajú rovnako spredu aj zozadu. Ak vymažeme znak na nultom indexe, tak musíme vymazať aj na poslednom -- `aL00La`; ak na prvom, tak aj predposlednom -- `DL00LD`; ... . Takto sa dostaneme ku vzorcu $2^{k/2}$. Pretože ak vymažeme ktorýkoľvek znak z prvej polovice stringu, tak vymažeme aj jeho dvojicu v druhej polovici. Keďže mažeme dvojice, tak máme ""polovičnú"" dĺžku stringu -- ${k/2}$; a každá dvojica bude alebo nebude v substringu. Berieme do úvahy aj to, že nevymažeme ani jeden znak alebo vymažeme všetky.

Ešte potrebujeme odčítať počet substringov nepárnej dĺžky, ktoré sa čítajú rovnako spredu aj zozadu. Je to jednoduchšie ako sa na prvý pohľad zdá. Majme všetky substringy párnej dĺžky z minulého odseku. Z dvojice znakov, ktorá je v strede vymažeme jeden znak a máme substring nepárnej dĺžky, ktorý sa číta rovnako spredu aj zozadu -- napr. `aL0La`. Na čo však nesmieme zabudnúť je to, že môžeme vymazať pravý alebo ľavý znak, čo sa počíta ako dva rôzne substringy. Takže dokopy máme $2 \\cdot 2^{k/2}$ možnoných substringov nepárnej dĺžky, ktoré sa čítajú rovnako spredu aj zozadu. Čo však nie je úplne pravda. Ako bolo aj predtým povedané, v ${k/2}$ sa ráta za možnosť aj prázdny string. Z prázdneho stringu však nevieme nič odčítať, takže vzorec bude vyzerať takto: $2 \\cdot (2^{k/2} - 1)$. Celkový vzorec na vypočítanie všetkých možných párnych stringov, ktoré sa nedajú prečítať rovnako spredu aj zozadu je $2^k - 2^{k/2} - 2 \\cdot (2^{k/2} -1)$.

Pri stringu nepárnej dĺžky sa správame podobne ako pri párnej dĺžky. Tie tiež pozostávajú z dvojíc rovnakých znakov na opačných stranách stringu, ale majú jeden znak v strede navyše -- `bysAsyb`. Predstavme si, že ten znak v strede navyše tam nie je -- `byssyb`. V takom prípade sme opäť naspäť pri stringu párnej dĺžky a vieme použiť vzorec $2^k - 2^{k/2} - 2 \\cdot (2^{k/2} -1)$. Avšak, od celkového počtu ešte potrebujeme odčítať možnosti, kedy sme znak v strede nevymazali. To je v podstate to isté ako keď vymazávame znaky tak, aby sme mali substringy párnej dĺžky. Budeme vymazávať dvojice rovnakých znakov a vždy necháme stredný znak -- `ysAsy`, `bsAsb`, `bAb`, ... . Takže od celého vzorca ešte odčítame $2^{k/2}$, a teda výsledný vzorec pre string nepárnej dĺžky bude vyzerať takto: $2^k - 2^{k/2} - 2 \\cdot (2^{k/2} -1) - 2^{k/2}$.

Samozrejme, nakoniec nesmieme zabudnúť na modulo $10^9 + 7$ a implementovať to cez rýchle modulovanie.

Časová zložitosť je $O(n \\cdot \\log k)$, pretože počet možností vypočítame v čase $\\log k$ a vypočítame ich $n$-krát, lebo máme $n$ otázok. Pamäťová zložitosť je $O(k)$.
",5
40b3eb2ce0607f51,ksp,"# Opatera zvieratiek

Matfyzák Ondrej sa už v škole nudí, a tak chodí pomáhať do terárií blízkej zoologickej záhrady. Tam sa rád stará o hlodavce. Kŕmi nimi písmenkovú veľužovku, ktorú má ešte radšej ako hlodavce. Pozdĺž celého tela má totiž škvrny tvaru písmen. A aj jej spôsob života sa Ondrovi veľmi pozdáva. Celý deň len vylihuje a žerie^[Veľužovka, nie Ondro.]. Keby vám však niekto hovoril, že je Ondro lenivý, tak klame. Napríklad teraz usilovne premýšľa, ako zlepšiť pochmúrnu zimnú náladu v teráriách.

Nakoniec sa rozhodol, že našej užovke vykúzli úsmev na tvári pekným menom. Aby bolo osobné, chce vybrať nejakú podpostupnosť písmen na jej tele. Ondrej ale vyznáva princípy KSP -- krása, symetria, pisateľnosť, preto je pre neho problém vybrať správne meno. Krásne meno je čo najdlhšie. Symetrické sa číta spredu rovnako ako zozadu -- je to palindróm. A pisateľné meno sa dá napísať na ceduľku pred teráriom. Experimentálne už zistil, že na ceduľku nevopchá viac než sto znakov. Pomôžte mu vybrať nejaké KSP meno!

## Úloha

Podpostupnosť reťazca dostaneme vynechaním niektorých znakov. Podpalindróm je podpostupnosť znakov ktorá je palindrómom. Máme užovku popísanú ako reťazec písmen. Nájdite ľubovolný podpalindróm dĺhý $100$ znakov, alebo najdlhší možný, ak tam vhodný stopísmenový nie je.

## Formát vstupu

Jediný riadok vstupu obsahuje reťazec do $10^6$ malých písmen anglickej abecedy -- popis veľužovky.

## Formát výstupu

Vypíšte reťazec $m$ -- vami odporúčané meno podľa princípov KSP. Ak existuje viacero rovnako dobrých mien, vypíšte ľubovoľné z nich.

## Príklady

```vstup
abcdabcd
```

```vystup
bab
```

```vstup
napisaasipan
```

```vystup
napisaasipan
```

```vstup
abcdefghijklmnopqrstuvwxyz
```

```vystup
f
```
","# Opatera zvieratiek

Našou úlohou je vybrať takú podpostupnosť vstupného reťazca, že tvorí palindróm. Táto podpostupnosť navyše nemusí byť súvislá a dokonca ani najdlhšia možná, stačí ak bude obsahovať $100$ znakov (poprípade, ak tam nie je takých $100$ znakov, tak musíme nájsť tú najdlhšiu).

Pokúsme sa zamyslieť nad tým, ako môže vyzerať nejaký najjednoduchší palindróm. Napríklad môže obsahovať len písmená jedného druhu, ako je to v palindrómoch $aaaa$ alebo $ddddd$. To ale znamená, že ak náš vstupný reťazec obsahuje $100$ výskytov toho istého písmena, vieme nájsť riešenie veľmi jednoducho. Proste vyberieme $100$ takýchto písmen.

Náš program teda môže začať nasledovne: Prejde celým vstupných reťazcom a pre každé písmeno si spočíta počet jeho výskytov. Ak sa niektoré písmeno nachádza v reťazci aspoň $100$ krát, vypíšeme výsledok skladajúci sa iba z tohoto písmena a program ukončíme.

Pomohli sme si? Veru áno. Aký dlhý môže byť reťazec, v ktorom sa niečo takéto nestane? Každé písmeno sa tam môže vyskytovať najviac $99$ krát, teda bude mať dĺžku $99\\cdot 26 = 2574$. Keď pridáme ďalší znak, túto vlastnosť pokazíme. Inak povedané^[Použitím Dirichletovho princípu.], ľubovoľný reťazec dĺžky aspoň $2575$ obsahuje aspoň $100$ rovnakých znakov. Výrazne sme teda zmenšili obmedzenie na dĺžku vstupu, pre ktorú je naša úloha netriviálna.

## Hľadanie najdlhšieho palindrómu

Zostáva nám teda vyriešiť tú zložitejšiu úlohu -- ako nájsť najdlhší podpalindróm vo vstupnom reťazci? Takáto úloha je pomerne klasická a preto sa oplatí poznať jej riešenie. Dokonca sa ani nebudeme zaoberať tým, či je ten palindróm dlhý najviac $100$, lebo už nám to viac pri riešení nepomôže.

Poďme sa vrhnúť rovno na popis riešenia. Nebude to nič iné ako jednoduchá rekurzia s memoizáciou, ktorú si hneď vysvetlíme. To čo hľadáme je **najdlhší palindróm od pozície $0$ po pozíciu $n$**.

Jedna možnosť je, že písmená na pozíciách $0$ a $n-1$ sú rôzne. V tom prípade aspoň jedno z týchto písmen nebude vo výsledku. Ak by totiž boli obe, boli by na kraji našej podpostupnosti a tým pádom by sme nemali palindróm. To znamená, že odpoveď bude buď **najdlhší palindróm od pozície $0$ po pozícii $n-1$** alebo **najdlhší palindróm od pozície $1$ po pozíciu $n$**. A toto sú nejaké menšie podproblémy, ktoré môžeme riešiť rekurzívne.

Druhá možnosť je, že obe písmená na krajných pozíciách sú rovnaké. V tom prípade ich môžeme zobrať do výsledku (ktorý je teraz o jedna dlhší) a hľadáme **najdlhší palindróm od pozície $1$ po pozíciu $n-1$**.

Náš problém sme si teda zapísali ako jednoduchú rekurzívnu funkciu, ktorá bude počítať **aký je najdlhší palindróm od pozície $\\ell$ po pozíciu $r$**, a ktorú by sme teraz mali vedieť bez problémov implementovať. Nezabudnite však na to, že ak už vyrátate odpoveď pre nejakú dvojicu $(\\ell,r)$, treba si túto odpoveď zapamätať, aby sme ju nemuseli pri ďalšom opýtaní opäť rátať celú. Na zapamätanie nám poslúži jednoduché dvojrozmerné pole. Bez tohto zapamätávania (memoizácie) by bola časová zložitosť riešenia exponenciálna.

Takisto nemôžete zabudnúť na to, že na konci musíme vypísať reťazec a teda musíme vedieť spätne zistiť, ktoré písmená patria do najdlhšieho palindrómu. Toto si môžete buď pamätať v ďalšom dvojrozmernom poli, kde si poznačíte, ktorým spôsobom dostanete najdlhší palindróm z daného úseku alebo si to budete značiť priamo pri simulácii. Dajte si však pozor, že keď bude najdlhší palindróm dlhší ako $100$ znakov, musíte ho na túto dĺžku skrátiť.

Na záver sa už len pozrime na časovú a pamäťovú zložitosť. Každý stav rekurzie vieme vyrátať v konštantnom čase, stačí keď sa pozrieme na tri iné čísla. Stavov je ale $n^2$, takže časová zložitosť nášho riešenia je $O(n^2)$. A rovnako to bude aj s pamäťovou zložitosťou, lebo si musím zapamätať výsledok pre každý možný stav.

\\medskip

Keď máme nejako popísať časovú zložitosť celého riešenia, označme si $d$ maximálnu dĺžku palindrómu a $a$ počet písmen abecedy. Dĺžka vstupu je $n$. Potom časová zložitosť je $O(n + (\\min(n,d \\cdot a))^2)$. Keď považujeme $d$ a $a$ za konštanty, tak je to jednoducho $O(n)$.
",8
bfa3786d83c7d347,ksp,"# Kristínine ponožtičky

Kristína si ráno obliekla biele ponožky. Keď však prešla po podlahe, zistila, že sa jej ponožky rýchlo zašpinili. Teraz stojí pred schodami a vidí aké su špinavé.

Na každej polke schodu je rôzne veľa špiny. Ľavou nohou Kristína stúpa na ľavú polovicu schodu a pravou na pravú. Na prejdenie schodov používa iba klasické metódy. (Nohy sa po schodoch striedajú, nepreskočí viac schodov naraz, kráča iba jedným smerom...).

Pomôžte Kristíne prejsť po schodoch tak, aby sa jej biele ponožky čo najmenej zašpinili.

## Úloha

Vašou úlohou bude zistiť, či má Kristína vstúpiť na schody pravou alebo ľavou nohou.

## Formát vstupu

Na vstupe dostanete celé kladné číslo $n$. Potom nasleduje $n$ riadkov obsahujúcich dve čísla $l_i, r_i$ -- špinavosť ľavej a pravej polovice $i$-teho schodu. Prvý schod, na ktorý Kristína stúpa je ten, ktorý je prvý na vstupe.

## Formát výstupu

Vypíšte `prava`, `lava` alebo `je to jedno` podľa toho, ktorou nohou má Kristína vstúpiť na schody.

## Príklady

## Hodnotenie

Sú 4 sady vstupov, v ktorých platia tieto obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |----------------------|------:|---------:|----------:|-----------:| | $1 \\le n \\le$ | $100$ | $1,000$ | $50,000$ | $100,000$ | | $0 \\le l_i, r_i \\le$ | $100$ | $100$ | $1,000$ | $1,000$ |

```vstup
3
2 1
2 1
4 4
```

```vystup
je to jedno
```

_Je jedno, ktorou nohou vstúpi na schodisko, ponožky bude mať zašpinené rovnako._

```vstup
5
5 2
4 5
3 1
9 3
4 2
```

```vystup
prava
```

```vstup
6
3 1
4 2
4 5
7 1
2 5
9 8
```

```vystup
lava
```
","# Kristínine ponožtičky

Ako už vidno zo zadania, sú iba dve možnosti ako môže Kristína prejsť po schodoch -- buď začne ľavou nohou, alebo pravou. Stačí nám teda vypočítať špinavosti oboch možností a vybrať tú menšiu.

Špinavosť pre pravú nohu spočítame tak, že v cykle budeme striedavo pripočítavať ku výslednej špinavosti pravú a ľavú časť schodu. Špinavosť pre ľavú nohu vypočítame obdobne, len začneme ľavou časťou schodu.

Všimnite si, že k vyriešeniu tejto úlohy nepotrebujeme pole -- jednotlivé špinavosti vieme spočítavať už pri načítavaní vstupu.

Časová zložitosť je $O(n)$ - pri sčítavaní špinavostí v cykle prejdeme všetkých $n$ schodov. Ak sme nepoužili polia, stačili nám dve premenné so špinavosťami a teda pamäťová zložitosť je $O(1)$. S použitím polí je pamäťová zložitosť $O(n)$.
",1
7360dc4397de0df8,ksp,"# Aerolinkové ceny

Nemenovanej spoločnosti sa podarilo navrhnúť dokonalý systém, ako čo najefektívnejšie navrhnúť lety medzi ľubovoľnou skupinou miest tak, aby nebolo treba príliš veľa prestupovať, nemuseli sme chodiť z Bratislavy do Trnavy cez Košice... No, určite si viete aj sami predstaviť mnohé nepríjemnosti, ktoré by mohli nastať, keby lety neboli naplánované rozumne. Čo ale ešte nevymysleli je, že koľko budú stáť jednotlivé lety. Bez veľkého rozmýšľania sa rozhodli priradiť mestám unikátne hodnoty, a cenu letu medzi dvomi mestami určovať ako súčet ich hodnôt. Už teda stačí iba mestám priradiť hodnoty. Lenže ako na to? Hlavným cieľom spoločnosti je samozrejme zarobiť čo najviac. Pomôžte spoločnosti vymyslieť systém ohodnocovania miest tak, aby súčet cien všetkých letov bol čo najväčší.

## Úloha

Vašou úlohou bude priradiť $n$ mestám _rôzne_ hodnoty od $1$ po $n$ (vrátane), a to tak, aby súčet cien všetkých letov medzi nimi bol čo najväčší. Cenu letu medzi dvomi mestami vypočítame ako súčet hodnôt daných dvoch miest.

## Formát vstupu

Na prvom riadku vstupu sú 2 medzerou oddelené čísla $n$ a $m$, kde $n$ je počet miest a $m$ je počet letov medzi nimi. Mestá sú očíslované od 0 po $n-1$. Nasleduje $m$ riadkov, každý z nich obsahuje 2 medzerou oddelené čísla miest, medzi ktorými sa pravidelne uskutočňujú lety. Rátame s tým, že ak existuje let z A do B, tak existuje aj let z B do A za presne rovnakú cenu, preto s nimi budeme rátať ako s jedným letom a zarátame jeho cenu iba raz (na vstupe nikdy nebude dvojica A B aj B A a taktiež nikdy nebudú na vstupe dva úplne rovnaké lety).

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------|-----:|---------:|---------:|---------:| | $1 \\leq n \\leq$ | $10$ | $500$ | $50000$ | $100000$ | | $0 \\leq m \\leq$ | $50$ | $125000$ | $300000$ | $500000$ |

## Formát výstupu

Vypíšte jediné číslo, a to najväčší možný súčet cien všetkých letov. Toto číslo môže byť veľké, a teda odporúčame použiť 64 bitovú premennú (`long long` v C++). Nezabudnite za číslom vypísať znak nového riadku.

## Príklady

```vstup
3 3
0 1
0 2
1 2
```

```vystup
12
```

_Keď priradíme mestám hodnoty_ `(mesto:hodnota): 0:1, 1:2, 2:3`, _tak potom súčet cien všetkých letov by bol:_ `(1 + 2) + (1 + 3) + (2 + 3) = 12`. _Môžeme si ale všimnúť, že v tomto prípade by sme pre ľubovoľné priradenie dostali rovnaký súčet._

```vstup
4 2
0 1
1 2
```

```vystup
13
```

_Pre priradenie:_ `0:3, 1:4, 2:2, 3:1` _získame takýto súčet:_ `(3 + 4) + (4 + 2) = 13`. _Ak by sme ale zvolili napríklad priradenie:_ `0:1, 1:2, 2:3, 3:4`, _tak by bol súčet cien všetkých letov menší, a to:_ `(1 + 2) + (2 + 3) = 8`.

```vstup
6 4
0 1
1 2
1 3
2 5
```

```vystup
37
```
","# Aerolinkové ceny

Na začiatok sa pozrime na to, aké informácie vlastne budeme potrebovať. Môžeme si všimnúť, že pre ľubovoľný let $A$ $B$ platí, že hodnota mesta $A$ sa za tento let započíta raz do celkového súčtu cien letov nezávisle od mesta $B$, rovnako pre mesto $B$ sa jeho hodnota započíta raz, bez ohľadu na mesto $A$. Pri zisťovaní celkovej ceny všetkých letov nám teda v skutočnosti nezáleží na tom, medzi ktorými mestami sa uskutočňujú jednotlivé lety, ale iba na tom, koľko existuje letov z jednotlivých miest.

To znamená, že hodnota mesta bude započítaná do celkového súčtu toľkokrát, koľko letov sa z neho uskutočňuje. Preto najväčší možný súčet všetkých letov získame tak, že mestám s najväčším počtom ciest priradíme najväčšie hodnoty.

## Vzorové riešenie

Na vyriešenie tejto úlohy nám pri načítavaní vstupu stačí pre každý výskyt nejakého mesta navýšiť počet letov tohto mesta. Následne tieto počty utriedime vzostupne a priradíme mestám v tomto poradí postupne hodnoty od $1$ po $n$. Celkový súčet potom dostaneme ako súčet hodnôt priradených mestám vynásobených počtom ich letov.

Keďže si potrebujeme pamätať iba počty letov pre $n$ miest, tak pamäťová zložitosť bude $O(n)$. Načítanie vstupu je v $O(n + m)$, utriediť pole o veľkosti $n$ vieme v $O(n \\cdot \\log n)$. Sčítanie celkovej\
sumy všetkých letov vieme spraviť v jednom cykle v $O(n)$. Celková časová zložitosť je teda $O(m + n \\cdot \\log n)$.

## Rýchlejšie riešenie

V skutočnosti ale existovalo aj lepšie riešenie v prípade využitia counting sortu. Ten v prípade, že máme $k$ hodnôt, ktoré triedime a sú zhora ohraničené nejakou hodnotou $l$, má časovú zložitosť $O(k + l)$. V našom prípade máme hodnoty ohraničené pomocou čísla $m$, keďže ak máme $m$ letov, tak zo žiadneho mesta nemôže viesť viac ako $m$ ciest. Preto s použitím counting sortu sa dala táto úloha vyriešiť dokonca v zložitosti $O(m + n)$.
",2
50668712f3a1b6c3,ksp,"# Obézni brankári

""Čížiček, čížiček, vtáčik maličký, povedz nám čížiček, ako brániť gól...""

Nuž, Joža táto filozofická otázka zaujala tiež. Až natoľko, že v jednom interview pre prestížny časopis DRB++, ktorého novinári pravidelne vyhľadávajú tie najvplyvnejšie osobnosti, povedal Jožo tento známy citát: ""Prečo monštruózne obézni ľudia nie sú hokejoví brankári?"". Táto otázka už bola citovaná množstvom filozofov. Aj vďaka tomu je Jožo považovaný za jedného z najvplyvnejších mysliteľov modernej filozofie.

Dnes Joža trápi podobná, avšak trochu iná otázka. Na Wikipédii sa dočítal, že existujú trpaslíci aj obri. A aj trpaslíci, aj obri, môžu byť monštruózne obézni. Je však jasné, že monštruózne obézny trpaslík je oveľa menší, než monštruózne obézny obor. Jedna vec ich však všetkých spája a síce to, že sú rovnako širokí, ako vysokí.

A keďže Jožo sa vo svojom myslení nikdy nezastaví a vždy ide hlbšie a hlbšie, teraz ho zaujíma takáto otázka: koľkými spôsobmi je možné vyplniť veľkú hokejovú bránku monštruózne obéznymi ľudmi tak, aby sa do nej nedal streliť gól?

## Úloha

Monštruózne obézni ľudia sú štvorcoví a majú rozmery $1 \\times 1$, $2 \\times 2$, $3 \\times 3$, alebo $4 \\times 4$ metre.

Máme veľkú hokejovú bránku s rozmermi $4 \\times n$ metrov. Zistite, koľkými spôsobmi je možné ju úplne vyplniť monštruózne obéznymi ľuďmi (môžu stáť na sebe) tak, aby sa žiadni neprekrývali a aby nebolo ani trochu voľného miesta pre puk.

Keďže výsledok môže byť pomerne veľký, vypíšte jeho zvyšok po delení $m$.

## Formát vstupu

Na vstupe sú na jednom riadku čísla $n$ a $m$ oddelené medzerou. Platí $1 \\leq n \\leq 10^{16}$ a $1 \\leq m \\leq 10^7$.

## Formát výstupu

Vypíšte jeden riadok a na ňom jedno číslo: počet možností, ako zaplniť bránku $4 \\times n$ monštruózne obéznymi ľuďmi modulo $m$.

## Príklady

```vstup
3 47
```

```vystup
13
```

```vstup
7 1000
```

```vystup
29
```
","# Obézni brankári

Táto úloha na prvý pohľad vyzerala ako nejaká komplikovaná kombinátorika. V skutočnosti to tak vôbec nebolo, išlo len o efektívne spočítanie všetkých možností vyplnenia obdĺžnika. Poďme sa najprv pozrieť na spôsob, ako tieto možnosti spočítať hrubou silou. (Odporúčam nepreskakovať riešenie hrubou silou, sú v ňom veľmi dôležité myšlienky potrebné pre pochopenie vzorového riešenia.)

## Hrubá sila -- vypĺňanie po jednotlivých políčkach

Poviete si: ""Poďme vygenerovať všetky možnosti!"", otázka však je ako. Jeden zo spôsobov by mohol byť, že si zoberieme prázdnu bránku a budeme do nej postupne všetkými možnosťami umiestňovať štvorce. Vždy, keď je bránka plná, započítame toto rozloženie do výsledku. Musíme ale nájsť taký spôsob vytvárania (prehľadávania) všetkých rozložení, aby sme každé rozloženie navštívili len raz.

Jeden zo spôsobov by mohol byť taký, že postupne prechádzame políčka bránky zhora dole, zľava doprava. Ak nájdeme nevyplnené políčko, skúsime sem vložiť štvorce všetkých možných veľkostí tak, aby na tomto políčku ležali ľavým horným rohom (vždy skúsime vložiť 1 štvorec a potom rekurzívne zavoláme funkciu, čo vyplní zvyšok bránky). Takto vždy zapĺňame políčka len smerom dole a doprava od našej pozície a všetky políčka smerom hore a doľava od nás sú už určite vyplnené. Pri vytváraní rozložení nevytvoríme žiadne viackrát (lebo každé dve sa líšia veľkosťou brankára aspoň na jednom políčku -- ľavom hornom rohu nejakého brankára) a takisto vytvoríme každé.

Toto riešenie sa ľahko vymyslí, aj implementuje, no navštívi všetky rozloženia, ktorých je exponenciálne veľa.

## Hrubá sila -- vypĺňanie po stĺpcoch

Čo ak by sme mali už vygenerované všetky bránky veľkosti $4 \\times n$? Dokážeme z týchto bránok vygenerovať všetky bránky veľkosti $4 \\times (n + 1)$? Odpoveď znie, áno, a budeme to robiť nasledovne. Predstavme si, že máme už vygenerované konkrétne rozloženie veľkosti $4 \\times n$:

Oblasť jednej farby je jeden brankár. Otázniky v poslednom stĺpci reprezentujú nový stĺpec, ktorý chceme pridať (teraz budeme pridávať brankárov do stĺpca tak, aby boli zarovnaní podľa pravého kraja -- teda aby sme presne vyplnili obdĺžnik $4 \\times (n + 1)$). Je jasné, že v pôvodnom rozložení musíme aj niečo zmeniť, inak by sme mohli predsa pridať len samých jednotkových brankárov. Avšak, ak budeme meniť ľubovoľne, môžme dôjsť k problému generovania rovnakého rozloženia viackrát.

Do stĺpca s otáznikmi umiestníme ľubovoľne veľkých brankárov, ktorí sa tam zmestia. V pôvodnom rozložení budú však môcť prekryť (a teda nahradiť) **len jednotkových brankárov**. Na našom obrázku máme napravo celkom pekné množstvo jednotkových brankárov. Jediného brankára, ktorého si nemôžeme dovoliť do stĺpca s otáznikmi umiestniť je brankár veľkosti $4 \\times 4$, pretože ten by musel prekryť tyrkysového brankára $2 \\times 2$ a vieme, že takého prekryť nemôžeme.

Vždy je najviac osem možností, ako umiestniť brankárov do stĺpca s otáznikmi (odporúčam si ich vypísať na papier), pre každú bránku veľkosti $4 \\times n$ je teda celkom ľahko možné vygenerovať najviac $8$ bránok veľkosti $4 \\times (n + 1)$.

Ukážme si ešte, že takýmto spôsobom vygenerujeme každé rozloženie a žiadne nevygenerujeme dvakrát. Zoberme si nejaké konkrétne rozloženie $4 \\times n$ a každého brankára, ktorý sa dotýka pravého okraja bránky nahraďme jednotkovými brankármi a potom odstráňme posledný stĺpec. Týmto spôsobom dostaneme rozloženie veľkosti $4 \\times (n - 1)$, z ktorého bolo naše rozloženie veľkosti $4 \\times n$ vygenerované. Vidíme teda, že každé rozloženie $4 \\times n$ vieme vygenerovať, ak už máme vygenerované všetky rozloženia veľkosti $4 \\times (n - 1)$. Každé dve rozloženia veľkosti $4 \\times n$ sa budú líšiť buď v poslednom stĺpci, alebo v rozloženiach $4 \\times (n - 1)$, z ktorých boli vygenerované.

Budeme si teda postupne generovať rozloženia pre stále dlhšiu a dlhšiu bránku, až sa nakoniec dostaneme po našu cieľovú šírku bránky. Toto riešenie je však pomerne pomalé. Z každej bránky $4 \\times n$ vygenerujeme prinajhoršom až $8$ bránok veľkosti $4 \\times (n + 1)$ a tak časová zložitosť môže byť až exponenciálna (aj pamäťová, ak si udržiavame všetky doteraz vygenerované rozloženia).

Poďme sa teda pozrieť na to, ako toto riešenie výrazne zefektívniť. (Pre porozumenie ďalším riešeniam je však veľmi dôležité v prvom rade porozumieť aktuálnemu.)

## Brankári si udržujú líniu -- lineárne riešenie

V predchádzajúcom riešení môžeme spraviť nasledujúce pozorovanie: to, akých brankárov môžeme pridať do posledného stĺpca s otáznikmi závisí len a len od počtu jednotkových brankárov úplne napravo v každom riadku. Napríklad, ak pravý okraj nejakej bránky vyzerá takto (prázdne políčka bez otáznikov znamenajú hocijakých nejednotkových brankárov):

tak tam vieme doplniť nejakých jednotkových, dvojkových a dole aj trojkového brankára.

Úplne všetky rozloženia, ktoré končia takto, sa dajú do otáznikov doplniť rovnakými spôsobmi. Koľko je spôsobov, ktorými môžu rozloženia končiť? Keďže to závisí len od počtu jednotkových brankárov úplne napravo v každom riadku, a záleží nám len na posledných troch (lebo ďalších už nezvládame prekryť), tak možností je $4^4$ (štyri riadky a v každom $0 - 3$ jednotkových brankárov).

Slabina predchádzajúceho riešenia hrubou silou bola, že sme si pamätali úplne všetky rozloženia, aj tie, ktoré sa končili rovnako. Pekným vylepšením teda bude, že namiesto toho si budeme pamätať len počet rozložení pre každé možné ukončenie. Tým sa nám zlepší priestorová zložitosť na konštantnú, časová sa však nezmení.

Na to musíme spraviť ešte jedno vylepšenie. Zaveďme si malú terminológiu: _stavom_ budeme nazývať ľubovoľnú z tých $256$ možností, ktorými môže končiť rozloženie. Čo ak by sme si pre každý stav dopredu vypočítali, na aké ďalšie stavy sa môže zmeniť doplnením stĺpca s otáznikmi? Predpočítať to je pomerne jednoduché. Všetky prechody medzi rozloženiami si môžeme uložiť do veľkej tabuľky $256 \\times 256$, kde $j$-te políčko v $i$-tom riadku bude určovať, koľkými spôsobmi sa dá dostať zo stavu číslo $j$ do stavu číslo $i$ (prečo nie naopak, z $i$ do $j$ uvidíme čoskoro). Nazvime si túto tabuľku $M$. (Situáciu si môžete predstaviť aj tak, že vytvoríme graf, kde stavy sú vrcholy a prechody medzi stavmi sú orientované hrany. $i$-ty riadok tabuľky hovorí, z ktorých vrcholov (stavov) sa dá dostať do stavu $i$ a číslo na pozícii $(i, j)$ hovorí koľko hrán vedie z $j$ do $i$.)

V ďalšom jednorozmernom poli veľkosti $256$ si budeme pamätať počty rozložení pre každý z $256$ stavov. Nazvime si toto pole $u$. Na začiatku máme len jeden stav $(0, 0, 0, 0)$. Vždy, keď už máme spočítané počty stavov pre šírku bránky $n$, tak pre šírku $n + 1$ spočítame ľahko. Označme si nové pole počtov stavov ako $v$. Toto pole vypočítame jednoducho ako $v_i = \\sum\_{j=0}^{255} u_j \\cdot M\_{i,j}$. Inými slovami, počet nových rozložení v stave $i$ vypočítame tak, že spočítame všetky možnosti, ako sa doňho vieme dostať zo starých rozložení. Keďže tie máme uložené, ako počty v jednotlivých stavoch a pre každý stav vieme podľa tabuľky $M$, kam sa z neho vieme dostať, tak nám stačí vždy vynásobiť počet rozložení v každom stave $j$ s počtom možností, ako sa z tohoto stavu dostať do stavu $i$ a celé to sčítať.

Celkový výsledok bude súčet počtov rozložení vo všetkých stavoch.

Týmto spôsobom dostaneme pekné lineárne riešenie. Výpočet riešenia pre každú ďalšiu šírku nám zaberie len konštantný čas, keďže počet stavov je konštantný a nijako nezávisí od vstupu.

## Znížme počet stavov

Riešenie je síce lineárne od veľkosti $n$, no konštanta, ktorou $n$ násobíme je $\\left(4^4\\right)^2 = 256^2 = 65536$, teda toto riešenie je prakticky použiteľné pre $n$ rádovo $100$.

Ak si ale maticu $M$ vypíšeme na výstup, zistíme, že je pomerne riedka. Inými slovami, veľa stavov je úplne nedosiahnuteľných. Ako sa týchto stavov zbaviť? Jedno z riešení by bolo spraviť prehľadávanie do šírky na grafe, ktorý matica reprezentuje a takým spôsobom nájsť všetky stavy dosiahnuteľné zo stavu $(0, 0, 0, 0)$.

Existuje však aj jednoduchšie riešenie. Každý riadok v matici $M$ určuje spôsob, ako vypočítať nový stav z predchádzajúcich stavov. Pokiaľ je celý riadok v matici nulový, tak stav, ktorý reprezentuje tento riadok nikdy nenadobudne žiadne rozloženie. Takýto stav je nedosiahnuteľný. Odstránime teda všetky nulové riadky a im prislúchajúce stĺpce. Týmto spôsobom nám môžu vzniknúť ďalšie nulové riadky a teda odstránime aj tie a tiež im prislúchajúce stĺpce. Tento proces opakujeme, až kým sa v matici nenachádzajú žiadne nulové riadky. Takto sa nám obrovská matica $256 \\times 256$ zredukuje na celkom príjemnú maticu $30 \\times 30$, čiže naše riešenie vyrieši úlohu aj pre $n$ rádovo $10000$. Konštanty sú niekedy podstatné :)

## Smer čierna matematika (ale vôbec nie až tak)

Máme lineárne riešenie, ale to zjavne nestačí, keďže šírka bránky môže dosahovať pomerne závratné hodnoty. Keď sa však pozrieme na to, čo vlastne robíme v našom lineárnom riešení, tak nie je to nič iné, ako násobenie vektora maticou! (V podstate, výpočet počtu nových rozložení zo starých pomocou tabuľky je tak častá matematická operácia, že ju ľudia dobre preskúmali a nazvali _súčinom matíc_. Použite Google a Wikipédiu, ak ste ešte o násobení dvoch matíc a o násobení vektora maticou nepočuli.)

Pozrime sa opäť na to, ako z poľa (vektora) $u$ vypočítame pole (vektor) $v$. Náš vzorec bol:

$$ v_i = \\sum\_{j=0}^{255} u_j \\cdot M\_{i,j} $$

Ale toto je predsa násobenie vektora maticou! Ľahko to prepíšeme na:

$$ v = M \\cdot u $$

Takto vypočítame počty stavov v bránke o jedna väčšej. Čo ak chceme vypočítať počty stavov v bránke o $2$ väčšej? Jednoducho:

$$ v = M \\cdot M \\cdot u $$

Tu sa nám začína rysovať celkom jednoduchý pattern. Ak chceme vypočítať počty stavov v bránke o $n$ väčšej, tak to spravíme takto:

$$ v = M \\cdot M \\cdot \\dots \\cdot M \\cdot v = M^n \\cdot u $$

Hurá, tým sme sa naozaj posunuli ďalej, pretože matice vieme umocňovať v logaritmickom čase^[ Napríklad ak $n = 14$, potom $M^n = M^{14} = M^8 + M^4 + M^2$ Stačí nám teda vypočítať mocniny $M^{2^k}$ a vhodné mocniny sčítať. Ak si zapíšeme $n$ v dvojkovej sústave $14\_{10} = 1110\_{2}$, vidíme, ktoré mocniny potrebujeme. Mocniny spočítame jednoducho, opakovaným násobením $M^{k+l} =M^{k} * M^{l}$]! Takýmto spôsobom sme dostali riešenie s časovou zložitosťou $O(\\log n)$ a pamäťovou $O(1)$.
",9
d32764450bd3da12,ksp,"# Olympiáda vo vyhľadávaní v texte

V Absurdistane sa tento rok koná historicky prvý ročník Olympiády vo vyhľadávaní v texte. Súťaže sa zúčastňujú trojčlenné tímy, a koná sa niekoľko zápasov -- v každom zápase proti sebe nastúpia dva tímy. Porazený tím súťaž opúšťa.

Každý zápas má nasledovnú formu:

- Každý tím ukáže protivníkovi zdrojový kód programu, ktorým bude vyhľadávať v texte.

- Oba tímy si tajne vyberú text, v ktorom bude ich súper vyhľadávať. Tiež zvolia slovo, ktoré chcú, aby ich súper našiel v texte. Samozrejme, je nejaké obmedzenie na veľkosť vstupu.

- Spustia sa programy oboch tímov na vstupe, ktorý zadal protivník. Úlohou programov je nájsť všetky výskyty zadaného slova v zadanom texte. Vyhráva rýchlejší z programov.

Knuth, Morris a Pratt sa tiež zaregistrovali na súťaž so svojím [algoritmom](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm). Práve začal ich prvý zápas, a ich súperom je niekto, kto je tak naivný, že do súťaže prišiel s naivným algoritmom na vyhľadávanie v texte:

```iobox
text[1..n] // text dlzky n, v ktorom vyhladavame
slovo[1..m] // slovo dlzky m, ktore hladame v texte
counter = 0

// postupne skusime kazdu poziciu textu ako zaciatok slova
for i = 1 to n:
  // zlava doprava overime, ci sa tam nachadza slovo
  for j = 1 to m:
    if i + j - 1 > n:
      break
    counter += 1
    if text[i + j - 1] != slovo[j]:
      // lisi sa v j-tom znaku, slovo urcite nezacina na pozicii i v texte
      break
    if j == m:
      // nasli sme vyskyt slova v texte, podame o tom oznam a pokracujeme dalej vo vyhladavani
```

Chcú protivníka totálne zničiť. Vymysleli niekoľko rôznych vstupov, no teraz sa nevedia zhodnúť, ktorý z nich by mali dať protivníkovi. Pomôžte im zistiť, ktorý vstup bude pre protivníka najhorší.

## Úloha

Zadaný je text, v ktorom vyhľadávame, a hľadané slovo. Zistite, koľko porovnaní spraví na tomto vstupe naivný algoritmus. (Zaujíma nás teda hodnota premennej `counter` po skončení algoritmu.)

## Formát vstupu

Na prvom riadku vstupu je text, v ktorom vyhľadávame. Na druhom riadku je hľadané slovo. Obe slová obsahujú iba malé písmená anglickej abecedy, a majú dĺžku aspoň $1$ a najviac $1,000,000$ znakov.

## Formát výstupu

Na jediný riadok výstupu vypíšte jedno číslo -- počet porovnaní, ktoré spraví naivný algoritmus na vstupe. Toto číslo môže byť veľké, a nemusí sa zmestiť do $32$-bitovej premennej (`int` v `c++`), odporúčame preto použiť $64$-bitové premenné (`long long`).

## Príklady

```vstup
aaaa
aab
```

```vystup
9
```
","# Olympiáda vo vyhľadávaní v texte

V texte budeme označovať veľkosť vstupu ako $n$. Teda dĺžka textu aj dĺžka slova sú $O(n)$. Zjednoduší nám to analýzu časovej zložitosti -- neberieme dĺžku textu a dĺžku slova ako dve rôzne premenné.

## Naivné riešenie

Samotné zadanie nám dáva návod, ako získať nejaké body za túto úlohu. Implementujeme naivný algoritmus, a počítame si počet porovnaní.

Ďalej si ukážeme tri riešenia. Prvé dve na seba nadväzujú, a síce nie sú z časového hľadiska optimálne, ale majú zaujímavú myšlienku, ktorá sa často dá uplatniť aj v iných úlohách. Kľudne ale môžete začať čítať od tretieho (optimálneho) riešenia.

## Šikovnejšie porovnávanie

Predstavme si, že by sme vedeli rýchlo porovnávať nie len znak textu so znakom slova, ale aj súvislý *blok* textu dĺžky $a$ so súvislým blokom slova rovnakej dĺžky. Potom by sme vedeli pre každú začiatočnú pozíciu rýchlejšie zistiť, koľko porovnaní od nej spravíme:

1. Porovnávame bloky, kým sa zhodujú. Každé blokové porovnanie zodpovedá $a$ jednotkovým porovnaniam, teda vždy, keď sa bloky zhodujú, zvýšime výsledok o $a$. Týchto blokových porovnaní nemôže byť viac ako $O(\\frac{n}{a})$.

1. Keď narazíme na nezhodu blokov (alebo keď do konca textu alebo slova ostáva menej ako $a$ znakov), začneme porovnávať znak po znaku. Týchto porovnaní spravíme najviac $a$, lebo vieme, že sa blok textu s blokom slova na niektorom znaku nezhoduje.

Ako ale možno bloky porovnávať rýchlejšie, ako znak po znaku? Kľúčovým pozorovaním je, že týchto blokov je iba $O(n)$. Môžeme si preto dovoliť ich na začiatku lexikograficky usporiadať, a každému bloku priradiť počet lexikograficky menších blokov -- jeho *číslo*. Namiesto porovnávania obsahov blokov nám teraz stačí porovnávať ich čísla, ktoré sú veľké $O(n)$ -- takže môžeme predpokladať, že sa nám zmestia do bežnej premennej a vieme ich porovnávať v konštantnom čase. To je pre dostatočne veľké bloky oveľa rýchlejšie, ako porovnávať ich znak po znaku.

Spravíme tak $O(\\frac{n}{a} + a)$ operácii pre každú začiatočnú pozíciu -- pre všetky pozície to potom trvá $O(n \\cdot (\\frac{n}{a} + a))$.

Ešte musíme započítať čas strávený zisťovaním čísel blokov. Máme ich $O(n)$, a porovnanie dvoch blokov trvá $O(a)$ -- takže triedenie nám bude trvať $O(n \\log {n} \\cdot a)$.

Vhodná voľba $a$ je $a = \\sqrt{n}$, pre ktorú dostávame celkovú časovú zložitosť $O(n \\sqrt{n} \\log{n})$. Pamäťová zložitosť je $O(n \\sqrt {n})$ -- najviac si toho pamätáme v zozname blokov, ktorých je $O(n)$, a každý má dĺžku $O(\\sqrt{n})$.

## Na štýl binárneho vyhľadávania

Nemusíme mať ale iba jednu veľkosť blokov. Bloky si môžeme rozdeliť do viacerých úrovní podľa ich dĺžky, a na každej úrovni ich očíslovať lexikograficky. Ďalej nám opäť stačí namiesto porovnávania obsahov blokov porovnávať ich čísla. Porovnávanie začneme na najvyššej úrovni. Vždy, keď nájdeme nezhodu, začneme porovnávať bloky o úroveň nižšie. Na najnižšej úrovni budú bloky dĺžky $1$, teda samotné znaky.

Potrebujeme teda vhodne zvoliť dĺžky blokov na jednotlivých úrovniach, a šikovne bloky na každej úrovni očíslovať lexikograficky. Vhodnou voľbou, ktorá vyrieši oba problémy, je mať na každej úrovni bloky práve dvakrát také dlhé, ako bloky na o $1$ nižšej úrovni.

Pri porovnávaní budeme mať na každej úrovni najviac $1$ zhodu -- $2$ zhody by totiž zodpovedali $1$ zhode na úrovni vyššie. Na aktuálnu úroveň sme sa ale mohli dostať iba tak, že na vyššej úrovni nastala nezhoda. Úrovní máme $O(\\log {n})$, takže by sme mali iba $O(\\log{n})$ blokových porovnaní pre každú začiatočnú pozíciu. Každé blokové porovnanie trvá $O(1)$ (porovnávame čísla veľké $O(n)$), táto časť algoritmu teda trvá $O(n \\log {n})$.

\\medskip

A ako nájdeme lexikografické číslovanie pre každú úroveň? Tentokrát si nemôžeme dovoliť bloky usporiadať podľa ich obsahu -- môžu byť totiž dlhé až $O(n)$, a normálne triedenie by trvalo až $O(n^2 \\log {n})$. Kľúčovým pozorovaním je, že blok na každej úrovni (okrem najnižšej úrovne) zodpovedá dvom blokom na úrovni o $1$ nižšej. Ak tie už máme očíslované, vieme ľahko porovnávať ľubovoľné dva bloky na aktuálnej úrovni -- najprv ich porovnáme podľa prvej polovice, a ak sa na nej zhodujú, tak ich porovnáme podľa druhej polovice. Keď vieme bloky porovnávať, tak ich vieme usporiadať a následne očíslovať.

Úrovní je $O(\\log {n})$, na každej triedime $O(n)$ blokov, a každé porovnanie trvá $O(1)$ (lebo dvakrát porovnávame čísla veľké $O(n)$). Preto má táto časť algoritmu časovú zložitosť $O(n \\log^2 {n})$.

\\medskip

Celková časová zložitosť je teda $O(n \\log^2 {n})$. Pamäťová zložitosť je $O(n \\log {n})$ -- najviac pamäte zaberajú úrovne, ktorých je $O(\\log{n})$, a na každej si pamätáme čísla blokov, ktorých je $O(n)$.

Toto riešenie sa dá vylepšiť tak, aby malo optimálnu časovú zložitosť $O(n)$ za využitia kladív ako *sufixové pole*, *LCP pole*, a *range-minimum query*. Tie výrazne presahujú rámec tejto úlohy, a uvádzať ich tu nebudeme.

## Čo navrhujú Knuth, Morris a Pratt

Predstavme si, že sa nám znaky textu odkrývajú postupne. Na začiatku máme teda prázdny text, a postupne na jeho koniec pridávame znaky. Ako sa bude meniť počet porovnaní, ktoré spraví naivný algoritmus?

Pozrime sa na nejakú začiatočnú pozíciu. Od nej spravíme niekoľko porovnaní, až kým nenastane jedno z nasledujúcich:

1. Našli sme nezhodu. Potom keď na koniec textu pridáme nový znak, tak počet porovnaní, ktoré spravíme pre túto začiatočnú pozíciu, sa nezmení.

1. Nenašli sme nezhodu, a došli sme na koniec slova. Pridaním znaku na koniec textu sa počet porovnaní, ktoré spravíme, opäť nezmení -- nie je s čím ďalej porovnávať, lebo sme na konci slova.

1. Nenašli sme ešte nezhodu, došli sme na koniec textu ale nie sme ešte na konci slova. Keď na koniec textu pridáme nový znak, tak určite spravíme jedno ďalšie porovnanie.

Zaujíma nás teda počet tých začiatkov, pri ktorých sme došli na koniec textu ale ešte nie sme na konci slova. Každému takému začiatku zodpovedá reťazec znakov, ktorý sme už spracovali, a ktorý sa zhodoval s prvými niekoľkými znakmi slova. Je to teda vlastný prefix slova. Takže keď pridávame znak na koniec textu, výsledok sa zvýši o počet vlastných prefixov slova, ktoré sú sufixom textu (pred pridaním nového znaku).

Toto nám umožňuje spočítať práve [Knuthov-Morrisov-Prattov algoritmus](https://www.ksp.sk/kucharka/kmp/). Konkrétne

1. Vieme s jeho pomocou po pridaní každého znaku zistiť najdlhší prefix slova, ktorý je sufixom textu.

1. Najdlhší prefix slova, ktorý je sufixom textu, nám jednoznačne určuje všetky prefixy slova, ktoré sú sufixami textu. To vyplýva z toho, že tie sú kratšie -- takže ak sú sufixami textu, musia byť aj sufixami nášho najdlhšieho prefixu.

1. Pre každý prefix slova vieme jeho najdlhší vlastný sufix taký, že je zároveň prefixom slova -- takzvané *spätné linky*.

1. Ak postupne budeme uvažovať prefix, na ktorý ukazuje naša spätná linka, potom prefix, na ktorý ukazuje spätná linka predchádzajúceho prefixu, ... tak vytvoríme postupnosť **všetkých** prefixov slova takých, že sú sufixom nášho najdlhšieho prefixu.

1. Nás zaujíma ich počet. Ak ho pre `i`-ty prefix slova označíme `pocet[i]`, a spätnú linku z `i`-teho prefixu ako `spat[i]`, tak `pocet[i] = pocet[spat[i]] + 1`. Takto vypočítame všetky počty.

1. Ak je najdlhším prefixom celé slovo, tak odrátame od výsledku $1$, nakoľko sme ho zarátali v predchádzajúcom procese, a nemali sme ho zarátať.

Časová aj pamäťová zložitosť sú $O(n)$.
",9
589ecd3859aae5fd,ksp,"# Optimálna šifrovačka

Šifrovačky sú úžasné akcie. Bežne na šifrovačke dostanete nejakú zašifrovanú správu a keď ju vylúštite, dozviete sa, kde sa nachádza ďalšia šifra. Nasleduje presun terénom a ďalšie lúštenie. Je to skvelá možnosť, ako si precvičiť mozgové závity aj nohy.

Mnohí ľudia sa domnievajú, že poriadna šifrovačka nie je ani tak o šifrách, ako skôr o náročnosti trasy. O čo ťažšia je cesta a čím väčšia je šanca na prechladnutie, tým dlhšie sa budú účastníci chváliť svojou účasťou v nej. Ak k tomu pridáte výškové rozdiely, zlé počasie a možnosť zlomiť si pár končatín, dostanete nezabudnuteľnú hru.

Hlavný vedúci KSP sa rozhodol namiesto jesenného sústredenia spraviť najnezabudnuteľnejšiu šifrovačku všetkých čias. Sedemdňovú (a sedemnočnú) šifrovačku umiestnil do Vysokých Tatier. Na jeseň bude určite mokro a skalnaté tatranské končiare budú krásne šmykľavé.

Keď svoj úžasný plán prezradil ostatným vedúcim, nestretol sa s nadšením. Vedúci sa chytali za hlavy a snažili sa ho od toho odhovoriť. No márne. Kocky už boli hodené a jediné, čo ešte mohli spraviť, bolo upraviť cestu tak, aby deti nemuseli nikdy ísť do kopca. Hlavný vedúci si vyprosil aspoň to, aby vzniknutá trasa bola čo najdlhšia.

## Úloha

Máte daný zoznam tatranských križovatiek a zoznam turistických chodníkov medzi nimi. Poznáte nadmorskú výšku každej križovatky a dĺžku každého chodníka. Zistite dĺžku najdlhšej klesajúcej (takej, ktorá neobsahuje stúpania ani roviny) trasy po týchto križovatkách.

Trasa môže začať a končiť na ľubovoľnej križovatke.

## Formát vstupu

Prvý riadok obsahuje dve celé čísla $n$ ($1 \\leq n \\leq 100,000$) a $m$ ($0 \\leq m \\leq 1,000,000$), ktoré udávajú počet križovatiek a počet chodníkov medzi nimi.

Ďalších $n$ riadkov obsahuje jedno číslo $v_i$ ($1 \\leq v_i \\leq 1,000,000,000$), ktoré udáva nadmorskú výšku $i$-tej križovatky (križovatky sa číslujú od jednotky). Všetky nadmorské výšky sú navzájom rôzne.

Ďalších $m$ riadkov obsahuje trojice čísel $x_i$, $y_i$, a $c_i$ ($1 \\leq c_i \\leq 1,000,000,000$), kde $c_i$ je dĺžka chodníka medzi $x_i$-tou a $y_i$-tou križovatkou.

_Vstupy v piatej sade sú pomerne veľké a očakávame, že pomalšie jazyky ako Python a Java nebudú stíhať. Ak používate tieto jazyky, zmierte sa s tým, že pravdepodobne dostanete len 4 body z 5 za program aj pri optimálnej časovej zložitosti. Ešte môžete skúsiť prepísať program do jazyka C++, ten je dosť rýchly._

## Formát výstupu

Vypíšte jedno celé číslo -- dĺžku najdlhšej klesajúcej trasy.

## Príklad

```vstup
6 6
100
50
300
47
20
15
1 3 10
3 2 40
2 1 50
4 2 70
5 3 60
5 6 30
```

```vystup
130
```

*Najdlhšia klesajúca cesta ide postupne po križovatkách 3 - 1 - 2 - 4.*
","# Optimálna šifrovačka

Zopakujme si, ako znie zadanie. Na vstupe máme niekoľko tatranských križovatiek, každú v inej nadmorskej výške. Medzi nimi vedie niekoľko rôzne dlhých chodníkov. Našou úlohou je nájsť čo najdlhšiu cestu, ktorá celý čas klesá.

Celú situáciu si môžeme predstaviť ako graf. Križovatky sú vrcholy a chodníky predstavujú hrany medzi nimi. Uvedomme si však, že po každej hrane môžeme chodiť len jedným smerom -- v smere od vyššie položeného vrchola k tomu nižšiemu. Takéto hrany nazývame orientované. Takisto v tomto grafe nemôžu existovať orientované cykly, lebo by to znamenalo, že v nejakom momente sme porušili podmienku klesania. Graf, ktorý nám zaručuje zadanie, je preto orientovaný a acyklický a zvykne sa označovať ako DAG^[Z anglického directed acyclic graph.].

Skúsme sa teraz pozrieť na to, ako vyzerajú najdlhšie cesty v ňom. Je jasné, že musia začínať vo vrchole, do ktorého nevedie žiadna hrana. V opačnom prípade by sme predsa začali o kúsok vyššie a cestu si predĺžili. Takisto, končiť bude v nejakom vrchole, z ktorého už žiadna hrana nevedie. Oveľa viac však zaručiť nevieme. To však nevadí, pokúsme sa vymyslieť aspoň nejaké prvé riešenie.

## Hľadanie všetkých ciest

Prvá možnosť, ktorá nás môže napadnúť, je vyskúšať všetky možné cesty, ktoré v našom grafe existujú a vybrať z nich tú, ktorá bude mať najväčšiu dĺžku. Myšlienkovo je to samozrejme správne riešenie, aj ked tušíme, že nebude až také rýchle. Keď sa ale zamyslíme, ako by sa niečo také dalo naprogramovať, zistíme, že to nebude také jednoduché. Ukážme si preto, ako naprogramovať toto prvé riešenie a potom si ukážeme, ako ho môžeme zlepšiť.

Ako vôbec vyzerá nejaká cesta? Začneme v niektorom najvyššom vrchole. Odtiaľ pôjdeme jednou z jeho hrán do susedného vrchola. Odtiaľ si opäť vyberieme niektorú z hrán, ktoré z neho vedú a takto budeme pokračovať, až kým sa nedostaneme na spodok. Uvedomme si však, že v každom vrchole, v ktorom sa ocitneme, sme v úplne rovnakej situácii. Chceme sa z neho presunúť všetkými možnými spôsobmi do jeho susedov a odtiaľ pokračovať v hľadaní.

Táto myšlienka je teda vo svojej podstate rekurzívna a to vieme patrične využiť a tak ju aj implementovať. Spravíme si teda funkciu `najdi(v)` s jedným parametrom. Táto funkcia bude mať nasledovnú úlohu: **Prejdi všetky cesty, ktoré vedú z vrchola $v$.**

Nech má vrchol $v$ susedov $w_1, w_2 \\dots w_k$. Ak chceme prejsť všetkými cestami, ktoré vedú z vrchola $v$, tak musíme ísť z vrchola $v$ do vrchola $w_1$ a potom prejsť všetky cesty z tohto vrchola, čo je vlastne len rekurzívne volanie `najdi(w1)`. No a potom musíme tiež ísť z $v$ do vrchola $w_2$ a odtiaľ prejsť všetko, čo je volanie `najdi(w2)`. A tak ďalej pre všetkých susedov vrchola $v$.

Nás však nezaujímajú všetky cesty, ale len tá najdlhšia. Teda chceme **prejsť všetkými cestami vedúcimi z vrchola $v$ a zistiť dĺžku najdlhšej z nich**. Je viacero spôsobov, ako vypočítať túto hodnotu. Mohli by sme si dĺžku aktuálne objavovanej cesty posúvať ako ďalší parameter našej funkcie. Mohli by sme si značiť prejdené vrcholy do pomocného poľa a vždy na spodku cesty pomocou neho vyrátať jej dĺžku. Nám sa však bude hodiť (a podľa mňa je to najelegantnejší spôsob), keď si ju budeme vracať ako návratovú hodnotu tejto funkcie. Naša funkcia `najdi(v)` bude teda vracať dĺžku najdlhšej cesty, ktorá začína vo vrchole $v$.

Túto hodnotu nie je problém vyrátať. Je to maximum z nasledovných hodnôt: dĺžka hrany z $v$ do $w_i$ plus dĺžka najdlhšej cesty z vrchola $w_i$, čo je `najdi(wi)`, postupne pre všetky možné $i$. Vďaka tomu dostávame prvé riešenie, ktorého program nájdete nižšie. Odporúčam podrobnejšie si ho preštudovať.

## Memoizácia

Po odovzdaní tohto riešenia zistíme, že je síce korektné, lebo na prvom vstupe prejde, ale strašne pomalé a na zvyšných prekročí časový limit. To ale neznamená, že postupujeme zle. Možno stačí malá úprava, aby sa naše riešenie zmenilo na vzorové. A ako uvidíte, od vzorového riešenia sa toto skúšanie všetkých možností líši v štyroch riadkoch.

Takmer vždy, keď máme správne, ale pomalé riešenie, (a už tobôž keď ho riešime pomocou rekurzívnej funkcie) oplatí sa položiť si nasledovné otázky: Nepočítame niečo zbytočne? Nepočítame niečo viackrát?

Predstavme si, že máme graf, v ktorom z vrchola $1$ vedie strašne dlhá cesta -- bez odbočiek, jednoducho stále iba jedna možnosť ako sa pohnúť ďalej. Naviac nech existuje veľa vrcholov, do ktorých nevedie žiadna hrana a vychádza z nich jediná hrana do vrchola $1$.

Výpočet nášho programu na tomto grafe vyzerá nasledovne: začnem v jednom z vrchných vrcholov, posuniem sa do vrchola $1$, pričom sa zavolá funkcia `najdi(1)`. Tá zistí, že najdlhšia cesta vedúca z vrchola $1$ má dĺžku $x$, lebo celú túto cestu prejde. Potom si zoberieme druhý vrchol, do ktorého nič nevedie a opäť sa presunieme do vrchola $1$. Potom sa opäť zavolá funkcia `najdi(1)`, ktorá vo svojich volaniach prejde celú tú dlhočiznú cestu nadol, aby nám povedala to, čo už dávno vieme. Teda, že najdlhšia cesta z vrchola $1$ má dĺžku $x$. A toto sa zopakuje ešte niekoľkokrát.

Môžeme si teda všimnúť, že vždy, keď v našom programe zavoláme funkciu `najdi(v)`, dostaneme tú istú hodnotu. Tá sa totiž nemá prečo meniť. Najdlhšia cesta z tohto vrcholu zostane najdlhšou bez ohľadu na to, z ktorého vrchola sme sem prišli. A to platí pre ľubovoľný vrchol $v$. Namiesto toho, aby sme spúšťali funkciu `najdi(v)` viackrát, zapamätáme si, akú hodnotu nám vrátila pri prvom zavolaní. Keď ju budeme chcieť neskôr zavolať znova, jednoducho zistíme, že sme tú hodnotu už vyrátali predtým a vrátime rovno toto vyrátané číslo, čím sa vyhneme celému zbytočnému výpočtu.

Toto celé sa dá implementovať veľmi jednoducho. Vytvoríme si pole `memoizacia[]`, ktoré si bude na $i$-tej pozícii pamätať, aká je najdlhšia cesta vedúca z vrchola $i$. Na začiatku naplníme toto pole hodnotami $-1$ (alebo niečím iným zbytočným). Následne sa funkcia `najdi(v)` vždy po zavolaní najskôr pozrie, čo je v poli `memoizacia[v]`. Ak je tam číslo $-1$, znamená to, že sme túto funkciu pred tým nerátali. Preto pokračujeme rovnako, ako v prvom riešení, akurát si na konci výsledok zapamätáme na pozícii `memoizacia[v]`. Ak je ale v `memoizacia[v]` nejaké nezáporné číslo, vieme, že sme túto funkciu už volali s parametrom $v$ a toto je jej výsledok, ktorý môžeme rovno vrátiť.

Táto technika, ktorá sa volá memoizácia, je naviac veľmi všestranná, lebo sa dá použiť na každú rekurzívnu funkciu. Občas nie až s tak dobrým výsledkom, ale často krát nám to riešenie výrazne zrýchli.

## Zložitosť

Zostáva nám odhadnúť zložitosť tohto riešenia. Uvedomme si, že funkciu `najdi(v)` budeme rátať najviac raz pre každé $v$, lebo pri jej ďalších volaniach už stačí vyberať výsledok z poľa `memoizacia[]`. Počas všetkých týchto rátaní dokopy prejdeme cez každú hranu práve raz, a teda výsledná časová zložitosť bude $O(n+m)$.

Pamäťová zložitosť je rovnaká, lebo si musíme zapamätať celý vstupný graf. No a ako som sľúbil, tu je vzorový program, v ktorom sa oproti pomalému riešeniu zmenili naozaj iba štyri riadky. Odporúčam vám overiť si to ;)
",6
738091ce3243636b,ksp,"# Výtvarný ateliér

Adam a Samo mali už odjakživa vzťah k výtvarnému umeniu, aj keď sa mu nevenujú profesionálne. Obaja išli na vysokú školu študovať nejakú odnož informatiky, no každý na inej univerzite a v inej krajine. Počas svojho štúdia sa aktívne podieľajú na príprave Korešpondenčnej Súťaže Papieroskladania. Keď sa ale naskytla ďalšia aktivita spojená s umením, neváhali a išli do toho.

V rámci medzinárodného a medziuniverzitného projektu výtvarného ateliéru Adam a Samo spolupracujú na vytváraní farebných ozdobných reťazí. Ide o reťaze, ktorých oká sú vyrobené z farebného papiera, pričom farieb je 26. Lenže, obaja už dokončili reťaze, keď zistili, že reťaze by mali byť vlastne rovnaké!

Adam je ale momentálne zahltený inými povinosťami, tak ostáva na Samovi, aby svoju reťaz patrične upravil.

Poraďte mu, ako má upraviť svoju reťaz!

## Úloha

Máte dve reťaze - Adamovu a Samovu. Reťaz má daný začiatok a koniec (neviete ju teda otočiť). Je opísaná postupnosťou farieb ôk od jej začiatku po koniec. Samo má k dispozícii nožnice, fixky, a dokonca aj predpripravené kusiská reťazí, takže vie buď:

- odstrihnúť súvislú časť reťaze a spojiť odstrihnuté miesta dokopy. Reťaz nemôže byť v procese obrátená!
  - z abcd tak môže vzniknúť _acd_, _bcd_, _bc_ ale nie _adc_ alebo _cda_
- vložiť nejaký súvislý kus reťaze medzi dve oká (alebo na koniec alebo začiatok reťaze)
  - z _abcd_ tak môže vzniknúť _ab**bb**cd_, alebo _a**efg**bcd_, alebo _**ksp**abcd_
- prefarbiť oko na inú farbu
  - z _abcd_ tak môže vzniknúť _abc**e**_

Tieto operácie vie Samo ľubovoľne kombinovať.

Chcel by ale, aby bol s výsledkom spokojný. Napríklad so svojou pôvodnou reťazou bol spokojný a je smutný, ak ju musí upravovať. Spokojnosť Samo kvantifikuje nasledovne:

- Za každé nezmenené oko (neodstránené, ani neprefarbené) je o $m$ bodov spokojnejší
- Za každý súvislý odstránený úsek je o $d$ bodov menej spokojný.
- Za každý súvislý vložený úsek je $i$ bodov menej spokojný.
- Za každé prefarbenie oka je o $r$ bodov menej spokojný.

Čísla $i$ a $r$ sú konštanty a nezávisia od dĺžky vloženého, respektíve odstráneného úseku.

Farieb existuje 26 a sú označené malými písmenami anglickej abecedy. Zistite, ako najviac spokojný môže Samo zostať, a nejaký spôsob, ako môže svoju reťaz upraviť.

## Formát vstupu

V prvom riadku vstupu sa nachádzajú štyri čísla:

- číslo, o koľko bude spokojnejší za každé nezmenené oko, $m$
- cena odstránenia súvislej časti ôk $d$,
- cena vloženia súvislej reťaze ôk $i$
- cena prefarbenia oka $r$.

Nasledujú dva riadky. V prvom z nich sa nachádza popis Samovej reťaze a na druhom popis Adamovej reťaze. Oba popisy sú reťazec z malých písmen anglickej abecedy.

Platí, že reťaze nepresahujú dĺžku $5,000$ a $0 \\leq m, d, i, r \\leq 100,000$.

## Formát výstupu

Vypíšte jeden riadok: najväčšiu spokojnosť, ku ktorej sa vie Samo dopracovať.

## Hodnotenie

Úloha má štyri sady. Maximálne dĺžky reťazí v nich budú postupne $500$, $2,000$, $2,000$ a $5,000$.

V druhej sade, navyše platí, $d = i = r = 0$, teda Samo nestráca žiadnu spokojnosť.

## Príklady

```vstup
1 2 2 1
abccb
accba
```

```vystup
0
```

*Samo by mal vymazať prvé oko s farbou 'b' zo svojej reťaze, a pridať oko s farbou 'a' na koniec. Takto sa štyroch svojich ôk nedotkne (+4 body spokojnosti), a raz odstráni 'b' (-2 body) a raz pridá 'a' (-2 body). Všimnite si, že napriek tomu, že je prefarbenie lacnejšie, než vymazanie, neoplatí sa mu.*

```vstup
3 2 2 1
asdffflp
kpfffor
```

```vystup
3
```

*Samo by mal vymazať 'asd' zo začiatku svojej reťaze a pridať tam 'kp'. Na druhej strane, mal by 'lp' zmeniť po jednom na 'or'. Takto bude $-2-2+3+3+3-1-1 = 3$ bodov spokojný*

```vstup
1 1 1 10
kms
ksp
```

```vystup
0
```

*Samo nechce prefarbovať. Najlepšie mu je teda vystrihnúť preč $m$ a pridanie $p$*

```vstup
10 1 1000 100
kspoooksp
kspkspksp
```

```vystup
-240
```

*Samo tu potrebuje zmeniť 'ooo' na 'ksp'. Pridávanie mu výrazne uberá na spokojnosti, tak radšej ich po jednom prefarbí.*
","# Výtvarný Ateliér

Ako si mohol skúsenejší riešiteľ isto všimnúť, úloha sa rieši *dynamickým programovaním*.

Zjednodušene, spočítame si hodnotu výsledku pre menšie časti zadania a skombinujeme aby sme dostali výsledok.

## Pomalé riešenie

Predstavme si, že by sme pre pozície $l$, $j$ vedeli nasledovné:

Koľko najviac spokojnosti vieme dostať, ak by sme mali len prvých $l$ ôk zo Samovej reťaze, a len prvých $j$ ôk z Adamovej reťaze a:

- Samo vymazal nejaký neprádzny koncový úsek svojich ôk. Označme toto číslo ako $D[l][j]$

- Samo na koniec svojej reťaze pridal nejaký neprázdny úsek ôk. Označme toto číslo ako $I[l][j]$

- Samo buď posledné oko nezmenil (ak sú koncové^[koncové v tomto prípade znamená $l$-te Samovo a $j$-te Adamovo oko] oká rovnaké), alebo prefarbil (ak sú rôzne). Označme toto číslo ako $M[l][j]$

Navyše, označme si najväčšiu spokojnosť akú vie Samo dostať pre takéto začiatky reťazí ako $S[l][j]$.

Všimnime si, že $S[l][j] = \\max(D[l][j], I[l][j], M[l][j])$

Predstavme si, že máme spočítanú hodnotu $S$ pre všetky skoršie začiatky (vrátane $S[l][j-1]$ a $S[l - 1][j]$). Ako z toho získať hodnotu $S[l][j]$?

Keďže $S[l][j]$ je minimum z $D[l][j], I[l][j]$ a $M[l][j]$, chceme spočítať tie.

Všimnime si, že

$$ M[l][j] = \\begin{cases} S[l-1][j-1] + m & \\text{ak sú } i \\text{-te Samovo oko a } j \\text{-te Adamovo oko rovnakej farby} \\ S[l-1][j-1] - r & \\text{ak sú rôznej farby} \\ \\end{cases} $$

Pre $I$ a $D$ vieme vyskúšať všetky možné dĺžky pridaného, resp. odstráneného úseku, teda $I[l][j]$ je maximum z $S[l][j-k] - i$, pre všetky $1 \\leq k \\leq j$. A nápodobne pre $D[i][j]$.

Takto vieme postupne prejsť všetky začiatky a napokon nájsť aj riešenie pre celé reťazce v čase $O(|S||A|(|A| + |S|))$, kde $|S|$, $|A|$ sú postupne dĺžky Samovho a Adamovho reťazca, a v pamäti $O(|S||A|)$.

## Ako rýchlejšie?

Chceli by sme zrýchliť naše riešenie. Čo robíme navyše?

Predstavme si, že okrem hodnôt $S$ si pamätáme aj hodnoty $I$, $D$ pre predchádzajúce začiatky. Potom si všimnime, že akonáhle je Samovi lepšie vložiť väčší úsek ako $1$, potom $I[l][j] = I[l][j-1]$. Inak je ideálne vložiť jediné oko, teda $I[l][j] = \\max(I[l][j-1], S[l][j-1] - i)$. Nápodobný vzorec získame pre hodnoty $D$.

Takto nám stačí pre výpočet $S[l][j]$ spraviť konštantne veľa operácií, takže dostávame časovú zložitosť $O(|S||A|)$ s rovnakou pamäťovou zložitosťou ako predtým.

## Ako to ešte zlepšiť?

Čas už nezlepšíme, ale máme tu ešte pamäť. Všimnime si, že pri počítaní $S[l][j]$ sa pozeráme len na hodnoty s indexami najmenej $[l-1][j-1]$. Teda nám stačí si pamätať posledný riadok a stĺpec výpočtu, teda iba lineárne veľa údajov.

Takže dostávame pamäťovú zložitosť $O(|S| + |A|)$.

## Máme to naozaj vyriešené?

A naozaj, v riešení hore sme sa nezmienili čo robiť so $S[l][j]$, keď je jedno z indexov $0$. Schválne, čo jediné môže Samo spraviť ak má on alebo Adam prázdny string?
",8
743f9d9a52ef4b2a,ksp,"# Ondrej odpúšťa

*,,Vyberme si nejaké náhodné číslo, napríklad päť. Hm, to je málo, päťdesiat päť,''* začal Ondrej Demáček vysvetľovanie nového zaujímavého algoritmu na hodine informatiky. Táto programátorská legenda už celé desaťročia nezlyhala v upútavaní pozornosti svojich študentov.

Až na Zaja. Zajo ten algoritmus už totiž poznal a tak sa mimoriadne nudil. Hojdal sa na stoličke, šepkal spolužiakom trápne vtipy, hádzal zožmolené kusy papiera do koša za dverami triedy, skrátka, robil neporiadok. Každému by z toho praskli nervy. Aj Demáčkovi.

*,,Zajo! Vyrušuješ! Tu máš prázdny zošit, mazaj za dvere a napíš doňho všetky prirodzené čísla od jedna po milión.''*

Zajo sklopil uši, zobral zošit do ruky a vyšiel za dvere. Spoza dverí začul ešte Demáčka: *,,Kto túto úlohu vyrieši ako prvý, dostane celú túto tabuľku **čokolády**''*.

*,,Ale no tak,''* pomyslel si Zajo. *,,Zaručene by som to vyriešil prvý. Mohol som mať čokoládu. Keby ten starý... musím sa mu nejako pomstiť... už viem! Keď už má tak rád to číslo **päť**, v tomto zošite ho nenájde. Napíšem sem všetky čísla od jedna po milión, okrem tých, ktoré obsahujú cifru päť. Pche, a načo sa zastavovať na milióne? Však ja mu ukážem!''*

S novým nadšením sa Zajo pustil do práce.

## Úloha

Zajo do svojho zošita píše za sebou prirodzené čísla od 1. Demáček mu dal za úlohu len do milión, Zajo sa však rozhodol, že sa nikdy nezastaví v písaní. Zajo pri tom vynecháva všetky čísla, ktoré obsahujú cifru 5.

Začiatok jeho zošita teda vyzerá takto:

```
1 2 3 4 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 22 23 24 26 27 28 29 ...
```

A keď prelistujeme zopár strán ďalej, tak to vyzerá takto:

```
... 491 492 493 494 496 497 498 499 600 601 602 603 604 606 ...
```

Dostanete číslo $k$. Vašou úlohou je zistiť hodnotu $k$-tej cifry napísanej v Zajovom zošite. Číslujeme od nuly.

## Formát vstupu

Každý testovací vstup obsahuje otázky na niekoľko cifier v Zajovom zošite. Na prvom riadku vstupu sa nachádza počet týchto otázok, celé číslo $n$. Nasleduje $n$ riadkov. V $i$-tom z nich sa nachádza celé číslo $k_i$ -- číslo cifry, ktorá nás zaujíma v $i$-tej otázke. Platí $1 \\leq n \\leq 10^5$ a $0 \\leq k_i \\leq 10^{18}$.

Sú 4 sady testovacích vstupov. Pre jednotlivé sady navyše platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:-----------------:|:--------:|:------------:|:-------------:|:---------:| | $n \\leq$ | $10^3$ | $10^5$ | $10^5$ | $10^5$ | | $k_i \\geq$ | $0$ | $10^9$ | $10^9$ | $0$ | | $k_i \\leq$ | $10^5$ | $10^9 + 256$ | $10^9 + 10^5$ | $10^{18}$ |

**Pozor!** Druhá a tretia sada majú špeciálne limity na $k_i$. Ak aj nevyriešite úlohu optimálne, za kreatívne vyriešenie druhej a tretej sady a následné popísanie vášho postupu môžete získať aj nejaké body za popis.

## Formát výstupu

Vypíšte $n$ riadkov, pričom na $i$-tom riadku má byť hodnota $k_i$-tej cifry v Zajovom zošite.

## Príklady

```vstup
5
0
1
4
17
19
```

```vystup
1
2
6
4
6
```
","# Ondrej odpúšťa

Úlohou bolo čo najrýchlejšie zistiť $k$-tu cifru v Zajovom zošite. Tam sa jedno za druhým nachádzajú všetky prirodzené čísla, v ktorých sa nenáchádza cifra $5$, počínajúc jednotkou.

Keby sme nemuseli vynechávať tú päťku, tak by to bolo ľahšie, nemyslíte?

## Ako sa vysporiadať s päťkou

Vynechávanie päťky nám nerobí až taký veľký problém. V prvom rade si uvedomme, že **vynechávame všetky celé čísla, ktoré obsahujú cifru päť**. Nevynechávame len jednotlivé cifry.

Tým sa dostávame dočinenia s prirodzenými číslami, ktoré sa skladajú z cifier $0, 1, 2, 3, 4, 6, 7, 8, 9$.

Vidíte to? Deväť rôznych cifier. Idú jedna po druhej. Po $2$ ide $3$, po $4$ ide $6$.

**V skutočnosti jednáme s číslami zapísanými v deviatkovej sústave!**

Aby to bolo zrejmejšie, stačí cifry $6, 7, 8, 9$ prepísať na cifry $5, 6, 7, 8$. Tým sa reálne nič nezmení, len sme si premenovali cifry. Teraz už pracujeme s ciframi $0, 1, 2, 3, 4, 5, 6, 7, 8$.

Trošku praktickej ukážky. Poďme zistiť, ktoré číslo (celé číslo, nie len cifra) je $31728$-té v poradí v Zajovom zošite. Najprv musíme zistiť, ktoré prirodzené číslo je $31728$-té v deviatkovej sústave. To zistíme jednoducho tak, že prepíšeme desiatkové číslo $31728\_{10}$ do deviatkovej sústavy. Dostaneme $47463_9$. Teraz sme dostali hľadané číslo, len v skutočnej deviatkovej sústave. Skutočná deviatková sústava v podstate vynecháva cifru $9$, my vynechávame cifru $5$. Preto musíme cifry väčšie ako $4$ zväčšiť o jedna. Hľadaným číslom je teda číslo $48473$.

## Hrubá sila

Najjednoduchšie riešenie je priamočiaré generovanie jednotlivých cifier, až kým nevygenerujeme hľadanú cifru, ktorú následne vypíšeme ako výstup. Postupne ideme cez prirodzené čísla od 1. Každé skonvertujeme do deviatkovej sústavy a dané cifry pripíšeme na koniec poľa, kde si pamätáme všetky cifry v Zajovom zošite v poradí. Cifry väčšie ako $4$ zväčšíme o $1$. Keď sa už v poli nachádza dostatok cifier, aby sme vedeli zodpovedať otázku na vstupe, prestaneme generovať a vypíšeme odpoveď. Keďže cifry v Zajovom zošite sú vždy také isté, dané pole cifier si môžeme pamätať medzi otázkami, čím si ušetríme kopu času, ktorý by sme zabili generovaním tých istých cifier viac krát.

**Aká je časová zložitosť tohto riešenia?** Každú cifru musíme osobitne vygenerovať a umiestniť do poľa. Ak chceme povedať ako vyzerá $k$-ta cifra, musíme vygenerovať všetkých prvých $k$ cifier. Keďže si však pole pamätáme medzi otázkami, každú cifru vygenerujeme len raz. Časová zložitosť je preto $O(n + k)$, kde $n$ je počet otázok a $k$ je maximálna cifra v otázke.

Takáto časová zložitosť je dostatočná pre prvú sadu vstupov. Je však celkom zrejmé, že pri $k = 10^{18}$ nám to už stačiť nebude.

## Chytré triky na druhú a tretiu sadu

V zadaní bolo napísané, že druhú a tretiu sadu vstupov sa dalo riešiť nejakými trikmi. A je to pravda!

**V druhej sade** si musíme všimnúť dôležitú vec: existuje len $257$ možných otázok. Môžeme si teda všetky tieto vstupy dopredu predrátať na vlastnom počítači s neobmedzeným časovým limitom. Potom ich napíšeme priamo do zdrojového kódu programu a okamžite ich vypíšeme na požiadanie.

**V tretej sade** tiež nie je veľa možných vstupov: $10^5$. To už je však priveľa na to, aby sme ich písali na tvrdo do zdrojového kódu. Všimnime si však inú vec. Máme dočinenia s ciframi s indexami od $10^9$ do $10^9 + 10^5$. *Všetky cifry sa nachádzajú vnútri 9-ciferných čísel v Zajovom zošite.* (Ak neveríte, overte si). Spočítaním počtov cifier v jednotlivých rádoch (jednociferné, dvojciferné, ...) vypočítame, že prvá cifra nachádzajúca sa v prvom 9-cifernom čísle je cifra číslo $338992928$.

A teraz prichádza veľká myšlienka. Jednáme iba s ciframi 9-ciferných čísel a vieme, ktorá cifra je prvá cifra prvého 9-ciferného čísla. Teda, keď dostaneme číslo cifry, ktorú máme vypísať, vieme ľahko vypočítať, v ktorom 9-cifernom čísle sa táto cifra nachádza.

Napríklad, povedzme, že máme vypísať cifru číslo $1000008371$. Odčítaním $1000008371 - 338992928 = 661015443$ zistíme, koľkatá cifra v 9-ciferných číslach to je. Teraz, keďže všetky 9-ciferné čísla sú rovnako dlhé, celočíselným delením $661015443 / 9 = 73446160$ vypočítame, v koľkatom 9-cifernom čísle sa táto cifra nachádza. Je to číslo $263173164$ (v deviatkovej sústave). Ako sme už raz spravili, keďže my vynechávame cifru $5$, poposúvame všetky cifry väčšie ako $4$ o jedna a jedná sa teda o číslo $273183174$ v Zajovom zošite. Ďalej, pomocou zvyšku po delení $661015443 \\mod 9 = 3$ ľahko zistíme, že hľadaná cifra je štvrtá v danom čísle. Správna odpoveď je teda $1$.

## Vzorové riešenie

Od triku, ktorý sme použili v tretej sade nám ostáva už len krôčik k vzorovému riešeniu. V tretej sade nám pomohlo, že sme vedeli koľko ciferné je číslo, v ktorom sa nachádza hľadaná cifra. **Nevedeli by sme túto informáciu vypočítať pre ľubovoľnú cifru?** Samozrejme, vedeli.

Stačí, keď si predpočítame indexy prvých cifier v každom ráde: v 1-ciferných, 2-ciferných, 3-ciferných, a tak ďalej, až po 18-ciferné (s väčšími totiž nebudeme mať do činenia). Potom, keď dostaneme index cifry, ktorej hodnotu máme vypísať, stačí zistiť, medzi ktorými dvoma začiatkami sa jej index nachádza a podľa toho zistíme, v koľkocifernom čísle ju hľadať. Napríklad, cifra s indexom $4321$ sa nachádza v nejakom 4-cifernom čísle, pretože prvá cifra zo štvorciferného čísla má index $2096$ a prvá cifra 5-ciferného čísla má index $25424$. Index $4321$ sa nachádza medzi týmito dvoma začiatkami, preto vieme, že sa jedná o cifru 4-ciferného čísla.

Keď zistíme, v koľkocifernom čísle sa hľadaná cifra nachádza, použijeme rovnaký postup, ako pri tretej sade, len ho zovšeobecníme na ľubovoľný počet cifier.

### Časová zložitosť

Aká je časová zložitosť tohoto riešenia? Pre každú otázku potrebuje spraviť tri veci:

1. Nájsť rád čísla, v ktorom sa nachádza daná cifra.
1. Vypočítať, v ktorom čísle sa daná cifra nachádza.
1. Vypočítať, koľkatá cifra to je, čím už vieme vypočítať konkrétnu cifru.

Časová zložitosť krokov 2. a 3. je jasná: $O(1)$. Koľko nám trvá nájsť rád cifry? Vzhľadom na limity na veľkosť vstupu, počet možných rádov je najviac $18$. Pre zjednodušenie môžeme teda povedať, že nájsť rád trvá $O(1)$.

Pokiaľ by však veľkosť čísel na vstupe bola neobmedzená, museli by sme započítať aj nejaké logaritmy navyše. Takéto logaritmy by sme však museli potom započítať aj do krokov 2. a 3.

Celková časová zložitosť je teda $O(n)$.
",5
ce1e26c3376b1194,ksp,"﻿# Zobudená programátorka

Kamila má rada kávu. Rokmi pokusov zistila presný objem kávy, pri ktorom sa jej pracuje najlepšie. Dnes sa dozvedela, že má náročnú domácu úlohu, ktorú treba rýchlo odovzdať, a potrebuje sa posilniť. Zamierila teda ku svojej zbierke výberových káv. Kávy v zbierke sú uskladnené v rôzne veľkých vrecúškach: každé vrecúško je dvakrát väčšie ako to pred ním, počínajúc vrecúškom s hmotnosťou 1 gram. To znamená, že v zbierke má vrecúška s váhami $1, 2, 4, 8, \\dots, 2^n$ gramov. Ako v každej správnej zbierke, aj v tej Kamilinej je vrecúško každej veľkosti práve raz.

Ktoré vrecúčka má Kamila vybrať aby dosiahla svoju vytúženú hladinu kofeínu?

## Úloha

Na vstupe dostanete $n$ -- potrebnú hmotnosť kávy a máte zistiť, ktoré z vrecúšok má Kamila zobrať, ak chce mať presne $n$ gramov kávy.

## Formát vstupu

Vstup má jeden riadok a v ňom jedno celé číslo $n$. Môžte predpokladať, že $1 \\leq n \\leq 10^{18}$.

## Upozornenie

Dajte si pozor na to, že váš program musí pracovať aj s hodnotami, ktoré sa **nezmestia** do bežnej (32-bitovej) celočíselnej premennej. Na ich uloženie potrebujete použiť premennú s dostatočne veľkým rozsahom -- napríklad `int64` v Pascale alebo `long long` v C++.

Takisto si dajte pozor, že súčin dvoch 32-bitových premenných vráti 32-bitové číslo bez ohľadu na to, či sa tam výsledok zmestí. T.j. `x := 1000000 * 1000000` uloží do `x` hodnotu `1420103680` bez ohľadu na to, či `x` je `int64` alebo `longint`.

## Formát výstupu

Vypíšte jediný riadok a v ňom použité vrecúška oddelené medzerou v poradí od najmenšieho po najväčšie.

Nezabudnite ukončiť riadok znakom konca riadku. Teda napríklad v Pascale vypíšte výsledok volaním `writeln(vysledok)`, v C++ zase volaním `cout << vysledok << endl`.

## Príklad

```vstup
20
```

```vystup
4 16
```

```vstup
35
```

```vystup
1 2 32
```
","#Zobudená Programátorka

Úloha sa dá riešiť dvoma spôbmi, buď vrecúška prechádzame od najmenších po najväčšie alebo naopak. Formát výstupu (tam vypisujeme čísla od najmenších) nám napovedá, ktorý spôsob bude asi jednoduchší.

Celý algoritmus je veľmi jednoduchý -- ak je celková hmotnosť nepárna, musíme použiť vrecúško s hmotnosťou $1$, ak je hmotnosť párna tak vrecúško použiť nesmieme. Po prípadnom odčítaní najmenšieho vrecúška nám ostalo párne číslo a tiež hmotnosti všetkých ostatných vrecúšok sú párne. Preto môžeme imaginárne zmenšiť všetky hmotnosti na polovicu a zrazu riešime tú istú úlohu len s menšími číslami.

Algoritmus bude teda opakovane kontrolovať paritu čísla zo vstupu. Keď je číslo v $i$-tom kole nepárne, vypíše hmotnosť $i$-teho vrecúška a po každej kontrole vydelí číslo zo vstupu dvoma.

Koľkokrát môžeme vydeliť číslo $n$ dvoma, kým dostaneme jednotku? Správna odpoveď je $\\log_2(n)$ (dvojkový logaritmus z $n$), pretože $\\log_a(a^x) = x$^\[Logaritmus $n$ pri základe $a$ zapisovaný ako $\\log_a(n)$ má nasledovný význam: číslo, na ktoré musíme umocniť $a$, aby sme dostali hodnotu $n$. Preto $\\log_2(8)=3$ a $\\log\_{10}(100)=2$. No a to, čo používame, je vzťah $a^{\\log_a(n)}=n$. Inými slovami, ak umocníme číslo $a$ na **číslo, na ktoré musíme umocniť $a$ aby sme dostali $n$**, dostaneme $n$.\]. Preto algoritmus skončí po $O(\\log n)$ krokoch. Časová zložitosť je teda $O(\\log n)$ a pamäťová $O(1)$, pretože si stačí pamätať zopár čísel.

Všimnime si, že každé prirodzené číslo sa dá zapísať ako súčet rôznych mocnín dvojek. Tento rozklad je skoro to isté ako prevod čísla do dvojkovej (binárej) sústavy.
",2
4afc3caff8e4a22e,ksp,"# Kreslenie stromov

""Let's make some happy little trees,"" povedal Bob Ross[^1] a začal kresliť stromy na plátno. Inšpirovaná týmto známym umelcom, zobrala Paulínka svoje obľúbené voskovky a začala kresliť stromy na papier.

Paulínka rada kreslí zakorenené informatické stromy, a aby bol výsledný obrázok čo najkrajší, musia byť všetky stromy rôzne a zároveň musia všetky pochádzať z rovnakého materského stromu. (Potom môže obdivovateľom umenia hovoriť, že stromy majú spoločnú dušu.) V časti _úloha_ hneď vysvetlíme, čo to znamená.

Pomôžte Paulínke zistiť, koľko najviac stromov, môže nakresliť, aby splnila želané podmienky. A nezabudnite, keby sa vám to aj na prvý pokus nepodarilo, Bob Ross má pre vás jednu múdrosť: ""We don't make mistakes, we have happy accidents.""

\[^1\]: Príklad Bobovej tvorby nájdete na [youtu.be/0n4f-VDjOBE](https://youtu.be/0n4f-VDjOBE).

## Úloha

_Informatický strom_ (ďalej len _strom_) je množina $n$ vrcholov a $n-1$ hrán, taká, že z každého vrcholu do každého vedie práve jedna cesta. _Zakorenený informatický strom_ (ďalej len _zakorenený strom_) je strom, v ktorom sme jeden vrchol vybrali ako koreň.

Zo stromu vieme vytvoriť $n$ zakorenených stromov tak, že postupne označíme každý z $n$ vrcholov ako koreň (viď obrázok pri prvom príklade vstupu).

Pre tieto zakorenené stromy si zavedieme nový pojem, _rovnakosť_, ku ktorému opačný pojem je _rôznosť_. Zakorenené stromy budeme volať _rovnaké_, keď sa líšia len v označení vrcholov a v poradí synov každého vrcholu. T.j. pokiaľ dovolíme ľubovoľne prehadzovať poradie synov, vieme pretvoriť jeden strom na druhý. Pokiaľ sa takto nedajú pretvoriť, tak uvažujeme, že sú stromy _rôzne_.

Formálna definícia by mohla byť nasledovná: Dva zakorenené stromy voláme _rovnaké_, ak existuje bijektívne zobrazenie^[každému vrcholu prvého stromu je priradený práve jeden vrchol z druhého stromu] $f$ vrcholov jedného stromu na vrcholy druhého stromu, také že pre všetky $x,y$ platí, že $x$ je otec $y$ práve vtedy, keď $f(x)$ je otec $f(y)$.

Na obrázkoch môžeme vidieť príklady troch stromov, z ktorých prvé dva sú _rovnaké_ a tretí je od oboch _rôzny_. Zobrazenie, ktoré spĺňa formálnu definíciu je $1,2,3,4,5,6,7,8 \\rightarrow 8,7,6,5,4,1,2,3$, ale aj $1,2,3,4,5,6,7,8 \\rightarrow 8,7,6,5,4,3,2,1$

Na vstupe máte zadaný strom. Vypíšte koľko najviac navzájom _rôznych_ zakorenených stromov môžeme dostať označením niektorého vrcholu tohto stromu ako koreň.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ -- počet vrcholov zadaného stromu. Vrcholy sú očíslované $1$ až $n$.

Na nasledujúcich $n-1$ riadkoch su vymenované hrany zadaného stromu, na každom riadku sú čísla dvoch vrcholov, $a_i, b_i$, ktoré táto hrana spája. $1\\leq a_i, b_i \\leq n$

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet _rôznych_ zakorenených stromov, ktoré dostaneme, ak postupne každý z vrcholov označíme ako koreň.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:--------------- | --: | --: | --: | --: | --: | --: | --: | --: | | $2 \\leq n \\leq$ | $10$ | $100$ | $100$ | $1,000$ | $1,000$ | $50,000$ | $100,000$ | $300,000$ |

## Príklady

```vstup
4
1 2
2 3
3 4
```

```vystup
2
```

_Ak strom zakoreníme za prvý alebo posledný vrchol, dostaneme rovnaký strom. Podobne dostaneme rovnaké stromy, ak ho zakoreníme za druhý alebo tretí. Vieme teda nakresliť dva rôzne zakorenené stromy._

_Na obrázku nižšie môžeme vidieť, aké stromy dostaneme, pokiaľ zakoreníme vstupný strom postupne vo vrcholoch $1, 2, 3, 4$_

```vstup
11
1 2
2 3
3 4
4 5
4 6
4 7
5 10
10 9
10 8
7 11
```

```vystup
10
```

```vstup
7
7 1
7 2
3 2
7 4
5 4
6 5
```

```vystup
7
```
","# Kreslenie stromov

To, čo sme v zadaní volali _rovnakosť_ sa v informatike zvykne nazývať _izomorfizmus_. Ďalej teda budeme hovoriť, že dva zakorenené stromy sú **_izomorfné_**, ak existuje bijektívne zobrazenie $f$ vrcholov jedného stromu na vrcholy druhého stromu, také že pre všetky $x,y$ platí, že $x$ je otec $y$ práve vtedy, keď $f(x)$ je otec $f(y)$. (Toto je rovnaká definícia ako v zadaní, len na pripomenutie.)

Intuitívna predstava izomorfizmu je, že zodpovedajúce vrcholy sa môžu líšiť len v poradí synov. Toto je dôležité mať na pamäti.

Mimochodom, keď máme zakorenený strom za koreň $v$, tak stromy, ktorých korene sú synovia $v$, budeme volať podstromy tohto stromu, alebo podstromy koreňa, alebo podobne. Občas budeme zamieňať pojmy podstrom a vrchol, väčšinou by malo byť jasné, že ide o tú istú vec. Ak napríklad označíme vrchol $u$ nejakým číslom, tak toto číslo obvykle hovorí niečo o celom podstrome.

## Obsah

Riešenie si rozdelíme na niekoľko častí:

V prvej časti sa pozrieme na to, ako algoritmicky spočítať, či ľubovoľné dva stromy sú izomorfné. Ukážeme si tri spôsoby, jeden z nich ilustruje podstatu zvyšných dvoch spôsobov, avšak je pomalý. Zvyšné dva implementujú túto podstatu efektívne, či už pomocou hashovania alebo pomocou iných techník. Obe rýchlejšie riešenia budú vedieť porovnať dva stromy v čase $O(n)$, hoci v jednom prípade si podrobne rozoberieme iba jednoduchšiu $O(n \\log n)$ variantu.

V druhej časti sa pozrieme, ako zovšeobecniť algoritmus z dvoch stromov na izomorfizmus $n$ stromov, a následne ako pomocou toho vyriešiť samotnú úlohu v celkovom čase $O(n)$ resp. $O(n\\log n)$.

Na plný počet bodov za popis úlohy stačí časová zložitosť $O(n\\log n)$ a zároveň žiaden riešiteľ neodovzdal popis deterministického riešenia so zložitosťou $O(n)$, takže nebudú ani bonusové body ;)

## Izomorfizmus dvoch stromov -- naivné riešenie

Stromy porovnávať zatiaľ nevieme, ale napríklad také reťazce znakov vieme porovnávať celkom dobre. Čo keby sme každý strom zapísali ako reťazec znakov? Celkom štandardný zápis zakoreného stromu je: _ľavá zátvorka, zreťazené zápisy všetkých podstromov koreňa, pravá zátvorka_.

Napríklad jednovrcholový strom, má zápis ""()"", trojvrcholový binárny strom má zápis ""(()())"", reťaz vysoká 3 má zápis ""((()))"". Na obrázku môžete vidieť pri každom vrchole zápis zodpovedajúceho podstromu.

Žiaľbohu a niekedy aj chvalabohu, izomorfné stromy môžu mať rôzny zápis, lebo v tomto zápise záleží na poradí podstromov. Tento problém však ľahko vyriešime, nasledovnou zmenou. Nový zápis zakoreneného stromu bude: _ľavá zátvorka, zretazené **abecedne zoradené** zápisy všetkých podstromov koreňa, pravá zátvorka_.

Dôkaz, že s touto definíciou, dva stromy majú rovnaký zápis práve vtedy, keď sú izomorfné, necháme ako cvičenie pre čitateľa. Na obrázku môžeme vidieť príklad pre dva izomorfné stromy.

Skonštruovať zápis celého stromu nám môže v najhoršom prípade (dlhá reťaz) trvať až $O(n^2)$. Porovnať dva zápisy a tým overiť izomorfizmus stromov potom vieme už v lineárnom čase.

## Izomorfizmus dvoch stromov -- hashovanie

Celý problém predošlého algoritmu je, že zápis stromu je potenciálne veľmi dlhý reťazec. Čo keby sme dokázali celý strom zapísať ako jedno číslo? Na základe predošlej úvahy by toto číslo malo byť rekurzívne definované cez podstromy a zároveň nezávislé od poradia podstromov.

Ako riešenie sa nám ponúka nasledovná hashovacia funkcia. Hash stromu $T$ bude $$H_T = chaos(S \\mod M) = chaos\\left(\\left(\\sum\_{t\\in P(T)} H_t\\right) \\mod M\\right)$$

kde $P(T)$ je zoznam podstromov stromu $T$, resp. $S$ je súčet hashov podstromov stromu $T$. $M$ je nejaké prvočíslo, ktorým modulujeme, aby nám udržala rozumná veľkosť čísel. $chaos$ je funkcia, ktorá pre každý vstup z ${0..M}$ vráti iný náhodný výstup z ${0..M}$.

Čo prosím? (Sa právom pýtate). V prvom rade súčet hashov podstromov je jednoduchý spôsob, ako zabezpečiť, aby nezáležalo na poradí podstromov. Potom ale potrebujeme, aby sa hashovacia funkcia nesprávala lineárne (t.j. zväčšenie nejakého zo vstupov o $x$ zväčší výstup o $kx$), lebo to by sa nám ľahko stalo, že presun jedného vrchola z jedného podstromu do iného by nemuselo zmeniť hash (na jednom mieste $+kx$, na inom $-kx$, výsledok rovnaký), hoci by zmenilo izomorfizmus. A čo sa správa menej lineárne ako random?

Funkciu chaos môžeme implementovať lazy spôsobom -- keď nám príde nový vstup, aký sme ešte nevideli, vygenerujeme si nový náhodný výstup a zapamätáme si ho. Ak nám príde vstup, aký už sme niekedy videli, vrátime zapamätanú hodnotu. Buď si môžeme dávať explicitne pozor, aby sme vždy vygenerovali iný výstup, alebo pokiaľ $M >> n^2$, je pomerne malá šanca, že by nastala kolízia.

S touto hashovacou funkciou, dva izomorfné stromy majú vždy rovnaký hash, a dva neizomorfné stromy majú s veľkou pravdepodobnosťou rôzny hash. Stále môže nastať neželaná kolízia, ale tak to pri hashovacích algoritmoch často býva a tak v princípe iba nastavíme dostatočne veľké $M$ a dúfame, že to bude fungovať.

Spočítať hash celého podstromu dokážeme rekurzívne v čase $O(n)$

## Izomorfizmus dvoch stromov -- labely a AHU

Ak sa nechceme spoliehať na náhodu, môžeme skúsiť nájsť iný spôsob, ako každému stromu priradiť jedno číslo, nazvime ho label (čítaj lejbl).

Pre spočítanie labelu stromu najprv rekurzívne spočítame labely všetkých podstromov, a zoberieme utriedený zoznam týchto labelov. Napríklad, pre list stromu (ktorý nemá žiadnych potomkov) dostaneme prázdny zoznam []. Ak má koreň stromu 5 synov s labelami 2,11,4,2,4, dostaneme zoznam [2,2,4,4,11].

Vždy, keď dostaneme takto utriedený zoznam, buď vidíme takýto zoznam prvýkrát a pridelíme mu najmenšie nepoužité prirodzené číslo ako label, alebo sme už zoznam videli a tak použijeme rovnaký label ako naposledy. Tu je príklad ako by vyzerali labely pre ukážkový strom a jeho podstromy. (Labely číslujeme od nuly).

Ako vieme efektívne priraďovať, labely zoznamom? Napríklad pomocou mapy (vyvažovaný binárny strom), kde zoznam bude kľúč a label bude hodnota. Na utriedenie zoznamu labelov podstromov a tiež vyhľadanie zoznamu v mape potrebujeme čas $O(p \\log p)$, kde $p$ je dĺžka zoznamu, resp. počet potomkov vrchola. Keďže súčet počtu potomkov pre všetky vrcholy stromu je $n-1$, celkový čas je $O(n \\log n)$.

Veľmi podobne funguje AHU algoritmus (Aho, Hopcroft and Ullman), čo je štandardný a asi najznámejší algoritmus na overenie izomorfizmu dvoch stromov. Tento algoritmus používa fakt, že dva stromy môžu byť izomorfné, iba ak majú rovnakú hĺbku (môžete si nechať chvíľku na zamyslenie, prečo je to tak). Potom izomorfizmus overujeme iba pre stromy s rovnakou hĺbkou, nech je to $h$. Najprv spočítame labely pre vrcholy v hĺbke $h$, potom pre vrcholy v hĺbke $h-1$, atď. až po koreň. Na jednej úrovni vždy najprv spočítame všetky zoznamy a potom im naraz priradíme labely postupne od nuly. V AHU algoritme, môžeme použiť v rôznych hĺbkach ten istý label.

Vďaka tomu, že labely počítame po vrstvách, môžeme naraz skonštruovať v čase $O(p)$, kde $p$ je počet vrcholov vo vrstve. Celý algoritmus potom beží v čase $O(n)$. Detaily sú nad rámec tohto vzoráku ale aspoň stručné zhrnutie je, že lexikograficky triedime samotné utriedené sekvencie labelov pomocou zovšeobecného radix-sortu pre rôzne dĺžky sekvencií a potom priradíme nové labely podľa tohto poradia. Jednotlivé sekvencie nemusíme triediť, lebo ich už konštruujeme v utriedenom poradí, a to tak, že spracúvame synov vrcholov na vyššej vrstve od najmenších labelov po najväčšie.

Ak vás to zaujíma a viete po anglicky, celý algoritmus na overenie izomorfizmu dvoch stromov je popísaný v knižke [The Design and Analysis of Computer Algorithms z roku 1974](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/The%20Design%20and%20Analysis%20of%20Computer%20Algorithms%20%5BAho,%20Hopcroft%20&%20Ullman%201974-01-11%5D.pdf), strana 84-85, example 3.2.

## Izomorfizmus $n$ stromov.

Ak máme $n$ zakorenených stromov a každý z nich má $n$ vrcholov, môžeme pomocou predošlých algoritmov spočítať zápis, hash, alebo label každého z nich, a potom overiť, koľko rôznych zápisov, hashov, resp. labelov vidíme. Toto vieme spraviť v čase $O(n^3)$ resp. $O(n^2)$, pretože zápis, hash, resp. label každého so stromov vieme spočítať v čase $O(n^2)$ resp. $O(n)$.

Riešenie, založené na tomto princípe, pokiaľ ako základ algoritmu použijeme hashovanie by mohlo vyzerať takto:

Posledné dve časti vzoráku sa budú zaoberať tým, ako to spraviť rýchlejšie.

## Vzorové riešenie -- hashovaie

Máme teda nezakorenený strom a chceme vedieť, aký hash by mali všetky jeho zakorenené verzie. Označme si hash vrcholu $u$ v strome zakorenenom za vrchol $v$ ako $H_v(u)$. Označme si tiež súčet hashov potomkov vrchola $u$ v strome zakorenenom za vrchol $v$ ako $S_v(u)$. Ak si ešte pamätáme definíciu našej hash funkcie, tak

$$H_v(u) = chaos(S_v(u))$$

Zakoreňme si náš strom najprv za vrchol 1 a spočítajme všetky hashe s týmto koreňom, čiže $H_1(v)$ pre všetky $v$.

Následne pre vyriešenie úlohy nám stačí vedieť $H_v(v)$ pre všetky $v$, a to vieme spočítať pomerne jednoducho. Vačsinu informácie potrebnú na spočítanie už máme. Pokiaľ $u$ je predok $v$ (v strome zakorenenom za vrchol 1) a $w_1..w_k$ sú potomkovia vrchola $u$ okrem $v$, tak platí, že

$$H_1(w_i) = H_v(w_i)$$

pre všetky $i\\in {1..k}$. Je to kvôli tomu, že podstromy pod $w_i$ neobsahujú ani vrchol $v$ ani vrchol $1$, a teda je ich podoba rovnaká pri zakorenení či už za $v$ alebo za $1$.

Zároveň z definície našej hash funkcie vieme, že:

$$H_1(u) = chaos(S_1(u)) = chaos\\left(H_1(v) + \\sum\_{i=1}^k{H_1(w_i)}\\right)$$

$$H_v(u) = chaos(S_v(u)) = chaos\\left(\\sum\_{i=1}^k{H_1(w_i)}\\right) = chaos(S_1(u) - H_1(v))$$

$$H_v(v) = chaos(S_1(v)+H_v(u)) = chaos\\left(S_1(v)+chaos(S_1(u)-H_1(v))\\right) $$

Na ľavej strane je to, čo chceme vedieť a na pravej sú informácie spočítané v strome zakorenenom za prvý vrchol. Implementácia sú dve po sebe spustené rekurzívne prehľadania stromu (`dfs_1` a `dfs_2`). Časová zložitosť je $O(n)$, pamäťová tiež $O(n)$

## Vzorové riešenie -- labely a AHU

Našim cieľom je efektívne všetkým $n$ zakoreneným stromom, a všetkým vrcholom (tieto zodpovedajú menším stromom pod vrcholmi) v nich priradiť labely (čísla) také, že dva stromy majú rovnaké číslo práve vtedy, keď sú izomorfné.

Podobne ako v predošlej časti, label vrcholu $u$, pokiaľ je celý strom zakorenený za $v$, budeme volať $L_v(u)$.

Zdalo by sa, že takto musíme skonštruovať potenciálne $n^2$ labelov, ale v skutočností môže existovať najviac $3n$ rôznych labelov, resp. stromov. Jeden label má každý vrchol ak je koreňom a najviac jeden ďalší label za každého suseda (ak by daný sused bol otcom vrchola). Dokopy majú všetky vrcholy v strome $2n-2$ susedov. Vôbec nás ale nezaujíma, aké labely by dostali nejaké úplne iné stromy, mimo týchto $3n$ stromov, a to nám dá trocha slobody.

Vo vzorovom riešení s hashovaním, sme v podstate riešili problém, že na spočítanie labelu vrcholu $v$ potrebujeme spočítať label vrcholu $u$ a naopak, ale obišli sme to dvoma dfs prechodmi a odčítavaním hashov. Iný spôsob je skúsiť nájsť nejaký jedinečný vrchol $v$ taký, že strom zakorenený vo $v$, nie je izomorfný so žiadnym iným stromom. Takýmto jedinečným vrcholom je centrum stomu, ktoré si hneď vysvetlíme.

Priemer stromu je vzdialenosť najvzdialenejších vrcholov v strome, resp. dĺžka najdlhšej cesty v strome. Na chvíľu ignorujme stromy s priemerom nepárnej dĺžky, neskôr sa k nim vrátime. Ak je priemer stromu párny, tak existuje takzvané centrum, čo je stred najdlhšej cesty. Aj keď najdlhších ciest môže byť viac, centrum je vždy jednoznačné (zamyslite sa prečo). Označme si centrum nášho stromu $c$.

Ak zakoreníme strom za centrum, dostaneme najplytšie možné zakorenenie a navyše strom zakorenený za vrchol $v$ má hĺbku rovnú vzdialenosti $v$ od $c$ plus hĺbka pri zakorenení za $c$. Z tohto vyplýva zaujímavá vec -- ak majú byť dve zakorenenia stromu izomorfné, musia byť ich korene rovnako vzdialené od centra.

Druhá, dôležitejšia, vec je, že strom zakorenený za centrum nie je izomorfný so žiadnym iným stromom. $L_c(c) \\neq L_v(u)$ pre žiadne $(v, u) \\neq (c, c)$. Pre $v=u$ nesedí hĺbka a pre ostatné nesedí počet vrcholov. Dokonca, ak aj strom zakoreníme za hociaký vrchol, tak $L_v(c) \\neq L_v(u)$ pre $c\\neq u$. Opäť dôvod je jednoduchý -- všetky ostatné stromy pod $v$ musia mať inú hĺbku a teda nemôžu byť izomorfné.

S týmito pozorovaniami by sme mali vedieť zvoliť takú definíciu $L_v(u)$, ktorá sa dá ľahko spočítať a zároveň dostatočne spĺňa izomorfickú podmienku (až na jednu výjnimku, viď nižšie).

Definujme si $L_v(c) = -1$ pre všetky $v$, inak povedané, dáme centru label, ktorý nepoužijeme nikde inde. Pre všetky ostatné stromy použijeme na definíciu labelu postup, ktorý poznáme zo sekcie _Izomorfizmus dvoch stromov - labely a AHU_.

$$L_v(u) = m(S_v(u))$$

kde $S_v(u)$ je utriedený zoznam labelov synov $w$ vrchola $u$ za predpokladu, že $v$ je koreň. $m$ je funkcia, ktorá na vstupe dostane zoznam celých čísel a na výstupe vráti jedno prirodzené číslo. Funkcia $m$ vracia rovnaké čísla pre rovnaké zoznamy, a rôzne čísla pre rôzne zoznamy (inak povedané $m$ je prostá funkcia). Implementácia takéhoto niečoho je jednoduchá pomocou mapy alebo hash-mapy (python vie dobre hashovať tuples).

Výstupom algoritmu je počet rôznych hodnôt $L_v(v)$, ktoré spočítame podobne ako v predošlej sekcii, zakoreníme strom za $c$ a dvakrát ho prejdeme pomocou `dfs`.

No počkať, ale strom pod $c$ môže vyzerať inak pre rôzne korene, prečo môžeme mať všade rovnakú hodnotu $L_v(c) = -1$? Všimnime si, že stromy zodpovedajúce $L_v(c)$ a $L_u(c)$ sú izomorfné práve vtedy, keď sú izomorfné stromy zodpovedajúce $L_c(v)$ a $L_c(u)$ (cvičenie pre čitateľa). Vďaka tomu, že pre výpočet $L_v(v)$ používame aj $S_c(v)$, tak nám jedna hodnota $L_v(c)$ nikdy nespraví problém.

A čo ak strom na vstupe nemá centrum? (T.j. priemer stromu má párnu dĺžku). V takom prípade je v strede jedinej najdlhšej cesty hrana. Do stredu tejto hrany pridáme nový vrchol, ktorý bude centrum. Vďaka tomu, že toto nové centrum je opäť unikátne (z hľadiska izomorfizmu), ostane všetko v poriadku. Ak v pôvodnom strome boli nejaké dva zakorenené stromy izomorfné, tak aj v strome s pridaným centrom budú izomorfné. Nesmieme však zabudnúť z výslednej odpovede odpočítať jednotku, lebo sme pridali jeden nový koreň, iný od všetkých ostatných.

Časová zložitosť riešenia je $O(n \\log n)$, ale podobne ako pri AHU algoritme, môžeme počítať labely po vrstvách, viď. popis AHU algoritmu vyššie, a dokážeme v lineárnom čase od počtu vrcholov na o jedna hlbšej vrstve spočítať všetky labely pre danú vrstvu. Takéto riešenie má časovú aj pamäťovú zložitosť $O(n)$.

Pri doprogramovaní si dávajte pozor, že vzorové riešenie v Pythone sa nemusí zmestiť do časového limitu, obzvlášť ak máte $O(n\\log n)$ časovú zložitosť. Vzorák v C++ zbehne s prehľadom a naše hashovacie riešenie v Pythone tiež v pohode prejde.
",9
e25b3c91ace45649,ksp,"# Centrifúgy sa dotočia

V útrobách švajčiarskych hôr, na nevypátrateľnom mieste, prebieha každoročné zasadnutie Konzorcia Svetového Poriadku. Postavy zahalené v tme sedia po obvode kruhového stola a v miestnosti sa ozýva iba kovové chrapčanie modifikátorov hlasu. Svet čelí veľkým výzvam, imigrácii či globálnemu otepľovaniu, oni sú tu však na to, aby zabraňovali oveľa vážnejším, skrytým hrozbám.

Najnovšie správy od agentov v utajení uvádzajú rozmah nelegálnych centier spracovávajúcich rádioaktívny materiál. A je jasné, že takto získaný obohatený urán má len jediný cieľ. Je na čase, aby KSP zakročilo. Ich zásah musí však byť nenápadný. Nemôžu si predsa dovoliť, aby sa krajiny začali navzájom obviňovať a spôsobili ešte väčší chaos.

Ich riešenie je jednoduché. Vytvoria počítačový vírus, ktorý sa bude šíriť po sieti, či pomocou infikovaných USB kľúčov. Jeho úlohou bude vyhľadávať počítače, na ktoré sú napojený centrifúgy používané na oddeľovanie rádioaktívneho materiálu a tieto centrifúgy zneškodňovať.

Centrifúga je pomerne jednoduché zariadenie. Po zapnutí začne postupne zvyšovať otáčky rotácie, až kým od kontrolného zariadenia nedostane signál na zastavenie. Aby sa zaručilo, že centrifúga bude spomaľovať plynule, signál na zastavenie pozostáva z viacerých znakov. Presnejšie, každá centrifúga má určené slovo $S$, ktoré sa používa na jej zastavanie. Kontrolný počítač vysiela centrifúge každú sekundu jedno písmeno a v prípade, že tieto písmená vytvoria slovo $S$, centrifúga zastane.

Cieľom navrhovaného vírusu by bolo zmeniť postupnosť písmen vyslaných kontrolným počítačom tak, aby centrifúga nezastavila, ale zrýchľovala tak dlho, až kým nedôjde k jej poškodeniu. Všetky vyslané signály sa však zaznamenávajú do logov, v záujme utajenia by preto bolo dobré, aby zmenené signály predsa len obsahovali slovo $S$. To však znie ako nemožná úloha -- ako navrhnúť signál tak, aby obsahoval a zároveň neobsahoval slovo $S$? Našťastie, agentom KSP sa podarilo získať zdrojové kódy centrifúg a nazdávajú sa, že časť overujúca signály je implementovaná zle.

## Úloha

Na vstupe dostanete slovo $S$ skladajúce sa z veľkých písmen anglickej abecedy. Vašou úlohou je vytvoriť **najkratší možný** (lebo nenápadnosť) reťazec $X$, ktorý obsahuje slovo $S$ ako súvislý podúsek, ale nižšie uvedený program o ňom prehlási, že reťazec $S$ neobsahuje.

K dispozícii máte ekvivalentné programy v jazykoch `C++` aj `Python`. V oboch prípadoch je implementovaná funkcia `obsahuje(S, X)`, ktorá vracia `True` ak si myslí, že $X$ obsahuje $S$ a `False`, keď si myslí, že ho neobsahuje.

## Formát vstupu

Na jedinom riadku vstupu sa nachádza slovo $S$ tvorené $n$ ($1 \\leq n \\leq 500,000$) veľkými písmenami anglickej abecedy.

V polovici testovacích vstupov platí, že $n$ je nanajvýš $2,000$.

## Formát výstupu

Na výstup vypíšte do jedného riadku najkratšie možné slovo $X$, ktoré spĺňa požadované podmienky. V prípade, že takéto slovo neexistuje, na výstup vypíšte hlášku `Centrifuga sa nepokazi!`.

## Príklady

```vstup
AAB
```

```vystup
AAAB
```

```vstup
CENTRIFUGA
```

```vystup
Centrifuga sa nepokazi!
```
","# Centrifúgy sa dotočia

Na začiatku stojí pomerne nemožná úloha -- vytvoriť slovo `X`, ktoré obsahuje a zároveň neobsahuje zadaný reťazec `S`. Pointa úlohy však spočíva v tom, že kontrola toho, či `X` obsahuje `S` je implementovaná zle. Ako prvé je teda potrebné zistiť, kde je problém v zadanej implementácii. Našťastie, k dispozícii máme aj ukážkový vstup, ktorý nefunguje.

Prečo vyššie uvedený kód prehlási, že text `AAAB` neobsahuje `AAB`? Premenná `px` označuje pozíciu v reťazci `X`, ktorú práve kontrolujeme. Premenná `ps` predstavuje to isté v reťazci `S` a ukazuje, koľko posledných písmen v `X` a `S` sa zhodovalo. Na pozícii `px` by teda mal končiť reťazec, ktorého posledné písmená sú zhodné s prvými `ps` písmenami `S`. Ako je to však v našom prípade?

Zo začiatku všetko ide správne a hodnoty premenných sú `px = 2` a `ps = 2`. To je naozaj správne, prvé dve pozícii `X` sa zhodujú s prvými dvoma pozíciami `S`. Ďalšie písmená sa však už nezhodujú, preto program prejde do `else` podmienky, kde nastaví `ps = 0`. Pri ďalšej kontrole bude platiť, že `S[ps] = X[px]` a teda `px = 3` a `ps = 1`. Teda koniec úseku dĺžky tri `AAA` sa zhoduje so začiatkom slova `S` dlhým 1, teda `A`. To je samozrejme pravda, platí však aj silnejšie tvrdenie, že sa zhoduje až s dvoma písmenami `S`. Hodnota `ps` by teda mala byť 2.

A to je presne problém tejto implementácie. V tomto okamihu je totiž `ps` pozadu a už to nemá ako dobehnúť. Pri ďalšom porovnaní správne zhodnotí, že `A` sa nerovná `B`, ale znak `A` porovnáva len preto, že hodnota `ps` nie je najväčšia možná. To nám napovedá, ako túto úlohu riešiť všeobecne. Zadaný program totiž dokážeme oklamať ak vhodne spojíme dve kópie zadaného slova. Zo začiatku sa bude všetko zhodovať, v nejakom momente, bez toho aby si to program všimol, však prejdeme do druhého slova. V okamihu, keď program nájde chybu, bude už neskoro, pretože sme už prešli začiatok slova `S`, ktoré sa v `X` nachádza a program sa už nevie vrátiť.

Ak chceme spojiť dve kópie slova `S` tak, aby si zadaný program nevšimol, že prešiel z jedného do druhého, najdôležitejšie je zamaskovať prvé písmeno `S`. Napríklad, ak sa prvé písmeno `S` v ňom nachádza iba raz, toto sa nám nepodarí a centrifúgu nepokazíme (napr. slovo `CENTRIFUGA`).

Všeobecný tvar našeho riešenia teda musí vyzerať nasledovne: Majme slovo `S`, pozíciu $x$ takú, že `S[0] = S[x]` a $y$ je najmenšie také číslo, pre ktoré platí `S[y] != S[x+y]`. Potom slovo, ktoré dostaneme zreťazením reťazcov `S[0:x]` (prvých $x$ písmen slova `S`) a `S`, pokazí centrifúgu.

Zadaný program začne spracovávať toto slovo a prvých $x+y$ písmen sa bude zhodovať. Potom však nájde chybu a nastaví `ps = 0`. Podľa správnosti by však hodnota `ps` mala byť $y$, preto do konca slova nedosiahne `ps` dostatočnú hodnotu.

Netreba ešte zabudnúť na to, že zadanie po nás chcelo najkratšie možné slovo. Všimnite si však, že dĺžka slova závisí iba od hodnoty $x$, tým pádom sa snažíme nájsť čo najmenšie vhodné $x$, číže prvý vhodný výskyt znaku `S[0]` v reťazci `S` (vynímajúc $x = 0$).

V tomto momente vieme implementovať jednoduché $O(n^2)$ riešenie. Postupne vyskúšame každé možné $x$ také, že `S[0] = S[x]` a skontrolujeme, či vzniknuté slovo naozaj spôsobí pokazenie centrifúgy. To spravíme buď tak, že nájdeme hodnotu $y$ takú, že `S[y] != S[x+y]` alebo proste vložíme vytvorené slovo do funkcie zo zadania. Uvedomme si, že toto overenie je skutočne potrebné, pretože funkcia zo zadania musí v niektorom momente nájsť dva rôzne znaky. Slovo `ABAB` je príkladom slova, pri ktorom centrifúgu nevieme pokaziť.

K optimálnemu riešeniu nám už chýba iba jedno pozorovanie. V skutočnosti totiž stačí overiť iba prvé $x > 0$, pre ktoré `S[0] = S[x]`. Buď sa nám totiž podarí vytvoriť vhodné slovo, a tým pádom máme najkratšie možné riešenie, alebo zistíme, že slovo `S` je istým spôsobom periodické a úloha preň nemá riešenie.

V tom druhom prípade totiž platí, že `S[i] = S[x + i]` pre všetky možné $i$. To ale vynucuje periodickosť slova `S`, bude totiž platiť aj to, že `S[x + i] = S[x + x + i]`, a teda aj `S[i] = S[2x + i]`. Tým pádom, rovnaký znak ako je na pozícii 0 je práve na pozíciách `S[x]`, `S[2x]`... Pre žiadne $k > 1$ však potom nemôže platiť, že `S[0] = S[kx]` a zároveň existuje $y$ také, že `S[y] != S[kx + y]`.

Optimálne riešenie je potom naozaj jednoduché. Stačí nájsť prvú hodnotu $x > 0$, na ktorej je znak zhodný s prvým písmenom `S` a overiť, či reťazec `S[0:x]S` pokazí centrifúgu. Na to nám stačí časová zložitosť $O(n)$.
",8
0c02fed1e61372ec,ksp,"# Záhradka

Kleofáša omrzelo kšeftovať s vysávačmi a rozhodol sa dať sa na farmárčinu. Krok jedna je samozrejme zohnať si záhradku, a na takú záhradku treba plot. Preto sa Kleofáš rovno vybral kúpiť tyčky a pletivo. A keďže mali skvelú zľavu na $s$ tyčiek, rovno ich kúpil. Následne si kúpil aj kozu, o ktorej vie, že potrebuje $t$ metrov štvorcových trávy. A teraz rozmýšľa, ako má vyzerať jeho záhradka, ak chce byť ekonomický -- nenechať žiadne tyčky vyjsť navnivoč (t.j záhradka má mať práve $s$ rohov, teda aj $s$ strán) a dať koze práve $t~\\mathrm{m}^2$ trávy. Zjavne ekonomickým metariešením je kúpiť si na vyriešenie tohto problému milého študenta \\dots

## Úloha

Dané sú $s$ a $t$ také, že $t \\geq s/2$. Kleofášova záhradka sa má dať nakresliť do štvorcovej siete (t.j. dĺžky strán musia byť celočíselné a všetky priľahlé kusy plotu musia byť na seba kolmé) a musí byť súvislá. Nájdite takú záhradku, ktorá má obsah $t$ a $s$ strán, alebo vypíšte ""Neda sa"", ak sa to nedá.

Navyše v popise riešenia dokážte, že existuje nekonečne veľa dvojíc $(s, t)$, pre ktoré $t < s/2$ a napriek tomu takáto záhradka existuje.^[T.j. nájdite konštrukciu, ktorá funguje pre nekonečne veľa takých dvojíc.]

## Vstup

V jedinom riadku vstupu sú dve čísla: $s$ a $t$, pričom $4\\leq s\\leq 10^3$ a $1\\leq t\\leq 10^6$. Vždy platí, že $t \\geq s/2$.

## Výstup

Vypíšte $s$ riadkov: návod, ako má Kleofáš postaviť plot. Každý riadok je vo formáte $S~D$, kde $S$ je smer -- jedno z písmen ""`S`"", ""`J`"", ""`V`"" a ""`Z`"" podľa svetovej strany a $D$ je dĺžka tohto kusu plota.

Záhradka musí byť uzavretá (teda musí skončiť tam, kde začala) a nasledujúce strany musia byť na seba kolmé.

Niektoré vstupy budú malé ($s, t < 25$). Pre niektoré vstupy platí $t \\geq s$. Nejaké body teda získate aj za čiastkové riešenia.

## Príklad

```vstup
6 5
```

```vystup
V 1
S 1
V 1
J 3
Z 2
S 2
```

```vstup
9 12
```

```vystup
Neda sa
```
","# Záhradka

Keďže v každom rohu obvod Kleofášovej záhradky zatáča o 90 stupňov, musia sa na obvode striedať vodorovné a zvislé strany. Vodorovných strán je teda presne toľko isto ako zvislých. Inými slovami, počet strán záhradky musí byť párny. Pre všetky vstupy s nepárnym $s$ teda môžeme smelo odpovedať, že nemajú riešenie.

Následne ošetríme okrajové prípady: $t=1$ aj $t=2$ sú možné len ak $s=4$. (V prvom prípade tvorí záhradku jeden štvorec, v druhom prípade sú to nutne dva stranou susediace štvorce. Tvar obvodu je v oboch prípadoch jednoznačne určený.) Odteraz teda môžeme predpokladať, že $t\\geq 3$.

Ako ďalší krok nášho riešenia sa pozrieme na najmenší povolený prípad: situáciu kedy $s=2t$. Chceme teda nakresliť útvar s $2t$ stranami a obsahom $t$.

Ako to bude vyzerať pre $t=3$? Ak má mať záhradka tri štvorce, môžu byť buď v rade za sebou (vtedy má ale obvod len štyri strany), alebo môžu byť zatočené ""do L"" (kedy je strán 6, čo je presne to, čo sme chceli).

```
+---+
|   |
|   +---+   <-- 6 strán, obsah 3
|       |
+-------+
```

Ďalej máme $t=4$. Tu chceme útvar, ktorý bude mať 8 strán. Ideálne by bolo neriešiť úlohu odznova, ale skúsiť upraviť predchádzajúce riešenie -- pridať nový štvorec tak, aby nám tým pribudli dve strany. A skutočne to ide spraviť. Jedna dobrá možnosť vyzerá nasledovne:

```
+---+
|   |
|   +---+
|       |   <-- 8 strán, obsah 4
+---+   +
    |   |
    +---+
```

No a už by malo byť aj jasné, že tento postup vieme ďalej ""do nekonečna"" opakovať. Pre názornosť sa ešte pozrime na $t=5$. Tam opäť pridáme jeden štvorec ""na chvost hada"", čím sa nám obsah zväčší o 1 a počet strán o 2.

```
+---+
|   |
|   +---+   <-- 10 strán, obsah 5
|       |
+---+   +---+
    |       |
    +-------+
```

Takže už vieme riešiť všetky prípady kedy $t\\geq 3$ a $s=2t$: jednoducho vyrobíme $t$-políčkového hada. Čo teraz so všeobecným prípadom? Predpokladajme, že $s$ je párne a že $t = s/2 + x$. Máme teda mať ten istý počet strán, ale o $x$ väčší obsah. Ako to dosiahnuť? Jednoducho -- stačí napríklad nášmu hadovi ""natiahnuť chvost"".

Riešenie si opäť ukážeme na jednom príklade, z ktorého bude jasné, ako to funguje vo všeobecnosti. Majme opäť $s=10$, ale tentokrát namiesto $t=5$ budeme mať $t=8$, teda o tri viac. Spravíme teda nášmu hadovi o tri dlhší chvost:

```
+---+
|   |
|   +---+   <-- stále 10 strán, ale už obsah 8
|       |
+---+   +---------------+
    |         1   2   3 |
    +-------------------+
```

Tu je implementácia tejto myšlienky:

## Ako vyzerajú nejaké situácie s malým obsahom?

Okrem naprogramovania vyššie popísaného riešenia ste mali ešte jednu úlohu: ukázať, že existuje nekonečne veľa dvojíc $(s, t)$, pre ktoré $t < s/2$ a napriek tomu hľadaná záhradka existuje. Teraz sa pozrieme na to, ako takéto prípady vyzerajú.

Jeden už vlastne poznáme: $t=1$ a $s=4$, teda jediný štvorec. To je však patologický prípad, ktorý nevieme zovšeobecniť.

Po troche skúšania však ľahko odhalíme druhý najmenší prípad s obsahom menším ako $s/2$. Vyzerá nasledovne:

```
    +---+
    |   |
+---+   +---+
|           |  <-- až 12 strán a obsah len 5
+---+   +---+
    |   |
    +---+
```

A odtiaľ už ľahko pokračujeme k ďalším, väčším záhradkám s touto vlastnosťou. Tu je nasledujúca:

```
    +---+   +---+
    |   |   |   |
+---+   +---+   +---+
|                   |  <-- až 20 strán a obsah len 9
+---+   +---+   +---+
    |   |   |   |
    +---+   +---+
```

a už je asi jasné, ako to bude pokračovať ďalej. Tým sme splnili zadanú úlohu -- našli sme nekonečne veľa rôznych záhradiek, ktorých obsah $t$ je menší ako polovica počtu ich strán.

## Hlbšie zamyslenie na záver

Na záver tohto vzorového riešenia si ukážeme dôslednejšiu úvahu, ktorá nás privedie k tomu, ako musia vyzerať záhradky s veľkým počtom strán a malým obsahom.

Začneme tým, že si predstavíme ľubovoľnú záhradku s obsahom $t$. Namiesto počtu strán obvodu sa ale sústreďme na jeho dĺžku (pričom strana štvorca má dĺžku 1). Aký najdlhší obvod vieme dosiahnuť?

Máme $t$ štvorcov a každý z nich má 4 strany, čiže určite to nebude viac ako $4t$. V skutočnosti to ale musí byť ešte výrazne menej. Celá záhradka musí držať pokope, takže niektoré dvojice štvorcov musia susediť. No a vždy, keď dáme dva štvorce jeden vedľa druhého, zmenšíme tým obvod o 2 -- ani z jedného ani z druhého už nie je na obvode ich spoločná strana. (Napr. dva izolované štvorce majú celkový obvod dĺžky 8, zatiaľ čo obdĺžnik $1\\times 2$ má obvod dĺžky 6.)

Koľko dvojíc susediacich štvorcov musí byť v záhradke tvorenej $t$ štvorcami? Ľahko nahliadneme, že aspoň $t-1$. (Predstavme si, že záhradku ideme pozliepať dokopy z $t$ izolovaných štvorcov. Každým zlepením pozdĺž nejakej strany zmenšíme počet kusov o 1. Aby teda celá záhradka držala pokope, musíme lepiť aspoň $t-1$ ráz.)

Najväčší možný obvod záhradky je teda $4t - 2(t-1) = 2t+2$. (Tento obvod majú všetky záhradky, ktoré majú stromovú topológiu.)

No a počet strán záhradky je zjavne nanajvýš rovný jej obvodu -- pričom rovnosť nastáva práve vtedy, keď má každá strana dĺžku 1. Takže najlepšie, čo teoreticky môžeme dosiahnuť, je $s=2t+2$. Inými slovami, $t=(s/2)-1$.

Ak nám teda niekto povie počet strán $s$ a chce od nás, aby sme mu navrhli záhradku s obsahom menším ako $s/2$, pôjde to len vo veľmi špecifickom prípade: budeme musieť nakresliť záhradku, ktorá má stromovú topológiu a ktorá má všetky strany dĺžky 1. Vedeli by ste teraz v tejto úvahe pokračovať a dokázať, ako vyzerajú *úplne všetky* záhradky pre ktoré $s/2 > t$?
",5
bf732e5dedfb8624,ksp,"# Strašná kopa papierov

Paulínka sa v detstve najradšej hrávala s voskovkami. V jej škôlke mali na hranie práve dve veci:

- veľa voskoviek v rade za sebou,
- veľa kôp papierov v rade za sebou.

Nemožno sa teda čudovať, že jej zábava, povedzme si na rovinu, nebola práve najintelektuálnejšia -- celý deň si brala voskovky v poradí, v akom boli na stole, a vždy, keď si vzala nejakú voskovku, nepustila ju z rúk, až kým ju celú nevypísala. Toto robila, až zafarbila všetky papiere v škôlke. Takto jej často vznikali jednofarebné obrázky a tie sa Paulínke až tak nepáčia. Vedeli by ste zistiť, koľko z jej obrázkov bolo viacfarebných?

## Úloha

Paulínka má $n$ voskoviek rôznych farieb, každá má svoju dĺžku $d_i$ a $m$ kôpok papierov. V každej kôpke sa nachádza $k_i$ rovnakých čistých papierov. Na zafarbenie jedného papiera z $i$-tej kôpky potrebuje Paulínka $c_i$ dĺžky voskovky/voskoviek. Paulínka vždy vyfarbí jeden celý papier a až potom prejde na ďalší. Papiere si berie poporadí, teda vždy vyfarbí celú kôpku pred tým, ako začne brať papiere z ďalšej. Voskovky si berie tiež poporadí, a vždy až potom, ako sa jej predošlá voskovka vypíše.

Zistite, koľko obrázkov bude obsahovať viac než jednu farbu.

Je zaručené, že voskovky stačia na pokreslenie všetkých papierov.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $n$ -- koľko rôznych voskoviek má Paulínka. Nasleduje $n$ riadkov, kde každý riadok obsahuje celé číslo $d_i$ -- dĺžku $i$-tej voskovky. Ďalší riadok obsahuje číslo $m$ -- počet kôpok papierov. Nasleduje $m$ riadkov, kde $i$-ty riadok obsahuje dve celé čísla $k_i$ a $c_i$, kde $k_i$ znamená počet papierov v $i$-tej kôpke a $c_i$ je celková dĺžka voskovky, ktorú treba na zafarenie jedného papiera v $i$-tej kôpke.

## Obmedzenia

Sú $4$ sady vstupov.

V prvých dvoch sadách platí, že $n \\leq 10,000$, $m \\leq 1000$, $d_i, c_i, k_i \\leq 1000$ a suma dĺžok voskoviek je menej ako $2,000,000$.

V druhých dvoch sadách platí, že $n \\leq 1,000,000$, $m \\leq 200000$, $d_i, c_i, k_i \\leq 200,000$ a suma dĺžok voskoviek je menej ako $50,000,000,000$.

## Formát výstupu

Vypíšte jedno celé číslo -- počet obrázkov, ktoré budú viacfarebné.

## Príklad

```vstup
2
5
5
1
2 5
```

```vystup
0
```

*Paulínka má dve voskovky, obe dĺžky $5$. Má jednu kôpku papierov, kde sú dva papiere, pre každý treba $5$ dĺžok voskoviek. Prvou voskovkou zafarbí prvý papier, druhou druhý. Ani jeden papier nie je viacfarebný.*

```vstup
2
4
6
2
1 6
1 4
```

```vystup
1
```

*Teraz má Paulínka dve voskovky, jednu dĺžky $4$ a druhú dĺžky $6$. Má dve kôpky papierov, v oboch je po jednom papieri. Na zafarbenie prvého papiera treba $6$ dĺžok voskoviek. Na zafarbenie druhého papiera treba $4$ dĺžok voskoviek. Keďže papiere aj voskovky Paulínka berie po poradí, tak prvou voskovkou zafarbí 4 dĺžky prvého papiera a zvyšok prvého a celý druhý zafarbí druhou voskovkou.*

```vstup
4
1
1
1
1
1
1 3
```

```vystup
1
```

*V tomto prípade má Paulínka štyri voskovky, všetky dĺžky $1$. Má jednu kôpku papierov, kde je ibe jeden papier, a na jeho zafarbenie treba $3$ dĺžky voskoviek. Tri voskovky minie na zafarbenie tohoto jediného papiera, a jedna jej ostane nepoužitá. Rôznofarebný papier je teda jeden.*
","# Strašná kopa papierov

## Priamočiare riešenie

Ako priamočiare riešenie nám môže napadnúť, že odsimulujeme, čo sa stane pre každý papier každej kôpky. Teda si budeme pamätať aktuálny kúsok voskovky ktorý nám ostáva a postupne pre každý papier každej kôpky sa spýtame, či je kus voskovky ktorý nám aktuálne ostáva dostatočne dlhý na jeho celé zafarbenie. Ak nie, vieme že bude viacfarebný a zapamätáme si to do výsledného počtu. Nesmieme pri tom zabudnúť ""odobrať"" aj časť ďalšej voskovky (ktorá sa použije na vyfarbenie), prípadne niekoľko celých a časť ďalšej, prípadne len niekoľko celých (podľa toho, koľko ešte potrebujeme na dovyfarbenie papiera). Kód by mohol vyzerať takto:

Problémom ale je, že takéto riešenie nebude dostatočne efektívne, keďže potrebujeme $O(m \\cdot k)$ operácií a v zadaní vidíme, že $m$ a $k$ môžu byť každé až $200,000$. Teda potrebujeme rozhodovať o zhruba $4,000,000,000$ papierov. To je priveľa a náš program to nestihne.

## Ako to zlepšiť ?

Tu si treba všimnúť, že ak by sme namiesto každého papiera každej kôpky prechádzali voskovkami, budeme potrebovať oveľa menej operácií, lebo podľa obmedzení, voskoviek bude najviac milión. Potom náš algoritmus bude fungovať tak, že si pamätá, koľko ostáva z aktuálnej voskovky a až kým sa neminie, berie celé kôpky a pýta sa:

- dokážem z tejto voskovky zafarbiť celú kôpku ?

- dokážem z tejto voskovky zafarbiť niekoľko celých papierov kôpky ? Toto sa dá jednoducho urobiť pomocou zvyšku po delení -- modulo.

- inak určite vznikne viacfarebný papier

Pri každom prípade treba dopočítať, koľko z aktuálnej voskovky ostane, prípadne ak potrebujeme viac ako len aktuálnu voskovku, tak si vypočítať, koľko ostane z poslednej ktorú použijeme.

### Časová zložitosť :

Riešenie bude mať zložitosť $O(m+n)$, pretože ako si môžeme všimnúť, s každou voskovkou a každou kôpkou pracujeme iba raz. Teda ak si napríklad označíme index voskovky s ktorou práve pracujeme ako $i$, tak toto $i$ vždy rastie, nikdy neklesá (k vypísaným voskovkám sa nevraciame). Rovnako ak si označíme index kôpky ktorú práve zafarbujeme ako $j$, tak aj toto $j$ vždy rastie, nikdy neklesá (k zafarbeným kôpkam sa nevraciame). Keďže pri zafarbovaní kôpky robíme len konštantné operácie - vetvenie a delenie, tak nič iné nám zložitosť neovplyvňuje.

### Pamäťová zložitosť :

Aj pamäťová zložitosť bude $O(m+n)$, lebo si musíme pamätať $n$ dĺžok voskoviek, $m$ veľkostí kôpok a $m$ hodnôt opisujúcich dĺžku voskovky na zafarbenie $1$ papiera danej kôpky. Teda pamäťová zložitosť bude $O(2m + n)$, teda $O(m+n)$.
",4
3c9e74d3902d5c16,ksp,"# Yyha to je šuter

Bubu sa jedného dňa prechádzal po lese, keď mu do oka padol šuter. Chvalabohu, iba metaforicky, nie doslova. Šutrák to bol riadny, čo Bubua potešilo, až radostne zýýkol (Yyyyyy!). No keď si Bubu uvedomil, že má tento balvan v ceste, radosť ho prešla. Pobral sa ho obísť, no hneď za šutrom, na čistine, mu jeden strom, starý hodne, zahatil, aby nezaspal, preventívne cestu tým, že sa vyvalil. Bubu sa nenechal odradiť a aj túto prekážku obišiel. Potom, čo obišiel tento strom, sa mu kdesi v podlesí zjavili v ceste dva vresy (a to riadne prerastené). Za mohutným sudom od kapusty (ktorý musel tiež chudák obchádzať) ležali vyvalené 4 bresty. A tak ďalej, (no viete si to domyslieť), no a keď bol koniec prechádzky, tak mu do cesty vošli sanitky.

Tak s potom až na brade, vo vysilenej nálade, Bubu dokončil svoje trápenie počnuté kusom žuly. Teraz hľadá optimálne riešenie ako obísť skaly.

## Úloha

Vašou úlohou je nájsť najkratšiu trasu z pozície udanej začiatočnými koordinátmi na pozíciu udanú konečnými koordinátmi, ktorá neprechádza žiadnou z popísaných prekážok. Prekážky sú buď úsečkami, alebo konvexnými mnohouholníkami.

Vo všeobecnosti platí, že sa tieto prekážky nedotýkajú. Inak povedané, začiatok a koniec žiadnej úsečky, vrátane vrcholov mnohouholníkov, nikdy neležia uprostred inej úsečky. (V niektorých sadách sa ale úsečky môžu pretínať a zdieľať koniec/začiatok)

Pozn.: Cesta môže prechádzať pozdĺž prekážky, aj cez jej začiatok a koniec, ale nie cez samotnú prekážku, čo v prípade mnohouholníkov znamená, že môže ísť po obvode ale nie cez ich vnútro.

## Formát vstupu

Na prvom riadku vstupu sú štyri čísla $x_s,$ $y_s,$ $x_e,$ $y_e$ popisujúce koordináty začiatku ($x_s,$ $y_s$) a konca ($x_e,$ $y_e$) trasy, ktorú chce Bubu prejsť.

Druhý riadok obsahuje jedno číslo $n$, počet prekážok.

Nasleduje $2n$ riadkov, ktoré po pároch popisujú prekážky na trase. Riadok číslo $2k$ obsahuje jedno číslo $m_k\\geq 2$, počet bodov popisujúcich $k$-tú prekážku. V prípade, že $m_k=2$, je prekážka úsečkou, v opačnom prípade je mnohouholníkom.

Riadok číslo $2k+1$ obsahuje $2m_k$ čísel vo formáte $x_0,$ $y_0,$ $\\dots$ $x\_{m_k-1},$ $y\_{m_k-1}$, ktoré popisujú koordináty prekážky, v poradí.

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1, 2 | 3, 4 | 5, 6 | 7, 8 | |:-----------------------|-----:|-----:|------:|------:| | $1 \\leq \\sum m_i \\leq$ | $20$ | $60$ | $150$ | $200$ |

V sadách 1, 2, 3, 4 môžete predpokladať, že sa žiadne dve úsečky nepretínajú. V sadách 1, 3, 5, 7 navyše platí $m_i=2$, vo všeobecnosti platí $m_i\\leq10$.

## Formát výstupu

Vypíšte dĺžku najkratšej možnej trasy zo začiatku na koniec. Váš výsledok by mal byť najviac $10^{-6}$ rozdielny od očakávaného výsledku.

## Príklady

```vstup
0.0 0.0 4.0 0.0 
3
2
1.0 -1.0 1.0 1.0
2
2.0 4.0 2.0 0.0
2
3.0 1.0 3.0 -4.0
```

```vystup
5.656854249492381
```

Prekážky sú čierne úsečky s vyznačeným koncom a začiatkom, optimálna trasa je červenou.

```vstup
0.0 0.0 4.0 0.0 
4
2
1.0 -1.0 1.0 1.0
2
2.0 4.0 2.0 0.0
2
2.0 0.0 2.0 -4.0
2
3.0 1.0 3.0 -1.0
```

```vystup
5.656854249492381
```

V prípade, že dve úsečky zdieľajú jeden koniec, môže tade prechádzať trasa.

```vstup
0.0 0.0 6.0 0.0
1
4
2.0 2.0 2.0 -2.0 4.0 -2.0 4.0 2.0
```

```vystup
7.656854249492381
```

Podobne ako vyššie, štvorcová prekážka je hnedou.
","# Yyha to je šuter {bodypopis=12 bodyprogram=8 vzorak=""Bubu"" mail=""peter.ondus@trojsten.sk""}

Kľúčom k riešeniu tejto úlohy je uvedomiť si dve veci. Za prvé: najkratšia trasa medzi dvomi bodmi je úsečka. Za druhé: smer, ktorým ideme sa nám neoplatí meniť nikde inde, ako na bodoch, ktoré definujú prekážky (konce v prípade úsečiek a rohy v prípade n-uholníkov).

Vďaka týmto dvom poznatkom vieme použiť abstrakciu, ktorou si celý problém vieme zjednodušiť na graf, v ktorom potom už len stačí nájsť najkratšiu trasu. Vrcholmi tohoto grafu budú štart, koniec, a body, ktoré definujú prekážky. Hrany v tomto grafe budú existovať iba v prípade, že medzi danými dvoma vrcholmi existuje priama úsečka, ktorá neprechádza žiadnou prekážkou. Keďže hľadáme najkratšiu cestu v 2D priestore, musíme každej hrane priradiť aj jej dĺžku, ktorá bude rovnaká, ako dĺžka príslušnej úsečky.

(Táto abstrakcia funguje iba v prípade, že sa žiadne úsečky nedotýkajú, čo je špecifikované v zadaní)

Keďže má náš graf hrany s definovanou dĺžkou, jednoduché BFS nám nebude stačiť na nájdenie najkratšej trasy. Na to musíme použiť [Dijkstrov algoritmus](https://www.ksp.sk/kucharka/dijkstra/), ktorý túto trasu ľahko nájde.

Ku kompletnému teoretickému riešeniu nám teda chýba jediná vec, a to síce, ako si tento graf vyrobiť.

## Generácia grafu

Ak chceme vygenerovať náš graf, musíme vedieť, ktoré hrany v ňom sú, a ktoré nie. Vec sa má tak, že teoreticky v ňom môže byť každá možná hrana medzi dvoma vrcholmi a bez toho, aby sme ich všetky skontrolovali nemôžeme žiadnu vylúčiť (až na výnimky, ktoré spomeniem nižšie). Náš prístup teda skontroluje každú dvojicu vrcholov, a zistí, či úsečka medzi nimi neprechádza cez žiadnu prekážku. Ak nie, môžeme ju pridať do grafu. Jej dĺžku ľahko vyrátame pomocou Pytagorovej vety.

V prípade, že všetky prekážky sú úsečkami (nepárne sady) je to celkom jednoduché: pre každú potenciálnu hranu skontrolujeme všetky prekážky, a ak ju niektorá pretína, vieme, že táto hrana nie je v grafe.

V prípade n-uholníkov je to trochu komplikovanejšie. Nemôžeme ich priamo zjednodušiť na úsečky, keďže ich vnútro je tiež nepriechodné. Iba, že by sme použili nejaký trik. Obvod n-uholníkov teda zjednodušíme na úsečky. Možností, ako vyriešiť vnútro je veľa.

Našim prístupom je, že vôbec nebudeme generovať hrany pre body, ktoré sa nachádzajú vnútri n-uholníkov (týmto automaticky vylúčime akékoľvek hrany, ktoré vchádzajú do a vychádzajú z n-uholníkov). Diagonály medzi rôznymi bodmi toho istého n-uholníka vieme veľmi ľahko skontrolovať a zakázať, keďže poznáme poradie bodov v n-uholníku.

Jediný problém, ktorý nám zostáva, sú hrany, ktoré prechádzajú krížom cez n-uholník, tak, že na nich ležia dva rohy n-uholníka. To vieme vyriešiť tak, že pri kontrole pretínania úsečiek vylúčime nielen prípad, kedy sa úsečky úplne pretnú, ale aj prípad, kedy sa dotknú. Zvyšok riešenia to neovplyvní, keďže v prípadoch, kde takéto úsečky potrebujeme nahradíme jednu úsečku $AC$ dvoma (alebo viacerými) úsečkami $AB$ a $BC$, v súčte rovnakej dĺžky. No v prípade hrany, ktorá ide krížom cez n-uholník, by táto hrana bola rozdelená na tri hrany

- dve, ktoré končia v rohoch n-uholníka a jedna diagonála. Túto diagonálu však už vylúčime, a teda je problém vyriešený.

## Riešenie a zložitosti

Naše riešenie načíta vstup, vygeneruje podľa popisu vyššie graf, a následne na ňom spustí Dijkstrov algoritmus.

Časová zložitosť nášho riešenia je $O(n^3)$, kde $n$ je počet bodov definujúcich prekážky ($n = \\sum m_i$ ak použijeme značenie zo zadania), keďže pri generácii grafu kontrolujeme každú potenciálnu hranu (ktorých je $O(n^2)$) na pretnutie s každou úsečkou definujúcou prekážku (ktorých je $O(n)$). Dijkstrov algoritmus vieme implementovať s časovou zložitosťou $O(n^2)$, čo celkovú časovú zložitosť neovplyvňuje.

Pamäťová zložitosť nášho riešenia je $O(n^2)$, keďže najväčšia vec, ktorú si musíme pamätať je graf, kde si musíme pre každú hranu uložiť jej dĺžku, prípadne existenciu (keďže dĺžku môžeme vždy znovu vyrátať v konštantnom čase).

## Vzorové riešenie

Asymptotickú časovú zložitosť tohoto riešenia síce nezlepšíme, no vieme zlepšiť jeho pamäťovú zložitosť, a praktickú časovú zložitosť. To vieme spraviť tak, že namiesto generácie grafu pred spustením Dijkstrovho algoritmu budeme kontrolovať existenciu hrany v grafe počas jeho behu. Na kontrolu existencie hrán použijeme rovnaký systém, ako sme použili na generáciu grafu, akurát ich budeme kontrolovať len keď ich treba.

Takéto riešenie má stále v najhoršom prípade časovú zložitosť $O(n^3)$, keďže v každom kroku Dijkstrovho algoritmu musíme skontrolovať pre $n$ potenciálnych ďalších bodov $n$ potenciálnych prekážok na pretnutie (ak nerátame body, ktoré sme už použili tak v jednotlivých krokoch musíme v najhoršom prípade spraviť najviac $n^2, n(n-1),\\cdots, 2n, n$ kontrol, čo sa sčíta na $O(n^3)$). Prakticky však bude náš program na vstupoch bežať násobne rýchlejšie.

Pamäťová zložitosť tohoto riešenia je $O(n)$, keďže si pamätáme len vstup a vzdialenosť každého bodu od začiatku, obe o veľkosti $O(n)$.

Podobným prístupom vieme dospieť aj k ďalšej optimalizácii. K rozhodnutiu negenerovať celý graf nás síce viedlo zlepšenie pamäťovej zložitosti, avšak tento prístup nám dovolí obmedziť vykonávanie časovo veľmi náročnej operácie (kontrola existencie hrany medzi dvoma vrcholmi) iba na užitočné prípady, teda iba na tie dvojice vrcholov, ktoré reálne zvažujeme pri prehľadávaní. Pokračovaním tejto myšlienky vieme dospieť k optimalizácii, kedy existenciu hrany nekontrolujeme pri pridávaní, ale pri vyberaní kandidáta nasledujúceho vrcholu pri prehľadávaní. Vykonávame Dijkstrovo prehľadávanie a tvárime sa, že každá hrana existuje až do posledného možného momentu. Takýmto spôsobom minimalizujeme počet overovovaní existencie hrany, čo urýchli beh algoritmu. Ďalším praktickým vylepšením vie byť implementovanie prehľadávania A\* namiesto Dijsktrovho algoritmu, čo je na grafoch na 2D ploche ľahký spôsob ako zrýchliť beh programu. Obe tieto optimalizácie stále nezlepšujú asymptotickú časovú zložitosť a nie sú potrebné na získanie plného počtu bodov za program. Prakticky však každé z nich zrýchľujú beh programu na naších vstupoch dvojnásobne.
",8
39b718ceb0144e1a,ksp,"# Ako Jemo Etku spoznal

V krajine, kde sa na strednej škole delilo nulou a prvočísla rozkladali na čísla zložené, žila Etka. Etka bola už od mala šikovná, veď už na základnej škole písala [Raabeho testy](https://en.wikipedia.org/wiki/Ratio_test#Raabe's_test) na plný počet. A tak si jedného dňa povedala, že aj ona ide zlepšiť svet a začne priamo v Tesku pri výklade s [kryptomenami](https://en.wikipedia.org/wiki/Cryptocurrency).

Na druhej strane kopca bola tiež vyspelá krajina. Mala tri kruhové objazdy, štyri semafory a pelikána v erbe. A v tejto krajine plnej šikovných ľuďí si nažíval, nie síce múdry, ale zato vysoký, Jemko. Jedného dňa ale prerástol celé svoje okolie natoľko, že musel ísť hľadať svoje šťastie cez kopec. Tu sa rýchlo priučil remeslu delenia nulou, no aj tak nikdy nezapadol medzi ostatných ľudí. Predsa len ale prišiel deň, ktorý mu navždy zmenil život.

Jedného zimného večera, keď Jemo opäť vyhladol a dojedol zbytky aj v susedovej chladničke, sa rozhodol ísť dokúpiť zásoby do neďalekého Teska. A tu Jemko zbadal prekrásnu Etku obsluhujúcu pult s kryptomenami. Okamžite sa tam vybral. Romýšľajúc, ako Etku očariť, mu v hlave skrsol geniálny nápad.

Ženu určite očarí bohatý muž, preto sa Jemo rozhodol, že za peniaze, ktoré má, toho nakúpi najviac, ako len môže. Ako ale všetci vieme, kryptomien je straaašne veľa a Jemko ani len nedovidí z jedného konca pultu na druhý. Navyše, Jemko vôbec žiadne kryptomeny nepoznal. Chcel to ale zahrať na odborníka, a tak sa rozhodol, že kúpi len z tých kryptomien, na ktorých názov dovidí. Čo si ale Jemko všimol je, že pri pulte s kryptomenami bola z každej kryptomeny len $1$ minca. Nechcel Etku posielať hľadať ďalšie do skladu, takže sa rozhodol, že kúpi z každej kryptomeny najviac $1$ mincu. Horšie zistenie bolo to, že Tesko má úplne iné ceny ako hodnoty kryptomien na trhu. Aby neskončil úplne na mizine, rozhodol sa zo svojho rozpočtu nakúpiť tak, že to možno nebude najdrahší nákup čo vie spraviť, ale bude mať najväčšiu hodnotu na trhu.

Takto večer už bola Etka veľmi unavená a tak Jemkovi nevenovala pozornosť. No Jemo sa len tak nevzdal. Rozhodol sa, že tam bude chodiť znova a znova hoc aj $10,000$-krát a opakovať to, čo urobil posledný večer. Až kým si jej srdce nezíska.

No napriek tomu, že Jemko pôjde cez leto hľadať [bugy](https://en.wikipedia.org/wiki/Bed_bug) do [švajčiarskych končín](https://careers.google.com/locations/zurich/), má problémy s vypočítaním najlepšieho nákupu. A Etka je veľmi inteligentné dievča, ak by nenakúpil optimálne, hneď by si to všimla a jeho šanca by bola v háji. Pomôžete mu?

## Úloha

V Tesku predávajú $n$ kryptomien. Kryptomeny sú vyložené na pulte v jednom dlhom rade. Každá kryptomena má nejakú cenu v obchode a nejakú hodnotou na trhu. Jemko obchod navštívi $q$-krát. Pretože ale chodí vždy večer, na pulte je vždy z každej meny už len $1$ minca. Pre každú návštevu vieme, koľko má Jemo peňazí v peňaženke a odkiaľ pokiaľ vidí, a zaujíma nás odpoveď na otázku: ""Akú najväčšiu hodnotu vie Jemo nakúpiť, ak jediné peniaze, čo má k dispozícii, sú tie v jeho peňaženke, a vyberá si len medzi menami, na ktoré dovidí?""

## Formát vstupu

V prvom riadku sú 2 celé čísla $n, q$ oddelené medzerou: počet rôznych kryptomien a počet návštev. Kryptomeny sú očíslované od $1$ po $n$.

Nasleduje $n$ riadkov, v každom sú dve medzerou oddelené celé čísla $c_i, h_i$: cena $i$-tej kryptomeny v Tesku a hodnota tejto kryptomeny na trhu.

Na konci bude $q$ riadkov popisujúcich Jemkove návštevy. V každom je trojica čísel $l_i, r_i, p_i$ oddelených medzerou, hovoriacich, že Jemko má v peňaženke $p_i$ peňazí a môže nakupovať kryptomeny od $l_i$ po $r_i$, vrátane.

## Formát výstupu

Pre každú Jemovu návštevu Teska vypíšte jeden riadok a v ňom jedno celé číslo: najväčšiu hodnotu, ktorú vie Jemo nakúpiť.

## Hodnotenie

Pre jednotlivé sady vstupov platia nasledovné obmedzenia

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:-----:| | $1 \\leq n \\leq$ | $20$ | $100$ | $400$ | $1,000$ | | $1 \\leq q \\leq$ | $50$ | $1,000$ | $5,000$ | $10,000$ | | $1 \\leq p_i \\leq$ | $100$ | $500$ | $2,000$ | $2,000$ | | $1 \\leq c_i \\leq$ | $10^{6}$ | $10^{6}$ | $10^{6}$ | $10^{6}$ | | $0 \\leq h_i \\leq$ | $10^{6}$ | $10^{6}$ | $10^{6}$ | $10^{6}$ |

## Príklady

```vstup
3 2
2 2
3 3
2 2
1 3 4
1 2 4
```

```vystup
4
3
```

```vstup
3 2
2 2
3 5
2 2
1 3 4
1 2 4
```

```vystup
5
5
```
","# Ako Jemo Etku spoznal

Potom, ako ste si spolu s Jemom prešli strastiplnou cestou na druhú stranu kopca, našli slušné bývanie a napriek obrovskému hladu stretli jeho vyvolenú, ste dostali neľahkú úlohu. Mnohým z vás však táto úloha musela prísť povedomá. A tak stačilo spomenúť si na jej riešenie a následne ho trošku vytúniť, aby riešilo aj túto úlohu.

## Knapsack

Áno, táto úloha bola len jemné zovšeobecnenie úlohy, ktorá je vo svete známa pod názvom [knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem). Zadanie znie nasledovne: ""Máme $n$ kryptomien, pre každú z nich poznáme jej cenu v Tesku a jej hodnotu na trhu. Akú najväčšiu hodnotu vieme nakúpiť za $p$ peňazí?""

Túto úlohu vyriešime dynamickým programovaním. Vypočítame si dvojrozmerné pole, kde v $D[i][j]$ je uložená najväčšia hodnota, akú vieme nakúpiť, ak máme k dispozícii $j$ peňazí a môžeme nakupovať len prvých $i$ typov kryptomien. Potom odpoveď na našu otázku je uložená v $D[n][p]$.

Ako vypočítame hodnoty v jednotlivých políčkach poľa? Predstavme si, že máme $j$ peňazí a nakupujeme z prvých $i$ typov kryptomien. Aké sú možnosti pre $i$-tu kryptomenu? Buď ju nekúpime a výsledok je rovnaký, ako keď nakupujeme iba z prvých $i-1$ kryptomien. Alebo ju kúpime (samozrejme, iba ak máme na to dosť peňazí). Vtedy chceme kúpiť najväčšiu hodnotu z prvých $i-1$ kryptomien, pričom už máme k dispozícii len $j-cena[i]$ peňazí.

Teda pokiaľ máme dosť peňazí na kúpenie $i$-tej kryptomeny ($j \\geq cena[i]$), tak platí $$D[i][j] = \\max (D[i-1][j], D[i-1]\[j-cena[i]\] + hodnota[i])\\text{.}$$ Inak $D[i][j] = D[i-1][j]$. Základný prípad je jednoduchý, keďže za $0$ peňazí a ani z $0$ kryptomien si nič nekúpiš. Vieme teda, že $D[0][j] = D[i][0] = 0$.

## Priamočiare využitie

Toto vieme využiť v našej úlohe tak, že vždy, keď príde otázka, zrátame si výsledok knapsacku pre kryptomeny od $l$ po $r$ a vypíšeme odpoveď. Akú to má celé časovú zložitosť? Pre každú otázku potrebujeme zrátať celé dvojrozmerné pole knapsacku odznova. Toto pole môže mať v najhoršom prípade veľkosť až $n \\times p$. Teda celková časová zložitosť je $O(q \\cdot n \\cdot P)$, kde $P$ je najväčšie $p_i$.

## Vzorové riešenie

Všimnime si, že keď zrátame knapsack pre nejaký interval kryptomien (od $l$ po $r$), tak musíme zrátať celú tabuľku $D$. Zaujímavé je ale to, že v $i$-tom riadku tabuľky $D$ vlastne uvažujeme len prvých $i$ kryptomien (kryptomeny od $l$ po $l+i-1$). A teda keď už máme vyrátané $D$, tak máme odpovede zrátané aj pre každý prefix tohto intervalu. Teda pre každý interval tvaru $\\langle l; l+i \\rangle$, kde $0 \\leq i \\leq r-l$. Pokiaľ zrátame všetky tieto knapsacky odzadu, tak máme dokonca zrátaný knapsack aj pre každý jeho sufix (intervaly tvaru $\\langle l+i; r \\rangle$).

Postavme si teraz nad našimi kryptomenami strom s rovnakou štruktúrou, ako má [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/) -- teda binárny strom, kde je každému vrcholu priradený nejaký interval, pričom koreňu je priradené celé pole, každému z jeho synov jedna polovica poľa, ich synom štvrtiny poľa atď. V každom vrchole nášho stromu zrátajme knapsack na intervale kryptomien, ktorý tento vrchol pokrýva, v oboch smeroch.

Akú výhodu nám to dá? Ľubovoľný interval sa teraz dá rozdeliť na dve časti (o chvíľu si ukážeme ako), pričom pre obe z nich už máme knapsack predrátaný niekde v našom strome. Ak by sme vedeli, koľko peňazí máme minúť v prvej a koľko v druhej časti, odpoveď na otázku by sme zrátali v konštantom čase sčítaním vhodných dvoch čísel, ktoré už máme predpočítané. To síce nevieme, ale môžeme vyskúšať všetky možnosti, ktorých je $p+1$. Poďme si teda zhrnúť naše riešenie.

Predstavme si, že nám príde otázka, že chceme výsledok knapsacku na intervale od $l$ po $r$. Skúsme nájsť nejaké intervaly v intervaláči, ktoré nám v tomto pomôžu. Začnime v koreni. Pokiaľ celý náš hľadaný interval leží len v pravom alebo len v ľavom synovi, tak nás vlastne tá druhá časť intervaláču nezaujíma a môžeme sa presunúť do syna, v ktorom sa náš interval nachádza. Toto opakujeme až dôjdeme do vrchola, kde toto opakovať nemôžeme. To môže znamenať, že sme v liste, vtedy je hľadaný interval dĺžky $1$ a odpoveď je jednoduchá. Buď si vieme dovoliť kúpiť kryptomenu a odpoveď je jej hodnota, alebo je odpoveď $0$. Iná možnosť je, že časti nami hľadaného intervalu ležia v oboch synoch. Dokonca vieme, že náš hľadaný interval je vlastne zlepením nejakého sufixu ľavého syna a nejakého prefixu pravého syna. Toto už ale máme predpočítané, teda jediné, čo ostáva, je nakombinovať odpoveď z týchto dvoch intervalov. Jediný problém je, že nevieme, koľko peňazí chceme minúť v ľavom synovi a koľko v pravom. Tak to urobíme jednoducho---keďže dokopy chceme minúť $p$ peňazí, tak vyskúšame všetky možnosti, ako rozdeliť tieto peniaze do synov. Potom už len zoberieme maximum a vypíšeme.

Ako sme teda zlepšili časovú zložitosť? Najprv si predpočítame celý intervalový strom. Všimnime si, že na každej úrovni tohto stromu zrátame niekoľko knapsackov, dokopy pre $n$ prvkov s tým, že minieme maximálne $p$ peňazí. Strom má $\\log n$ úrovní, a teda zrátať celý strom vieme v čase $O(n \\cdot p \\cdot \\log n)$. Pri spracovávaní konkrétnej otázky najprv potrebujeme nájsť vhodný vrchol, pričom pri každom kroku tohto hľadania klesneme v hĺbke stromu o $1$. Teda vrchol vieme nájsť v $O(\\log n)$, a na záver vyskúšame všetky možnosti rozdelenia peňazí do ľavého a pravého intervalu, čo bude trvať $O(p)$. Celková časová zložitosť je teda $O(n \\cdot p \\cdot \\log n + q \\cdot (\\log n + p))$. Čo sa týka pamäťovej zložitosti, tak si musíme pamätať celý náš intervalový strom, čo je $O(n \\cdot p \\cdot \\log n)$.
",10
1189cfe451fac935,ksp,"# Osobná doprava

Táto úloha má tak dlhé zadanie, že by potrebovala mínus pätnásť riadkov rozprávky.

Máme krajinu a v krajine rozmiestnených niekoľko zastávok. Zastávky majú mená: reťazce 1 až 10 malých písmen anglickej abecedy. Medzi $d$ dvojicami zastávok sa dá priamo cestovať. Pre takéto dvojice zastávok máme zadanú vzdialenosť v metroch. (Vzdialenosť je rovnaká oboma smermi.)

V našej krajine existuje $s$ jednosmerných spojení. Každé spojenie postupne navštívi dve alebo viac zastávok. Popis spojenia obsahuje okrem zoznamu zastávok ešte tri parametre: jeho rýchlosť $v_i$ (v metroch za sekundu), jeho periódu $p_i$ (v sekundách) a jeho offset $o_i$ (tiež v sekundách). Čas potrebný na presun medzi dvoma zastávkami si vieme vypočítať tak, že vzdialenosť medzi nimi vydelíme rýchlosťou a výsledok zaokrúhlime **nahor** na celé sekundy. Význam offsetu a periódy je nasledovný: Po trase spojenia už od nepamäti každých $p_i$ sekúnd vyráža zo začiatočnej zastávky nový spoj. Najbližšie sa tak stane o $o_i$ sekúnd odteraz.

Všimnite si, že pre jednoduchosť predpokladáme, že sa perióda nemení počas dňa. A taktiež sme zanedbali čas státia na zastávke: všetky naše spoje na zastávkach stoja 0 sekúnd, nastupuje a vystupuje sa za jazdy :)

Medzi spojeniami vieme na zastávkach ľubovoľne prestupovať. Na prestup nám tiež stačí nulový čas. Ak teda zastávkou prechádzajú v tom istom okamihu dva rôzne spoje, stíhame prestúpiť z jedného na druhý. Na zastávkach samozrejme môžeme na prestup aj ľubovoľne dlho čakať.

## Úloha

Daný je popis siete zastávok a spojení medzi nimi. Následne nasleduje niekoľko otázok. Každá otázka je tvorená dvomi menami zastávok: odkiaľ a kam chceme ísť. Vašou úlohou je vypočítať, či sa to dá, a ak áno, v akom najkratšom čase. Presnejšie, ak sme v čase 0 na zastávke, odkiaľ ideme, v akom najskoršom čase vieme byť na zastávke, kam ideme?

## Formát vstupu

V prvom riadku vstupu je číslo $d$, udávajúce počet dvojíc zastávok, medzi ktorými sa dá priamo cestovať. V každom z ďalších $d$ riadkov vstupu je popis jednej dvojice zastávok. Tento je uvedený vo formáte ""`meno1 meno2 vzdialenost`"".

V nasledujúcom riadku je číslo $s$, udávajúce počet spojení. V každom z nasledujúcich $s$ riadkov je popis jedného spojenia. Tento je uvedený vo formáte ""$v_i$ $p_i$ $o_i$ $z_i$ `zastavka_1 ... zastavka_`$z_i$"". Významy $v_i$, $p_i$ a $o_i$ sú uvedené vyššie, číslo $z_i\\geq 2$ udáva počet zastávok obsluhovaných spojením. Zastávky sú navzájom rôzne a pre každú dvojicu po sebe idúcich zastávok sme na vstupe mali uvedenú ich vzdialenosť.

V nasledujúcom riadku je číslo $q\\leq 10$, udávajúce počet otázok. V každom z ďalších, posledných $q$ riadkov vstupu je popis jednej otázky. Tento je uvedený vo formáte ""`odkial kam`"", pričom `odkial` a `kam` sú platné mená dvoch rôznych zastávok.

## Obmedzenia

Vo všetkých vstupoch platí $d\\leq 300,000$, ale v približne polovici vstupov je $d$ výrazne menšie. Rôznych zastávok bude nanajvýš $100,000$.

Všetky vzdialenosti medzi zastávkami, rýchlosti a periódy sú **kladné** celé čísla neprevyšujúce $100,000$. Pre offsety platí $0\\leq o_i \< p_i$.

Súčet všetkých $z_i$ (teda počtov zastávok jednotlivých spojení) neprekročí $300,000$. Vo vstupoch s malým počtom zastávok bude aj počet spojení malý.

Optimálna cesta (ak nejaká existuje) vždy trvá menej ako 20 dní. Všetky potrebné výpočty by sa vám teda mali zmestiť do bežných celočíselných premenných.

## Formát výstupu

Pre každú otázku uveďte jeden riadok a v ňom text ""`neda sa`"" ak sa z daného začiatku do daného cieľa nedá dostať, resp. text ""`?d ?h ?m ?s`"", kde namiesto otáznikov uveďte najmenší možný počet dní, hodín, minút a sekúnd, po ktorom vieme byť v cieli cesty.

## Príklad

```vstup
7
skladka smetisko 350
kontajner smetisko 299
dub javor 123
javor breza 234
dub breza 45678
breza lipa 1000
topol breza 50010
6
15 600 47 3 skladka smetisko kontajner
23 10 0 3 dub breza javor
1 1234 5 4 dub javor breza lipa
4 350 35 3 dub javor breza
100 1 0 2 javor dub
10 50 0 3 topol breza lipa
3
skladka kontajner
kontajner skladka
dub lipa
```

```vystup
0d 0h 1m 31s
neda sa
0d 0h 4m 11s
```

Prvé spojenie má rýchlosť $v_i=15$ (bežná MHD), periódu $p_i=600$ (ide raz za 10 minút) a offset $o_i=47$. Premáva na trase `skladka` -- (350 m) -- `smetisko` -- (299 m) -- `kontajner`. Vzdialenosť medzi skládkou a smetiskom prekonajú spoje tejto linky za 24 sekúnd, vzdialenosť medzi smetiskom a kontajnerom za 20. Najbližšie tri spoje po tejto trati odídu od skládky o 47, 647 a 1247 sekúnd odteraz, prejdú okolo smetiska o 71, 671 a 1271 sekúnd odteraz, a svoju cestu ukončia pri kontajneri o 91, 691 a 1291 sekúnd odteraz. Ak pôjdeme prvým z nich, dostaneme sa teda ku kontajneru o 1 minútu a 31 sekúnd od začiatku.

Pozrime sa teraz na poslednú otázku: ako sa dostať od dubu k lipe?

Ako prvé odchádza už v čase 0 spojenie, ktoré rýchlosťou 23 smeruje k breze a odtiaľ k javoru. Síce by sme sa ním mohli odviezť k breze, to ale nie je veľmi dobrý nápad -- prišli by sme tam až po 1986 sekundách, a ešte by sme sa museli odtiaľ dostať k lipe.

Ide nám aj priama linka okolo javora a brezy k lipe, ani tou však nie je dobrý nápad ísť. Najbližší spoj síce ide už o 5 sekúnd, je však pomalý: potrvá mu to 123 sekúnd k javoru, ďalších 234 ku breze a ďalších 1000 k lipe. Do cieľa by sme teda dorazili až po 1362 sekundách.

Najlepšie riešenie vyzerá nasledovne: Na štarte počkám 35 sekúnd, potom nasadnem na spoj idúci rýchlosťou 4 okolo javora k breze. Ten ma za 31 sekúnd privezie k javoru a za ďalších 59 k breze. Tam vystúpim. Je práve 125 sekúnd od začiatku. O ďalších 26 sekúnd, teda v čase 151, pôjde okolo brezy spoj na linke topoľ-breza-lipa. (Všimnite si, že tento spoj vyrazil na svoju cestu výrazne skôr ako my.) Ten ma za 100 sekúnd prevezie od brezy k lipe. V cieli som teda po 251 sekundách.
","# Osobná doprava

Našou úlohou bolo zistiť, či sa dá zo zastávky A dostať na zastávku B, a ak áno, ako najrýchlejšie to vieme spraviť. Toto je zjavne úloha grafová a zrejme bude nejak súvisieť s najkratšími cestami. Ale ako presne?

Základné pozorovanie, ktoré nám pomôže úlohu vyriešiť, je nasledovné: Predstavme si, že sme objavili dva rôzne spôsoby, ako sa zo zastávky A dá dostať na nejakú zastávku C. Prvý z nich tam príde v čase $t_1$, druhý v čase $t_2$ a platí $t_1\<t_2$. Pri hľadaní optimálneho presunu z A do B nám stačí zapamätať si len jeden z týchto dvoch spôsobov -- ten prvý. Totiž každý spôsob, akým vieme pokračovať zo zastávky C ďalej v druhom spôsobe máme k dispozícii aj pri prvom spôsobe príchodu, a možno máme ešte aj nejaké iné možnosti navyše, ktoré by sme pri príchode v čase $t_2$ nestihli.

Myšlienka všetkých nižšie popísaných algoritmov bude teda veľmi jednoduchá: V priebehu nášho algoritmu sa budeme snažiť zostrojiť množinu *všetkých* zastávok, ktoré sú dosiahnuteľné zo zastávky A. Pre každú takú zastávku si navyše vypočítame aj **najskorší** čas, v ktorom môžeme na danej zastávke byť.

## Predspracovanie vstupu

Už vieme, že vrcholmi nášho grafu budú jednotlivé zastávky. Na vstupe však namiesto hrán máme zadanú množinu spojení, ktoré našimi zastávkami prechádzajú. Priamo pri načítavaní vstupu však vieme každé spojenie prekonvertovať na sadu hrán -- ako keby sme ho nahradili viacerými linkami, z ktorých každá premáva len z jednej zastávky spojenia na druhú, bezprostredne nasledujúcu. Všetky hrany pochádzajúce z toho istého spojenia budú mať tú istú periódu. Ich offsety vypočítame jednoducho tak, že simulujeme jednu jazdu dotyčného spojenia a zapisujeme si, kedy sme navštívili ktorú zastávku.

Pre algoritmus Bellmana a Forda (prvé z riešení uvedených nižšie) by nám stačilo uložiť si všetky hrany grafu v jednom dlhočiznom zozname. Pre Dijkstrov algoritmus (druhé, lepšie riešenie) však budeme potrebovať hrany roztriediť: v každom vrchole grafu si budeme pamätať zoznam hrán, ktoré vedú z neho von. Takéto predspracovanie uvádzame aj v nasledovnom listingu.

V ďalšom texte budeme počet zastávok označovať $n$ a celkový počet hrán v našom grafe (teda súčet počtov úsekov jednotlivých spojení) budeme označovať $m$.

## Algoritmus Bellmana a Forda

Tento algoritmus je veľmi jednoduchý. Na začiatku vieme, že na zastávke A vieme byť v čase 0, a na žiadnej inej zastávke ešte nevieme byť. Toto si zapamätáme tak, že si pre ostatné zastávky zapíšeme, že tam vieme byť v čase ""nekonečno"", pričom ako nekonečno použijeme nejakú dostatočne veľkú hodnotu.

Teraz ideme tieto hodnoty postupne zlepšovať. Zlepšovanie bude prebiehať v kolách. V každom kole sa postupne (je jedno, v akom poradí) raz pozrieme na každú hranu. Predstavme si, že sa práve pozeráme na hranu zo zastávky C na zastávku D. Momentálne sa vieme na zastávku C dostať v čase $t_c$ a na zastávku D v čase $t_d$. Pomôže nám hrana, ktorú práve skúmame, niečo zlepšiť? Jediné, v čom nám môže táto hrana pomôcť, je, že sa pomocou nej možno vieme skôr dostať na zastávku D. Zoberime teda čas $t_c$, počkáme na zastávke C na najbližší spoj idúci práve skúmanou hranou a zistíme, kedy tento spoj dorazí na zastávku D. Ak sme práve dostali hodnotu menšiu ako $t_d$, zmenšíme $t_d$ na práve vypočítanú hodnotu -- práve sme objavili lepší spôsob ako docestovať z A na D.

V programe spracovanie jednej hrany vyzerá nasledovne:

Keď už v nejakom kole nenastanú vôbec žiadne zmeny, celý proces končí. Tvrdíme, že časy, ktoré sme vypočítali, sú najlepšími možnými časmi. Teda ak si pre nejakú zastávku ešte stále pamätáme hodnotu nekonečno, nedá sa na ňu vôbec dostať, a v opačnom prípade čas, ktorý sme vypočítali, je najlepší možný.

Teraz potrebujeme spraviť dve veci: dokázať, že vyššie uvedené tvrdenie platí, a zistiť, akú má tento algoritmus časovú zložitosť.

Všimnime si ľubovoľnú zastávku X, na ktorú sa dá zo zastávky A dostať. Nech je optimálna cesta z A na X tvorená $k$ hranami a postupne prechádza zastávkami $X_1$ až $X\_{k-1}$. Čo sa deje v našom algoritme? V prvom kole sa postupne pozeráme na všetky hrany, teda aj na hranu z A do  $X_1$. Po prvom kole sa teda už určite vieme dostať do $X_1$ v potrebnom čase. V druhom kole sa *opäť* postupne pozeráme na všetky hrany, a medzi nimi aj na hranu z $X_1$ do $X_2$. Po druhom kole sa teda už vieme v potrebnom čase dostať aj z A do $X_2$. A postupne ďalej -- po $k$-tom kole už musí byť vypočítaný čas pre zastávku X rovný optimálnemu.

Náš algoritmus je teda korektný. Navyše si uvedomme, že pre ľubovoľnú zastávku existuje optimálna cesta, pre ktorú platí $k\<n$. To je jednoduché -- nikdy sa neoplatí vracať na zastávku, na ktorej sme už boli, takže existuje optimálna cesta, na ktorej sa zastávky neopakujú. Algoritmu teda bude stačiť nanajvýš $n-1$ kôl. A keďže v každom kole sa pozeráme na $m$ hrán, je časová zložitosť tohto algoritmu $O(nm)$.

Implementácia spracovania jednej otázky:

## Dijkstrov algoritmus

Dijkstrov algoritmus počíta presne tie isté hodnoty ako algoritmus Bellmana a Forda, robí to ale šikovnejším spôsobom, a teda dosiahneme lepšiu časovú zložitosť. Existuje viacero rôznych implementácií Dijkstrovho algoritmu. Tá, ktorú si ukážeme my, bude mať časovú zložitosť $O(m\\log n)$.

Zlepšenie dosiahneme nasledovne: Namiesto toho, aby sme znova a znova prechádzali celý zoznam hrán, budeme každú hranu spracúvať len raz, ""v správnej chvíli"". Takisto práve raz budeme spracúvať každú zastávku. Zastávky budeme spracúvať *usporiadané podľa optimálneho času, kedy sa na ne vieme dostať*. Tieto časy síce na začiatku nepoznáme, ale postupne ich budeme zisťovať a vždy budeme vedieť, ktorú zastávku spracovať ako nasledujúcu v poradí.

Na začiatku zjavne spracujeme zastávku A: pozrieme sa na všetky hrany vedúce z nej a tak zistíme nové spôsoby ako sa dostať na nejaké ďalšie zastávky. Zastávku A si následne označíme ako spracovanú.

Ako bude vo všeobecnosti vyzerať kolo tohto algoritmu? Nejaké zastávky sme už spracovali, tie nás už nezaujímajú. Ak sa už na žiadnu ďalšiu zastávku nevieme dostať, algoritmus končí. Inak sa pozrime na tie, ktoré ešte spracované nie sú, a vyberme spomedzi nich zastávku X, na ktorú sa momentálne vieme dostať (spomedzi všetkých nespracovaných) najskôr. Túto zastávku spracujeme ako nasledujúcu v poradí.

Prečo tento algoritmus funguje? Preto, že v okamihu, keď zastávku spracúvame, tak platí, že čas, ktorý sme pre ňu vypočítali, je už optimálny.

(Formálne by sme napríklad matematickou indukciou dokázali, že platí nasledovné tvrdenie: keď sme už spracovali prvých $k$ zastávok, tak pre každú nespracovanú zastávku máme nájdený najlepší čas takej cesty na ňu, počas ktorej môžeme prestupovať len na už spracovaných zastávkach. No a následne si už len stačí všimnúť, že pre nami vybranú zastávku X už nemôže existovať ani rýchlejšia cesta, pri ktorej by sme prestupovali aj na nejakých nespracovaných zastávkach.)

Ako to celé dobre implementovať? Kľúčová operácia, ktorú potrebujeme robiť efektívne, je nájdenie zastávky X, ktorú ideme spracovať ako ďalšiu v poradí. Aby sme toto vedeli robiť rýchlo, budeme si zatiaľ nespracované zastávky *udržiavať usporiadané* podľa doteraz najlepšej vzdialenosti do nich.

V C++ by sme napríklad mohli ako dátovú štruktúru použiť `set< pair<int,int> > Q`, v ktorom by sme mali záznamy tvaru $(t,z)$ s významom ""najlepší známy čas, v ktorom už vieme byť na zastávke $z$, je $t$"". Nájsť nasledovnú zastávku na spracovanie vieme v čase $O(\\log n)$ tak, že sa pozrieme na `Q.begin()` (teda zastávku s najmenšou vzdialenosťou). Všetky výbery dokopy počas celého algoritmu nám teda budú trvať len $O(n\\log n)$.

Spracovať konkrétnu zastávku vieme v čase $O(d\\log n)$, kde $d$ je počet hrán vedúcich z nej. Pre každú hranu skúsime zlepšiť čas pre zastávku, kam vedie. A ak sa nám to podarí, tak z `Q` zmažeme starý záznam pre dotyčnú zastávku a nahradíme ho novým s menšou vzdialenosťou. No a keďže každú zastávku spracujeme počas behu algoritmu najviac raz, nasčítajú sa nám časy ich spracovania na sľubovaných $O(m\\log n)$.

V našej implementácii sme použili trochu lenivejší prístup. Ako dátovú štruktúru použijeme obyčajnú prioritnú frontu (implementovanú ako haldu). Z nej síce nevieme priebežne vymazávať, ale to nám vôbec vadiť nebude -- jednoducho to nebudeme robiť a keď zlepšíme čas pre nejakú zastávku, do prioritnej fronty pridáme nový záznam s novým lepším časom. A potom len pri výbere ďalšej zastávky na spracovanie dáme pozor, či nejde o zastávku, ktorú sme už skôr spracovali. Takéto záznamy jednoducho preskočíme (a teda ich vlastne až vtedy zmažeme).

V najhoršom prípade bude naša prioritná fronta obsahovať až $O(m)$ záznamov naraz. (Totiž každú hranu v grafe spracúvame najviac raz a každé také spracovanie nám pridá najviac jeden záznam.) Všetky operácie s prioritnou frontou budú teda v čase $O(\\log m)$ a teda výsledná časová zložitosť našej implementácie bude $O(m\\log m)$.
",9
1a2f0f36c73034ea,ksp,"﻿# Cyrilove investície

Ako aj mnoho iných v Krajine Sedemhranných Päťkorunákov, aj Cyril sa venuje investovaniu. Od rána do večera sleduje ceny rôznych aktív, aby mu neušla žiadna príležitosť. Našťastie, aj burzy majú svoje otváracie hodiny, a Cyril môže ísť niekedy aj spať.

Cyril ešte nedokončil svoje vzdelanie, a preto sa musí pravidelne účastniť (virtuálnych) prednášok. Aby mu nezapísali neprítomnosť, musí sa ukázať aspoň raz na každej prednáške. Keď je ale na prednáške, nemôže sledovať kurzy, a môže mu ujsť výhodná ponuka!

V Krajine Sedemhranných Päťkorunákov majú burzy neobvyklé otváracie hodiny, jedna je otvorená od 7:14:23.49 do 9:31:07.98, ďalšia od 8:42:22.72 do 11:53:21.44... Cyril by preto rád našiel časy, v ktorých keď sa objaví na prednáškach, príde o čo najmenej investičných príležitostí. Keďže Cyril venuje všetok svoj čas investovaniu, nemá čas si to spočítať, a preto potrebuje vašu pomoc.

## Úloha

V Krajine Sedemhranných Päťkorunákov sa nachádza $n$ búrz. Každá burza má svoje otváracie hodiny uvedené v centisekundách otvoreným intervalom $(a_i, b_i)$. Keďže Cyril na prednáškach nedáva pozor, ani nevie aké sú dlhé. Vie ale, že sa na nich musí ukázať aspoň raz za $t$ centisekúnd.

Vašou úlohou je nájsť takú postupnosť časov, v ktorých keď sa Cyril ukáže na prednáškach, ujde mu čo najmenej príležitostí. Za ujdenú príležitosť Cyril považuje to, že sa ukáže na prednáške v čase keď je otvorená niektorá burza.^[Cyrilovi stačí na prednáške sa iba ukázať, nemusí tam stráviť žiaden čas. Ak sa jedna burza v nejakom čase zatvára a druhá burza sa v tom čase otvára, Cyril sa v tomto čase stíha ukázať na prednáške bez toho aby mu ušla príležitosť na týchto burzách.] Každá burza otvorená v tomto čase sa ráta za jednu ujdenú príležitosť.

## Formát vstupu

V prvom riadku vstupu je číslo $t$ ($2\\leq t\\leq 1,000,000$) udávajúce maximálny čas medzi Cyrilovými účasťami na prednáškach. V druhom riadku vstupu je číslo $n$ ($1\\leq n\\leq 1,000,000$) udávajúce počet búrz v Krajine Sedemhranných Päťkorunákov.

V každom z nasledujúcich $n$ riadkov sa nachádzajú dve čísla oddelené medzerou, udávajúce interval $(a_i, b_i)$ ($1\\leq a_i < b_i\\leq 8,640,000$)^[$8,640,000 = 24 \\cdot 3600 \\cdot 100$, počet centisekúnd v jednom dni.] v ktorom je otvorená burza $i$.

V polovici sád testovacích vstupov navyše platí, že $t \\leq 250$.

## Formát výstupu

Vypíšte práve tri riadky.

Na prvom riadku vypíšte číslo $p$ udávajúce najmenší možný počet ujdených príležitostí.

Na druhom riadku vypíšte číslo $m \\leq 250,000$ udávajúce počet účastí na prednáškach.

Na treťom riadku vypíšte zoradenú postupnosť $m$ čísiel $u_i$ oddelených medzerami udávajúcu časy, v ktorých keď sa Cyril ukáže na prednáškach, ujde mu najviac $p$ príležitostí. Prvé číslo $u_1$ musí byť menšie alebo rovné času otvorenia prvej burzy a posledné musí byť väčšie alebo rovné času zatvorenia poslednej burzy.^[Keď už sú všetky burzy zatvorené, vie si Cyril sám určiť kedy sa zúčastní prednášok a nepotrebuje s tým vašu pomoc.] Rozdiel dvoch susedných čísiel musí byť $1 \\leq u\_{i+1} - u_i \\leq t$.

Vo všetkých testovaných vstupoch stačí Cyrilovi ukázať sa na prednáškach maximálne $250,000$ krát, dlhšie postupnosti nie je ochotný uznať.

## Príklady

```vstup
100
2
100 200
200 300
```

```vystup
0
3
100 200 300
```

*Cyril sa stíha zúčastniť sa prednášky v čase 200 bez toho aby mu ušla nejaká príležitosť.*

```vstup
150
3
100 300
140 260
190 350
```

```vystup
3
3
100 250 400
```

*V čase 250 Cyrilovi ujdu príležitosti na všetkých troch burzách.*

```vstup
150
3
100 300
140 260
190 350
```

```vystup
3
4
50 190 300 400
```

*Iné platné riešenie pre predchádzajúci vstup. V čase 190 Cyrilovi ujdú príležitosti na prvých dvoch burzách, v čase 300 na tretej burze.*

```vstup
150
3
100 300
140 260
190 350
```

```vystup
3
4
50 130 270 400
```

*Ďalšie platné riešenie pre predchádzajúci vstup. V čase 130 Cyrilovi ujde príležitosť na prvej burze, v čase 270 znovu na prvej a aj na tretej burze.*
","# Cyrilove investície

## Pomalé riešenie

Máme nájsť postupnosť časov, v ktorých sa má Cyril ukázať na prednáškach tak, aby mu ušlo čo najmenej príležitostí na investovanie. Toto môžeme riešiť dynamikou nasledovne: Nech $o_i$ je najmenší možný počet ujdených príležitostí do času $i$ (vrátane), ak sa Cyril ukáže na prednáške v čase $i$. Potom je $o\_{8;640;000}$ riešenie úlohy, najmenší možný počet ujdených príležitostí do konca dňa.^[Každá burza sa zatvára najneskôr na konci dňa, takže touto účasťou na prednáške Cyrilovi neujdú žiadne príležitosti.]

Nech $p_i$ je počet príležitostí, ktoré Cyrilovi ujdú zúčastnením sa prednášky v čase $i$, teda počet búrz otvorených v čase $i$. Potom je $o_i = p_i + \\min\_{i-t \\leq j < i} o_j$, keďže v čase $i$ Cyrilovi ujde $p_i$ príležitostí, a pred tým sa musel zúčastniť na prednáške niekedy v intervale $\\left\<i-t, i\\right)$. Na to, aby sme našli aj postupnosť časov, v ktorých sa má Cyril zúčastniť prednášok, stačí nám uložiť si pri počítaní $o_i$ aj zvolený čas $j$ predchádzajúcej účasti na prednáške.

Aby sme nevypisovali zbytočne veľa účastí, stačí úlohu riešiť na intervale $\\left\<\\min\_{0 \\leq i < n} a_i, \\max\_{0 \\leq i < n} b_i\\right>$, keďže podľa zadania si Cyril vie mimo tohto intervalu poradiť aj sám. Zadanie nám zaručuje, že najlepšie riešenie v tomto intervale bude dostatočne krátke.

Nakoniec ešte musíme nájsť postupnosť časov, v ktorých sa má Cyril ukázať na prednáškach. Keďže sme si pre každé $o_i$ zapísali čas predchádzajúcej účasti na prednáške, stačí postupovať od konca vždy k predchádzajúcemu času, a jednotlivé časy si zapisovať. Toto je jednoduchý cyklus kratší ako počítanie $o_i$, takže nám časovú ani pamäťovú zložitosť neovplyvní.

Nech $d = \\max\_{0 \\leq i < n} b_i - \\min\_{0 \\leq i < n} a_i + 1$ je dĺžka intervalu, v ktorom hľadáme riešenie. Najjednoduchší spôsob ako vypočítať hodnoty $p_i$ je v cykle spočítať ktoré burzy sú otvorené v čase $i$, čo má časovú zložitosť $O(dn)$. Hodnoty $o_i$ potom môžeme zrátať cyklom v čase $O(dt)$, teda celková časová zložitosť je $O(dn + dt)$, čo stačí na prvú sadu vstupov za 2 body.

## Rýchle riešenie

Hodnoty $p_i$ a $o_i$ je samozrejme príliš pomalé počítať cyklom.

Ak by sme mali hodnoty $a_i$ a $b_i$ usporiadané od najmenšej, $p_i$ môžeme vypočitať ako rozdiel počtu začiatkov a koncov intervalov od času $0$ po aktuálny čas, na čo nám stačí prejsť oba utriedené zoznamy po jednotlivých centisekundách pomocou dvoch indexov. Počet búrz otvorených v danej centisekunde je totiž rovný počtu búrz, ktoré boli otvorené pred touto centisekundou, mínus počet búrz, ktoré boli zatvorené najneskôr v tejto centisekunde. To vieme vypočítať ako počet búrz $p\_{i-1}$, ktoré boli otvorené v predchádzajúcej centisekunde, zväčšený o jedna pre každú burzu, ktorá sa otvára v čase $i-1$, a zmenšený o jedna pre každú burzu, ktorá sa zatvára v čase $i$. Keďže ale najprv musíme zoznamy $a_i$ a $b_i$ utriediť, má toto časovú zložitosť $O(n \\log n + d)$.

Počítanie $o_i$ vieme zrýchliť tým, že namiesto cyklu vyberieme najmenšie hodnoty $o_j$ pomocou [intervalového stromu](https://www.ksp.sk/kucharka/intervalovy_strom/) alebo [haldy](https://www.ksp.sk/kucharka/halda/). Ľahšie je použiť haldu, keďže tá je vstavaná vo väčšine programovacích jazykov.^\[`priority_queue` v C++, `heapq` v Pythone, `java.util.PriorityQueue` v Jave\] Stačí nám každú vypočítanú hodnotu $o_i$ vložiť do haldy, a pri hľadaní najmenšieho $o_j$ najprv vyhodíme tie hodnoty, ktoré sú už príliš staré. Nakoniec nám na vrchu haldy vždy ostane minimum. Túto časť teda vieme vypočítať s časovou zložitosťou $O(d \\log d)$.

Celkové riešenie má teda časovú zložitosť $O(d \\log d + n \\log n)$. Na toto riešenie potrebujeme $O(d + n)$ pamäte, keďže si musíme pamätať celý vstup dĺžky $n$ na to, aby sme ho mohli utriediť, a pre každú z $d$ hodnôt $o_i$ si musíme pamätať čas predchádzajúcej hodnoty $o_j$. Dobre napísané riešenie s touto časovou zložitosťou by malo prejsť všetky štyri sady vstupov.

## Rýchlejšie riešenie

Výpočty $p_i$ aj $o_i$ sa dajú ešte zrýchliť, a pri tom vieme vylepšiť aj pamäťovú zložitosť.

Ako prvé môžeme zrýchliť výpočet $p_i$ tým, že sa zbavíme triedenia hodnôt $a_i$ a $b_i$. To vieme spraviť tak, že si najprv pripravíme hodnoty $p_i'$ určujúce počet búrz, ktoré sa otvárajú v danú centisekundu, mínus počet búrz, ktoré sa zatvárajú v nasledujúcej centisekunde. Hodnoty $p_i$ potom dostaneme jednoducho prefixovými súčtami $p_i = \\sum\_{0 \\leq j < i} p_j'$. Toto je správne preto, lebo takto do $p_i$ zarátame počet všetkých búrz otvorených pred časom $i$ (pretože každá z týchto búrz je započítaná v jednom z $p_j'$ pre $j\<i$) a odrátame počet všetkých búrz zatvorených najneskôr v čase $i$ (pretože každá z týchto búrz je odpočítaná v jednom z $p_j'$ pre $j\<i$). Táto časť má časovú zložitosť $O(d+n)$, keďže potrebujeme $O(n)$ času na zarátanie každej burzy a $O(d)$ času na zrátanie prefixových súčtov.

Výpočet $o_i$ môžeme zrýchliť nasledovným pozorovaním. Ak pre $m < n$ platí $o_m \\geq o_n$, hodnotu $o_m$ už nepoužijeme pre žiadne ďalšie $o_i$ s $i > n$, keďže ak môžeme použiť $o_n$, je to vždy prinajhoršom rovnako dobrá voľba ako $o_m$, a hodnotu $o_n$ budeme môcť použiť aj pre $n + t \\geq i > m + t$ (narozdiel od $o_m$). Pri výpočte $o_i$ nám preto stačí pamätať si iba rastúcu podpostupnosť predchádzajúcich hodnôt $o_j$, a vždy keď nájdeme hodnotu, ktorá je menšia ako nejaké číslo v tejto podpostupnosti, predchádzajúce číslo môžeme zabudnúť. Taktiež môžeme vždy zabudnúť hodnoty, ktoré sú síce malé, ale už príliš staré. Preto vieme každé číslo $o_i$ vypočítať v konštantnom čase. Udržiavanie tejto podpostupnosti nám zaberie dokopy $O(d)$ času, keďže každé číslo do nej vložíme a z nej odstránime maximálne raz.

Celkové riešenie má teda časovú zložitosť $O(d + n)$. Keďže sme sa zbavili triedenia, vieme toto riešenie naprogramovať s pamäťovou zložitosťou $O(d)$, lebo stačí aby sme si pamätali hodnoty $p_i'$, konkrétne intervaly jednotlivých búrz nás nezaujímajú (samozrejme, musíme si pamätať aj $o_i$, predchádzajúce časy, atď., ale to je tiež $O(d)$).
",8
aa6ea3eb1db45ac6,ksp,"# Inotaj

Odnepamäti Kika vie,\
že to naj čo život skrýva,\
sú len predsa inotaje,\
kde zopár písmenok chýba.

Oj, písmen má chýbať veľa;\
až na f, k, s, m, p všetky.\
Čo sa to však deje? Ľaľa!\
Číž tu vyvoláva zmätky!

Len správne názory má, vraj.\
Jeho predstava je vcelku iná.\
Len to je správny inotaj,\
kde aspoň polka sú tie isté písmená.

Hodinu sa zvládli hádať,\
sťa hromu ozývajúc hlasy.\
Kristínka, už nebudeš mať,\
o dva roky dlhšie vlasy!

Odhodlane skričí: Číž,\
na papier mi slová daj!\
Keď ich všetky vymyslíš,\
napíšem ten inotaj!

## Úloha

Správny inotaj podľa Kiky a Číža je množina slov, kde aspoň polovica všetkých použitých písmen (vo všetkých slovách dohromady) je to isté písmeno. Číž Kike napísal zopár slov (podľa Kikinej požiadavky použil len písmená `f`, `k`, `s`, `m`, `p`). Kikina (a vaša) úloha je teraz zistiť, aký najdlhší inotaj z nich vieme poskladať (najdlhší v zmysle počtu slov). Kiku totiž nezaujíma počet znakov, ktoré má výsledný inotaj, ale počet slov, z ktorých sa skladá.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve čísla oddelené medzerou $n, k$. Nasleduje $n$ riadkov, na každom je jedno slovo dĺžky $s_i$, kde $1 \\leq s_i \\leq k$.

Platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-------------------|---------:|--------:|-----------:|----------:| | $1 \\leq n \\leq$ | $10$ | $100$ | $8000$ | $20,000$| | $1 \\leq k \\leq$ | $20$ | $200$ | $1000$ | $3500$|

## Formát výstupu

Na jediný riadok výstupu vypíšte jediné číslo, ktorého hodnota je počet slov v najdlhšom správnom inotaji, ktorý sa dá vyskladať z Čížových slov.

## Príklad

```vstup
3 2
k
sp
s
```

```vystup
3
```

*Keď vezmeme všetky tri slová, počet písmen `s` je presne polovica z celkového počtu použitých písmen.*

```vstup
3 3
kms
ksp
fks
```

```vystup
0
```

*Síce sa písmená opakujú medzi slovami, žiadna kombinácia však nemá aspoň polovicu rovnaké písmeno.*
","# Inotaj

## Veľmi pomalé riešenie

Na začiatok je dobré si uvedomiť, že inotaj je množina slov, čiže na poradí slov v inotaji _nezáleží_. Prvý spôsob riešenia, ktorý mnohým z vás mohol napadnúť je vyskúšať všetky možnosti. Postupovali by sme postupne zhora dole, čiže najprv by sme prešli riešenie zahŕňajúce všetkých $n$ slov, potom všetky $n-1$ slovné riešenia, $n-2$ slovné riešenia atď. Prvé riešenie, ktoré by v aspoň jednom znaku prešlo kontrolou (t. j. súčet výskytov jedného zo znakov je aspoň polovica všetkých znakov) by bol náš inotaj a vypísali by sme počet slov ktoré obsahuje.

Toto riešenie má ale veľmi pomalú časovú zložitosť: $O(nk2^n)$. To je zapríčinené tým, že počet všetkých podmnožín $n$-prvkovej množiny je $2^n$, a pre každú takúto množinu musíme prejsť najviac $n$ slov, každé dĺžky najviac $k$. Pamäťová zložitosť tohto programu je $O(nk)$.

## Na čo sme prišli

Zaujímavé pozorovanie, ktoré nám s úlohou pomôže je nasledovné: niektoré slová nám ""kazia"" kontroly a niektoré nie. Vlastne, pre konkrétny znak $x$, nám kontrolu, či znak $x$ tvorí aspoň polovicu znakov inotaja, kazia slová v ktorých $x$ tvorí menej než polovicu znakov. Mohli by sme sa teda pozrieť na jednotlivé písmená samostatne, a roztriediť si slová, podľa toho či nám kontrolu kazia, alebo nie (pre každé písmeno osobitne). Najskôr si nejako kvantifikujme ""kazenie.""

## Ako správne vyriešiť

Naše úvahy nás doniesli do momentu, kde sme si uvedomili, že je veľmi dôležitý pomer súčtu výskytu písmena v slove ku súčtu všetkých znakov slove. Pomer nám však dáva len zlomok, percentuálne vyjadrenie. Keby že porovnávame slová podľa toho ako veľmi sa nám oplatí ich zobrať, dlhšie slovo s pomerom pod 50% nám pokazí kontrolu viac ako kratšie slovo s rovnakým, niekedy aj horším pomerom.

Radšej si preto vypočítame, koľko výskytov písmena $x$ je v slove nad polovicou celkového súčtu jeho znakov. Ak je pod polovicou, tento koeficient ($c$) bude záporný. Potom vieme písmeno po písmene pažravo brať slová s najlepšími hodnotami $c$ čo sme si vypočítali. To sa dá implementovať pomocou funkcie `sort`; pre každé písmeno si zoradíme slová podľa $c\_{1}, ... c\_{k}$ od najlepšieho po najhorší. Následne postupne berieme slová, kým súčet $c\_{1}, ... c\_{i}$ nie je menší ako 0. Toto aplikujeme pre každé písmeno. Na výstup vypíšeme maximum slov, ktoré sme zobrali, čiže hodnotu $i$.

## Prečo to funguje

Ukážme si teraz, že ak existuje inotaj dĺžky $L$ kde má písmeno $x$ nadpolovičnú väčšinu výskytov, tak náš algoritmus určite nájde aspoň taký dlhý inotaj, kde bude mať písmeno $x$ tatiež nadpolovičnú väčšinu výskytov. Predstavme si, že náš algoritmus nájde najdlhší inotaj s nadpolovičným výskytom $x$ dĺžky $L'$ pozostávajúci zo slov $a\_{1}, a\_{2}, ... , a\_{L'}$, pričom slová sme si zoradili podľa koeficientu, tak že $a\_{L}$ má najnižší koeficient (vzhľadom na písmeno $x$).

Predstavme si, že by existoval nejaký inotaj dĺžky $L > L'$ pre toto písmeno, a povedzme že $b\_{1}, b\_{2}, ... , b\_{L'}, ... , b\_{L}$ je taký inotaj, ktorý má navyše najväčší prienik^[počet rovnakých slov] ako inotaj náš algoritmus našiel (slová sme zoradili podľa koeficientu tak ako predtým).

Najskôr uvažujme, čo by sa stalo ak existuje slovo $a_i$ v nájdemom inotaji, ktoré zároveň nie je v dlhšom inotaji. Potom, keďže algoritmus berie slová od najväčšieho koeficientu kým môže, musí existovať medzi slovami dlhšieho inotaju slovo s menších koeficientom, $b_j$. Všimnite si, že keď vymeníme slovo $b_j$ za $a_j$, dostaneme stále inotaj! Ale to je v rozpore s tým, ako sme dlhší inotaj vybrali. Tento prípad teda nemôže nastať.

Teda musí platiť, že všetky slová v nájdenom inotaji boli aj tomto dlhšom inotaji. Potom zoberme si prvé slovo ktoré už algoritmus nezobral do inotaju. Kvôli tomu, že sme si slová vzali pažravo, toto slovo má aspoň taký koeficient ako $b_L$, takže jedno pridaním by sme stále získali inotaj. Ale toto je v rozpore s tým, že si už algoritmus toto slovo nezobral.

Takže ani jeden s týchto prípadov nemôže nastať, a náš algoritmus vždy nájde nejaký najdlhší inotaj.

## Zložitosti

Vypočítanie koeficientov pre každé slovo pre každé písmeno trvá $O(5nk) = O(nk)$. Utriedenie koeficientov pre každé písmeno trvá $O(5n\\log(n)) = O(n\\log(n))$. Pažravé branie v usporiadaných poliach trvá $O(5n) = O(n)$. Toto riešenie má teda celkovú časovú zložitosť $O(nk) + O(n\\log(n)) + O(n) = O(nk + n\\log n)$. Ak na triedenie použijeme [counting sort](https://en.wikipedia.org/wiki/Counting_sort), časová zložitosť sa zníži na $O(nk)$.

Pamäťová zložitosť tohto programu je $O(nk)$.
",4
74816cdd62861876,ksp,"﻿# Interpol

Interpol naháňa nebezpečného zločinca: doktora Horibilného. Pomocou interpolácie (ako ináč) práve zistili jeho približnú polohu -- niekedy dnes sa zjaví niekde na dlhej rovnej ceste vedúcej cez soľné polia v Utahu. Rýchlo tam preto presmerovali kamery všetkých špionážnych satelitov.

Každý z týchto satelitov má slepé miesto. Toto má konštantnú veľkosť a ako sa satelit hýbe, aj toto miesto sa hýbe po ceste -- budeme predpokladať, že rovnomernou konštantnou rýchlosťou.

Je možné, že napriek množstvu satelitov nedokáže Interpol zločinca nájsť?

## Úloha

Na osi $x$ (predstavujúcej cestu) sa nachádza $n$ uzavretých intervalov. Každý interval predstavuje slepé miesto jedného zo satelitov. V tejto chvíli platí, že $i$-ty z týchto intervalov pokrýva súradnice $[\\ell_i,r_i]$. Interval $i$ sa hýbe doprava rýchlosťou $v_i$. Teda po uplynutí času $t$ bude slepý interval satelitu $i$ začínať na súradnici $\\ell_i + t\\cdot v_i$.

Zistite, či niekedy bude existovať nejaká časť cesty, ktorú v danom okamihu nebude nahrávať žiadny satelit. Ak áno, vypočítajte, aký najdlhší úsek cesty bude mať túto vlastnosť.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($1\\leq n\\leq 100,000$): počet satelitov. V každom z ďalších $n$ riadkov je jedna trojica celých čísel $\\ell_i$, $r_i$, $v_i$ ($0\\leq \\ell_i < r_i \\leq 10^6$, $1\\leq v_i\\leq 10^6$).

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno celé číslo -- najdlhšiu dĺžku intervalu, ktorý v nejakom okamihu nebol v zábere žiadneho zo satelitov.

(Toto číslo môže byť reálne, viď posledný príklad. Vypíšte ho s presnosťou na aspoň 7 desatinných miest. Výstupy, ktoré budú mať od nášho dostatočne malú odchýlku, budú akceptované.)

Ak hľadaný interval (ani degenerovaný) neexistuje, vypíšte namiesto toho číslo $-1$.

## Hodnotenie

Vaše riešenia budeme testovať na štyroch sadách vstupov. V jednotlivých sadách platí $n\\leq 5$, $n\\leq 20$, $n\\leq 1,000$ a $n\\leq 100,000$. V druhej a tretej sade navyše platí, že žiaden vstup nemá výstup $-1$ ani $0$.

## Príklady

```vstup
2
5 7 1
10 13 1
```

```vystup
-1
```

*Slepé miesta satelitov sa v tejto chvíli neprekrývajú, takže každý bod cesty vidí aspoň jeden z nich. No a keďže sa obe slepé miesta hýbu tou istou rýchlosťou, toto ostane pravdou aj naďalej.*

\\bigskip

```vstup
2
3 7 1
7 18 10
```

```vystup
0
```

*V tomto okamihu ani jeden zo satelitov nezaberá bod na súradnici 7, máme teda interval dĺžky 0, ktorý je nepozorovaný. V budúcnosti už nič lepšie (pre doktora Horibilného) nenastane.*

\\bigskip

```vstup
3
40 140 30
130 180 10
47 190 1
```

```vystup
44.4827586207
```

*V čase $t\\approx 1.724$ budú slepé intervaly našich troch satelitov približne $[91.724,191.724]$, $[147.241,197.241]$ a $[48.724,191.724]$, čiže v danom okamihu interval $[147.241,191.724]$ nebude zaberaný ani jedným zo satelitov.*
","﻿# Interpol

Zamyslime sa najskôr nad statickou verziou tejto úlohy: ak máme daných $n$ úsekov cesty $[ x_i,y_i]$, ako vyzerá ich prienik? Kedy je neprázdny?

Aby nejaký bod $x$ patril do prieniku všetkých intervalov, museli už všetky začať, teda musí platiť $x\\geq\\max_i x_i$. Tiež musí platiť, že žiaden interval ešte nesmel skončiť, teda $x\\leq\\min_j y_j$.

Z toho vidíme, že môžu nastať dva prípady: ak $\\max_i x_i > \\min_j y_j$, prienik je prázdny -- niektorý interval skončí skôr ako niektorý iný začne. V opačnom prípade je prienik neprázdny a je ním zjavne práve uzavretý interval $[\\max_i x_i, \\min_j y_j]$.

## Dĺžka intervalu ako funkcia

Ak si v našej úlohe zvolíme nejaký konkrétny okamih $t\\geq 0$, vieme si vypočítať, ako v danom okamihu vyzerajú slepé intervaly: $i$-ty z nich bude $[\\ell_i + tv_i, r_i + tv_i]$.

Nás zaujíma, akú najdlhšiu dĺžku (a pre aké $t$) bude mať tento interval. Uvažujme preto nasledujúcu funkciu: $f(t) = \\min_j (r_j + tv_j) - \\max_i (\\ell_i + tv_i)$. Zjavne platí, že ak $f(t) < 0$, tak je v čase $t$ prienik prázdny, a inak $f(t)$ udáva jeho dĺžku. Našu úlohu teda vieme preformulovať tak, že hľadáme, pre ktoré $t\\geq 0$ nadobúda funkcia $f$ svoje maximum.

## Príklad funkcie f

Na prvom grafe nižšie vidíme, ako sa tri rôzne slepé intervaly pohybujú v čase. Na $x$-ovej osi je čas, na $y$-ovej vzdialenosť na ceste. Znázornené intervaly zodpovedajú poslednému príkladu v zadaní, až na to, že $\\ell_2$ je o čosi väčšie, aby to lepšie vyzeralo.

Čiarkované čiary predstavujú začiatky jednotlivých intervalov. Nás vždy zaujíma posledný začiatok (hodnota $\\max_i (\\ell_i + tv_i)$), čiže najvyššie sa nachádzajúca čiarkovaná čiara.

Analogicky nás v každom čase zaujíma prvý koniec intervalu, čiže najnižšie sa nachádzajúca plná čiara. Ak sa tá nachádza nad všetkými čiarkovanými, intervaly majú v danom čase neprázdny prienik.

Na druhom grafe sme vyfarbili oblasť, ktorá zodpovedá neprázdnemu prieniku intervalov, a hrubou čiarou sme vyznačili optimálne riešenie našej úlohy.

## Dôležitá vlastnosť funkcie f

V čase $t=0$ vidíme, že najvyššia čiarkovaná čiara zodpovedá intervalu 1, zatiaľ čo najnižšia plná čiara intervalu 0. No a keďže interval 0 sa hýbe rýchlosťou 30 a interval 1 len rýchlosťou 10, keď teraz pôjdeme v čase ďalej, bude dĺžka prieniku plynule rásť (rýchlosťou $30-10 = 20$ za jednotku času).

V čase $t=50/29$ sa spodnou plnou čiarou stane čiara zodpovedajúca intervalu 2. Ten sa hýbe len rýchlosťou 1. Od tohto okamihu ďalej teda bude čiarkovaná čiara \\uv{dobiehať} plnú. Dĺžka prieniku sa teda bude meniť o $1-10 = -9$ za jednotku času.

V čase $t=9/2$ nastane ďalšia zmena: hornou čiarkovanou čiarou sa stane čiara zodpovedajúca intervalu 0. Od tejto chvíle sa dĺžka prieniku mení rýchlosťou $1-30 = -29$ za jednotku času, a čoskoro už prienik prestane existovať.

Na tomto príklade si môžeme všimnúť všeobecné pravidlo, ktoré bude vždy platiť: rýchlosť, ktorou rastie dĺžka prieniku, sa môže s rastúcim časom \\emph{len zmenšovať}. Totiž vždy, keď nastane zmena najvrchnejšej čiarkovanej čiary, tá nová rastie rýchlejšie, a vždy, keď nastane zmena najspodnejšej plnej čiary, tá nová rastie od tej predchádzajúcej pomalšie.

Keďže na začiatku môže byť rýchlosť rastu kladná, znamená to, že samotná \\emph{dĺžka prieniku} (presnejšie, hodnota funkcie $f$, ktorá nás zaujíma) vo všeobecnosti \\emph{najskôr nejaký čas rastie, potom je nejaký čas konštantná, a nakoniec klesá}.

My teraz potrebujeme nájsť maximum takejto funkcie. Spravíme to binárnym vyhľadávaním.\\footnote{Existuje aj korektné riešenie založené na tzv. ternárnom vyhľadávaní, ktoré funguje trochu ináč. Značnú časť riešenia však majú oba tieto prístupy podobnú, preto sme sa rozhodli popísať len binárne vyhľadávanie. K ternárnemu uvedieme na konci len program.}

## Binárne vyhľadávanie

V ľubovoľnom čase $t$ si vieme v čase $O(n)$ nájsť aj najspodnejšiu plnú čiaru, aj najvrchnejšiu čiarkovanú, a u oboch sa pozrieť na to, ako rýchlo rastú. Rozdiel týchto dvoch hodnôt nám povie, či v danom bode funkcia $f$ ešte rastie, je práve konštantná, alebo už klesá.

Začneme tým, že sa pozrieme na čas $t=0$. Ak už v tomto okamihu $f$ nerastie, je $f(0)$ odpoveďou, ktorú hľadáme a môžeme skončiť.

Označme teraz $m$ najväčšie číslo na vstupe (či už ide o súradnicu alebo rýchlosť). Pripomíname, že pre testovacie dáta platilo $m\\leq 10^6$. Potom tvrdíme, že po čase $m$ už nenastane žiadna zmena: od tohto času ďalej musí byť aj čiarkovaná aj plná čiara stále tá istá. Totiž ak iná bola od nej rýchlejšie/pomalšie rastúca, tak na začiatku mala táto pred ňou \\uv{náskok} najviac $m$, a keďže sú všetky čísla celé, tá druhá čiara tento náskok dobiehala aspoň rýchlosťou 1 za jednotku času.

(Algebraicky, priesečník priamok $a+bt$ a $c+dt$, kde $c\\not= d$, je v bode $t=(a-c)/(d-b)$, no a v základnom tvare má tento zlomok má čitateľ $\\leq m$ a menovateľ $\\geq 1$.)

Máme teraz dve pozorovania: v čase $t\_{lo}=0$ funkcia $f$ ešte rastie, zatiaľ čo v čase $t\_{hi}=m$ už určite nerastie. Od tohto okamihu ďalej môžeme použiť spomínané binárne vyhľadávanie: dokola opakujeme, že sa pozrieme do stredu intervalu, vyhodnotíme, či tam $f$ ešte rastie alebo už nerastie, a podľa toho posunieme buď $t\_{lo}$ alebo $t\_{hi}$.

## Trocha technických detailov na záver

Pri praktickej implementácii si treba dať pozor na zaokrúhľovacie chyby. Hodnotu optimálneho $t$, a teda aj hodnotu $f(t)$, zistíme len približne. Zadanie síce sľubuje, že testovač je tolerantný, ale aj tak ostáva jeden okrajový prípad, na ktorý si treba dať pozor: ak je optimálna odpoveď presne $f(t)=0$, ale správne $t$ netrafíme presne, dostaneme ako $f(t)$ hodnotu, ktorá je tesne pod nulou. Ak vtedy prehlásime, že riešenie neexistuje, dáme nesprávnu odpoveď.

V jednom autorskom riešení sme pre istotu celý záver riešenia spravili exaktne: po dostatočnom počte iterácií binárneho vyhľadávania máme nájdené nejaké $t$. Okrem tohto $t$ si exaktne (ako zlomok dvoch veľkých čísel) dopočítame najbližšie menšie aj najbližšie väčšie $t$, v ktorom sa mení niektorá hraničná čiara, a v oboch časoch exaktne vyhodnotíme funkciu $f$. Takto máme istotu, že sme určite našli optimálne riešenie.

Na úspešné vyriešenie úlohy však stačilo aj použitie reálnych (floating-point) čísel a vhodné zaokrúhľovanie. Správny čas $t$, aj správna odpoveď je totiž vždy zlomok, ktorého menovateľ je najviac $m$. V našom prípade to teda znamená, že ak je maximum $f$ naozaj záporné, tak je vždy menšie alebo rovné $-10^{-6}$. A teda ak nám vychádza odpoveď výrazne bližšia nule, môžeme si byť rozumne istí, že správnou odpoveďou je samotná nula.
",8
715f2f4a78a993aa,ksp,"# Bezkonkurenčná manufaktúra

V dnešnej zúboženej ekonomike sa možno iba ťažko na niečo spoľahnúť. Jednou výnimkou tohoto pravidla je však nemenný dopyt po sršňom mede. Ten ako jediný zostal neovplyvnený, po tom, čo nedávne udalosti postihli už aj ziskovosť produkcie pavúčieho medu.

Vašej sršnej farme sa už dlhšiu dobu darí náramne dobre. Morálka je vysoká, produkcia je bezproblémová a výrobok je kvalitný. Sršne sú vďaka desiatkam hodín nadštandardného tréningu schopné a vysoko zorganizované. Na rozdiel od včiel majú sršne vďaka svojej vyššej inteligencii rádovo väčší potenciál, ktorý má v kombinácii s poctivým prvotriednym tréningom za následok pedantne efektívnu Lean-Agile manufaktúru s rozsiahlou hierarchiou vedenia. Primitívny pôvod včelieho medu je v porovnaní na smiech.

## Úloha

Výroba špičkového sršnieho medu je vysoko technická záležitosť založená na častej komunikácii. Tá prebieha *iba* v rámci hierarchie. Teda každý sršeň vie komunikovať iba so svojím priamym nadriadeným alebo podriadenými, pričom na umožnenie komunikácie ľubovoľnej dvojice sršňov bol zavedený systém preposielania správ. Sršnia hierarchia samozrejme umožňuje komunikáciu ľubovolným dvom sršňom a to dokonca unikátnym najkratším spôsobom. V hierarchii sa teda nevyskytujú cykly, keďže v internom testovaní sa ukázalo, že ich prítomnosť síce občas skrátila čas dodania správy, avšak pridaná komplexita narúšala sršňom pracovný flow.

Tento systém doteraz fungoval bezchybne. Máte však obavy o jeho dlhodobom vplyve na niektorých jedincov. V hierarchii sa vyskytuje niekoľko sršňov, ktoré slúžia ako nevyhnutný spostredkovateľ komunikácie veľkého množstva dvojíc. Dokonca ste zistili, že v nej existuje jeden sršeň, ktorý je najvyťaženejší zo všetkých a o ktorého máte preto najväčšie obavy. Ste teda ochotní umožniť komunikovať jednej ľubovoľnej dodatočnej dvojici sršňov, aby ste ho aspoň trochu odbremenili. Zaujímalo by vás, koľko dvojíc využíva tohoto sršňa ako sprostredkovateľa a koľko najmenej dvojíc ho bude stále nutne využívať po tom, čo umožníte komunikáciu jednej dodatočnej dvojici (výber dvojice nechávame na vaše uváženie). Vašou úlohou bude túto analýzu efektívne vykonať na všetkých manufaktúrach vašej farmy.

## Formát vstupu

Na vstupe bude na prvom riadku číslo $2 \\leq N \\leq 100001$ označujúce počet sršňov v práve analyzovanej manufaktúre. Nasleduje $N-1$ riadkov popisujúcich hierarchiu sršňov - na každom z nich dve čísla $0 \\leq A, B < N$ symbolizujúce susednosť sršňov $A$ a $B$ v rámci hierarchie. Hierarchia na vstupe je súvislá a bez cyklov. Sršeň $0$ je vedúcim manufaktúry a existuje práve jeden najvyťaženejší sršeň.

## Formát výstupu

Na výstup vypíšte na práve jeden riadok práve dve celé čísla v desiatkovej sústave oddelené práve jednou medzerou. Prvé číslo je počet dvojíc sršňov, ktoré nutne komunikujú cez najvyťaženejšieho sršňa a druhé číslo je to isté, avšak v prípade umožnenia komunikácie jednej dodatočnej dvojici.

## Príklady

```vstup
7
0 1
1 2
2 3
2 4
4 5
4 6
```

```vystup
11 5
```

_Sršeň 2 je navyťaženejší. Po tom, čo umožníme komunikovať napríklad sršňom 0 a 6, už bude sršeň 2 nutne sprostredkovávavávať iba komunikáciu sršňa 3 so všetkými ostatnými (avšak pri komunikácii sršnov 2 a 3 neslúži sršeň 2 ako sprostredkovateľ)._
","# Bezkonkurenčná manufaktúra

Zadanie úlohy nám popisuje graf v tvare stromu a nariaďuje nájsť určitý kritický vrchol. Tento vrchol sa nachádza na ceste medzi najväčším počtom dvojíc. Otázkou je, koľko dvojíc to je (nazvime túto vlastnosť dôležitosť) a koľko dvojíc to bude, ak môžeme pridať jednu dodatočnú hranu (dôležitosť s dodatočnou hranou). Otázka na koľkých cestách sa nachádza vrchol je ekvivalentná otázke, koľko ciest sa preruší keď ho odstránime.

## Triviálny bruteforce

Na začiatok navrhnime kľudne aj pomalé riešenie, ktoré nám však dá aspoň správny výsledok. Pre odpoveď na prvú otázku, môžeme skúsiť odstrániť každý možný vrchol a potom pre každú možnú dvojicu spustiť prehľadávací algoritmus (DFS, BFS, ...), ktorý nám povie, či sú tieto dva vrcholy spojené. Keďže pred odstránením kritického vrcholu nutne spojené museli byť, počet dvojíc čo spojené nebudú bude dôležitosť tohoto vrcholu. Vrchol s najvyššou dôležitosťou je potom kritický vrchol. Toto vieme spraviť v čase $O(N^4)$, keďže pre každý vrchol a každú dvojicu spustíme prehľadávanie v $O(N)$.

Jednoduché vylepšenie bude spustiť prehľadávanie nie pre každú dvojicu, ale iba pre každý vrchol, keďže počas jedného vyhľadávania nájdeme všetky dosiahnuteľné vrcholy. Dostávame sa teda k časovej zložitosti $O(N^3)$ na zodpovedanie prvej otázky.

Pri zodpovedaní druhej otázky už poznáme kritický vrchol. Môžeme teda napríklad pre každú dvojicu vrcholov skúsiť pridať hranu a znova zistiť dôležitosť vrchola v čase $O(N^2)$, čím by sme získali celkovú časovú zložitosť $O(N^4)$.

## Netriviálny bruteforce

Zamyslime sa, čo sa stane, ak odstránime tento kritický vrchol. Strom sa rozpadne na niekoľko súvislých komponentov, ich počet bude rovný počtu susedov kritického vrcholu. Samozrejme, z definície súvislého komponentu, všetky dvojice vrcholov v rámci jednotlivých komponentoch medzi sebou naďalej budú mať cestu (Mohli sme si všimnúť, že keď sme pri zodpovedaní prvej otázky robili prehľadávanie, veľa vrcholov malo rovnaký počet dosiahnuteľných vrcholov, keďže boli v tom istom komponente. Ďalšie vylepšenie je teda púštať prehľadávanie iba pre ešte nenavštívené vrcholy). Cesty, ktoré sa odstránením kritického vrcholu narušia budú teda nutne iba cesty medzi vrcholmi z dvoch rôznych komponentov.

To znamená, že nezáleží na konkrétnych koncových vrcholoch pridávanej hrany, ale iba na tom, ktoré komponenty daná hrana spája. Mohli by sme teda naše doterajšie riešenie zoptimalizovať tak, aby neskúšalo všetky dvojice vrcholov, ale iba všetky dvojice susedov kritického vrcholu. Keďže však môže mať vrchol až $N-1$ susedov, počet dvojíc susedov je stále $O(N^2)$, a teda si z pohľadu efektivity nepomôžeme. Predsa nám však toto uvedomenie pomôže.

Cesty, ktoré sa prerušia odstránením kritického vrcholu sú iba cesty medzi vrcholmi z dvoch rôznych komponentov a cesta bude prerušená všetkým takýmto dvojiciam vrcholov. Dôležitosť vrcholu sa teda dá vyjadriť iba na základe veľkosti komponentov jeho susedov. Nech množina susedov kritického vrcholu je $S$ a $K_x$ je veľkosť komponentu, v ktorom je sused $x$, potom dôležitosť daného vrcholu je [^1] $$ {1 \\over 2} \\sum\_{i, j \\in S, i \\neq j} K_i * K_j $$ teda súčin počtu vrcholov v jednom komponente a počtu v vrcholov v druhom komponente pre každú dvojicu komponentov (predelený dvomi, keďže komponent $A$ a $B$ boli zarátané pre $i=A, j=B$ a $i=B, j=A$).

Zmysluplným pridaním hrany vieme spojiť práve dva komponenty. Keďže chceme minimalizovať dôležitosť vrcholu, chceme maximalizovať počet dvojíc vrcholov, ktoré ňou prepojíme. Zjavne chceme teda vybrať dva najväčšie komponenty.

Znovu vieme zoptimalizovať náš aktuálny algoritmus. Na zodpovedanie druhej otázky môžeme ľubovoľným prehľadávaním nájsť veľkosti jednotlivých komponentov pre už nájdený kritický vrchol, vybrať dva najväčšie z nich a znížiť odpoveď prvej otázky o ich súčin. Toto vieme spraviť v lineárnom čase. Celková časová zložitosť bude kvôli zodpovedaniu prvej otázky $O(N^3)$.

Zjavne je teraz hrdlom fľaše nájdenie kritického vrcholu. Môžeme takéto lineárne hľadanie veľkosti komponentov použiť pre každý vrchol, a teda v čase $O(N^2)$. Následne by sme pre každý vrchol v čase $O(s^2)$ kde $s$ je počet jeho susedov vypočítali jeho dôležitosť. Dá sa ukázať, že aj keď pre $N$ vrcholov robíme po $O(s^2)$ operácií, celková časová zložitosť je stále $O(N^2)$ (dôležité pri analýze časovej zložitosti je, že graf je strom a má teda iba málo hrán).

## Optimálne riešenie

Aktuálne máme dva problémy. Hľadanie veľkosti komponentov nám trvá $O(N^2)$ a počítanie dôležitosti pre vrchol nám trvá $O(s^2)$. Ani jeden problém však našťastie nie až také ťažké vyriešiť.

Chceme veľkosti komponentov vypočítať na jeden prechod. Spustíme z koreňa DFS prehľadávanie, ktoré nám pre každý vrchol zistí, koľko vrcholov je v jeho podstrome. Robíme to rekurzívne. Pre vrchol, ktorý už nemá deti je odpoveď $1$, pre vrchol čo má deti je odpoveď súčet výsledkov rekurzívnych volaní na jeho deti plus $1$. Pre každý vrchol sa vieme pozrieť na veľkosti podstromov jeho detí, čo sú predsa veľkosti komponentov jeho susedov. Chýba nám iba veľkosť jedného komponentu a to komponentu suseda, ktorý je náš rodič. Jeho veľkosť však vieme samozrejme ľahko vypočítať ako počet vrcholov v strome mínus veľkosť podstromu aktuálneho vrcholu. Časová zložitosť tejto časti je teda $O(N)$.

Druhý problém si zase vyžaduje trochu matematiky. Pozrime sa na vzorec, podľa ktorého sme to počítali doteraz a skúsme ho upraviť.

\\begin{align\*} &{1 \\over 2} \\sum\_{i, j \\in S, i \\neq j} K_i * K_j \\ &{1 \\over 2} \\sum\_{i\\in S} \\sum\_{j \\in S, i \\neq j} K_i * K_j \\ &{1 \\over 2} \\sum\_{i \\in S} (K_i \*\\sum\_{j \\in S, i \\neq j} K_j) \\ &{1 \\over 2} \\sum\_{i \\in S} K_i * (-K_i +\\sum\_{j \\in S} K_j) \\ &{1 \\over 2} \\sum\_{i \\in S} K_i * (-K_i + (N - 1)) \\ &{1 \\over 2} \\sum\_{i \\in S} (K_i * (N - 1) - K_i^2) \\ &{1 \\over 2} (\\sum\_{i\\in S} K_i * (N - 1) - \\sum\_{i \\in S} K_i^2) \\ &{1 \\over 2} ((N - 1) *\\sum\_{i \\in S} K_i - \\sum\_{i \\in S} K_i^2) \\ &{1 \\over 2} ((N - 1)^2 -\\sum\_{i \\in S} K_i^2) \\end{align*}

Pri úpravách sme použili dve netriviálne úpravy vo forme rovností:

1. $\\sum\_{j \\in S, i \\neq j} K_j = -K_i + \\sum\_{j\\in S} K_j$, teda že súčet veľkostí všetkých susedných komponentov až na komponent suseda $i$ je súčet všetkých mínus veľkosť toho jedného a
1. $\\sum\_{x \\in S} K_x = N - 1$, teda že súčet veľkostí všetkých susedných komponentov je počet všetkých vrcholov okrem jedného vrcholu (toho kritického).

No a vidno, že takýto vzorec už zvládame vypočítať v lineárnom čase od počtu susedov pre každý vrchol, čo je dokopy iba dvojnásobok počtu hrán. Celková časová aj pamäťová zložitosť je teda $O(N)$.

\[^1\]: $\\sum\_{podmienka} \\cdots$ označuje súčet nejakých čísel na základe danej podmienky. Teda ak napríklad $S = {1, 2, 3}$, potom $\\sum\_{i, j \\in S, i \\neq j} K_i * K_j$ vieme rozpísať ako $K_1 * K_2 + K_1 * K_3 + K_2 * K_1 + K_2 * K_3 + K_3 * K_1 + K_3 * K_2$
",6
370f6da5470f84ce,ksp,"﻿# Idem, padám, balancujem

Krtko sa chce dostať z tej masívnej KSP párty domov, ale keďže sa prejedol torty, tak sa len tak kotúľa. Snaží sa kráčať, no každým krokom sa bojí, že sa preváži a spadne. Preto, koľko krokov spraví pravou nohou, toľko ich musí spraviť aj ľavou, aby to nejak vybalansoval. Ale keďže je hrooozne najedený, tak sa nechce úplne nachodiť.

## Úloha

Daný je graf s $n$ vrcholmi, očíslovanými od $1$ po $n$, ktorého vrcholy reprezentujú Krtkove pozície na ceste domov po krokoch -- čo vrchol, to krok (kam Krtko spraví krok, tam sa posunie celým telom; nemôže byť nohami v dvoch vrcholoch naraz). V grafe sú samozrejme aj nejaké iné možnosti krokov, kam nie nutne musí stúpiť. Hrana z $a$ do $b$ znamená, že z vrcholu $a$ vie do $b$ prejsť na jeden krok.

Nájdite cestu párnej dĺžky z vrcholu číslo $1$ (miesto, kde bola párty) do vrcholu číslo $n$ (miesto, kde Krtko býva), kratšiu ako $2n$ (nechce sa predsa nachodiť). Krtko sa samozrejme ale vie stratiť a zamotať, a teda môže prejsť v grafe cez vrchol aj viackrát a po hranách tiež.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ ($1 \\leq n \\leq 10^5$) počet vrcholov, a $m$ ($1 \\leq m \\leq 10^6$) počet hrán.

Nasleduje $m$ riadkov popisujúcich hrany. V každom z nich sú dve čísla oddelené medzerou, čísla vrcholov medzi ktorými je hrana.

Pre sady vstupov platia nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------|---------:|---------:|---------:|---------:| | $n \\leq$ | $10$ | $100$ | $1,000$ | $10^5$ | | $m \\leq$ | $10$ | $1,000$ | $10^4$ | $10^6$ |

## Formát výstupu

Na jeden riadok vypíšte zaradom čísla vrcholov cez ktoré Krtkova cesta prechádza -- do ktorých Krtko spraví krok, oddelené medzerou (vrátane vrcholu $1$ a $n$). Ak žiadna vyhovujúca postupnosť neexistuje vypíšte $-1$.

## Príklady

```vstup
6 6
1 6
3 2
2 4
5 4
4 3
3 6
```

```vystup
1 6 3 2 4 3 6
```

```vstup
6 6
1 2
2 3
3 4
2 5
3 6
5 6
```

```vystup
-1
```
","# Idem, padám, balancujem

V tejto úlohe sme mali zadaný graf na $n$ vrcholoch. Zaujímalo nás nájdenie takej cesty z vrchola 1 do vrchola $n$, ktorá má párnu dĺžku menšiu ako $2n$.

## Pomalé riešenie

Zadanie úlohy vyzerá takmer ako bežné hľadanie najkratšej cesty. Jediným problémom je, že naša cesta musí mať párnu dĺžku.

Môžeme teda spraviť nasledovný trik. Vyrobíme si nový graf na vrcholoch 1 až $n$. V tomto novom grafe bude hrana medzi každou dvojicou vrcholov $a$, $b$ takou, že v pôvodnom grafe boli $a$, $b$ vo vzdialenosti 2. Inak povedané, každá hrana v novom grafe bude predstavovať dve hrany pôvodného grafu.

Keď teraz nájdene najkratšiu cestu mezdi vrcholmi 1 a $n$ v novom grafe, bude mať nejakú dĺžku $d$. Táto cesta bude zodpovedať ceste dĺžky $2d$ v pôvodnom grafe. Ak je $2d < 2n$, našli sme vyhovujúce riešenie. Na hľadanie najkratšej cesty môžeme použiť vhodné prehľadávanie grafu.

Toto riešenie bude mať časovú zložitosť $O(n^3)$ kvôli vytváraniu nového grafu.

## Štandardná úloha

Táto úloha je celkom štandardná. Pri bežnom hľadaní najkratšej cesty si v každom vrchole pamätáme najmenšiu vzdialenosť, na ktorú sa do daného vrchola vieme dostať zo zdroja. My si ale v každom vrchole budeme pamätať dve informácie. Jedna z nich bude predstavovať najmenšiu párnu vzdialenosť, na ktorú sa do daného vrchola vieme dostať. Druhá bude analogicky predstavovať najmenšiu nepárnu vzdialenosť do daného vrchola zo zdroja.

Obe tieto informácie vieme počas prehľadávania grafu jednoducho aktualizovať. Princíp je rovnaký, ako pri obyčajnom BFS.

## Netreba najkratšiu cestu

Zadanie od nás vyžaduje iba nájsť nejakú nie príliš dlhú párnu cestu. Namiesto BFS teda môžeme použiť aj DFS. Opäť budeme mať 2 kópie pôvodného grafu. Jednu nazveme nepárna, druhú párna. V každom kroku DFS sa presunieme do susedného vrchola, avšak v opačnej kópii. Prehľadávanie začneme v jednej z kópií vo vrchole 1. Ak sa nám podarí dostať do vrchola $n$ v tej istej kópií, našli sme párnu cestu.

Ak niekedy počas prehľadávania prejdeme už viac, ako $2n$ vrcholov, nevnoríme sa ďalej, pretože by takáto cesta bola príliš dlhá.

Takéto riešenie má časovú aj pamäťovú zložitosť $O(n + m)$.
",6
1e69ee2694c16787,ksp,"# Lamborghini? Bicykel.

**22.02.2022, Amsterdam.**

Presne pred rokom Kolektív Sofistikovaných Pesimistov získal 90%-nú väčšinu Klimatizovaného Svetového Parlamentu.

Dnes organizuje tajnú Konferenciu o Sprevinilej Planéte, ktorej cieľom je rozhodnúť o osude našej modrej planéty Zem. Iniciatíva na zvolanie tejto tajnej konferencie bola podaná po zverejnení virálnej eseje šéfa zmieneného kolektívu, Dr. Michala Anderleho, s názvom _""Ľudstvo, ktoré si zvolilo pesimistov, stráca nárok na budúcnosť""_. Logicky, v kolektíve teraz prevláda názor, že Zem treba odpáliť do vesmíru a/alebo zrovnať so zemou.

Je tu však nádej. Posledný optimista. Posledný pravý optimista, s vôľou zachrániť túto planétu pred nenávratnou skazou. Jeho meno je Askar.

**vŕŕŕŕŕ** _Somebody once told me_ **vŕŕŕŕŕ** _the world is gonna roll me_ **vŕŕŕŕŕ**

Askar: Haló? ???: Askar, to som ja, Afrodita. Askar: ??? Afrodita: Kolektív Sofistikovaných Pesimistov pripravuje plán na zničenie planéty. Nemôžeš to dopustiť. Na svete je toľko krásy. Musíš okamžite ísť na Konferenciu o Sprevinilej Planéte! Askar: To dnes nestíham -- myš mi rozhrýzla pneumatiku na mojom Lamborghini. Afrodita: Použi miestny bike-sharing systém. Stihneš to. Askar: Ale počúvaj... hééj, ty si to zložila? Do kelu aj s tebou!

## Úloha

Askar sa musí dostať zo svojho domu na Konferenciu o Sprevinilej Planéte a spraviť tam niečo bombové.

Mapa mesta je neorientovaný [graf](https://www.ksp.sk/kucharka/grafy_uvod/) s $n$ vrcholmi, očíslovanými $1, 2, \\dots, n$. Vo vrchole $1$ je Askarov dom a vo vrchole $n$ sa organizuje konferencia. V niektorých vrcholoch sa nachádzajú bike-sharing stanice. V nich je možnosť nasadnúť na bicykel, alebo ho odložiť a pokračovať pešo. Nikde inde nemožno získať ani odložiť bicykel.

Keď sa Askar hýbe pešo, po jednej hrane prejde za $k$ minút. Na bicykli to zvláda za $1$ minútu. Doma bicykel nemá a do budovy konferencie tiež nemôže prísť s bicyklom.

Zistite, koľko minút mu bude trvať, kým dostane šancu zachrániť našú krásnu planétu.

## Formát vstupu

Na prvom riadku sa nachádzajú dve kladné celé čísla $n$ a $k$ -- počet vrcholov grafu a čas, ktorý Askarovi trvá prejdenie jednej hrany pešo.

Na druhom riadku sa nachádza jedno celé číslo $m$ -- počet hrán v grafe.

Každý z nasledujúcich $m$ riadkov obsahuje dve čísla: $a_i$, $b_i$ ($1 \\leq a_i, b_i \\leq n$), ktoré hovoria, že medzi vrcholmi $a_i$ a $b_i$ je hrana. Medzi každou dvojicou vrcholov je najviac jedna hrana. Môžete predpokladať, že zo štartu sa dá dostať do každého iného vrcholu postupnosťou hrán.

Na ďalšom riadku je jedno celé číslo $s$ -- počet bike-sharing staníc.

Každý z nasledujúcich $s$ riadkov obsahuje jedno číslo $s_i$, ktoré hovorí, že vo vrchole $s_i$ sa nachádza stanica. Tieto čísla sú rôzne a platí $1 < s_i < n$.

## Formát výstupu

Vypíšte jeden riadok a na ňom jedno číslo -- najmenší počet minút, za ktorý sa Askar vie dostať z domu do budovy konferencie.

## Hodnotenie

Sú štyri sady vstupov. Platí pre ne nasledovné:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ---:| ---:| ---:| -----:| | $n,m\\leq$ | $50,000$ | $100,000$ | $100,000$ | $250,000$ | | $s \\leq$ | $2$ | $20$ | $n-2$ | $n-2$ |

Vo všetkých vstupoch $1 < k \\leq 10^5$. Navyše, pri práci s časovými a pamäťovými zložitosťami môžete predpokladať, že $O(k) = O(n)$.

## Príklad

```vstup
5 10
4
1 3
3 4
5 4
2 1
2
2
4
```

```vystup
23
```

*Askar najprv prejde za desať minút hranu do vrcholu $2$. Vo vrchole $2$ nasadne na bicykel. Za tri minúty to odbicykluje do vrcholu $4$, kde bicykel nechá a za ďalších desať minút už dorazí na miesto konferencie.*
","# Lamborghini? Bicykel!

Každému skúsenému riešiteľovi pravdepodobne napadlo neoptimálne riešenie tejto úlohy hneď po prečítaní zadania. K optimálnemu riešeniu potom už ostáva si len uvedomiť jednu skutočnosť a je to tam.

Poďme sa pozrieť na obe riešenia.

## Neoptimálne riešenie -- Dijkstra

Askar sa musí dostať zo svojho domu do budovy Konferencie o Sprevinilej Planéte, čo najrýchlejšou cestou. Najznámejším algoritmom na hľadanie najrýchlejšej cesty je starý dobrý Dijkstra. [Tu si o ňom môžete prečítať.](https://www.ksp.sk/kucharka/dijkstra/)

V našom prípade ho však nemôžeme aplikovať úplne priamočiaro -- Askar môže totiž ísť pešo aj na bicykli. Tento problém sa dá ľahko vyriešiť: pôvodný graf si trochu prerobíme. Každý vrchol $i$ nahradíme dvoma vrcholmi: $i_p$ (pešo) a $i_b$ (bicykel). Vrchol $i_b$ reprezentuje situáciu, keď je Askar vo vrchole $i$ a má so sebou bicykel, vrchol $i_p$ zasa situáciu, keď je Askar vo vrchole $i$ bez bicykla. Ak v pôvodnom grafe bola hrana medzi vrcholmi $i$ a $j$, tak v novom grafe bude hrana $i_p - j_p$ s dĺžkou $k$ a hrana $i_b - j_b$ s dĺžkou $1$. Čiže, ak bol Askar pešo, tak môže pešo prejsť do druhého vrcholu a podobne, ak bol na bicykli, tak na ňom môže pokračovať. V prípade, že vrchol $i$ je bike-sharing stanica, tak pridáme ešte dve ďalšie hrany: $i_p - j_b$ s dĺžkou $1$ (Askar po tejto hrane už prejde na bicykli) a $i_b - j_p$ s dĺžkou $k$ (Askar zosadol z bicykla a túto hranu prejde pešo).

Takto upravený graf má $2n$ vrcholov a nanajvýš $6m$ hrán (v najhoršom prípade, ak by skoro všade boli bike-sharing stanice, budeme mať šesť hrán za každú pôvodnú hranu).

V skutočnej implementácii nemusíme ani konštruovať nový graf. Stačí si v halde okrem čísla vrcholu pamätať aj to, či je Askar pešo alebo na bicykli a podľa toho akumulovať vzdialenosti.

Časová zložitosť tohoto riešenia je $O(m \\log m)$ a pamäťová $O(n + m)$.

## Optimálne riešenie

Intuícia nám napovedá, že predchádzajúce riešenie nie je optimálne. Dijkstra funguje na hocijaké grafy, ale náš graf nie je hocijaký: všetky jeho hrany sú dĺžky $1$ alebo $k$. Toto sa musí dať využiť.

A naozaj to ide. Všeobecnú logaritmickú haldu z predchádzajúceho riešenia vieme nahradiť dvoma frontami. Do prvej fronty budeme vkladať vrcholy, keď je Askar na bicykli a do druhej keď je pešo. Ako si o chvíľu ukážeme, obe fronty ostanú vždy usporiadané podľa vzdialenosti, a teda keď chceme vybrať nasledujúci najbližší vrchol (tak, ako to robíme v Dijkstrovi), stačí nám vybrať menší (bližší) z vrcholov na začiatku oboch front.

Tak ako sme si už povedali, obe fronty musia vždy ostať usporiadané, aby naše riešenie fungovalo -- inak by sme sa nevedeli spoľahnúť, že nasledujúci vrchol sa nachádza na začiatku niektorej z nich. Dôkaz je veľmi ľahký. Predpokladajme, že doteraz sú fronty usporiadané. Z dvoch začiatkov teda vyberieme menší vrchol, povedzme, že tento vrchol je vo vzdialenosti $15$. V prípade, že z neho ideme pokračovať peši, do fronty pre pešie vrcholy vložíme vrchol so vzdialenosťou $15+k$. Aby fronta ostala usporiadaná, nesmel sa v nej nachádzať žiaden vzdialenejší vrchol. Mohol sa? Nemohol: keďže Dijkstrov algoritmus navštivuje vrcholy podľa vzdialenosti (a doteraz boli fronty usporiadané, takže bežal korektne), všetky vrcholy, ktoré sme doteraz navštívili, boli vo vzdialenosti $15$ alebo menšej. Najvzdialenejší vrchol, ktorý sme doteraz mohli do pešej fronty pridať, mohol mať vzdialenosť najviac $15 + k$, čo nie je viac, než náš naposledy pridaný vrchol. Fronta teda ostane usporiadaná. Dôkaz pre druhú frontu je úplne rovnaký.

Fronty nám pomohli vyhnúť sa logaritmu, časová zložitosť tohoto riešenia je teda $O(n + m + s) = O(m)$ a pamäťová je rovnaká. Keďže na vyriešenie úlohy určite musíme minimálne načítať vstup, lepšiu asymptotickú časovú zložitosť sa už dosiahnuť nedá.
",9
f099f125acf23301,ksp,"# Terms and conditions

Ešte pred pár mesiacmi všetky firmy menili svoje pravidlá narábania s osobnými údajmi. Preto všetci chceli, aby obyčajní používatelia ako Denis tieto nové pravidlá odsúhlasili. V tom čase to Denis vôbec neriešil. Teraz sa však rozhodol, že už nezaklikne ani jedno políčko. Veď tým nebude zbytočne strácať čas! A preto vymyslel geniálny ťah. Vytvorí program, čo to zaňho odklikne. No uvedomil si dôležitý fakt. Keď to dá ako úlohu do KSP nemusí to ani len programovať!

## Úloha

Napíšte Denisovi program, ktorý v texte nájde políčko, ktoré vyzerá presne takto:

```
+-+
| |
+-+
```

a zakreslite doň veľké písmeno X.

## Formát vstupu

Na začiatku vstupu sa nachádza číslo $n$ -- $3 \\leq n \\leq 1000$ -- počet riadkov na vstupe. Nasleduje $n$ riadkov textu. Na každom riadku sa nachádza $m$ znakov -- $1 \\leq m \\leq 100$. Medzi nimi sa bude nachádzať práve jedno políčko na zaškrtnutie. Znaky, ktoré sa v texte budú nachádzať, budú znaky z [ASCII tabuľky](https://sk.wikipedia.org/wiki/ASCII). Konkrétne, pre každý znak $c$ platí, že je z rozsahu $32 \\leq c \\leq 126$ alebo je znakom nového riadku ($10$).

## Formát výstupu

Na výstup vypíšte rovnaký text, aký ste dostali na vstupe (bez prvého riadku, v ktorom sa nachádza $n$), s tým rozdielom, že políčko bude zaškrtnuté.

## Príklady

```vstup
15
V zmysle zakona Slovenskej republiky
c. 18/2018 Z. z. o ochrane osobnych
udajov a o zmene a doplneni niektorych
zakonov, ktory najma v $19-30 upravuje
prava dotknutej osoby v oblasti
spracovania osobnych udajov, vyjadrujem
suhlas so spracovanim poskytnutych osobnych
udajov.
+-+
| |
+-+
Uvedeny suhlas sa tyka aj poskytnutia
uvedenych udajov tretim stranam za ucelom
mierenych reklam na iste druhy pracich
prostriedkov.
```

```vystup
V zmysle zakona Slovenskej republiky
c. 18/2018 Z. z. o ochrane osobnych
udajov a o zmene a doplneni niektorych
zakonov, ktory najma v $19-30 upravuje
prava dotknutej osoby v oblasti
spracovania osobnych udajov, vyjadrujem
suhlas so spracovanim poskytnutych osobnych
udajov.
+-+
|X|
+-+
Uvedeny suhlas sa tyka aj poskytnutia
uvedenych udajov tretim stranam za ucelom
mierenych reklam na iste druhy pracich
prostriedkov.
```

```vstup
13
Tymto potvrdzujem, ze nie som robot
ani program na zaklikavanie policok
   +-+   +_+   
   | |   | |   
   +_+   +-+   
 
a navyse suhlasim so vsetkymi podmienkami
ktore som si precital v prilozenych
47 stranach legalneho balastu
 
click   +-+ here
to      | | accept
terms   +-+ & conditions

```

```vystup
Tymto potvrdzujem, ze nie som robot
ani program na zaklikavanie policok
   +-+   +_+   
   | |   | |   
   +_+   +-+   
 
a navyse suhlasim so vsetkymi podmienkami
ktore som si precital v prilozenych
47 stranach legalneho balastu
 
click   +-+ here
to      |X| accept
terms   +-+ & conditions

```
","# Terms and conditions

Riešenie tejto úlohy rozdelíme na dve časti.

## Načítavanie vstupu

Prvou komplikovanejšou úlohou je správne načítať vstup. Ak používate C++, pravdepodobne na načítavanie vstupu používate `cin`. Ten však načíta iba časť textu po najbližší tzv. 'whitespace' znak, teda medzeru. Preto sa na načítanie vstupu doporučuje použiť príkaz `getline(cin, string)`. Tento načíta všetky znaky až po prvý znak nového riadku (`'\n'`). Ešte si treba dať pozor, že keď zo vstupu načítame počet riadkov $n$ ako číslo, tak za ním ostane znak konca riadku. Tento znak príkaz `getline` zachytí, a teda načíta prázdny string. Treba teda `getline` zavolať ešte raz po načítaní $n$.

Ak používate napríklad Python, tak príkaz `input()`, ktorý bežne používate na načítanie vstupu, načíta celý riadok, takže tu problém nie je. Rovnako by nemal byť problém v ostatných jazykoch, ktoré testovač podporuje.

## Hľadanie políčka

Teraz, keď máme text v pamäti, môžeme začať hľadať správne políčko. Hľadanie políčka môžeme vždy začínať od jeho ľavého horného rohu, stačí skontrolovať všetkých 9 znakov, či sa zhodujú -- buď manúalne overíme každý znak, alebo si vytvoríme vlastnú kópiu políčka, ktoré hľadáme, a overíme či sa všetky znaky zhodujú v štvorčeku $3x3$ pomocou dvoch cyklov.

Treba si pritom dávať pozor na to, aby sme neskúsili pozrieť na neexistujúci index niektorého reťazca, keďže susedné riadky môžu byť rôzne dlhé.

## Čo všetko si potrebujeme pamätať?

Keď sa zamyslíme nad tým ako hľadáme políčka, uvedomíme si, že keď skontrolujeme trojicu riadkov, údaje z prvého z nich už nikdy nebudeme potrebovať. Preto nám stačí pamätať si iba tri riadky, v ktorých aktuálne hľadáme políčko, teda pamäťová zložitosť tohto riešenia je $\\text{O}\\left(m\\right)$, kde $m$ označuje počet znakov v jednom riadku.

## Zhrnutie

Postupne načítame riadky. Pre každý načítaný znak skontrolujeme či sa ""pod ním"" nenachádza políčko. Ak sa nachádza políčko zaškrtneme, inak hľadáme ďalej. Takýmto postupom spravíme pre každý znak iba konštantný počet operácií. Teda časová zložitosť je lineárna od veľkosti vstupu $\\text{O}\\left(n \\cdot m\\right)$
",1
e8346e29fd40f818,ksp,"# Aha, psíky!

V každej správnej záhradke by mal byť strážny pes. Preto aj my máme na záhradke nášho KSPsa[^1], ktorý dáva pozor, aby nenastal žiadny nepríjemný incid*ent*. Záhradka je ale veľmi veľká a sám ju neustriehne. Preto má v záhradke aj pomocníkov -- malých KSPsíkov! Keďže sú to ale ešte len malé šteniatka, musí na nich dávať dobrý pozor a preto teraz celé dni chodí od jedného k druhému a kontroluje ich.

KSPsíkovia sú, prirodzene, veľmi intelig*ent*ní, no trochu nedočkaví. Preto si začali v hlave počítať, pri ktorom z nich zastane KSPs niekedy v budúcnosti. Jednému z nich sa už ale počítať v hlave nechce, a preto by chcel, aby ste mu pomohli.

## Úloha

Naša záhradka má tvar jednodimenzionálneho (jednorozmerného) poľa, ktorého políčka sú buď prázdne, alebo je na nich KSPsík. Tí sa nehýbu a po celý čas zostávajú na svojich pôvodných políčkach. KSPs sa na začiatku nachádza na niektorom políčku s KSPsíkom a pozerá sa smerom doprava, potom sa v každom kroku správa nasledovne:

- Ak vidí vo svojom smere nejakého KSPsíka vo vzdialenosti $\\le x$, ide za ním.
- Ak nie, tak zistí, že či je opačným smerom nejaký KSPsík vo vzdialenosti $\\le x$. Ak je, tak sa otočí a ide za ním.
- Inak ostáva na svojom mieste.

Vašou úlohou je zistiť, na ktorom políčku sa bude KSPs nachádzať po $k$ takýchto krokoch.

## Formát vstupu

Na prvom riadku dostanete štyri čísla $n, s, x, k$, kde $n$ je počet KSPsíkov, $s$ označuje KSPsíka, na ktorého políčku KSPs začína, $x$ je vzdialenosť na ktorú KSPs dovidí a $k$ je počet krokov.

Nasleduje jeden riadok, ktorý obsahuje $n$ usporiadaných celých čísel $n_i$, kde $n_i$ označuje pozíciu $i$-tého KSPsíka. KSPs začina na políčku $n_s$.

Dajte si pozor, že niektoré čísla na vstupe sa nemusia zmestiť do obyčajnej 32-bitovej premennej. Odporúčame použiť 64-bitové premenné (`long long` v C/C++).

## Formát výstupu

Vypíšte jediné číslo -- číslo políčka, na ktorom sa bude KSPs nachádzať po tom, čo urobí $k$ krokov.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |-----------------|------:|-------:|-------:|-------:|-------:|-------:|----------:|----------:| | $0 < n \\le$ | $10$ | $1000$ | $10^4$ | $10$ | $1000$ | $10^4$ | $10^6$ | $10^6$ | | $0 \\le n_i \\le$ | $100$ | $1000$ | $10^7$ | $100$ | $10^5$ | $10^7$ | $10^{12}$ | $10^{12}$ | | $0 \\le k \\le$ | $10$ | $1000$ | $10^5$ | $10^6$ | $10^8$ | $10^8$ | $10^{18}$ | $10^{18}$ |

## Príklad

```vstup
4 2 10 3
1 3 5 7
```

```vystup
3
```

*KSPs začína na políčku s číslom $5$, v ďalšom kroku pôjde doprava k najbližšiemu KSPsíkovi na políčko $7$. Potom sa už ale musí otočiť a vrátiť na políčko $5$, keďže ďalej už nie je žiadny KSPsík. V poslednom kroku prejde na políčko $3$.*

```vstup
3 1 1 47
0 2 4
```

```vystup
2
```

*KSPs nevidí na žiadneho ďalšieho KSPsíka (keďže sú príliš ďaleko) a preto ostane na pôvodnom mieste.*

\[^1\]: Ak ešte KSPsa nepoznáte, nezúfajte. Stačí sledovať náš [Instagram](https://instagram.com/ksp.trojsten), kde sa čoskoro objaví!
","# Aha, psíky!

Už na prvý pohľad je asi celkom zrejmé, že pohyb KSPsa môžeme pomerne jednoducho odsimulovať. Stačí si pamätať pole s pozíciami KSPsíkov, našu aktuálnu pozíciu a smer. Následne sa v každom kroku posunieme v poli o jeden index doprava/doľava (podľa aktuálneho smeru KSPsa) a overíme, či vzdialenosť od pôvodnej pozície KSPsa ku KSPsíkovi, ku ktorému sme práve došli, je najviac $x$. V opačnom prípade sa vrátime na predchádzajúci index, zmeníme aktuálny smer KSPsa a skúsime sa posunúť sa v opačnom smere.

Ako vidíme, potrebujeme odsimulovať všetkých $k$ krokov, teda časová zložitosť bude $O(k)$. Pamäťová zložitosť je zase $O(n)$, keďže si pamätáme celé pole s pozíciami KSPsíkov. Takéto riešenie mohlo (v závislosti od implementácie) získať na testovači približne polovicu bodov.

## Vzorák

Aby sme z priamočiarej simulácie dostali vzorové riešenie nám stačí jednoduchý trik. Mohli sme si všimnuť, že pri simulácii sa KSPes vždy otočí pri tých istých dvoch KSPsíkoch. Pri veľkom počte krokov teda KSPes strávi väčšinu času behaním medzi týmito dvomi pozíciami.

Našu simuláciu upravíme nasledovne: Najskôr necháme KSPsa ísť doprava, až kým nenavštívi posledného dosiahnuteľného KSPsíka a jeho index si zapamätáme. Podobne si zistíme index najľavejšieho dosiahnuteľného KSPsíka.

Nech je rozdiel najpravejšieho a najľavšieho dosiahnuteľného indexu $l$, potom KSPsovi bude trvať $2l$ krokov, kým prejde všetkých KSPsíkov. Keďže sa po takomto ""kolečku"" KSPes vždy vráti na pôvodnú pozíciu, môžeme túto časť simulácie jednoducho preskočiť tým, že počet zostávajúcich krokov zmodulujeme $2l$.

Nakoniec nám ostane niekoľko krokov, ktoré by sme mohli znova odsimulovať. V skutočnosti to ale ani nie je potrebné. Predpokladajme, že KSPs sa momentálne nachádza pri najľavejšom dosiahnuteľnom KSPsíkovi (tam sme ho totiž pri hľadaní najľavejšieho dosiahnuteľného KSPsíka presunuli). Teraz môže nastať jeden z dvoch prípadov: Ak je zostávajúci počet krokov $k$ menší ako $l$, stačí nám posunúť KSPsa v poli s pozíciami KSPsíkov o $k$ indexov doprava. Naopak, ak je $k > l$, finálny index KSPsa vypočítame ak od indexu napravejšieho dosiahnuteľného KSPsíka odčítame $k - l$.

Na nájdenie najpravšieho a najľavšieho dosiahnuteľného KSPsíka budeme musieť prejsť najviac $n$ psíkov. Následne iba vypočítame zvyšok po delení a finálnu pozíciu KSPsa v $O(1)$, čiže celková časová zložitosť bude $O(n)$. Pamäťová zložitosť ostáva stále rovnaká.
",2
71a164822096ed49,ksp,"﻿# Chicago

Kvalitný Slovenský Provider je nový mobilný operátor, ktorý práve vyhral grant na pokrytie Chicaga. Žiaľ, dostali iba polovicu finančných prostriedkov o ktoré žiadali. Preto ich nový vysielač síce má neobmedzený dosah, ale funguje iba v štyroch smeroch -- Sever, Východ, Juh a Západ.

Podľa podmienok grantu má Kvalitný Slovenský Provider vybudovať vysielače na strechách práve dvoch mrakodrapov. Vysielače chcú umiestniť tak, aby maximalizovali počet potenciálnych zákazníkov, teda tak, aby pokryli čo najväčšie množstvo obyvateľov Chicaga. Vašou úlohou je zistiť najväčší možný počet ľudí, ktorým vedia poskytnúť mobilné pripojenie.

## Úloha

Chicago má tvar štvorcovej mriežky so stranou $n$ políčok. Na každom políčku stojí mrakodrap, v ktorom býva daný počet ľudí. Každý vysielač pokryje všetkých obyvateľov tých mrakodrapov, ktoré sú od neho na Sever, Východ, Juh, alebo Západ. Budovu, na ktorej je postavený, vysielač nevie pokryť. Navyše, ani druhý vysielač ju nemôže pokryť, lebo ich signály sa tu vyrušia.

Vašou úlohou je pre dané rozloženie obyvateľov Chicaga nájsť najväčší možný počet potenciálnych zákazníkov pokrytých aspoň jedným z dvoch vysielačov.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($2\\leq n\\leq 300$) udávajúce dĺžku strany Chicaga. Na každom z nasledujúcich $n$ riadkov je $n$ čísiel udávajúcich počty obyvateľov na jednotlivých políčkach štvorca. Počet obyvateľov na jednom políčku je nezáporný a neprevyšuje $10^3$.

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo -- maximálny možný počet potenciálnych zákazníkov.

## Príklady

```vstup
3
1 2 3
3 2 1
2 2 2
```

```vystup
14
```

*Vysielače môžu byť postavené napríklad na mrakodrapoch s jedným obyvateľom.*

```vstup
2
2 2
2 2
```

```vystup
4
```

*Každé rozmiestnenie vysielačov je optimálne. Dva mrakodrapy bez vysielača majú pokrytie, a dva mrakodrapy s vysielačom pokrytie nemajú.*
","# Chicago

## Hrubá sila

Riešenie hrubou silou je jednoduché: Vyskúšame všetky možné umiestnenia dvojíc vysielačov, a pre každé spočítame počet pokrytých obyvateľov. Keďže Chicago má $n^2$ mrakodrapov, možných rozložení dvojice vysielačov je $O(n^4)$. Ak potom pre každé rozloženie zrátame v konštantnom čase počet pokrytých obyvateľov pomocou predpočítaných súčtov riadkov a stĺpcov, môžeme získať 4 body za riešenie s časovou zložitosťou $O(n^4)$.

## Vzorové riešenie

Na plný počet bodov musíme riešenie hrubou silou o jeden rád zrýchliť na $O(n^3)$, napríklad takto:

Najprv predpokladáme, že vysielače sú v optimálnom riešení v rôznych riadkoch a stĺpcoch. Vyskúšame každú možnú dvojicu stĺpcov: V oboch stĺpcoch si spočítame pokrytie jedného vysielača na každej pozícií v tomto stĺpci (ignorujúc mrakodrap v druhom stĺpci, keďže ten bude určite pokrytý druhým vysielačom). Použijeme pritom predpočítané súčty riadkov a stĺpcov, podobne ako v riešení vyššie, aby sme každé pokrytie spočítali v $O(1)$. Ak tieto pokrytia zoradíme, môžeme jednoducho zobrať najlepšie pozície z ľavého a z pravého stĺpca (ak sú v tom istom riadku, skontrolujeme najlepšie dve pozície). Ich súčet nám potom dá najlepšie riešenie s vysielačmi v týchto dvoch stĺpcoch. Takto dosiehneme časovú zložitosť $O(n^3)$, keďže pre každú z $O(n^2)$ dvojíc stĺpcov raz prejdeme každý zo stĺpcov s $n$ mrakodrapmi. Musíme si dať ale pozor, aby sme si namiesto zoraďovania iba vybrali dve najlepšie riešenia, keďže triedenie je príliš pomalé (triedenie $O(n, log, n)$, celý cyklus teda $O(n^3 , log , n)$).

Ešte musíme vyskúšať možnosť, že v optimálnom riešení sú oba vysielače v tom istom riadku alebo stĺpci: Stačí nám pre každý riadok vyskúšať všetky dvojice stĺpcov, v ktorých sa nachádzajú vysielače, a vybrať najlepšie pokrytie (a podobne pre stĺpce). Časová zložitosť $O(n^3)$ nám tu stačí, keďže takú má prvá časť tohoto riešenia.

_Mimochodom, takáto možnosť naozaj môže nastať. Napríklad pre vstup nižšie sú v optimálnom riešení vysielače na mrakodrapoch s $0$ obyvateľmi:_

```vstup
5
1 9 1 9 1
1 9 1 9 1
9 0 9 0 9
1 9 1 9 1
1 9 1 9 1
```
",9
9f3e9ae80a4eda37,ksp,"# Dobré hádanie

Pytón Python sa rozhodol, že pri príležitosti 30. výročia vybudovania jeho štvrte usporiada veľkolepú online párty, na ktorej si všetci účastníci zahrajú novú hru s názvom Háda, Hádaš, Hádate. Princíp tejto hry spočíva v tom, že Python si pripraví množinu čísel, o ktorej nikto z účastníkov nič netuší, a súťažiacim prezradí niekoľko čísel z tejto množiny s ich pozíciami (pri zoradení od najmenšieho) v tejto množine. Vyhráva ten hádač, ktorý prvý príde na to, akým receptom Python zostrojil množinu.

Nie sme si úplne istí, ako veľmi a či vôbec budú účastníci párty z tejto Pythonovej hry nadšení, ale čo už.

Python ale potrebuje vašu pomoc. Už má vymyslený recept na zostrojenie množiny čísel, no teraz potrebuje nejaký program, do ktorého zadá pozíciu čísla v jeho množine a on mu vypíše, aké číslo sa na tejto pozícii nachádza, aby vedel súťažiacim dávať tieto indície a nemusel to sám ručne počítať.

## Úloha

Pre čísla $a, b, c$ sa Pythonova množina skladá práve z takých $x$, ktoré spĺňajú práve jednu z dvoch podmienok:

- $a$ delí $x$, no $b$ nedelí $x$.
- $a$, $b$ aj $c$ delia $x$.

Poznáte čísla $a, b, c$ a $m$. Python sa vás postupne opýta na $m$ pozícií v jeho množine. Pre každú z nich zistite, aké číslo sa nachádza na danej pozícii (pri usporiadaní od najmenšieho). Pomôžete mu tak s prípravou hry a okorenením výročnej párty.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú 4 čísla $a, b, c$ (parametre množiny) a $m$ (počet otázok), pričom platí, že $1 \\leq a, b, c \\leq 1,000$ a $1 \\leq m \\leq 100,000$. Nasleduje $m$ riadkov. Na $i$-tom z nich je číslo $n_i$, čiže pozícia čísla v množine, na ktorú sa Python pýta v $i$-tej otázke. Platí, že $1 \\leq n_i \\leq 10^{9}$.

## Formát výstupu

Na $i$-ty riadok vypíšte odpoveď na $i$-tu otázku, teda $n_i$-te číslo množiny.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich takéto obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:---------------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n_i \\leq$ | $100$ | $10,000$ | $10^{6}$ | $10^{9}$ | | $1 \\leq m \\leq$ | $100$ | $100,000$ | $100,000$ | $100,000$ |

Pozor, vstupné a výstupné údaje sa nemusia zmestiť do 32 bitovej premennej, odporúčame preto použiť 64 bitovú premennú (napr. `long long` v C++).

## Príklad

```vstup
3 6 7 3
1
2
8
```

```vystup
3
9
42
```

*Pre $a=3, b=6, c=7$ vyzerá prvých 8 prvkov množiny tako: {3, 9, 15, 21, 27, 33, 39, 42}. Každé číslo je buď deliteľné všetkými troma alebo je deliteľné 3 ale nie 6.*

```vstup
151 993 103 3
1893
2499
24
```

```vystup
285994
377651
3624
```
","# Dobré hádanie

Poznáme recept (čísla $a$, $b$ a $c$) špeciálnej množiny a potrebujeme vedieť povedať, aké číslo sa nachádza na $n$-tej pozícii v nej.

## Nájdeme prvých n čísel

Prvým nápadom na riešenie môže byť, že podľa receptu vyrátame prvých $n$ čísel. To vieme spraviť tak, že postupne pre každé číslo od $1$ vyššie zistíme, či číslo patrí do špeciálnej množiny, a opakujeme, kým nenájdeme $n$ takých čísel, pričom $n$-té z nich je odpoveďou na otázku.

Ako teda zistíme, či nejaké číslo patrí do Pythonovej množiny? No, priamočiaro implementujeme podmienky z receptu: $a$ delí $x$, no $b$ nedelí $x$. Alebo $a$, $b$ aj $c$ delia $x$. Nejaké $a$ delí nejaké $x$, práve vtedy keď zvyšok po delení $x / a$ je nula. Inak povedané, ak $x \\bmod a = 0$.

Takéto riešenie by teda pre každú z $m$ otázok prešlo všetky čísla od 1 po $n$-té číslo množiny. Všimnime si, že každé číslo množiny musí byť deliteľné $a$. Z tohto dôvodu si odhadnime, že čísel od 1 po $n$-té číslo množiny je $a \\cdot n$. Tým pádom je časová zložitosť celého riešenia $O(m a n)$. Pamäťová zložitosť je konštantná, teda $O(1)$, keďže si nič špeciálne (žiadne polia, iba pár premenných) nepotrebujeme pamätať.

Za takéto riešenie bolo možné získať najviac 2 body.

## Nebudeme sa opakovať

Hm... Keď pri každej otázke overujeme vždy čísla od $1$, znamená to, že asi veľa čísel overujeme viacnásobne. Teda zbytočne strácame čas rátaním rovnakých vecí. Vieme vymyslieť také riešenie, ktoré každé číslo overí najviac jedenkrát?

Jasné. Vieme si na začiatku programu vyrátať prvých niekoľko veľa čísel Pythonovej množiny. Tie si budeme ďalej pamätať a pri otázke sa iba pozrieme do pamäte a vrátime číslo na $n$-tej pozícii. Prípadne si vieme najprv prečítať všetky otázky, nájsť najväčšie $n$ a vyrátať si prvých $\\max(n)$ čísel.

Samotné hľadanie odpovedí v predrátanej množine trvá konštantne dlho, no predrátanie nám podľa odhadu v predchádzajúcom prístupe zaberie $O(a \\max(n))$. V pamäti si teraz potrebujeme držať predpočítanú Pythonovu množinu, čo znamená, že pamäťová zložitosť je $O(\\max(n))$.

Za takéto riešenie bolo možné získať 4 body. Ak vylepšíme program tak, že nebudeme skúšať úplne všetky čísla po jednom ale iba po násobkoch $a$, dostaneme 6 bodov.

## Koľké v poradí je toto číslo?

Vieme nejakým spôsobom zistiť odpoveď bez toho, aby sme si museli vyrátať všetky menšie čísla v množine? Áno, vieme. O ľubovoľnom čísle vieme povedať, na akej pozícii v Pythonovej množine sa nachádza (ak číslo nie je v množine, tak dostaneme pozíciu najbližšieho menšieho čísla z množiny).

Koľko existuje čísel menších alebo rovných $x$, ktoré delí $a$? Na túto jednoduchú otázku existuje jednoduchá odpoveď: $x / a$.

Koľko existuje takých čísel menších alebo rovných $x$, že ich delí $a$, $b$ aj $c$ súčasne? Je ich presne $x / \\operatorname{lcm}(a, b, c)$. (LCM ako least common multiple alebo NSN -- najmenší spoločný násobok)

Koľko existuje čísel menších alebo rovných $x$, ktoré delí $a$, ale nedelí ich $b$? Je to v podstate odčítanie množín. Čiže $x / a - x / \\operatorname{lcm}(a, b)$.

Keďže dve pravidlá z receptu na zostrojenie Pythonovej množiny tvoria dve disjunktné množiny (v jednom $b$ delí, v druhom nedelí), môžeme k nim pristupovať osobitne a iba ich sčítame: $(x / a - x / \\operatorname{lcm}(a, b)) + (x / \\operatorname{lcm}(a, b, c))$

Vidíme, že potrebujeme vedieť iba $\\operatorname{lcm}(a, b)$ a $\\operatorname{lcm}(a, b, c)$, ktoré sú pri všetkých otázkach rovnaké. Takže si ich môžeme vyrátať iba raz na začiatku a ďalej používať iba tieto dve zapamätané čísla, aby sme ich nerátali vždy odznova. Tým pádom zložitosť tohto výpočtu zanedbáme.

## Binárne vyhľadávanie

Zistenie pozície nejakého čísla vieme šikovne využiť v riešení hlavne vtedy, keď budeme odpoveď hľadať binárne a nie zaradom od jednotky.

Na začiatku si stanovíme hranice intervalu, na ktorom hľadáme odpoveď, na najmenšie a najväčšie možné číslo v množine ($10^{15}$ by malo stačiť). Pozrieme sa na číslo v strede tohto intervalu a zistíme, koľké je v poradí v Pythonovej množine. Ak je hľadané $n$ väčšie, opakujeme postup s pravou polovicou tohto intervalu (stred, koniec). Ak je menšie, pokračujeme s ľavou polovicou (začiatok, stred).

Keď už dostaneme $n$, potrebujeme ešte nájsť najbližšie menšie alebo rovné číslo patriace do množiny, keďže číslo v strede ľubovoľného intervalu vôbec nemusí spĺňat recept. Toto zaberie rádovo zanedbateľne málo operácií. Maximálne $ac$, ak by sme postupne dekrementovali odpoveď po jednotkách. Ak uvažujeme rovno celé násobky $a$, bude to maximálne $c$ operácií. Myšlienka dôkazu: Ak sú $a$ a $b$ rôzne, do množiny môže v najhoršom prípade patriť druhý najbližší menší násobok $a$, ak by ten prvý bol zároveň aj násobkom $b$. Ak sú $a$ a $b$ rovnaké, hľadáme najbližšie menšie alebo rovné číslo deliteľné $a$ a $c$ zároveň.

Pracovný interval pri hľadaní odpovede zmenšujeme binárnym vyhľadávaním vždy na polovicu. Z toho vyplýva, že pred nájdením $n$ vykonáme $O(\\log(n))$ operácií. Následné zarovanenie na najbližšie menšie alebo rovné číslo z množiny môžeme zanedbať. A teda celkovú zložitosť pri $m$ otázkach dostaneme $O(m \\log(n))$. Keďže si nepotrebujeme nič špeciálne pamätať (okrem konštantného počtu premenných), pamäťová zložitosť je konštatná, teda $O(1)$.

V tomto prípade nám toto riešenie stačilo na plný počet. Existuje však aj niečo ešte lepšie.

## Počkať, to ešte nebol vzorák?

Pozrime sa ešte raz na tú matematiku. Už spomenutým vzorcom vieme v konštantnom čase povedať, na akej pozícii sa nachádza nejaké číslo (túto funkciu si nazvyme $get_pos(x)$). Vieme to ale aj opačne. Dôležité sú pre nás čísla $\\operatorname{lcm}(a, b)$ a $\\operatorname{lcm}(a, b, c)$. Medzi $0$ a $\\operatorname{lcm}(a, b, c)$ je rovnaký počet prvkov množiny ako medzi $\\operatorname{lcm}(a, b, c)$ a $2 \\cdot \\operatorname{lcm}(a, b, c)$. A rovnako to platí aj pre všetky ďalšie intervaly medzi bezprostredne nasledujúcimi násobkami $\\operatorname{lcm}(a, b, c)$.

Vo vnútri týchto intervalov zase platí, že každých $\\operatorname{lcm}(a, b)$ čísel sa opakuje rovnaký počet prvkov Pythonovej množiny (násobky $a$ bez násobku $\\operatorname{lcm}(a, b)$), keďže všeobecne platí, že $\\operatorname{lcm}(a, b) \\leq \\operatorname{lcm}(a, b, c)$ pre ľubovoľné $a, b, c$. Práve pre zistenie presného počtu v každom takomto intervale použijeme už spomínanú funkciu $get_pos(x)$. Teda, $get_pos(\\operatorname{lcm}(a, b))$ nám povie, koľko prvkov množiny sa opakuje každých $\\operatorname{lcm}(a, b)$ čísel, a rovnako to funguje aj pri $\\operatorname{lcm}(a, b, c)$.

Ak teda dostaneme nejaké $n$, $n / get_pos(\\operatorname{lcm}(a, b, c))$ nám povie, koľko krát sa v $n$-tom čísle množiny nachádza $\\operatorname{lcm}(a, b, c)$, resp. na ktorom spomínanom intervale medzi násobkami $\\operatorname{lcm}(a, b, c)$ sa nachádza $n$-té číslo. Podobne, zvyšok zase vydelíme $get_pos(\\operatorname{lcm}(a, b))$ a zistíme, na ktorom miniintervale sa nachádza medzi násobkami $\\operatorname{lcm}(a, b)$. Ak ešte máme nejaký zvyšok, je to počet násobkov $a$, ktoré ešte potrebujeme k číslu pridať. Tieto tri medzivýsledky vynásobíme príslučnými deliteľmi ($\\operatorname{lcm}(a, b, c)$, $\\operatorname{lcm}(a, b)$ a $a$), sčítame to a máme výsledok, čiže $n$-té číslo Pythonovej množiny. Samozrejme, delíme celočíelne so zvyškom.

Pozor ale na to, že pri delení prvého zvyšku $x$ číslom $\\operatorname{lcm}(a, b)$ chceme v skutočnosti deliť $x - 1$ a k zvyšku tohto delenia potom prirátame jednotku. To z toho dôvodu, že v prípade, že by $x$ bolo násobkom $\\operatorname{lcm}(a, b)$, nezostal by nám žiadny zvyšok, čiže by sme k medzivýsledku už neprirátali žiadny ďalší násobok $a$ v ďalšom kroku a dostali by sme tým pádom zlý výsledok, keďže práve násobky $\\operatorname{lcm}(a, b)$ nepatria do množiny a patrí tam vždy až ďalší najbližší násobok $a$. Ak tam pridáme tú $-1$, tento hraničný prípad vyriešime.

Toto riešenie má časovú zložitosť konštantnú, teda $O(1)$, keďže si stačí iba raz vyrátať $\\operatorname{lcm}(a, b)$ a $\\operatorname{lcm}(a, b, c)$ a ďalej už vieme vyrátať výsledky iba vzorcom pozostávajúcim z konštantného počtu výpočtov. Pamäťová zložitosť je tiež $O(1)$, keďže si stačí pamätať iba konštantný počet premenných.

Nejakým nedopatrením sa stalo, že za toto riešenie bolo možné získať najviac rovnaký plný počet bodov ($8$), aj keď je lepšie než to predchádzajúce. Avšak, vo výnimočných prípadoch boli rozdané aj nejaké bonusové bodíky.
",4
f6fb9734b6e4fa43,ksp,"# Letné nakupovanie

Prišlo leto a s ním aj [LTT](https://ltt.trojsten.sk/). Úžasná akcia, ktorej sa chce každý nadšený matematik, fyzik či informatik zúčastniť. Vedúci si na sústredenie prichystali množstvo zaujímavých prednášok. Keď však dorazili na chatu, zistili, že väčšina ich fixiek nepíše. Na vedúcovskej izbe zavládol nepokoj. Čo budú robiť? Aké vedomosti si účastníci z tábora odnesú, ak nikto nebude môcť vysvetľovať na tabuľu? Nuž, podujali sa fixky vo veľkom množstve nakúpiť. Zásoby v jednotlivých dedinách naokolo sú však obmedzené a z miest, ako tak blízko k chate, to bude isto nejaký čas trvať. Oni však majú málo penazí a tiež by chceli, aby fixky prišli čím skôr. Vymyslite, ako im s týmto problémom pomôcť a čo najskôr k ním fixky dopraviť.

## Úloha

V úlohe dostanete pre každý obchod počet fixiek, ktoré má na sklade -- $p_i$ a cenu za jeden kus -- $c_i$. Naviac od nás dostanete informáce o tom, ktoré obchody sú s ktorými priamo prepojené cestou. Môžete predpokladať, že prevoz fixiek medzi nejakými priamo spojenými obchodmi trvá nejaký konštantný čas, napr. $1$ hodinu. Vašou úlohou je nájsť najmenší čas $t$, za ktorý je možné dopraviť $p$ fixiek na chatu za cenu najviac $c$. Znamená to teda, že vašou hlavnou úlohou je minimalizovať čas, za ktorý fixky dorazia na chatu, nie celkovú cenu, tá samozrejme ale musí byť dostatočne malá aby bola zaplatiteľná vedúcimi.

## Formát vstupu

Na začiatku vstupu sa nachádzajú $4$ čísla $n$, $m$, $p$, $c$. Číslo $n$ ($1 \\leq n \\leq 100,000$) -- počet obchodov, ktoré sa nachádzajú v okolitých dedinách, $m$ ($1 \\leq m \\leq 1,000,000$) -- počet spojení medzi obchodmi ale aj chatou a potom $p$ ($1 \\leq p \\leq 10^7$) a $c$ ($1 \\leq c \\leq 10^9$), počet fixiek, ktoré chceme nakúpiť a maximálna cena, ktorú si môžme dovoliť zaplatiť. ***Chata*** má v našom číslovaní vždy číslo $n$ a nepočíta sa medzi obchody. Na ďaľšom riadku je $n$ medzerou oddelených čísel, ktoré reprezentujú $p_i$($0 \\leq p_i \\leq 10^7$). $i$-te číslo na tomto riadku určuje počet fixiek, ktoré má na sklade $i$-ty obchod. Na ďaľšom riadku je $n$ medzerou oddelených čísel, ktoré reprezentujú $c_i$($0 \\leq c_i \\leq 10^9$). $i$-te číslo na tomto riadku určuje cenu jednej fixky v $i$-tom obchode. Na nasledujúcich $m$ riadkoch sú postupne dvojice čísel $a$, $b$ ($0 \\leq a, b \\leq n$), reprezentujúce, že existuje priama a obojsmerná cesta medzi lokáciami(chata/obchod) s číslom $a$ a $b$. Všimnite si, že napriek tomu, že obchody číslujeme od $0$, $a$, či $b$ môžu byť aj rovné $n$, čo symbolizuje cestu, ktorá spája nejaký obchod a chatu. Možete predpokladať, že z každej lokácie sa dá dostať do každej inej lokácie postupnosťou nejakých priamych spojení.

## Formát výstupu

Na výstup vypíšte jedno číslo -- najmenší čas, za ktorý sa dá nakúpiť $p$ fixiek, pričom ich cena dokopy nepresiahne cenu $c$ alebo $-1$ ak sa to nedá.

## Hodnotenie

Pre jednotlivé sady platia aj tieto špeciálne obmedzenia:

V prvej sade platí, že počet obchodov je malý a takisto aj počet priamych ciest, teda $n \\leq 100$ a $m \\leq 150$. V druhej sade platí, že $n \\leq 10,000$ a $m \\leq 50,000$. Pre tretiu a štvrtú sadu neplatia žiadne špeciálne obmedzenia.

## Príklad

```vstup
4 4 10 32
7 3 5 4
9 2 3 4
0 4
1 4
2 4
3 2
```

```vystup
2
```

_V tomto pripade existujú obchody do vzdialenosti $2$, ktoré nám spolu vedia dopraviť dosť fixiek za prijateľnú cenu. Konkrétne sú to obchody $1$, $2$ a $3$. Môžme napr. vziať $3$ fixky z obchodu $1$, $5$ fixiek z obchodu $2$ a $2$ fixky z obchodu $3$. Za cenu $3 \\cdot 2 + 5 \\cdot 3 + 2 \\cdot 4 = 29$. Ak by sme hľadali riešenie do vzdialenosti $1$, museli by sme nakúpiť fixky v obchode $0$, ktorý je ale na naše dostupné prostriedky pridrahý._

```vstup
4 5 5 20
10 3 1 2
7 4 4 6
4 3
4 2
1 0
4 1
3 0
```

```vystup
-1
```

_V tomto prípade neexistujú obchody, z ktorých by sme vedeli nakúpiť potrebné množstvo za nami požadovanú cenu._
","# Letné nakupovanie

Najprirodzenejším spôsobom ako sa dá celá úloha reprezentovať je zrejme [grafom](https://www.ksp.sk/kucharka/grafy_uvod/). Vrcholmi sú v tomto grafe obchody a chata, pričom hranami sú cesty medzi nimi. Grafová reprezentácia je výhodná najmä v tom, že na grafoch poznáme mnoho algoritmov.

## Riešenie hrubou silou

Ak sa pýtame na najmenší čas, za ktorý sa dá nakúpiť $p$ fixiek za cenu najviac $c$, môžeme postupovať jednoduchým spôsobom a pýtať sa : ""ide to za čas $1$?"", ""ide to za čas $2$?""...

Akonáhle je odpoveď na nejakú takúto otázku áno, vieme, že sme našli najmenší čas, za ktorý vieme $p$ fixiek nakúpiť. Ide ale jednoducho nájsť odpoveď na takéto otázky? Ukážeme si, že áno. Vezmime si otázku : ""ide to za čas $x$?"" a poďme na ňu skúsiť nejak odpovedať.

Čo najskôr potrebujeme urobiť, je nájsť obchody z ktorých máme na výber, teda zistiť, ktoré ležia do vzdialenosti $x$. To vieme ľahko jedným [prehľadávaním do šírky](https://www.ksp.sk/kucharka/bfs/) v lineárnom čase. Keď máme tieto obchody, chceme vedieť či ide len pomocou nich kúpiť $p$ fixiek za cenu najviac $c$. Ak si zoradíme obchody, ktoré máme k dispozícií podľa ceny za jednu fixku, vieme postupne nakupovať fixky od najlacnejších obchodov až po najdrahšie. Čo sa môže stať sú 3 veci:

```
1. fixky úspešne nakúpime za cenu dokopy menej ako c
2. počas nakupovania fixiek nám dojdú peniaze
3. počas nakupovania nám dojdú obchody, z ktorých by sme mohli nakúpiť
```

Asi je jasné, že iba prvá možnosť znamená, že to ""ide za čas $x$"", ostatné znamenajú, že zatiaľ sme s touto vzdialenosťou nepochodili a musíme sa pozrieť na obchody o kus ďalej.

Akú má toto riešenie časovú zložitosť? Koľko môže byť otázok typu : ""ide to za čas $x$?"". Je to zjavne $n$. S časom $x=n$ už vieme určite použiť všetky obchody, žiadny obchod nemôže byť ďalej a pridaním času sa nám teda už ponuka nezvýši, inými slovami, ak to nejde za čas $n$, nepôjde to ani za čas $n+1$, $n+2$, $n+3$... Koľko najviac môže trvať odpoveď na takúto otázku? Zoradiť všetky obchody a raz ich prejsť bude trvať pokaždé $O(n \\cdot log(n))$. Teraz vieme v čase $O(n \\cdot n \\cdot log(n) + m)$ riešiť túto úlohu. Akú ma toto pamäťovú zložitosť? Ukazuje sa, že tak ako všetky naše riešenia to bude $O(n+m)$. V každom našom riešení nám bude stačit zapamätať si konštantne veľa vecí pre každý obchod a potom ešte zoznam susedov, reprezentujúci graf.

Ako naše riešenie teraz časovo zlepšiť?

## Zlepšenie riešenia hrubou silou

K jednoduchému zlepšeniu vedie nasledovné pozorovanie: Ak vieme $p$ fixiek nakúpiť za cenu $c$ a to všetko za čas $x$ (teda pomocou obchodov do vzdialenosti $x$), vieme to určite aj za čas $x+1$, $x+2$, $x+3$ atď. Pokiaľ je $x$ najmenší čas, za ktorý to vieme, tak zároveň platí, že to nevieme za čas $x-1$, $x-2$, $x-3$... $0$. To ale znamená, že vieme odpoveď jednoducho binárne vyhľadať. Povedali sme si, že najskôr ide $p$-fixiek nakúpiť za čas $1$, najneskôr za čas $n$. Ak si vezmeme nejaký čas $x$, môžu sa stať dve veci:

```
1. za čas x ide nakúpiť p fixiek za cenu najviac c a teda musíme najmenšiu odpoveď
hľadať vo vzdialenosti menšej alebo rovnej ako x.
2. za čas x nejde nakúpiť p fixiek za cenu najviac c a teda musíme najmenšiu odpoveď
hľadať vo vzdialenosti väčšej ako x.
```

Tento malý trik si zapamätajte. V úlohách, kde treba hľadať najmenší čas za ktorý sa niečo dá spraviť, sa tentro trik používa pomerne často. Akú má tento postup časovú zložitosť? Počet otázok, na ktoré vieme stále odpovedať v čase $O(n \\cdot log(n))$, sa zmenšil z $n$ na $log(n)$. Výsledná časová zložitosť je teda $O(log(n) \\cdot n \\cdot log(n))$ alebo inak $O(n \\cdot log(n)^2 + m)$. Toto už stačí na prejdenie všetkými vstupmi.

## Vzorové riešenie

Vzorové riešenie bude akosi trochu kopírovať naše prvé riešenie hrubou silou. Zas sa bude náš algoritmus pozerať na problém po úrovniach. Chceme totiž využiť vlastnosť, že akonáhle fixky, ktoré máme k dispozícií spĺňajú podmienky počtu a ceny, vieme, že naše riešenie je najlepšie možné. Riešenie hrubou silou malo nevýhodu, že po každej úrovni zahodilo všetky informácie, ktoré o grafe získalo. Ako budeme teda postupovať?

Budeme prechádzať obchody postupne po úrovniach (podľa vzdialenosti od chaty) a udržiavať si v akomsi virtuálnom nákupnom košíku dostatočný počet, doteraz najlacnejších fixiek. Do košíku najskôr naložíme všetky fixky z obchodov v nejakej úrovni. Ak je počet fixiek stále moc nízky, pokračujeme ďalšou úrovňou. Ak je počet fixiek v košíku moc veľký, začneme fixky vyhadzovať pokým ich nie je v košíku toľko, koľko chceme. Vyhadzovať ich samozrejme budeme od najdrahších. Po dovyhodzovaní fixiek je ich určite v košíku toľko, koľko potrebujeme. Ak je ale cena privysoká, pokračujeme ďalšou úrovňou. Akonáhle nájdeme riešenie, je jasné, že žiadne lepšie neexistuje, kedže by sme ho boli objavili skôr.

Ako bude vyzerať implementácia? Od košíka chceme, aby sme doňho vedeli rýchlo vkladať dvojice\
(cena_za_fixku_v_obchode, obchod) a vedeli z neho rýchlo vyberať a pozerať sa na akutálne najdrahší obchod, z ktorého máme nejaké fixky. Pokaždé keď fixky vyhadzujeme, stačí sa nám pozrieť na vrchný najdrahší obchod, z ktorého fixky v košíku máme. Asi tušíte, že na toto je vhodná dátová štruktúra maximová [halda](https://www.ksp.sk/kucharka/halda/).

Aká bude časová zložitosť tohto riešenia? Obchody musíme určite zoradiť, každý obchod pridáme do košíka iba raz a z košíka vyhadzujeme iba na jednotlivých úrovniach. Časová zložitosť je teda $O(n\*log(n) + m)$. Pamäťová zložitosť ostáva $O(n+m)$.
",6
656b6e6ed6c33c3c,ksp,"# Srny, Viki, Viki a iné divé veci

Tento príbeh je čisto fiktívny, a akákoľvek podobnosť s udalosťami Suši chaty je čisto náhodná[^1].

Miško je už dve hodiny bez jedla, a teda mu ostáva už len zopár minút života, pokiaľ nebude nakŕmený. Našťastie majú Viki a Viki dobré srdcia a rozhodli sa Miškovi život zachrániť. Vzali vysoký kaleráb, a položili ho na krájaciu dosku naležato. Vzniknutý široký kaleráb rozdelili na dva široké kusy kalerábu. Každý z nich si môžeme predstaviť ako rad čísel -- každé číslo je kusom šupy širokého kusu kalerábu, a označuje počet listov na danom kuse šupy (to bude dôležité neskôr). Viki a Viki šúpu kaleráb tak, že každý má vlastný široký kus kalerábu. Následne opakujú jednoduchý proces: Viki aj Viki zo svojho kusu ošúpe z konca nejako široký kus šupy a následne oba ošúpané kusy šupy zahodia do koša. Tento proces opakujú, kým obe široké kusy kalerábu neošúpu celé.

Ako to už v takýchto situáciach býva, plány vedúcich boli zrušené matkou prírodou. V okolí Suši chaty totiž žijú divé srny, ktoré nedokážu odolať chuti listov širokého kalerábu. Vždy, keď Viki a Viki zahodia dvojicu kusov šupy do koša, v koši sa objaví niekoľko nových sŕn, podľa jednoduchého vzorca:

Nárast populácie divých sŕn v koši sa dá vypočítať ako súčin rozdielu počtu listov na prvom kuse šupy a šírky prvého kusu šupy a rozdielu počtu listov na druhom kuse šupy a šírky druhého kusu šupy.

Miško je príliš hladný, Viki príliš lenivý a Viki nie je vedúca KSP. Je teda len na vás, aby ste zistili, ako treba obe časti širokého kalerábu šúpať tak, aby po ich ošúpaní bolo v koši čo najmenej sŕn.

\[^1\]: To je čosi ako čarodejnícky sabat, ale namiesto čarodejníc sú tam vedúci Súťaže v Šifrovaní (malý rozdiel).

## Úloha

Na vstupe dostanete dve sekvencie kladných celých čísel -- počty listov na šupách oboch kusov kalerábu. V jednom kroku Viki a Viki zvolia dve kladné čísla $x,y$. Z prvej sekvencie zmažú z konca $x$ čísel, z druhej $y$, a následne sa v koši objaví nasledovný počet sŕn: $(S - x)\*(Z - y)$ Pričom $S$ je súčet $x$ zmazaných čísel z prvej sekvencie a $Z$ je súčet $y$ zmazaných čísel z druhej sekvencie. Vašou úlohou je určiť, koľko najmenej sŕn sa môže v koši objaviť v procese šúpania kalerábu, kým kaleráb ošúpeme celý, ak šúpeme optimálne.

## Formát vstupu

Na prvom riadku vstupu sú 2 čísla $n, m$ -- šírky kusov kalerábu. V ďaľšom riadku nasleduje $n$ čísel -- počty listov na Vikiho kuse kalerábu. V ďaľšom riadku je $m$ čísel -- počty listov na Vikinom kuse kalerábu.

## Formát výstupu

Na jediný riadok výstupu vypíšte jedno číslo -- počet sŕn v koši, ak Viki a Viki šúpali kaleráb optimálne. Nezabudnite na koniec riadku.

## Hodnotenie

Sú 4 sady vstupov, za každú sú 2 body. Vo všetkých vstupoch platí, že $n,m \\geq 1$ a zároveň na každej šupe je aspoň $1$ list. Na žiadnej šupe nie je viac ako $1000$ listov. Ďalšie obmedzenia si môžete pozrieť v tabuľke.

| sada | $n, m \\leq$ | |:----:|:------------:| | $1.$ | $6$ | | $2.$ | $100$ | | $3.$ | $300$ | | $4.$ | $1000$ |

## Príklady

```vstup
3 2
1 2 3
1 2
```

```vystup
2
```

Najprv Viki aj Viki ošúpu 1 šupu zo svojho kusu kalerábu. Pritom sa v koši objavia $(3-1)\\times(2-1)=2$ divé srny. Potom Viki ošúpe 2 šupy zo svojho kusu kalerábu, a Viki jednu šupu zo svojho kalerábu. Pritom sa v koši objaví $(3-2)\\times(1-1)=0$ divých sŕn. Za celý čas sa teda v koši objavia $2$ divé srny.
","# Srny, Viki, Viki a iné divé veci {bodypopis=12 bodyprogram=8}

Túto úlohu budeme riešiť pomocou dynamického programovania. Budeme sa pozerať len na posledný krok. Zamyslime sa, čo by mohol byť jeden stav našej dynamiky. Potrebujeme ním nejak popísať stav oboch šúp kalerábu. Stav jednej šupy jednoznačne popisuje jedno číslo - počet zostávajúch kusov na danej šupe. Náš stav teda bude dvojica čísel, počty ostávajúcich kusov. Rôznych stavov teda bude $O(nm)$. Ako vieme zistiť riešenie pre jednu dvojicu?

## Prvé riešenie

V jednom kroku Viki a Viki zvolia koľko kusov sa odstráni z ktorej šupy, a na základe toho pribudnú nejaké srny. Naše riešenie by teda mohlo prejsť cez všetky možnosti, a vybrať z nich najlepšiu - tú pri ktorej sa v koši objaví najmenej sŕn. Keďže máme potencionálne až $n$ možností ako zvoliť $x$, a $m$ možností ako zvoliť $y$, výpočet jedného stavu by nám zabral $O(nm)$ času. Celý program by teda bežal v časovej zložitosti $O(n^2m^2)$.

## Optimalizácia

Všimnime si, že výraz $(S - x)$ a $(Z - y)$ má rovnaký efekt ako zníženie všetkých čísel o $1$ a minimalizovanie výrazu $S X$. Tento krok nie je nutný na vyriešenie úlohy, ale výrazne zjednoduší zápis nasledujúcich vzorcov.

V optimálnom riešení bude v každom kroku buď $x$ alebo $y$ $1$. Predpokladajme, že by v optimálnom riešení bol krok, pri ktorom zvolené $x$ aj $y$ bolo väčšie ako $1$. Počet sŕn v koši by potom bol $S Z$. Nech $s$ a $z$ sú počty listov na posledných kusoch kalerábov tak, že $S = S' + s$ a $Z = Z' + z$. Počet sŕn v koši je teda $(S' + s) (Z' + z)$. Ak by sme ale najprv spravili krok, kde zvolíme hodnoty $1$ a $1$, a potom krok pre $x-1$ a $y-1$ v koši sa objaví $s * z + S' Z'$ sŕn. V optimálnom riešení sa však v koši objavilo $S Z = (s + S')

- (z + Z') = s z + S' Z' + s Z' + z S'$ sŕn. Keďže ale $s Z' + z S' \\geq 0$ tak aj v novom riešení sa v koši objavilo nanajvýš toľko sŕn, čo znamená, že môžeme (alebo dokonca musíme) spraviť krok dĺžky $1$. Opakovaným aplikovaním tohoto postupu ukážeme, že určite existuje optimálne riešenie, v ktorom je vždy $x$ alebo $y$ rovné $1$.

Tento poznatok môžeme využiť vo svojom riešení. Pri skúšaní už budeme skúšať iba tie dvojice $x$ a $y$, kde $x=1$ alebo $y=1$. Nemáme už $nm$ možností ale iba $n+m$ možností. Naše vylepšené riešenie teda má časovú zložitosť $O(nm(n+m))$, čiže rádovo kubickú.

## Vzorové riešenie

Zatiaľ sme vždy pri výpočte počítali, že Viki a Viki spravia celý krok. Pozrime sa teraz na niečo ako medzikroky. Ak teraz rátame s možnosťou, že zvolíme $x=1$, tak sa vieme vždy rozhodnúť, či zväčšíme $y$ o $1$, alebo tento krok ""ukončíme"". Vždy keď zvačšíme $y$ o $1$ sa v koši objaví $s z$ sŕn, kde $s$ je počet listov na poslednej šupy prvého kusu kalerábu, a $z$ je počet listov na poslednej šupy druhého kusu kalerábu. Uvedomme si, že môžeme počet sŕn rátať takto postupne. Vyplýva to z distributívnosti násobenia a sčítavania ($s Z = s (z_1 + ... + z\_{k-1} + z_k) = (s z_1 + ... + s z\_{k-1}) + s z_k$).

Náš stav teda bude trojica počty zostávajúcich kusov jedného a druhého kalerábu a indikátor, z ktorého kusu berieme viac ako $1$. Počet stavov sa teda zdvojnásobí, ale stále bude stavov $O(nm)$.

Hodnotu v jednom takomto stave vieme vypočítať v konštantnom čase. Možnosti, ktoré treba vyskúšať, sú zobrať ešte jeden alebo ukončiť. Ak ukončíme, tak máme ešte 2 možnosti, či v ďaľšom kroku budeme brať viac z prvého alebo druhého kusu.

## Časová zložitosť

Časová zložitosť nášho algoritmu teda bude $O(nm)$. Hodnotu pre každý z $O(nm)$ stavov vieme zistiť v konštantnom čase.

## Pamäťová zložitosť

Ak si budeme pamätať hodnotu pre každý stav, priestorová zložitosť nášho algoritmu bude $O(nm)$. Ak by sme ale algoritmus implementovali iteratívne, mohli by sme si všimnúť, že dokážame zlepšiť pamäťovú zložitosť na O(n+m).

## Program

Rekurzívne implementované riešenie:

Riešenie s lineárnou pamäťovou zložitosťou:
",9
625b424674c2dfe2,ksp,"# Šibalské sny

Súhvezdia sú nudné. Existujú si na oblohe a veľa toho nenarozprávajú. Niektoré dvojice hviezd v súhvezdí sú spojené čiarou, vraj, aby ľuďom viac niečo pripomínali.

Sem-tam sa ale aj také súhvezdie potrebuje ponaťahovať. Hadonoš[^1] rád sníva. Rozmýšľa, ako rôzne by sa mohol ponaťahovať, keby bol nejakým iným súhvezdím. Vždy, keď sa mu takto prisní, že je iným súhvezdím, prudko sa zobudí a začne počítať, koľkými rôznymi spôsobmi by vedel svoje hviezdy usporiadať. Nemá ale príliš veľký mozog a tak sa mu snívajú iba samé spojité acyklické konfigurácie.

Nie je to ale iba tak. Nebyť súhvezdí, Kolumbus by nedoplával do Ameriky[^2], Cook by zablúdil už pri Dubline a Krtko by nevedel trafiť na správne sústredenie. Nemôžu sa teda naťahovať len tak, ako sa im zachce. Musia sa ľuďom javiť nezmenené.

\[^1\]: Nemýliť s [hadonos](<https://sk.wikipedia.org/wiki/Hadonos_(s%C3%BAhvezdie)>). \[^2\]: Možno...

## Úloha

Hadonoš vám postupne popíše každý jeho sen. Každý sen je jedno súhvezdie, teda hviezdy a čiary, ktorými sú niektoré dvojice hviezd prepojené. Každé prisnené súhvezdie tvorí strom. Každá hviezda má svoje číslo, hviezdy sú teda rozoznateľné.

Hadonoš po zobudení potrebuje vyrátať, koľkými spôsobmi sa dajú v prisnenom súhvezdí preusporiadať hviezdy tak, aby platilo:

- Hviezda číslo $0$ nezmení svoju pozíciu
- Množina pozícií na oblohe, ktoré boli obsadené hviezdami súhvezdia je pred usporiadaním rovnaká ako po ňom
- Ak pred usporiadaním boli čiarou spojené hviezdy $a$ a $b$, tak sú spojené čiarou aj po usporiadaní

Každé súhvezdie teda tvorí strom zakorenený v $0$.

Bez odpovede Hadonoš znovu nezaspí a na zajtrajšiu skúšku z astronómie príde unavený. Uspite ho!

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $T$ -- počet Hadonošovych snov. Platí $1 \\leq T \\leq 10$. Nasleduje $T$ popisov snov.

Popis sna začína riadkom s číslom $n$ -- počet hviezd v prisnenom súhvezdí. Platí $3 \\leq n \\leq 10,000$. Nasleduje $n - 1$ riadkov. Na $i$-tom z nich sa nachádzajú čísla $a_i$, $b_i$ oddelené medzerou. Tie hovoria, že v prisnenom súhvezdí sú čiarou spojené hviezdy $a_i$ a $b_i$. Platí $0 \\leq a_i, b_i < n$.

Každé prisnené súhvezdie tvorí strom.

## Formát výstupu

Pre $i$-ty sen vypíšte na $i$-ty riadok výstupu jedno číslo -- počet rôznych usporiadaní hviezd $i$-teho prisneného súhvezdia spĺňajúcich vyššie popísané požiadavky. Keďže odpoveď môže byť veľmi veľká, vypisujte ju modulo $10^9 + 7$.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |-----: | ----: | --------: | -------: | | $3 \\leq n \\leq$ | $8$ | $20$ | $1,000$ | 10,000 |

## Príklad

```vstup
2
5
0 1
0 2
1 3
1 4
7
0 1
0 2
1 3
1 4
2 5
2 6
```

```vystup
2
8
```

_V prvom súhvezdí sú vyhovujúce dve možnosti. Prvou je nespraviť žiadnu zmenu, druhou je vymeniť vrcholy 3 a 4._ _V druhom súhvezdí je jednou z možností napríklad vymeniť koreňu ľavý a pravý podstrom a naviac vymeniť vrcholy 5 a 6._
","# Šibalské sny

Na vstupe sme mali strom popisujúci súhvezdie. Našou úlohou bolo spočítať, koľkými spôsobmi vieme preusporiadať hviezdy v súhvezdí, aby boli splnené isté podmienky. Konkrétnejšie, mali sme zrátať niečo ako koľko stromov je izomorfných so zadaným stromom tak, že koreňom je stále vrchol číslo 0. Presné podmienky si môžete pozrieť v zadaní.

## Pozorovania

Zamyslime sa najskôr nad tým, kedy sa budú dať hviezdy preusporiadavať. Pozrime sa na koreň. Aby sme dostali iný strom spĺňajúci podmienky, môžeme zmeniť poradie tých podstromov koreňa, ktoré sú v nejakom zmysle rovnaké. Aby sme teda zachovali správne prepojenie vrcholov hranami, budeme môcť koreňu iba vymieňať rovnaké podstromy. Avšak, v rámci každého podstromu môžeme spraviť tiež nejaké preusporiadanie, ktoré štruktúru podstromu nezmení. Rekurzívne teda môžeme popísať vyhovujúce preusporiadania pre podstromy koreňa, a tak ďalej, až ku listom.

Ako ale povedať, či sú dva podstromy rovnaké?

## Vzorové riešenie

Je množstvo možností, ktoré nám na riešenie tejto otázky napadnú. Či už je to porovnávanie počtu vrcholov, listov, alebo hĺbok, žiaden z týchto spôsobov nebude fungovať. Nájsť príklady dvoch rôznych stromov, pre ktoré tieto metriky budú tvrdiť, že sú rovnaké, nie je problém.

Riešenie je prekvapivo jednoduché. Dva podstromy sú zameniteľné práve vtedy, keď ich korene majú ako synov rovnaké podstromy. Nezáleží nám na poradí synov. Zameniteľné budú, pretože synov vieme vhodne preusporiadať a neporušíme pri tom žiadnu podmienku zo zadania.

Budeme teda podstromom priraďovať `id`. Dva podstomy budeme považovať za zameniteľné, ak majú rovnaké `id`. Tieto čísla budeme priraďovať rekurzívne od listov. Stačí nám na to jedno [DFS](https://www.ksp.sk/kucharka/dfs/). Listy budú mať `id = 1`. Keď sa rekurzívne zavoláme do všetkých synov, budú už mať priradené `id`. Tieto ich `id` si zaradom dáme do poľa. Dostaneme tak napríklad pole `[1, 2, 4, 1, 1, 6]`. Z toho chceme určiť `id` aktuálneho vrchola. Zistili sme už ale, že na poradí synov nezáleží. Aby naše pole teda určovalo `id` vrchola, usporiadame si ho. Následne sa pozrieme, či sme už niekedy boli vo vrchole s týmto usporiadaným poľom `id`-čiek synov. Ak áno, pridelíme aktuálnemu vrcholu rovnaké `id` ako danému vrcholu. Ak sme takého pole ešte nevideli, pridelíme nášmu vrcholu napríklad najmenšie ešte nepridelené `id`.

Ostáva nám ešte vyriešiť kombinatorickú časť úlohy. Nech `ways[ID]` hovorí, koľkými spôsobmi vieme preusporiadať podstrom s `id = ID`. Už vieme, že môžeme vymieňať synov s rovnakým `id`. Každého syna zároveň vieme preusporiadať. Konkrétne, syna s `id = x` vieme usporiadať `ways[x]` spôsobmi. Jednotlivé typy synov sú na sebe nezávislé, preto tieto počty medzi sebou vynásobíme. Označme `cnt[ID]` počet synov aktuálneho vrchola s `id = ID`. Ďalej označme $S$ množinu `id`-čiek synov aktuálneho vrchola (teda je bez duplikátov). Dostaneme nasledový vzťah:

$$\\text{ways}[\\text{ID}] = \\prod\_{x \\in S} \\text{cnt}[x]! \\cdot \\text{ways}[x]^{\\text{cnt}[x]}$$

Samozrejme, všetko modulujeme. Celkovým výsledkom potom bude $\\text{ways}[\\text{id}\_{\\text{koreň}}]$.

Časová zložitosť bude kvôli usporiadavaniu v DFS $O(n \\log n)$ na test. Pamäť bude $O(n)$.
",9
bcd4f326d15f3794,ksp,"# Obmedzená slovná zásoba

Na izolovanom ostrove v Atlantickom oceáne, na ktorý až donedávna ľudská noha nevkročila, objavili vedci nový druh príbuzný ľudom -- _homo antisapiens_. Výzorom je veľmi podobný človeku, a je dokonca schopný vyslovovania všetkých hlások. Ako sa však ukázalo, ich schopnosť vyjadrovať sa, je pomerne obmedzená.

Rečové centrá tohto druhu sú totiž decentralizované, a na nízkej úrovni -- každá hemisféra mozgu si vie zapamätať najviac jedno slovo. Preto má každý jedinec uložené jedno slovo v ľavej a jedno slovo v pravej hemisfére, pričom tieto slová môžu, ale nemusia byť rovnaké.

Keď chce príslušník rodu _homo antisapiens_ vysloviť nejaké slovo, tak povie nejaký začiatok slova ľavej hemisféry a potom nejaký koniec slova pravej hemisféry. Obe časti musia byť dlhé aspoň jeden znak.

Napríklad ak ľavá hemisféra pozná slovo `jedlo` a pravá slovo `lopta`, tak jedinec vie vysloviť slová `ja`, `jedlolopta`^[Taktiež nazývané melón.], `jedlopta`, `jepta`, `jedllopta`, ... ale nevie vysloviť `lopta` (lebo by nepoužil nič z `jedlo`), ani `jedlop` (lebo `lop` nie je koniec slova `lopta`) a dokonca ani `ptajed` (lebo ľavá hemisféra musí povedať svoju polovicu skôr).

Vedci by chceli porozumieť jedincom tohto druhu, nakoľko často robia na prvý pohľad nezmyselné veci (tlačia veľký balvan na vrch hory). Radi by však najprv vedeli, či počet slov vysloviteľný týmto druhom nie je priveľký, aby ich výskum nebol taktiež sizyfovský.

## Úloha

Dané sú dva reťazce malých písmen anglickej abecedy -- slová $A, B$. Zistite, koľko existuje **rôznych** slov $W$ takých, že nejaká začiatočná časť slova $W$ je neprázdny prefix $A$ a zvyšná časť slova $W$ je neprázdny sufix $B$.

## Formát vstupu

Na prvom riadku vstupu je slovo $A$, a na druhom slovo $B$.

Obmedzenia veľkosti vstupov pre jednotlivé sady sú nasledovné:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | |:------------------- | ----:| ----:| ----:| ----:| -----:| -----:| | Maximálna dĺžka slov $A$, $B$ | 32| 425| 5657| 75212|1000000|1000000|

Navyše, v sade 6 platí pre každé zo slov $A, B$ nasledovné: rovnaké písmená tvoria v oboch slovách súvislý úsek. (Vo vstupe môže byť napríklad $aaaxuupkkkkkll$, ale nie $abaaacccb$.)

## Formát výstupu

Na jediný riadok výstupu vypíšte počet vyhovujúcich slov.

## Príklad

```vstup
aha
haha
```

```vystup
9
```

_(Znakom $|$ označíme, kde končí prefix a začína sufix.) Všetky možnosti, ako vybrať vhodný prefix a sufix, sú $a|a, ah|a, aha|a, a|ha, ah|ha, aha|ha, a|aha, ah|aha, aha|aha, a|haha, ah|haha, aha|haha$. Z toho si všimneme, že $ah|a = a|ha, aha|ha = ah|aha = a|haha$. Z pôvodných 12 máme iba 9 rôznych, teda správny výsledok je 9._

```vstup
zeleny
akokrava
```

```vystup
48
```

```vstup
stastnynovyrok
vyrok
```

```vystup
64
```
","# Obmedzená slovná zásoba

Táto úloha bola zaujímavá tým, že na jej vyriešenie nebolo potrebné poznať žiadne dátové štruktúry, ani techniky riešenia úloh ako napríklad dynamické programovanie. Ba dokonca, ak ste v úlohe hľadali nejaké tie štandardné štruktúry a algoritmy, tak ste pravdepodobne zabili veľa času :)

Prvý krok k úspešnému vyriešeniu je rozobrať si niekoľko malých prípadov ručne, a snáď pritom odpozorovať niečo o tom, ako sa to celé správa.

Na začiatok si všimneme, že ak niektoré slovo na vstupe je prázdne, tak odpoveď je zrejme $0$. (Nemá prefix ani sufix dĺžky aspoň 1.) V ďalšom texte predpokladáme, že obe slová majú dĺžku aspoň $1$.

## Hrubá sila

Každé slovo vieme nájsť tak, že zoberieme nejaký prefix $A$, nejaký sufix $B$ a spojíme ich. Naskytá sa nám tak nasledujúce riešenie:

Vyskúšame všetky možné prefixy $A$. Pre každú možnosť vyskúšame všetky sufixy $B$. Spojíme ich do jedného slova, a uložíme do vreca. Po odskúšaní všetkých možností z vreca odstránime všetky duplikáty. Počet zvyšných prvkov vo vreci je hľadaný výsledok.

Jediný problém môžeme mať pri vyhadzovaní duplikátov -- ako to spraviť? Zamyslime sa, ako by sme odstránili duplikáty z postupnosti čísel -- postupnosť utriedime, a následne vieme, že rovnaké prvky sú v postupnosti hneď za sebou. Prejdeme teda postupnosť od začiatku po koniec, a každý prvok, ktorý je rôzny od predchádzajúceho, hodíme do výsledného vreca (ktoré už neobsahuje duplikáty).

To isté spravíme so slovami. Slová budeme porovnávať **lexikograficky** (takým spôsobom sú slová usporiadané napríklad v slovníkoch). To znamená, že sa najprv pozrieme na prvý znak. Ak sa slová na ňom nezhodujú, za **lexikograficky menšie** prehlásime to, ktorého znak je v abecede skôr. Ak sa slová na ňom zhodujú, pokračujeme ďalším písmenom.

Čo sa ale stane, ak niektoré slovo už nemá nasledujúci znak? Jednoducho ho prehlásime za menšie. Teda ak je jedno zo slov prefixom druhého, tak je od neho lexikograficky menšie.

Napríklad $jablko < jablkoahruska$, $a < bcdef$, prázdny reťazec je menší od ľubovoľného slova, ...

Čo sa týka implementácie, väčšina programovacích jazykov štandardne vie porovnávať dva reťazce, a tiež väčšinou majú štandardnú funkciu na triedenie. Stačí ju teda zavolať na naše pole všetkých kombinácii prefixov a sufixov.

Časová zložitosť tohto riešenia je $O(n^3 \\log{n})$, a pamäťová $O(n^3)$, kde $n$ je veľkosť vstupu. (Máme $O(n^2)$ reťazcov, a každý má dĺžku $O(n)$. Triedenie spraví $O(n^2 \\log{n^2})$ porovnaní, každé v čase $O(n)$, takže celková zložitosť je $O(n^2 \\log{n^2} \\cdot n) = O(n^3 \\log{n})$.) V špeciálnych prípadoch je to aj menej (napríklad keď $|A| = 0$), ale v najhoršom prípade je to toľkoto.

## Jemnejšia sila

Na ""odstránenie"" duplikátov sa dá použiť aj iný postup -- zabezpečíme, že ich nikdy do nášho ""vreca"" nevložíme.

Na začiatku budeme mať prázdny slovník a postupne vyskúšame pridať všetky kombinácie prefixov $A$ a sufixov $B$, tak, ako v predchádzajúcom riešení. Ak práve skúšaná kombinácia ešte nie je v slovníku, pridáme ju doň a zvýšime si počítadlo počtu slov v slovníku o $+1$. V opačnom prípade ju zahodíme.

Slovník môžeme implementovať ako písmenkový strom (po anglicky trie) alebo ako hashovaciu tabuľku (`unordered_map` v štandartnej knižnici C++). Vkladanie prvkov a zisťovanie, či už sa tu takýto prvok nachádza trvá týmto štruktúram lineárny čas od dĺžky reťazca.

Oproti predchádzajúcemu riešeniu sme si vylepšili čas o $\\log{n}$ -- časová zložitosť je $O(n^3)$, a pamäťová je rovnaká.

## Riešenie postupnými zmenami

Najprv si všimneme, že má zmysel hľadať duplikáty iba v slovách rovnakej dĺžky, nakoľko slová rôznych dĺžok určite nie sú rovnaké. Vieme tak znížiť pamäťovú zložitosť na $O(n^2)$ -- namiesto toho, aby sme si spravili zoznam všetkých kombinácii naraz, stačí nám spraviť si osobitný zoznam pre každú dĺžku. Ten môžeme po spracovaní (vyhodení duplikátov) zahodiť, a tak si nikdy nepamätáme viac ako $O(n)$ reťazcov dĺžky $O(n)$ **naraz**.

Pozrime sa teraz, ako vyzerajú kombinácie s jednou konkrétnou dĺžkou, keď ich spracúvame ""sprava doľava"" (tak, že začneme kombináciou s najdlhším prefixom $A$, a postupne zmenšujeme prefix $A$ a zväčšujeme sufix $B$). Napríklad ak máme kombinácie slov $jablko, hruska$ dĺžky $8$, tak ich budeme spracúvať v tomto poradí: $$jablkoka, jablkska, jabluska, jabruska, jahruska$$

Zameriame sa na zmeny. Čo sa zmení, keď sa posuniem v zozname o $1$ ďalej? Posledný znak prefixu sa nahradí znakom sufixu. (Napríklad v treťom posune sme mali prefix $jabl$ a sufix $uska$. Posledný znak prefixu, $l$, sme nahradili znakom sufixu, ktorý v $hruska$ predchádza $uska$, teda $r$.) Ak sú tieto znaky rovnaké, dostaneme to isté slovo -- našli sme duplikát. Čo ale ak sú tieto znaky rôzne? Nemôže sa stať, že by sme dostali slovo, ktoré bolo spracované ešte skôr?

Všimnime si ale, že zmeny sa postupne dejú na skorších pozíciách. Prvý posun $jablkoka \\rightarrow jablkska$ nám zmenil znak na pozícii $6$, druhý posun ovplyvňuje znak na pozícii $5$, ... Teda **každá pozícia sa zmení v najviac jednom posune**. Ak sa znak na pozícii $k$ zmenil v nejakom posune z $\\alpha$ na $\\beta$, potom všetky kombinácie pred tým posunom majú na danej pozícii $\\alpha$, a všetky kombinácie po tom posune majú na tej pozícii $\\beta$. Napríklad v presune $jabluska \\rightarrow jabruska$ sa zmenila pozícia $4$: $$jab\\mathbf{l}koka, jab\\mathbf{l}kska, jab\\mathbf{l}uska \\rightarrow jab\\mathbf{r}uska, jah\\mathbf{r}uska$$

To ale znamená, že ak je nahradený znak rôzny od pôvodného, tak výsledné slovo určite nebolo spracované skôr, lebo všetky slová spracované skôr majú na tejto pozícii pôvodný znak. Našli sme tak novú kombináciu.

Vyskúšame teda všetky možné dĺžky kombinácií, a pre každú spracujeme kombinácie s tou dĺžkou. Pritom nemusíme kombinácie vytvárať (nemusíme _materializovať_ stringy), ale pri spracovaní sa pozeráme iba na $2$ znaky -- pôvodný (pred posunom), a nový (po posune). Časová zložitosť je preto $O(n^2)$, a pamäťová $O(n)$.

Možno ste si všimli detail v implementácii: Všetkých kombinácií je $|A| \\cdot |B|$ a odčítavame počet duplikátov. Tento detail sa nám bude hodiť za chvíľku.

## Počítanie toho istého iným spôsobom

Čo vlastne predchádzajúce riešenie robí? Pozerá sa na niektoré dvojice [pozícia v $A$, pozícia v $B$], a ak sú znaky na týchto pozíciách rovnaké, odráta od výsledku $1$. Zamyslime sa nad tým, koľkokrát pozrie ktoré dvojice. Zvolíme si nejakú konkrétnu dvojicu $[a,b]$ a chceme zistiť, koľko posunov spôsobí nahradenie znaku na pozícii $a$ znakom, ktorý je v $B$ na pozícii $b$?

Každá pozícia v $A$ nám jednoznačne určí, aký má byť prefix pred posunom, a aký je po posune. (Napríklad pozícia $2$ v $jablko$ vraví, že pred posunom je prefix $ja$, a po posune je $j$.) Pozíciu $1$ ale neberieme do úvahy, lebo po posune bude prefix prázdny. Zaujímajú nás len kombinácie tvaru [neprázdny prefix $A$] zreťazený s [neprázdny sufix $B$].

Taktiež každá pozícia v $B$ nám jednoznačne určí, aký má byť sufix pred a po posune. Nerátame pozíciu $|B|$. Dostávame tak, že na každú dvojicu $[a,b]$, kde $a > 1, b < |B|$ sa pozrieme **práve raz**. Čo to ale znamená? Zvoľme si nejakú pevnú pozíciu $a$, a povedzme, že na nej je znak $\\alpha$. Potom odrátame $1$ za každý znak v [$B$ okrem posledného znaku], ktorý je rovný $\\alpha$. Celkovo si odrátame $k$, kde $k$ je počet znakov $\\alpha$ v [$B$ bez posledného znaku]. Ak máme v [$A$ bez prvého znaku] $l$ znakov $\\alpha$, od výsledku dokopy odrátame $l \\cdot k$.

Dopracovali sme sa tak k nasledujúcemu riešeniu: spočítame si počty jednotlivých znakov v [$A$ bez prvého znaku], [$B$ bez posledného znaku]. Zo získaných počtov ľahko vypočítame výsledok. Časová zložitosť je $O(n + \\sigma)$, kde $\\sigma$ je veľkosť abecedy.

Pamäťová zložitosť riešenia je $O(n + \\sigma)$, ale vedeli by sme ju zlepšiť aj na $O(\\sigma)$, ak by sme vstup načítavali po znakoch.
",6
12f640d5b4f46a15,ksp,"# Strašná kopa papierov

Paulínka sa v detstve najradšej hrávala s voskovkami. V jej škôlke mali na hranie práve dve veci:

- veľa voskoviek v rade za sebou,
- veľa kôp papierov v rade za sebou.

Nemožno sa teda čudovať, že jej zábava, povedzme si na rovinu, nebola práve najintelektuálnejšia -- celý deň si brala voskovky v poradí, v akom boli na stole, a vždy, keď si vzala nejakú voskovku, nepustila ju z rúk, až kým ju celú nevypísala. Toto robila, až zafarbila všetky papiere v škôlke. Takto jej často vznikali jednofarebné obrázky a tie sa Paulínke až tak nepáčia. Vedeli by ste zistiť, koľko z jej obrázkov bolo viacfarebných?

## Úloha

Paulínka má $n$ voskoviek rôznych farieb, každá má svoju dĺžku $d_i$ a $m$ kôpok papierov. V každej kôpke sa nachádza $k_i$ rovnakých čistých papierov. Na zafarbenie jedného papiera z $i$-tej kôpky potrebuje Paulínka $c_i$ dĺžky voskovky/voskoviek. Paulínka vždy vyfarbí jeden celý papier a až potom prejde na ďalší. Papiere si berie poporadí, teda vždy vyfarbí celú kôpku pred tým, ako začne brať papiere z ďalšej. Voskovky si berie tiež poporadí, a vždy až potom, ako sa jej predošlá voskovka vypíše.

Zistite, koľko obrázkov bude obsahovať viac než jednu farbu.

Je zaručené, že voskovky stačia na pokreslenie všetkých papierov.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $n$ -- koľko rôznych voskoviek má Paulínka. Nasleduje $n$ riadkov, kde každý riadok obsahuje celé číslo $d_i$ -- dĺžku $i$-tej voskovky. Ďalší riadok obsahuje číslo $m$ -- počet kôpok papierov. Nasleduje $m$ riadkov, kde $i$-ty riadok obsahuje dve celé čísla $k_i$ a $c_i$, kde $k_i$ znamená počet papierov v $i$-tej kôpke a $c_i$ je celková dĺžka voskovky, ktorú treba na zafarenie jedného papiera v $i$-tej kôpke.

## Obmedzenia

Sú $4$ sady vstupov.

V prvých dvoch sadách platí, že $n \\leq 10,000$, $m \\leq 1000$, $d_i, c_i, k_i \\leq 1000$ a suma dĺžok voskoviek je menej ako $2,000,000$.

V druhých dvoch sadách platí, že $n \\leq 1,000,000$, $m \\leq 200000$, $d_i, c_i, k_i \\leq 200,000$ a suma dĺžok voskoviek je menej ako $50,000,000,000$.

## Formát výstupu

Vypíšte jedno celé číslo -- počet obrázkov, ktoré budú viacfarebné.

## Príklad

```vstup
2
5
5
1
2 5
```

```vystup
0
```

*Paulínka má dve voskovky, obe dĺžky $5$. Má jednu kôpku papierov, kde sú dva papiere, pre každý treba $5$ dĺžok voskoviek. Prvou voskovkou zafarbí prvý papier, druhou druhý. Ani jeden papier nie je viacfarebný.*

```vstup
2
4
6
2
1 6
1 4
```

```vystup
1
```

*Teraz má Paulínka dve voskovky, jednu dĺžky $4$ a druhú dĺžky $6$. Má dve kôpky papierov, v oboch je po jednom papieri. Na zafarbenie prvého papiera treba $6$ dĺžok voskoviek. Na zafarbenie druhého papiera treba $4$ dĺžok voskoviek. Keďže papiere aj voskovky Paulínka berie po poradí, tak prvou voskovkou zafarbí 4 dĺžky prvého papiera a zvyšok prvého a celý druhý zafarbí druhou voskovkou.*

```vstup
4
1
1
1
1
1
1 3
```

```vystup
1
```

*V tomto prípade má Paulínka štyri voskovky, všetky dĺžky $1$. Má jednu kôpku papierov, kde je ibe jeden papier, a na jeho zafarbenie treba $3$ dĺžky voskoviek. Tri voskovky minie na zafarbenie tohoto jediného papiera, a jedna jej ostane nepoužitá. Rôznofarebný papier je teda jeden.*
","# Strašná kopa papierov

## Priamočiare riešenie

Ako priamočiare riešenie nám môže napadnúť, že odsimulujeme, čo sa stane pre každý papier každej kôpky. Teda si budeme pamätať aktuálny kúsok voskovky ktorý nám ostáva a postupne pre každý papier každej kôpky sa spýtame, či je kus voskovky ktorý nám aktuálne ostáva dostatočne dlhý na jeho celé zafarbenie. Ak nie, vieme že bude viacfarebný a zapamätáme si to do výsledného počtu. Nesmieme pri tom zabudnúť ""odobrať"" aj časť ďalšej voskovky (ktorá sa použije na vyfarbenie), prípadne niekoľko celých a časť ďalšej, prípadne len niekoľko celých (podľa toho, koľko ešte potrebujeme na dovyfarbenie papiera). Kód by mohol vyzerať takto:

Problémom ale je, že takéto riešenie nebude dostatočne efektívne, keďže potrebujeme $O(m \\cdot k)$ operácií a v zadaní vidíme, že $m$ a $k$ môžu byť každé až $200,000$. Teda potrebujeme rozhodovať o zhruba $4,000,000,000$ papierov. To je priveľa a náš program to nestihne.

## Ako to zlepšiť ?

Tu si treba všimnúť, že ak by sme namiesto každého papiera každej kôpky prechádzali voskovkami, budeme potrebovať oveľa menej operácií, lebo podľa obmedzení, voskoviek bude najviac milión. Potom náš algoritmus bude fungovať tak, že si pamätá, koľko ostáva z aktuálnej voskovky a až kým sa neminie, berie celé kôpky a pýta sa:

- dokážem z tejto voskovky zafarbiť celú kôpku ?

- dokážem z tejto voskovky zafarbiť niekoľko celých papierov kôpky ? Toto sa dá jednoducho urobiť pomocou zvyšku po delení -- modulo.

- inak určite vznikne viacfarebný papier

Pri každom prípade treba dopočítať, koľko z aktuálnej voskovky ostane, prípadne ak potrebujeme viac ako len aktuálnu voskovku, tak si vypočítať, koľko ostane z poslednej ktorú použijeme.

### Časová zložitosť :

Riešenie bude mať zložitosť $O(m+n)$, pretože ako si môžeme všimnúť, s každou voskovkou a každou kôpkou pracujeme iba raz. Teda ak si napríklad označíme index voskovky s ktorou práve pracujeme ako $i$, tak toto $i$ vždy rastie, nikdy neklesá (k vypísaným voskovkám sa nevraciame). Rovnako ak si označíme index kôpky ktorú práve zafarbujeme ako $j$, tak aj toto $j$ vždy rastie, nikdy neklesá (k zafarbeným kôpkam sa nevraciame). Keďže pri zafarbovaní kôpky robíme len konštantné operácie - vetvenie a delenie, tak nič iné nám zložitosť neovplyvňuje.

### Pamäťová zložitosť :

Aj pamäťová zložitosť bude $O(m+n)$, lebo si musíme pamätať $n$ dĺžok voskoviek, $m$ veľkostí kôpok a $m$ hodnôt opisujúcich dĺžku voskovky na zafarbenie $1$ papiera danej kôpky. Teda pamäťová zložitosť bude $O(2m + n)$, teda $O(m+n)$.
",4
0422bf1c6dec2d25,ksp,"# Nádlab

Kristíne sa podarilo byť úspešným riešiteľom jej obľúbeného Trojsten korešpondenčného semináru, čím si zaslúžila účasť na jeho letnom sústredení. V rámci štandardného týrania detí na Lesnej Omege je potrava iba na prídel za dobré správanie. Účastníci za dobré skutky ako pomáhanie pri budíčkoch, zúčastňovanie sa rozcvičiek, aktivitu na prednáškach, čistenie záchodov a iné získavajú jednorázové stravné lístky.

Niekoľko svedkov pozorovalo Kristínu nekalo sa škeriť.

## Úloha

Lístok môže vyzerať napríklad takto:

```
+-------+
| 0247g |
|   11% |
+-------+
```

Všetky lístky vyzerajú rovnako, líšia sa iba v číselných hodnotách. Môžeme vidieť, že na každom lístku sú dve čísla, jedno končiace sa `g` a druhé ukončené `\%`. Lístok sa dá teda využiť buď tak, že účastník dostane určité množstvo gramov, alebo určité percento zostávajúceho jedla v hrnci.

Kristína vie, že dnešná večera je granadír. Celé sústredenie si odkladala stravné lístky a podarilo sa jej ich nahrabať až $N$. Cieľ je jasný a nenechá sa ničím a nikým zastaviť - získať všetok granadír pre seba.

Ale dá sa to vôbec? Lístky vie použiť v ľubovoľnom poradí a pre každý si vie samozrejme vybrať, akým z daných dvoch spôsobov ho chce uplatniť. Pomôžte jej zistiť, ako má lístky použiť aby nahonobila najmasívnejšie množstvo granadíru. Krisína pevne verí, že kuchyňa je čestná a prípadné dlhy jej budú vyplatené na ďalšom sústredení. Jej cieľom je teda maximalizovať zisk granadíru a výsledný zostatok kuchyne môže byť záporný.

## Formát vstupu

Na prvom riadku je jedno číslo $V$ ($1 \\leq V \\leq 10$) udávajúce počet večerí. Nasleduje $V$ popisov večerí, pričom všetky sú navzájom nezávislé. Pre každú večeru je na vstupe nasledovné:

V prvom riadku sú dve čísla $N_v$ ($1 \\leq N_v \\leq 40$) a $H_v$ ($0 \\leq H_v \\leq 10^9$) udávajúce počet kartičiek a hmotnosť navareného granadíru.

Nasleduje $N_v$ riadkov, každý tvaru `<A>g <B>%` kde `<A>` ($0 \\leq A \\leq 10^4$) a `<B>` ($0 \\leq B \\leq 100$) sú už spomínané dve čísla napísané na kartičke.

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:------------------|-----:|-----:|-----:|-----:| | $1 \\leq N_v \\leq$ | $10$ | $20$ | $30$ | $40$ |

## Formát výstupu

Na výstup vypíšte $V$ odpovedí ako postupovať pri jednotlivých večeriach. V každej odpovedi vypíšte $N_i$ riadkov, každý vo formáte `<L> <T>`, kde `<L>` je číslo lístku indexované od jednotky a `<T>` je spôsob akým tento lístok chceme použiť, teda buď `g` alebo `%`. Poradie lístkov na výstupe určuje v akom poradí ich chcete uplatniť.

Riešenie je považované za správne ak sa od optimálneho riešenia líši maximálne o $10^{-9}$ v absolútnej alebo relatívnej hodnote.

## Príklady

```vstup
1
3 1000
10g 2%
20g 1%
30g 1%
```

```vystup
1 %
2 g
3 g
```

*Po uplatnení prvého lístku máme 20g a zostáva 980g, po uplatnení zvyšnych dvoch máme 70g a zostáva 930g.*

```vstup
1
3 1010
9g 1%
20g 1%
99g 10%
```

```vystup
3 %
1 %
2 g
```

*Dokopy získame 130.09g.*

```vstup
1
3 1010
9g 1%
20g 1%
100g 10%
```

```vystup
1 %
2 g
3 g
```

*Dokopy získame 130.10g.*

```vstup
1
3 10
10g 1%
10g 1%
10g 1%
```

```vystup
3 g
1 g
2 g
```

*Dokopy ""získame"" 30g, aj keď je to viac ako je reálne k dispozícii.*
","# Nádlab

## Načítavanie

Prvý krok nutný na vyriešenie úlohy je načítanie vstupu. Keďže je to 7. úloha, aj trošku neštandardný formát vstupu by nám nemal robiť problém. Najťažšie je načítať parametre kartičiek – chceme načítať dve čísla na jednom riadku, ale odignorovať posledný znak.

V Pythone vieme tento riadok načítať napríklad nasledovne:

```
gram, perc = input().split()
gram, perc = int(gram[:-1]), int(perc[:-1])
# alebo kompaktnejšie
gram, perc = map(lambda s: int(s[:-1]), input().split())
```

V C++ zase takto:

```
int gram, perc;
// pomocou scanf
scanf(""%dg %d%% "", &gram, &perc);
// alebo, keďže `cin`:
// - číselné typy načítava pokým nenarazí na nečíselný znak
// - ignoruje vedúce whitespace
// stačí načítať do čísla a následne načítať koncový znak do typu `char`
char koncovy;
cin >> gram >> koncovy >> perc >> koncovy;
```

Aby sa nám uľahčil život, ďalej vo vzorovom riešení, pod hodnotou 'x%'-kartičky myslíme zlomok granadíru ktorý ešte ostane po použití tejto kartičky, teda $1-x/100$.

## Bruteforce

Najprv si uvedomme, že ak vo výsledku máme dve po sebe idúce kartičky použité rovnakým spôsobom (teda obe `g` alebo obe `%`), nezáleží na ich poradí.

Ďalej si uvedomme, že sa nám nikdy neoplatí použiť `%`-kartičku po `g`-kartičke. Bez ujmy na všeobecnosti nech ide o posledné dve kartičky a nech množstvo granadíru zostávajúceho po použití všetkých zvyšných kartičiek je $R$. Potom výsledok (koľko granadíru zostane) po použití kartičiek v poradí `g%` bude $(R - m) \\cdot k = R \\cdot k - m \\cdot k$ zatiaľčo v poradí `%g` bude $R \\cdot k - m$, kde $0 \\leq b \\leq 1$. Vidíme teda, že použitím kartičiek v poradí `g%` iba zbytočne odčítavame menej. Výsledné kartičky teda obsahujú najprv postupnosť `%`-kariet a potom už iba `g`-kariet.

Spojením týchto dvoch uvedomení zistíme, že našou úlohou je iba pre každú kartu rozhodnúť o jej type, čo už potom jednoznačne určuje výsledok. Naskytá sa nám teda priamočiare riešenie vyskúšať všetkých $2^N$ možností, každú vyhodnotiť a vypísať najmenšiu.

Najťažšou časťou takéhoto programu je iterovanie cez všetky kombinácie. To sa štandardne robí prostredníctvom iterovania cez čísla od 0 po $2^N-1$. Binárny zápis každého tohoto čísla reprezentuje jednu podmnožinu $N$-prvkovej množiny.

```
for binarna_mnozina in range(1 << N):
    mnozina = set(i for i in range(N) if binarna_mnozina & (1 << i))
```

Pamäťová zložitosť je $O(N)$ a časová zložitosť je $O(N\\times 2^N)$. Efektívnou implementáciou tohoto prístupu sa dali prejsť až dve sady.

## Stredová stretávka

Pri riešení úloh vieme použiť obmedzenia vstupov ako pomôcku na nájdenie riešenia. V tomto prípade sme si mohli všimnúť, že $N$ je podozrivo malé, a teda by sa úloha mohla dať riešiť _Meet-In-The-Middle_ prístupom.

Princíp MITM riešení je využiť symetriu problému a rozdeliť ho na dve časti, ktoré sa dajú riešiť nezávisle. Snažíme sa teda nájsť také rozdelenie, aby každá časť bola dostatočne malá na to, aby sme ju vedeli vyriešiť nejakým iným prístupom (napríklad bruteforce) a výsledky z oboch častí dakázali spojiť do výsledného riešenia.

Ako by to vyzeralo? Rozdelíme si množinu kartičiek na dve rovnako veľké disjunktné časti. Pre každú z nich zbehneme bruteforce a zapamätáme si všetky podvýsledky – podvýsledok je optimálne riešenie pre zvolené určenie typov pre danú polovicu kartičiek. Pre každú časť ich bude $2^{N/2}$.

My už vieme, že určením typov kartičiek je jednoznačne určený výsledok čo nimi vieme dosiahnuť a efekt ich uplatnenia vieme zjednodušene reprezentovať ako dve čísla -- súčet všetkých `g`-kartičiek a súčin všetkých `%`-kartičiek, teda $(M, K)$.

Skombinovanie podvýsledkov z týchto dvoch podmnožín je potom jednoduché. Ak chceme skombinovať podvýsledok $(M\_{1,i}, K\_{1,i})$ s podvýsledkom $(M\_{2,j}, K\_{2,j})$, kombinácia bude $(M\_{1,i} + M\_{2,j}, K\_{1,i} \\cdot K\_{2,j})$, čo po konzumácii spôsobí zostatok granadíru $(H \\cdot K\_{1,i} \\cdot K\_{2,j}) - (M\_{1,i} + M\_{2,j})$.

Nás by teraz zaujímalo, aký je najlepší možný výsledok. To zistíme tak, že pre každý podvýsledok prvej časti nájdeme preňho najlepší podvýsledok v druhej časti – teda taký, ktorý minimalizuje daný výraz.

Naivným skúšaním všetkých možností by sme znova získali bruteforce ($O(2^{N/2}\\times 2^{N/2})$). Naším cieľom je pre fixné $(M\_{1,i}, K\_{1,i})$ minimalizovať $(H \\cdot K\_{1,i} \\cdot K\_{2,j}) - (M\_{1,i} + M\_{2,j})$ cez všetky $(M\_{2,j}, K\_{2,j})$. Všimnime si, že to je to isté ako minimalizovať $H_i \\cdot K\_{2,j} - M\_{2,j}$, pre $H_i := H \\cdot K\_{1,i}$, keďže $M\_{1,i}$ a $K\_{1,i}$ sú v tomto prípade konštanty. Problém je, že $H_i$ je konštanta iba pre jedno konkrétne $K\_{1,i}$, pričom rôznych $K\_{1,i}$ je až $2^{N/2}$.

### Konvexný obal

Sťažme si úlohu. Ak by sme vedeli nájsť optimálne $(M\_{2,j}, K\_{2,j})$ pre každé reálne $H'$, tak by sme ho predsa vedeli nájsť aj pre ľubovoľné konkrétne $H_i$. Z $H_i$ sa teda stáva reálna premenná $x$ a $x \\cdot K\_{2,j} - M\_{2,j}$ nám určuje lineárnu funkciu – priamku. Každé jedno $(M\_{2,j}, K\_{2,j})$ určuje jednu priamku a nás pre každé $x$ zaujíma najnižší bod ležiaci na niektorej z týchto priamok. Inak povedané, hľadáme konvexný obal týchto priamok.

<figure>
    <img src=""obrazky/prikl7/imgs/convex_hull.png"" width=""100%""/>
    <figcaption>
        <p>Na obrázku vidíme 10 lineárnych funkcíi.
        Ich spodný konvexný obal je označený prerušovanou čiernou čiarou.
        Niektoré (šedé) priamky nie sú súčasťou konvexného obalu.
        Každá priamka ktorá je súčasťou je ňou iba na jednom súvislom intervale.</p>
    </figcaption>
</figure>

Hľadanie konvexného obalu priamok je podobné hľadaniu konvexného obalu bodov. Priamky si utriedime podľa ich smernice a potom ich prechádzame od najväčšej po najmenšiu (teda budeme tvoriť _KO_ zľava doprava), pričom si udržiavame doteraz nájdený _KO_. Každú priamku sa pokúsime pridať do _KO_. Môžu nastať dve situácie – buď nová priamka nepatrí do _KO_ alebo patrí.

V prípade, že nová priamka $f\_{\\mathrm{nová}}$ patrí do _KO_ tak existuje nejaký najľavejší bod, ktorý patrí aj tejto priamke aj _KO_ – teda to bude priesečník $f\_{\\mathrm{nová}}$ a niektorej doterajšej priamky $f\_{\\mathrm{hľadaná}}$ z _KO_. Otestujme, či posledná priamka _KO_ $f\_{\\mathrm{posledná}}$ je $f\_{\\mathrm{hľadaná}}$. Ak je priesečník priamok $f\_{\\mathrm{nová}}$ a $f\_{\\mathrm{posledná}}$ ľavší než priesečník priamok $f\_{\\mathrm{posledná}}$ a $f\_{\\mathrm{predposledná}}$, tak $f\_{\\mathrm{posledná}}$ nie je $f\_{\\mathrm{hľadaná}}$ a dokonca $f\_{\\mathrm{posledná}}$ nie je ani súčasťou _KO_. V takom prípade ju odstránime a pokračujeme v hľadaní najľavejšieho bodu.

<figure>
    <img src=""obrazky/prikl7/imgs/convex_hull_decision.png"" width=""100%""/>
    <figcaption>
        <p>Nech červená priamka je $f_{predposledná}$,
        zelená je $f_{posledná}$ a modrá je $f_{nová}$.
        Potom podľa toho, či je $B$ naľavo alebo napravo
        od $A$ vieme povedať či $f_{posledná}$ patrí do _KO_.</p>
    </figcaption>
</figure>

Inak povedané: Tým, že sa na priamky pozeráme v poradí s klesajúcou smernicou platí, že najnovšia priamka je vždy lepšia ako nejaký (potenciálne nulový) počet priamok na konci _KO_. Teda porovnávame novú priamku s poslednou priamkou _KO_ a odstraňujeme túto poslednú priamku pokým je horšia ako nová. Ošetrenie rovnobežných priamok ponechávame na čitateľa.

Časová zložitosť je $O(N\\log(N))$ a pamäťová zložitosť je $O(N)$, kde $N$ je počet priamok. Viac si o konvexnom obale môžete prečítať v [kuchárke](https://www.ksp.sk/kucharka/konvexny_obal).

### Dôsledok

S nájdeným konvexným obalom potom pre ľubovoľné $H_i$ vieme nájsť najlepšie $(M\_{2,j}, M\_{2,j})$ binárnym vyhľadávaním. V prípade, že sa na jednotlivé $H_i$ budeme pýtať v utriedenom poradí ani nemusíme binárne vyhľadávať, ale len prechádzať postupne priamky _KO_. Tento prístup sa volá _Convex Hull Optimization/Trick_.

Pamäťová zložitosť je $O(2^{N/2})$ a časová zložitosť je $O(2^{N/2}\\times\\log(2^{N/2})) = O(N\\times 2^{N/2})$ (logaritmus pochádza z triedenia v hľadaní _KO_ a triedenia $H_i$ alebo binárneho vyhľadávania). Oproti bruteforce teda úspešne zvládame približne dvakrát väčšie vstupy. Pre aktuálne obmedzenia toto však nie je dostatočne rýchle riešenie. Na iných vstupoch (ktoré by mali napríklad väčšie hodnoty gramov) by toto bol dobrý prístup. Tento prístup zvláda prejsť až tri sady, ale v hodnotení popisov vie takéto riešenie získať plný počet.

## Vzorové riešenie

Čo ďalšie by sme si mohli všimnúť zo zadania? Gramáže kartičiek sú nanajvýš $10^4$ a spolu s malým $N$ teda aj súčet gramáží bude malé číslo.

Ako sme si už povedali, pre zvolené určenie typov kartičiek je výsledok závislý iba od súčinu `%`-kartičiek ($=k$) a súčtu `g`-kartičiek ($=m$). Preto ak by sme mali pevne určený nejaký súčin $k$, našou snahou je maximalizovať súčet $m$. Naopak, ak by sme mali pevne určený nejaký súčet $m$, našou snahou je dosiahnuť minimálny súčin $k$.

A my vieme, že rôznych súčtov $m$ je málo. Ak pre každé možné $m$ nájdeme minimálne $k$, tak sme našli riešenie. Naskytá sa nám celkom štandardné riešenie dynamickým programovaním – stav je určený počtom kartičiek ktorým sme už určili typ a súčtom $m$ týchto kartičiek. Pre každý stav si pamätáme minimálny súčin $k$ pre zvyšné kartičky. V každom stave sa do ďalšieho stavu dostaneme určením typu ďalšej kartičky. Teda:

```
dp[i+1][m] = min(dp[i+1][m], dp[i][m] * k_i) # ak použijeme % kartičku
dp[i+1][m+m_i] = min(dp[i+1][m+m_i], dp[i][m]) # ak použijeme g kartičku
```

### Poznámky k implementácii

Nakoniec, aby sme vedeli vypísať riešenie, musíme vedieť z tabuľky nejako vyčítať ako sme určovali kartičky. Toto si vieme v tabuľke buď priamo pamätať, alebo si to vieme v prípade tejto úlohy jednoducho spätne zistiť (keďže existujú iba dve možnosti), čo nám ušetrí pamäť a kúsok urýchli program (nie asymptoticky, ale iba konštantne).

Vieme ešte riešenie urýchliť? Mohli by sme veľkosť tabuľky ďalej zmenšiť tým, že jednotlivé riadky budú mať veľkosť iba doterajšieho súčtu gramáží kartičiek. Tomuto ďalej pomôžeme ak si kartičky na začiatku utriedime podľa gramáže, keďže v tomto prípade bude veľkosť tabuľky minimálna. Znova, nejde o asymptotické zlepšenie, ale vieme takto reálne program zrýchliť dvojnásobne.

Dynamiku neodporúčame kódiť v Pythone, keďže priamy prepis C++ do Pythonu je často krát 100x pomalší. Dodatočnými optimalizáciami vieme získať násobne zrýchlenia, ale môžeme byť šťastný keď sa dostaneme na 30x spomalenie. Ako malý tip povieme, že je oveľa rýchlejšie napísať `if x < y: y = x` než `y = min(y, x)`.

V úlohách kde násobíme veľa desatinných čísel a záleží nám na presnosti sa väčšinou oplatí počítať si súčet logaritmov namiesto priameho súčinu. V tomto prípade to však nie je nutné, keďže násobíme maximálne $40$ čísel, čo zvládneme presne uložiť do dostatočne veľkého dátového typu.

### Zložitosť

Časová a pamäťová zložitosť je $O(N \\times \\sum A_i) = O(N^2 \\times MaxA)$. Vzorové riešenie v C++ zvláda vstupy aj pre $N=100$.

Často upozorňujeme, že pamäťová zložitosť sa pri úlohách s dynamickým programovaním dá znížiť na veľkosť menšiu ako celkový počet stavov. Väčšinou to dosiahneme tak, že si pamätáme iba posledné dva riadky tabuľky. V tomto prípade si však v tabuľke okrem najlepšieho výsledku implicitne pamätáme aj cestu a teda ich nemôžeme zabudnúť! Alebo? V skutočnosti to je možné a dokonca bez toho aby sa nám zhoršila časová zložitosť. Viac informácií nájdete v [tomto codeforces tutoriáli](https://codeforces.com/blog/entry/43256) v poslednom odseku sekcie _Store results only for two layers of DP state domain_.

Uvedomme si, že všetky tri uvedené riešenie prehľadajú všetkých $2^N$ možností. Prvý prístup naivne, druhý šikovne a tretí iba tak, že nevykonáva žiadnu robotu dva krát – dynamické programovanie pracuje iba na stavoch, ktoré sú relevantné a pre každý takýto stav si pamätá iba jeden výsledok. Toto je dôvod, prečo tieto riešenia fungujú, zatiaľ čo heuristiky a greedy riešenia nie.
",9
166c137c35272f84,ksp,"# Odďaľovanie roboty

Bob by mal pracovať na dizertačnej práci, ale veľmi sa mu nechce. Keďže do ukončenia PhD _zostáva ešte čas_, Bob preferuje iné činnosti ako napríklad hranie frisbee.

Každý Bobov rok vyzerá tak, že mu školiteľ dá $n$ rôznych problémov, ktoré by mal vyriešiť v rámci dizertačnej práce. Aby školiteľ Boba motivoval,^[inak povedané, aby zabránil jeho úplnému flákaniu sa] každá úloha má svoj termín, dokedy ju má urobiť. Bob sa ale statočne bráni a má celkom jednoduchú stratégiu. Najprv sa chce čo najdlhšie flákať (venovať sa iným činnostiam ako dizertačke), a až potom začne robiť na úlohách.

Navyše sa mu podarilo zistiť, že jeho školiteľ je príliš mäkký. Bob si tak môže beztrestne dovoliť nespraviť najviac $k$ úloh. Ako najdlhšie sa môže Bob zo začiatku flákať pri takejto stratégii?

## Úloha

Máme zadaných $n$ úloh. Pre každú úlohu vieme, koľko času Bob potrebuje na to, aby ju splnil -- $t_i$ a dokedy ju má splniť -- deadline $d_i$. Vašou úlohou je zistiť, ako najdlhšie sa môže na začiatku flákať, pričom si môže dovoliť nespraviť najviac $k$ úloh. Bob vie pracovať v jednom čase najviac na jednej úlohe. Keď Bob začne pracovať na úlohe, celú ju spraví naraz.

## Formát vstupu

V prvom riadku sú dve celé čísla oddelené medzerou $1 \\leq n \\leq 3000$ a $0 \\leq k < n$. V ďalších $n$ riadkoch sa nachádzajú dvojice celých čísel oddelených medzerou $1 \\leq d_i \\leq 10^9$ a $1 \\leq t_i \\leq \\min(d_i, 10^6)$, pričom $d_i$ je deadline do ktorého treba splniť $i$-tu úlohu a na jej dokončenie treba $t_i$ času.

V jednej sade vstupov zo štyroch bude platiť $k = 0$.

## Formát výstupu

Vypíšte jedno nezáporné celé číslo -- ako dlho sa môže Bob na začiatku flákať, aby nestihol najviac $k$ termínov. Bob sa chce najskôr čo najdlhšie flákať, a potom, až keď je to nevyhnutné, začne robiť. Ak sa úloha nedá splniť, vypíšte `Neda sa to stihnut.`

## Príklad

```vstup
2 0
10 5
7 1
```

```vystup
4
```

_Bob začne s druhým termínom v čase 4. Dokončí ho v čase 5, a potom pracuje na prvom, ktorý dokončí v čase 10._

```vstup
3 1
10 3
8 2
6 2
```

```vystup
5
```

_Bob si povie, že zmešká tretí termín a začne druhým v čase 5 a dokončí ho v čase 7. Potom začne robiť na prvej úlohe. Môžete si všimnúť, že ak by Bob nespravil prvú úlohu, mal by celkovo viac voľného času, lenže jemu ide len o to, aby prácu čo najviac oddialil._

```vstup
2 0
10 10
2 2
```

```vystup
Neda sa to stihnut.
```
","# Odďaľovanie roboty

Najprv si ukážeme, ako sa dal riešiť ľahší problém, kedy chceme stihnúť všetky úlohy. Potom si ukážeme, ako sa dal riešiť zložitejší problém, kedy môžeme nejaké úlohy vynechať.

## Ľahšia úloha -- riešenie jednoduchou myšlienkou

Intuitívne by sa mohlo zdať, že keď chceme maximalizovať čas flákania sa na začiatku, tak chceme riešiť úlohy čo najneskôr, teda čo najbližšie k ich deadlajnu. Ináč povedané, ak má úloha $i$ deadline $d_i$ a jej splnenie trvá $t_i$ času, tak by sme ju ideálne chceli začať plniť v čase $d_i - t_i$.

Bohužiaľ toto sa nedá vždy urobiť. Napríklad, ak máme úlohu, ktorú treba splniť do času $6$ a jej plnenie trvá $3$ jednotky času a úlohu, ktorej deadline je $5$ a máme na ňu tiež $3$ jednotky času. Podľa vyššie spomenutej stratégie chceme prvú úlohu začať v čase $3$ a skončiť v čase $6$ a druhú úlohu chceme začať v čase $2$ a skončiť v čase $5$. To je ale problém, lebo nevieme robiť na dvoch úlohách naraz.

Nevieme teda obe úlohy splniť tesne pred deadlajnom. Máme na výber z dvoch možností: buď splníme tesne pred deadlajnom prvú, alebo druhú úlohu. Náš cieľ je flákať sa čo najdlhšie na začiatku, takže bude lepšie, ak splníme tesne pred deadlajnom úlohu, ktorá má neskorší deadline. Čiže druhú úlohu začneme plniť v čase $0$, skončíme v čase $3$, a potom robíme prvú úlohu, ktorú dokončíme v čase $6$ -- tesne pred deadlajnom.

Ak si to zosumarizujeme, tak sme vlastne urobili dve pozorovania. Prvé pozorovanie je, že chceme riešiť úlohu čo najbližšie k jej deadlajnu. Druhé pozorovanie je, že občas sa to nedá, keď sa intervaly plnenia úloh prekrývajú. Tento prípad vieme riešiť tak, že úlohu, ktorej deadline je neskoršie, budeme končiť presne v čase deadlajnu a intervaly pre ostatné úlohy trocha poposúvame doľava (na časovej osi).

## Ľahšia úloha -- algoritmus

Táto stratégia sa dá zovšeobecniť do algoritmu. Najprv utriedime všetky úlohy podľa deadlajnu zostupne, a potom prechádzame cez takto utriedené úlohy. Počas tohto prechodu si udržiavame čas $x$ -- kedy sme začali plniť poslednú úlohu v našom poradí. Zistime, kedy začneme plniť $i$-tu úlohu v našom poradí:

- Ak $d_i \\geq x$, úlohu nemôžeme začať plniť tesne pred deadlajnom, lebo v čase $d_i$ už riešime jednu z nasledujúcich úloh. Začneme preto túto úlohu plniť už v čase $x - t_i$.
- Inak začneme úlohu plniť v čase $d_i - t_i$ (tesne pred deadlajnom).

Potom nastavíme $x$ na novú hodnotu a pokračujeme ďalšou úlohou. To, čo nám na záver zostane v premennej $x$ je náš výsledok -- čas, kedy sme začali plniť prvú úlohu.

Časová zložitosť tohto riešenia je $O(n \\log n)$, kde $n$ je počet úloh. Triedenie je najpomalšia operácia. Zvyšok je iba prechod poľom.

Pamäťová zložitosť je $O(n)$, lebo si musíme pamätať všetky úlohy.

## Ľahšia úloha -- dôkaz správnosti

Pri takýchto greedy algoritmoch je dôležité si zdôvodniť, prečo náš algoritmus skutočne nájde optimálne riešenie.

Zoberme si **ľubovoľné poradie úloh, ktoré dáva najlepšie riešenie**, teda nám dovolí flákať sa na začiatku najdlhšie a porovnajme toto riešenie **s riešením, ktoré vytvorí náš algoritmus**. Chceme ukázať, že naše riešenie nám dovolí sa flákať na začiatku aspoň tak dlho ako optimálne riešenie.

Zoberme si z optimálnej postupnosti úlohu $i$, ktorá má deadline najneskôr a presuňme ju na koniec postupnosti úloh. Takto dosiahneme to, že túto úlohu budeme končiť presne v čase jej deadlajnu. Ak sme v optimálnom poradí v čase od $d_i - t_i$ riešili inú úlohu, musíme posunúť interval jej riešenia doľava (na časovej osi) a takisto aj intervaly ostatných predošlých úloh.

Dôležité je všimnúť si, že intervaly neposunieme viac doľava než bol pôvodný začiatok intervalu riešenia úlohy $i$. Tým, že sme presunuli úlohu $i$ na koniec sme totiž využili časový interval medzi deadlajnom predposlednej úlohy a deadlajnom poslednej úlohy, $i$. Vďaka tomu nemusíme posúvať intervaly, pre úlohy ktoré sme v optimálnom riešení začali riešiť pred $i$, a teda touto operáciou určite nezhoršíme optimálne riešenie.

Teraz si zoberme úlohu s druhým najneskorším deadlajnom a presuňme ju na predposlednú pozíciu. Znova platia podobné argumenty, že si týmto nezhoršíme naše riešenie. Tento postup budeme opakovať pre všetky intervaly. Takto dostaneme poradie úloh, v akom by ich vykonával náš algoritmus, čiže vlastne vieme prerobiť ľubovoľné optimálne riešenie na naše riešenie a nezhoršiť ho. To znamená, že naše riešenie musí byť jedno z optimálnych.

## Pôvodná úloha

Teraz sa pozrime na úlohu pre $k>0$. V tomto prípade už nejde riešiť túto úlohu greedy spôsobom. Ak by sme napríklad použili stratégiu, ktorou sme riešili prípad $k=0$, tak sa nám nie vždy musí oplatiť zobrať úlohu s najneskorším deadlajnom. Ak práca na poslednej úlohe trvá veľmi dlho, oplatí sa nám ju vynechať a namiesto nej splniť ostatné úlohy.

Greedy algoritmy sa vyznačujú tým, že sú veľmi rýchle. Keď si poriadne pozrieme obmedzenia v zadaní úlohy, tak zistíme, že postačí aj pomalšie riešenie. Na riešenie použijeme techniku zvanú dynamické programovanie. Pri dynamickom programovaní si najprv jednoducho definujeme problém, a potom sa pomocou menších podproblémov snažíme vyskladať ten väčší. Najprv riešime malé problémy a z nich skladáme riešenia pre väčšie a väčšie problémy.

Náš problém je definovaný postupnosťou úloh a počtom úloh, ktoré chceme vynechať. Ako podproblém si teda definujeme, že chceme zistiť, ako najdlhšie sa môžeme flákať, ak chceme z prvých $i$ úloh vynechať najviac $j$. Pričom stále chceme spracúvať úlohy v takom istom poradí, ako sme to robili v riešení pre ľahší problém -- od najneskoršieho deadlajnu po najskorší. Riešenie pre podproblémy si budeme ukladať do tabuľky $P$, aby sme ich nemuseli rátať viackrát. Pričom na **$P[i][j]$ je uložené číslo, ako najdlhšie sa môžeme flákať ak chceme vynechať najviac $j$ úloh z prvých $i$**.

Začnime triviálnym prípadom, keď chceme z prvých nula úloh nestihnúť najviac $j$ úloh. V takom prípade sa môžeme nekonečne dlho flákať, takže do prvého riadku dáme samé nekonečná.

Zoberme si prípad, keď $i>0$. V takom prípade máme dve možnosti. V optimálnom riešení $P[i][j]$ sa nachádza alebo nenachádza úloha $i$:

- Ak sa v riešení nenachádza úloha $i$, tak je toto riešenie zhodné s riešením pre $P[i-1][j-1]$. Čiže v takom prípade sa môžeme flákať $P[i-1][j-1]$ času.

- Ak sa v tomto riešení nachádza úloha $i$, tak odobratím $i$ dostaneme optimálne riešenie pre podúlohu $P[i-1][j]$. Toto sa dá jednoducho dokázať sporom. Ak by to nebolo optimálne riešenie, tak potom odobratím úlohy $i$ dostaneme lepšie riešenie pre podproblém $P[i-1][j]$, čo je spor.

  Otázkou ešte je, kedy začneme (a skončíme) plniť úlohu $i$. Buď ju skončíme skončíme v čase deadlajnu, alebo v čase, keď začneme prvú úlohu z riešenia $P[i-1][j]$. Ak je deadline pred začiatkom prvej úlohy v riešení pre $P[i-1][j]$, tak musíme úlohu $i$ začať v čase $d_i - t_i$. Ak už počas $d_i$ riešime jednu z neskorších úloh, začneme $i$ riešiť v čase $P[i-1][j] - t_i$ a skončíme v čase $P[i-1][j]$.

Z oboch týchto možností si vyberieme tú, ktorá nám dovolí sa najviac flákať. $$P[i][j] = \\max(P[i-1][j-1],\\min(d_i-t_i,P[i-1][j] - t_i))$$

Túto tabuľku si počítame po riadkoch a finálny výsledok sa nachádza na políčku $P[N][K]$ -- ako najdlhšie sa môžeme flákať ak chceme vynechať najviac $K$ úloh z prvých $N$.

Časová zložitosť tohto riešenia je $O(nk)$ a pamäťová tiež. Môžeme si všimnúť, že na vypočítanie nového riadku v tabuľke potrebujeme iba predchádzajúci riadok, takže vieme pamäťovú zložitosť vylepšiť na $O(k)$ tým, že si budeme pamätať iba posledné dva riadky tabuľky.
",8
764729ba739fcae7,ksp,"﻿# Kto Spasí Pochúťku

Timka je veľká kuchárka a na 40. výročie KSP napiekla tortu. Lenže, naskytol sa problém: Timka by chcela tortu doniesť do T2^[KSP miestnosť na matfyze], lenže sa tam sama nevie práve dostať. Chcela by preto tortu poslať do T2 cez iných vedúcich. Problém však je, že keď sa vedúci dostane ku torte, okoštuje ju (""veď to si nikto nevšimne"").

Preto by Timka chcela poslať tortu do T2 cez čo najmenej vedúcich.

Problém však je, že vedúci sú leniví a nechce sa im chodiť ďaleko. Keď si dvaja vedúci idú vymeniť tortu, stretnú sa presne v polceste, -- keby jeden musel ísť dlhšie ako druhý, bolo by to nespravodlivé!

Vedúci môžu, ale nemusia byť ochotní sa prejsť trochu dlhšie do T2^[Napríklad, môžu si tam ľahnúť na gauč. Ale ak tam prídu, prídu o tortu...], podľa toho ako priateľská im práve pripadá.

Pomôžte Timke prepraviť tortu do T2 cez čo najmenej vedúcich!

## Úloha

Máme $N$ vedúcich (Timka je jedna z nich), ktorých si vieme predstaviť, že sa nachádzajú na priamke. Na tej istej priamke sa nachádza aj T2, povedzme, že na pozícii $0$.

$i$-ty vedúci je na prepravu torty ochotný prejsť $d_i$ metrov.

Navyše, T2 má *priateľskosť* D.

Torta medzi vedúcimi putuje tak, že vedúci sa vždy stretnú v *polceste*, torta zmení (dočasného) majiteľa a ten s ňou odkráča späť, odkiaľ prišiel. Dvaja vedúci si tortu vedia vymeniť len vtedy, ak sú obaja ochotní prejsť vzdialenosť do polcesty medzi nimi.

Vedúci sú (niekedy) ochotní prejsť sa viac ako $d_i$ metrov do T2. Všetko záleží na tom, ako *priateľská* im T2 práve pripadá. Tento faktor je pre všetkých rovnaký, vyjadrený číslom $D$. $i$-ty vedúci je ochotný zaniesť tortu do T2, ak je od nej vzdialený najviac $2\\min(d_i,D)$ metrov.

Rozhodnite, či vie Timka dostať tortu do T2 a ak áno, koľko najmenej vedúcich musí tortu prenášať.

## Formát vstupu

V prvom riadku vstupu sú dve čísla oddelené medzerou: $N$ ($1 \\leq N \\leq 2\\times 10^5$) -- počet vedúcich a $1\\leq D \\leq 10^8$ -- priateľskosť T2.

Na druhom riadku sú medzerami oddelené pozície vedúcich (v metroch), všetky v absolútnej hodnote nepresahujúce $10^9$. Všetky pozície sú navzájom rôzne a nie sú $0$.

Na poslednom riadku sú medzerami oddelené $d_1,\\dots, d_N$ -- vzdialenosti (v metroch), ktoré sú vedúci ochotní s tortou prejsť. Všetky sú medzi $1$ a $10^8$.

Timka je vedúca číslo $1$ (prvá vedúca uvedená vo vstupe). T2 je na pozícii $0$.

Úloha má štyri sady. V prvých dvoch platí, že $N \\leq 1000$. Navyše, v tretej sade platí, že vzdialenosti, ktoré sú vedúci ochotní prejsť, sú malé -- $d_i \\leq 50$.

## Formát výstupu

Ak Timka nevie dostať tortu do T2, vypíšte ""Torta nebude"".

Inak, vypíšte jedno celé číslo: koľko najmenej vedúcich (vrátane Timky) treba, aby sa torta dostala do T2?

## Príklady

```vstup
9 1
14 -2 2 4 6 8 10 12 16
1 5 1 1 1 5 1 1 4
```

```vystup
4
```

*Timka vie najlepšie tortu poslať deviatemu vedúcemu (do polcesty to majú obaja $1$ meter). Ten by mal poslať tortu vedúcej na pozícii 8 (do polcesty to majú obaja $4$ metre). Tá ju ešte nevie poslať sama do T2 (do T2 sa tu nikomu nechce, pokiaľ nie je ozaj blízko), tak pošle tortu vedúcemu na pozícii $-2$, ktorý ju už do T2 vie doniesť. Torta prejde cez $4$ vedúcich (vrátane Timky)*

```vstup
2 5
5 100
2 2
```

```vystup
Torta nebude
```

*V tomto prípade je T2 pre Timku prílíš ďaleko, lenže jediná ďalšia vedúca je ešte ďalej.*
","# Kto Spasí Pochúťku

Ako prvé, poďme si úlohu trochu učesať. Na prvé prečítanie úloha môže vyzerať trochu desivo, ale na druhé prečítanie už skúsenejší riešiteľ všimne, že úloha je o hľadaní najkratšej cesty v grafe.

Vrcholy v tomto prípade sú vedúci a T2, a medzi vedúcimi `A` a `B` je hrana, ak si vedia medzi sebou premeniť tortu a hrana medzi vedúcim a T2 je ak vedúci vie doniesť tortu do T2. V tomto grafe je následne úloha nájsť najkratšiu cestu medzi Timkou a T2, alebo rozhodnúť, že žiadna cesta neexistuje.

Ako na to?

## Máme celý graf

Riešenie, ktoré nám prirodzene napadne je vygenerovať si celý graf, a následne na ňom zbehnúť náš obľúbený rýchly algoritmus na hľadanie najkratších ciest v grafoch -- BFS.

Ako vygenerujeme graf? Pre každú dvojicu vedúcich stačí skontrolovať, či minimum ich dosahov je aspoň vzdiaľenosť do polcesty medzi nimi. Takto vieme postaviť graf v čase $O(N^2)$ a následne v lineárnom čase vo veľkosti grafu spustiť BFS. Graf však môže mať tiež veľkosť najviac $O(N^2)$ -- v prípade, že sú všetci vedúci ochotný ísť ďaleko.

Ak niečo ďalej nezlepšíme, dostaneme kvadratické riešenie, ktoré nám dá 4 body. Toto riešenie vieme implementovať aj v lineárnej pamäti (napríklad si graf konštruujeme postupne, a nepamätáme si všetky hrany naraz).

## Malé grafy

BFS vieme robiť v čase lineárnom od veľkosti grafu. Ak je graf reprezentovaný v zadaní *malý*, keby sme ho vedeli rýchlo zkonštruovať, vieme ho aj rýchlo prehľadať.

Predstavme si, že máme vedúcich v zadaní utriedených podľa pozície. $i$-ty vedúci, stojaci na pozícii $x_i$, ochotný prejsť $d_i$ si vie tortu potenciálne vymeniť iba s vedúcimi na pozíciách medzi $x_i - 2d_i$ a $x_i + 2d_i$.

Mohli by sme si preto napríklad spraviť nasledovné: utrieďme si vedúcich podľa pozície. Keď sa v BFS dostaneme k vedúcemu číslo $i$, začneme si pole prechádzať (do oboch strán) kým neprídeme k vedúcemu nachádzajúcemu sa mimo intervalu, kde $i$-ty vedúci vie potenciálne tortu vymeniť. Pre každého vedúceho v intervale si už vieme overiť existenciu hrany v konštantnom čase.

Takto $i$-teho vedúceho v BFS spracujeme v čase $O(d_i)$, takže dokopy dostaneme časovú zložitosť $O(n \\max_i d_i+ n\\log n)$ ($O(n\\log n)$ je preto, lebo musíme triediť). Pamäťovú zložitosť vieme stále mať lineárnu, keďže zostrojený graf nedržíme v pamäti. Takéto riešenie nám dá $6$ bodov.

## Kde je to pomalé?

Problém je, že vo všeobecnosti môžu byť jednotlivé $d_i$ veľké, takže aj počet hrán v grafe príliš veľký, aby sme sa na ne pozreli. Všimnime si, že keď už v BFS pridáme vrchol do fronty (alebo už spracujeme), tak keď sa pri spracovávaní iných vrcholov pozeráme na hrany idúce do tohto vrcholu, je to zbytočné, pretože tento vrchol už druhý krát nebudeme pridávať do fronty (a teda druhý krát spracovávať).

Mohli by sme si vrchol z grafu po jeho prvotnom pridaní do grafu vymazať aby sme sa tomuto vyhli? Na prvý pohľad to neznie sľubne, keďže nevieme rozumne efektívne vymazávať elementy zo stredu poľa.

Problém je ale aj to, že keby sme aj vedeli, stále sa nám môže stať, že väčšina vedúcich ku ktorým je $i$-ty vedúci nablízku sú príliš leniví aby si ním vymenili tortu. Takže by sme potrebovali vymyslieť spôsob akým sa nepozerať na príliš veľa neexistujúcich hrán.

Mohli by sme to vyriešiť použitím vhodnej dátovej štruktúry?

## Meníme pole za intervaláč

Najskôr sa pozrime na druhý problém. Kedy si dvaja vedúci $i$ a $j$ vedia vymeniť tortu? Keď je rozdiel ich vzdialeností najviac $2\\min(d_i, d_j)$, inak povedané (BUNV $x_i < x_j$) ak $x_j \\leq x_i + 2d_i$ a zároveň $x_i \\geq x_j - 2d_j$.

Predstavme si, že by sme vedeli spraviť nasledovné: pre všetkých vedúcich stojacich medzi $x_i$ a $x_i +2d_i$, pozrime sa na takého vedúceho $j$ pre ktorého je $x_j - 2d_j$ čo *najmenšie*. Ak $x_j - 2d_j > x_i$, potom ani žiadny ostatní vedúci v napravo od $i$-tého vedúceho si s ním môžu vymeniť tortu (ak sú príliš ďaleko od $i$-teho vedúceho, ten im nie je ochotný predať tortu; všetci vedúci v dosahu $i$-teho vedúceho ale majú $x\_{j^\\prime}-2d\_{j^\\prime} > x_j - 2d_j > x_j$, teda nie sú ochotní chodiť až ku vedúcemu $i$). Podobne vieme pre vedúcich naľavo od vedúceho $i$ hľadať zase blízkeho vedúceho $j$ s najvyšším $x_j + 2d_j$.

Hľadanie maxím a miním v intervale znie ako práca pre intervalový strom^\[pozri [článok o intervalovom strome v kuchárke KSP](https://www.ksp.sk/kucharka/intervalovy_strom/) \].

Ten má aj výhodu, že v ňom vieme rýchlo (v $O(\\log n)$) updatovať dáta.

Mohli by sme preto spraviť nasledovné: majme dva intervalové stromy. Minimový s hodnotami $x_j - 2d_j$, a maximový s hodnotami $x_j + 2d_j$.

Vždy keď spracovávame vedúceho $i$ v BFS, pozrieme sa na vedúcich v dosiahnuteľnom intervale naľavo v maximovom intervaláči. Nech $j$ je iný vedúci s najvyššou hodnotou $x_j + 2d_j$ nachádzajúci sa na pozíciach medzi $x_i - 2d_i$ a $x_i$. Potom, ak si s ním nevieme predať tortu, skončili sme -- žiadny iný dosiahnuteľný vedúci napravo od $i$-teho vedúceho si s ním tortu nevymení. Ak sme ale naďabili na hranu, potom môžme pokračovať.

Aby sme sa ale vyhli spracovaniu nájdeného vedúceho neskôr v BFS (ako sme si všimli hore, to robí problémy), *vymažeme ho zo stromov*. Vymazať pozíciu v strede intervalového stromu na prvý pohľad znie ako pomalé, avšak namiesto vymazania môžeme nastaviť pozíciu vedúcemu v minimovom strome na $-\\infty$ a v maximovom strome na $+\\infty$ (kde nekonečno je nejaké dostatočne veľké číslo), takže keby sme ho našli ako minimum/maximum tak hľadania vždy ukončíme (keďže to znamená, že žiadny nespracovaný/nevidený vedúci intervale nie je).

Keď $j$-teho vedúceho týmto spôsobom vyhodíme zo stromu, môžme pokračovať hľadanie vedúcich ktorým možno odovzdať tortu, až kým nám buď dôjdu vedúci, alebo všetci vedúci v intervale sú príliš lenivý vymeniť si tortu s $i$-tym vedúcim.

Následne toto isté opakujeme pre dosiahnuteľných vedúcich napravo od $i$-teho, pomocou minimového intervaláča.

Každého vedúceho spracujeme najviac raz, a dokopy sa cez intervaláče pozrieme na najviac $O(n)$ možných hrán (najviac $n$ hrán ktorými sa v BFS vyberieme, a pre každý vrchol sa pozrieme na najviac dve počet neexistujúce hrany resp. hrany do už navštíveného vrchola). Každá otázka, alebo update do intervaláča má časovú zložitosť $O(\\log n)$, takže časová zložitosť tohto algoritmu je $O(n\\log n)$. Intervaláč vieme postaviť v pamäti $O(n)$, takže aj celý algoritmus vieme implementovať v lineárnej pamäti.

## Technické detaily

Zabudli sme spomenúť dve veci: T2, a ako sa v intervaláči pozrieť na interval vedúcich na nejakom intervale pozícií.

Začnime tým jednoduchším: T2. Potom, ako sme spočítali vzdialenosti od Timky pre všetkých vedúcich vieme spočítať minimálnu vzdialenosť do T2 jednoducho: v konštantnom čae sa pre každého vedúceho spýtame, či vie dostiahnuť T2, a to tak, že nájdeme vedúceho s minimálnou vzdialenosťou od Timky ktorý vie tortu dostať do T2.

Čo s druhým problémom? Jedno z riešení je použiť kompresiu súradníc: dať v intervalom strome vedúcich v utriedenom poradí podľa ich pozície, a pomocou utriedenej množiny (kde si uskladníme dvojice `(pozícia, relatívna pozícia)`) zistiť ktoré relatívne pozície pripadajú ku danému intervalu pozícií.

Druhé riešenie je mať súradnice priamo v intervaláčoch: majme vedúcich vložených do intervaláča podľa ich utriedených pozícií, ale priamo v intervaláči si zapamätajme aj súradnice. Potom v každom vrchole si môžeme navyše pamätať minimálnu a maximálnu pozíciu v listoch patriacich pod vrchol. Takto sa môžeme intervaláč pýtať priamo na interval pozícií, bez toho aby sme museli riešiť navyše kompresiu súradníc.

Žiadne z týchto dvoch riešení nezhoršuje časovú zložitosť celkového riešenia.
",9
c608ee2b7d425e4f,ksp,"# Ováľané mince

V meste hovniválov sa deje veľká udalosť -- ide sa stavať obrovský palác z trusových gulôčok. Stavia sa na počesť Hovnivála I. , ktorý zjednotil všetky kmene hovniválov do jednej veľkej ríše a priniesol medzi nich pokoj a mier. Keď sa zhromažďovali gulôčky, bolo jasné, že ho nebude také ľahké postaviť. Začal sa konkurz na stavbu paláca. Tento konkurz vyhrala firma, kde pracujú Janko a Ferko, a práve oni dostali poverenie postaviť tento palác. Ako roky plynuli, stavbári čakali už len na jedno -- peniaze za túto neľahkú stavbu. A ten čas nastal dnes.

Kto vykonal viac práce? Janko či Ferko? Boli ste poverení vyplatiť im ich zaslúžené peniaze. Ale pozor! Nechcete, aby sa ich výplaty veľmi odlišovali, inak sa pobijú!

## Úloha

Máme $n$ mincí s hodnotami $1$ až $n$. Keďže chceme, aby sa nepobili, musíme rozdeliť tieto mince čo najviac rovnomerne obidvom stavbárom. Každú mincu máte k dispozícii len raz. Pochopiteľne ju musíte dať len jednému stavbárovi. Vašou úlohou je nájsť čo najmenší rozdiel výplat Janka a Ferka.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $t, 1\\leq t \\leq 1000$, počet výplat, ktoré chcete rozdeliť. Na každom z ďalších $t$ riadkov sa nachádzajú dve medzerou oddelené čísla $n_i$ a $p$, kde číslo $n_i$ znamená počet mincí, ktoré máme pre danú výplatu (mince majú teda hodnoty $1, 2, ... , n_i$), a $p \\in {0,1}$. Platí, že $1 \\leq n_i \\leq 3000$

## Formát výstupu

Ak sa $p=0$, na výstup vypíšte pre danú výplatu jedno číslo na samostatnom riadku -- minimálny rozdiel výplat Janka a Ferka.

Ak sa $p=1$, na výstup pre danú výplatu okrem jedného čísla na samostatnom riadku -- minimálneho rozdielu výplat, vypíšte aj príklad na nejaké rozdelenie mincí, kde je rozdiel výplat minimálny. Pre každú výplatu okrem minimálneho rozdielu vypíšte ďalšie dva riadky.

Prvý z nich na začiatku obsahuje číslo $j$ -- počet mincí, ktoré dostane Janko. V tom istom riadku nasleduje medzera a $j$ medzerou oddelených čísiel -- hodnoty Jankových mincí.

Druhý z nich na začiatku obsahuje číslo $f$ -- počet mincí, ktoré dostane Ferko. V tom istom riadku nasleduje medzera a $f$ medzerou oddelených čísel -- hodnoty Ferkových mincí.

## Obmedzenia

V prvej štvrtine sád platí $p=0$.

## Poznámka

V posledných sadách je treba vypisovať pomerne veľa čísel, a v prípade, ak to robíte pomaly (a najmä v pomalom programovacom jazyku ako napr. Pythone), vám môže byť neakceptované riešenie, ktoré má vzorovú časovú zložitosť. Na vypisovanie poľa odporúčame namiesto:

použiť

## Príklad

```vstup
2
3 0
5 0
```

```vystup
0
1
```

*V prvom prípade máme mince hodnôt $1, 2, 3$. Medzi dvoch ľudí ich vieme rozdeliť tak, že prvý dostane mince $1$ a $2$ a druhý dostane mincu $3$. Rozdiel medzi súčtami ich mincí je teda $0$. V druhom prípade máme mince $1, 2, 3, 4, 5$. Tieto mince vieme najlepšie rozdeliť tak, že prvý dostane mince $1, 2, 5$ a druhý mince $3, 4$, teda rozdiel medzi súčtami ich mincí je 1.*

```vstup
2
3 1
5 1
```

```vystup
0
2 1 2
1 3
1
3 1 2 5
2 3 4
```

*Iný príklad na 5 mincí môže byť napríklad aj tak, že prvý človek dostane mince $1, 2, 4$ a druhý $3, 5$*
","# Ováľané mince

Skúsme si najprv rozdeliť rovnomerne nejaké čísla $a, a+1, ..., b$. Veľmi rýchlo si môžeme všimnúť, že ak berieme najväčšie a najmenšie, druhé najväčšie a druhé najmenšie, tak tieto dvojice majú vždy rovnaký súčet.

Bohužiaľ, nám to ešte nepovie, ako rozdeliť čísla, aby bol medzi nimi čo najmenší rozdiel. Povedzme si najprv, že kedy vieme mince $1,2, ..., n$ rozdeliť na rovnaké časti. Aby bolo možné rozdeliť mince rovnomerne, tak ich súčet musí byť párny, a teda v ňom musí byť párny počet nepárnych čísiel. To, či to v našej postupnosti platí, vieme šikovne zisťovať tak, že (počet čísel označme ako $n$), $n % 4 = 3$ alebo $n % 4 = 0$.

Ľahko si všimneme, že ak $n % 4 = 0$, tak mince vieme rovnomerne rozdeliť tak, že zoberieme dvojice $1$ a $n$, $2$ a $n-1$, ... . Takýchto dvojíc je párny počet, a teda ich vieme rozdeliť na dve rovnaké polovice.

V prípade ak $n % 4 = 3$, tak je to už trochu zložitejšie. Ak ale vieme, že $n+1$ mincí (teda $n % 4 = 0$) sa dá rozdeliť, tak toto sa líši len o $n+1$ a teda ak jednej strane zoberieme mincu/mince v hodnote $(n+1)/2$, tak budú obe polovice vyrovnané. (Dá sa to jednoduchšie predstaviť ak si to napíšete na papier.)

Čo ale v prípade, ak sa nedajú mince rozdeliť rovnomerne? Ak $n % 4 = 2$, tak máme vlastne oproti prípadu, ktorý vieme rovnomerne rozdeliť ($n % 4 = 0$), naviac čísla $n+1$ a $n+2$, a tieto čísla sa líšia len o $1$, a to je minimálny rozdiel, čo vieme dosiahnuť. (Nech robíme čo robíme, nepárny súčet na dve rovnaké polovice nerozdelíme.)

A ostáva posledný prípad, keď $n % 4 = 1$. Tento prípad je zase veľmi podobný prípadu keď $n % 4 = 3$, a rovnako tu máme naviac dve čísla, a rovnako je minimálny rozdiel $1$.

Keď už máme vypočítanú hodnotu, akú má dostať každý stavbár, teraz pokiaľ $p = 1$, tak musíme vypísať aj aké mince každý dostane.

Čísla vieme získavať buď tak, ako sme písali, teda po dvojiciach, alebo jednoduchšie, pažravo. Pažravo ich získame tak, že ideme od najväčších mincí, a počítame si súčet už zobraných mincí. Ak si danú mincu vieme zobrať (pripočítať k súčtu) bez toho, aby sme presiahli polovicu cekovej sumy, zoberieme ju.

Možno si kladiete otázku, či to takto pažravo môže fungovať. Odpoveď je, áno. Naše mince majú v súčte určite väčšiu hodnotu ako potrebujeme, a máme mince s každou hodnotou, ktorú by sme mohli potrebovať. Teda máme zaručené, že nech zmenšíme rozdiel medzi sumou, ktorú chceme získať a sumou, ktorú sme zatiaľ nazbierali, na ľubovoľnú hodnotu, tak určite bude existovať minca, ktorá sa nám do tohto rozdielu zmestí.

Čo sa týka časovej zložitosti, pokiaľ $p = 0$, tak časová zložitosť je $O(1)$, lebo odpoveď na jednu otázku vypočítame v konštantnom čase, vzorcom. V prípade, že $p = 1$, musíme dokopy vypísať $n$-prvkové pole, ktoré ale vieme získať v čase priamo úmernom od $n$, takže zložitosť je $O(n)$. Pamätať si nemusíme nič, pretože hodnoty poľa môžeme vypočítať vo for-cykle bez toho, aby sme si okrem niekoľko málo premenných niečo naviac pamätali, a preto je pamäťová zložitosť konštantná = $O(1)$.
",2
2063b52a90575e00,ksp,"# Všetko so všetkým súvisí

Anička rada hľadá súvislosti medzi rôznymi vecami - napríklad medzi počtom ľudí v autobuse a jeho meškaním, medzi klimatickým stavom podnebia a kvalitou sobej pečienky, medzi časom stráveným na záchode a počtom bodov v Olympiáde v informatike, medzi časom stráveným na záchode a počtom bodov z písomky z dejepisu... a takto by sme mohli pokračovať ďalej.

V poslednej dobe Anička začala skúmať ciferné súčty a uvedomila si, že číslo a jeho ciferný súčet zvyčajne spolu nijak nesúvisia ^[To, že majú rovnaký zvyšok po delení deviatimi, jej nepríde vôbec zaujímavé.]. Napríklad by sa jej páčilo, keby bolo číslo svojím ciferným súčtom deliteľné. Hľadať takéto čísla je však vcelku namáhavé, a preto by Anička bola rada, keby ste jej napísali program na ich hľadanie.

## Úloha

Vašou úlohou je pre dané prirodzené číslo $n$ nájsť také prirodzené číslo, ktoré má ciferný súčet rovný $n$ a je ním aj deliteľné. Navyše, aby Aničke neprišlo zle z priveľkých čísel, nájdite najmenšie také číslo. Môžete predpokladať, že riešenie vždy existuje.

## Formát vstupu

Na jedinom riadku vstupu je dané celé číslo $1 \\leq n \\leq 1000$.

## Formát výstupu

Vypíšte jediný riadok a na ňom jediné prirodzené číslo -- najmenšie číslo s ciferným súčtom $n$, ktoré je týmto ciferným súčtom aj deliteľné. Upozorňujeme, že výsledné číslo môže byť veľmi veľké a nemusí sa vojsť ani do $64$-bitovej celočíselnej premennej.

## Hodnotenie

Sú štyri sady vstupov, za každú možno získať $2$ body. Maximálne hodnoty $n$ v jednotlivých sadách sú postupne $20$, $50$, $200$ a $1000$.

## Príklady

```vstup
4
```

```vystup
4
```

```vstup
11
```

```vystup
209
```

$2+0+9=11$ a $209/11=19$, čo je celé číslo.

```vstup
81
```

```vystup
999999999
```
","# Všetko so všetkým súvisí

Asi prvá vec, ktorú si všimneme, je, že hľadané číslo bude deliteľné číslom $n$, ktoré sme dostali na vstupe. Tu sa nám črtá prvé riešenie, ktoré jednoducho vyskúša všetky násobky čísla $n$ a vypíše prvý, ktorý má ciferný súčet rovný $n$.

Výsledné číslo musí mať aspoň $\\frac{n}{9}$ cifier, a takých čísel je $10^{\\frac{n}{9}}$.

Z nich každé $n$-té je deliteľné $n$, čiže toto riešenie skúša exponenciálne veľa možností. Keďže výsledok môže obsahovať aj nuly, nemáme žiadny horný limit na dĺžku hľadaného čísla, takže tento program môže bežať dokonca ľubovoľne dlho. Poďme teda nájsť lepšie riešenie.

Vcelku dobrý nápad vyzerá byť generovanie hľadaného čísla postupne cifru po cifre. Budeme to robiť zľava doprava, teda od najvýznamnejších číslic k najmenej významným. Pozrime sa na to, čo sa stane, keď k nejakému číslu $m$ s ciframi $c_1c_2 \\dots c_k$ pripíšeme na koniec cifru $d$ a dostaneme tak číslo $c_1c_2 \\dots c_kd$. Jeho ciferný súčet sa zvýši o $d$. Zároveň sa už nikdy neskôr nemôže znížiť, keďže všetky cifry sú nezáporné. Zaujímavé je, čo sa stane s jeho zvyškom. Pri pripísaní cifry na koniec čísla sme všetky cifry posunuli o jedno miesto doľava, čo zodpovedá vynásobeniu desiatimi a napokon sme pričítali cifru $d$. Hodnota nového čísla je tak $10m+d$.

Teraz si uvedomme, že pri skúmaní deliteľnosti nás vlastne až tak nezaujíma samotné číslo $m$, stačí nám poznať jeho zvyšok po delení $n$, označme ho $z$. Ten sa pripísaním cifry $d$ zmení na $(10z+d) ,\\mathrm{mod}, n$.

Našu úlohu si tak vieme previesť na prehľadávanie grafu, kde každý vrchol reprezentuje číslo, ktoré máme aktuálne napísané, a každá (jednosmerná) hrana reprezentuje pripísanie číslice na koniec čísla. Samotné napísané čísla si však pamätať nechceme, keďže sú príliš dlhé. O každom takomto čísle nám stačí pamätať si jeho ciferný súčet a jeho zvyšok po delení $n$.

Na začiatku máme napísaný prázdny reťazec cifier, ktorý má ciferný súčet $0$ a zvyšok tiež $0$ (pretože keď napíšeme cifru $d$, dostaneme zvyšok $10 \\cdot 0+d=d ,\\mathrm{mod}, n$). K tomuto prázdnemu reťazcu teraz budeme pripisovať nejaké cifry, čo v tomto poňatí znamená nejaké presuny po hranách. Nakoniec sa chceme dostať do stavu s ciferným súčtom $n$ a zvyškom $0$.

Na prehľadanie grafu použijeme prehľadávanie do šírky (BFS). Na začiatku si do prázdnej fronty vložíme počiatočný stav (ciferný súčet aj zvyšok rovné $0$). Postupne vyťahujeme z fronty nové stavy a ku každému skusíme pridať každú cifru. Zo stavu so súčtom $s$ a zvyškom $z$ sa cifrou $d$ dostaneme k súčtu $s+d$ a zvyšku $(10 \\cdot z+d),\\mathrm{mod}, n$. Ku každému stavu si tiež pamätáme, odkiaľ a s akou cifrou sme sa doň dostali, aby sme vedeli spätne zrekonštruovať vytvorené číslo. Ak nájdeme stav, ktorý má rovnaký ciferný súčet aj zvyšok, ako sme už videli, tento stav nebudeme skúmať znova (je to ten istý vrchol grafu).

Na konci programu pomocou zapamätaných spätných liniek vytvoríme hľadané číslo po jednotlivých cifrách. Treba mať na pamäti, že toto číslo dostaneme odzadu, takže ho pred výpisom musíme ešte otočiť.

Zadanie však od nás chce, aby sme našli najmenšie možné číslo, nie ľubovoľné. Tu je dôležité, že sme použili BFS. Ukážeme, že tento algoritmus našiel naozaj najmenšie možné číslo. BFS nájde cestu s najmenším počtom hrán, teda dostaneme číslo s najmenším počtom cifier (čo hrana, to cifra). Najskôr spracúvame stavy s jednou napísanou cifrou, potom s dvomi, tromi atď. Tiež je dôležité spracúvať hrany idúce z jedného vrcholu v poradí podľa pripísanej cifry od $0$ do $9$. Spomedzi rovnako dlhých čísel sa tak vždy dostane menšie číslo vo fronte pred väčšie. Ak dve čísla začínajú rovnako a líšia sa len v poslednej cifre, potom číslo s menšou poslednou cifrou bude vo fronte skôr. Ak sa rovnako dlhé čísla líšia skôr ako v poslednej cifre, potom začiatok (bez poslednej cifry) menšieho sme vytiahli z fronty skôr, a tak všetky čísla, ktoré vzniknú z neho, sa dostanú do fronty skôr a usporiadanosť čísel vo fronte sa zachová. Stavy teda spracúvame v poradí od najmenšieho napísaného čísla k väčším, ale tieto čísla v pamäti nedržíme, každý stav reprezentujeme len dvojicou čísel -- ciferný súčet a zvyšok.

Uvažujeme iba ciferné súčty menšie alebo rovné $n$ a existuje $n$ rôznych zvyškov po delení $n$, máme teda $O(n^2)$ stavov (vrcholov grafu), do ktorých sa vieme dostať. V každom stave máme $10$ možností, akú cifru pripísať, teda z každého stavu ide $10$ (konštantne veľa) hrán. Časová zložitosť prehľadavánia je teda $O(n^2)$, pamäťová je rovnako $O(n^2)$.
",6
43ddd6a881cad1f8,ksp,"﻿# Turisticky na oslavu

Ako ste iste pochopili, KSP oslavuje 40. narodeniny, takže sa bude konať veľká oslava.

Oslava sa koná na Kikinej chate, kam sa ale všetci vedúci musia najprv dostať. Keďže ceny paliva sú stále vysoké, vedúci sa rozhodli, že si spravia turistiku.

Vybrali sa teda cez hory, kde na nich čakalo množstvo prekážok - strmých skál. Po skale sa nedá vyliezť, lebo je veľmi šmykľavá a nedá sa ju ani obísť.

Vedúci sú natrénovaní, a tak každý z nich dokáže vyskočiť do výšky $k$ metrov.

Ak je skala vyššia ako $k$ metrov, tak ju samostatne vedúci nepreskočí, ale dokážu si vzájomne pomôcť tak, že sa jeden druhému postavia na ramená, a tak vytvoria akýsi ľudský rebrík, po ktorom môže iný vedúci vyliezť. Každý vedúci má výšku $1$ meter. Každý vedúci, ktorý sa stane rebríkom, sa musí obetovať a pod danou skalou ostať - nemôže pokračovať ďalej.

Kika už čaká na chate a chystá sa krájať tortu. Rada by ale vedela, koľko porcií má nachystať. Zistite, koľko vedúcich prejde pohorím a dorazí na chatu.

## Úloha

Vašou úlohou bude zistiť, koľko najviac vedúcich z celkového počtu $v$ dokáže prejsť pohorím a dorazí na chatu.

Na to aby vedúci mohol prejsť cez skalu potrebuje vedieť vyskočiť dostatočne vysoko. Ak je skala vyššia ako výška jeho skoku $k$, požiada svojich spoluvedúcich o pomoc. Vedúci, ktorí tvorili ľudský rebrík sa musia obetovať a na chatu nikdy nedorazia.

Skaly, ktoré treba prekonať si môžete predstaviť ako postupnosť výšok skál zľava doprava, pričom vedúci vyrážajú úplne zľava, na nulovej výške a chata sa nachádza úplne vpravo, tiež v nulovej výške. Keď vedúci preskočí skalu, znova bude v nulovej výške (teda za každou skalou je zase chodník nulovej výšky).

## Formát vstupu

V prvom riadku sú čísla $n, v, k$ udávajúce počet skál, počet vedúcich a výšku skoku vedúceho.

V druhom riadku nasleduje $n$ čísel, reprezentujúcich výšky jednotlivých skál.

Môžete predpokladať, že výška skaly nepresiahne číslo $m$.

Sú 4 sady vstupov, a môžete v nich predpokladať nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|---------:|---------:|---------:| | $1 \\leq n \\leq$ | $10$ | $10^3$ | $10^5$ | $10^5$| | $1 \\leq v \\leq$ | $10$ | $10^3$ | $10^6$ | $10^{11}$| | $1 \\leq k \\leq$ | $10$ | $10^3$ | $10^6$ | $10^9$| | $1 \\leq m \\leq$ | $10$ | $10^3$ | $10^6$ | $10^9$|

Všimnite si, že v poslednej sade sa Vám vstupné premenné nemusia zmesiť do `int`-u, odporúčame preto v C/C++ použiť `long`.

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno celé číslo udávajúce počet vedúcich, ktorým sa podarilo doraziť na chatu.

## Príklady

```vstup
5 20 10
5 7 3 4 2
```

```vystup
20
```

*Ani jedna skala nie je vyššia ako výška do ktorej vie vedúci doskočíť, čiže na chatu dorazí všetkých `20` vedúcich.*

```vstup
3 5 5
4 7 3
```

```vystup
3
```

*Prvú skalu sa podarilo zdolať všetkým, na druhej dvaja vedúci museli vytvoriť rebrík aby ostatní prešli, tretiu skalu zvyšni vedúci preskočili všetci.*

```vstup
3 7 2
14 1 2
```

```vystup
0
```

*Cez prvú skalu sa nedostal ani jeden vedúci, na chatu dorazilo `0` vedúcich.*
","# Turisticky na oslavu

## Myšlienka riešenia

Aby sme zistili, koľko vedúcich sa dostane na chatu, potrebujeme najskôr zistiť počet vedúcich, ktorí budú pri každej skale tvoriť ľudský rebrík. To docielime tak, že od výšky skaly odčítame výšku skoku vedúceho, čo nam dá počet, koľko vedúcich je potrebné obetovať na ľudský rebrík. Ak je počet záporné číslo, znamená to, že vedúci vie preskočit danú skalu, a teda nebolo treba obetovať žiadneho vedúceho.

Po zistení počtu vedúcich, ktorí tvoria ľudský rebrík, odčítame dané číslo od celkového počtu vedúcich. (Vedúci, ktorí tvoria ľudský rebrík už ďalej ísť nemôžu)

Túto úvahu aplikujeme pre každú skalu na vstupe.

Ukážeme si myšlienku na $2.$ príklade zo zadania:

```vstup
3 5 5
4 7 3
```

```vystup
3
```

Počet skál $3$, výška skoku $5$, počet vedúcich $5$.

Skala výšky $4 \\to 4 - 5 = -1$, zoberieme `max(-1, 0)`, teda $5 - 0 = 5$, všetci vedúci prejdu. \
Skala výšky $7 \\to 7 - 5 = 2$, zoberieme `max(2, 0)`, teda $5 - 2 = 3$, dvaja vedúci tvoria rebrík, zvyšní traja prejdu. \
Skala výšky $3 \\to 3 - 5 = -2$, zoberieme `max(-2, 0)`, teda $3 - 0 = 3$, traja vedúci sa dostali na chatu.

## Optimálne riešenie

Optimálne riešenie číta výšky skál a hneď rozhoduje, či bude treba obetovať vedúcich. Ak áno, odčíta počet obetovaných vedúcich od celkového počtu vedúcich.

Stačí nám prejsť vstupom iba raz, a teda časová zložitosť riešenia je $O(n)$. Pri čítaní nám stačí si pamätať iba aktuálnu výšku skaly, a teda pamäťová zložitosť riešenia je $O(1)$.
",1
f3bc9454a76baaae,ksp,"# Žer Celaskon

Po ukrutnej zime strávenej s nádchou si Zuzka uvedomila, že jej ohnutá nosná prepážka je už na nevydržanie a dá si ju operovať. Najprv však musí podstúpiť predoperačné vyšetrenie, čo znamená, že musí navštíviť doktora a stráviť tri temné doby v čakárni, kým na ňu príde rad. Čakáreň v nemocnici je v skutočnosti len dlhočizná chodba s jedným dlhým radom sedadiel, ktoré sú buď voľné, obsadené zdravým človekom alebo nejakým úbožiakom s kalným pohľadom a osoplenou vreckovkou. Keďže má Zuzka ešte stále trocha podlomenú imunitu, posledné, čo by chcela, je zase ochorieť. Preto si v čakárni chce sadnúť čo najďalej od všetkých posmrkávajúcich a odŕhajúcich ľudí. Zároveň ju však už bolia nohy z postávania v preplnenej 39-tke^[Táto autobusová linka je živou ilustráciou matematickej indukcie: ak sa zmestí $n$ ľudí, zmestí sa aj $n + 1$.] a tento strategický výber sedadla chce spraviť čo najrýchlejšie. Pomôžete jej?

## Úloha

Dostanete popis radu sedadiel v čakárni. Každé sedadlo je buď voľné, obsadené zdravým človekom, alebo obsadené chorým človekom. Vašou úlohou je nájsť to voľné sedadlo, pre ktoré je vzdialenosť od najbližšieho chorého človeka maximálna.

## Formát vstupu

Sedadlá v čakárni sú zaradom očíslované kladnými celými číslami.

Na prvom riadku vstupu dostanete dve kladné celé čísla $v, c$ označujúce počet voľných sedadiel a počet sedadiel, na ktorých sedí niekto chorý. Na druhom riadku nasleduje $v$ čísel označujúcich pozície voľných sedadiel. Na treťom riadku je $c$ čísel označujúcich pozície sedadiel obsadených chorými ľudmi. Na pozíciach nešpecifikovaných v predošlých dvoch riadkoch sa nachádzajú sedadlá obsadené zdravými ľuďmi.

Pre jednotlivé testovacie sady platia nasledujúce obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ---:| ---:| ---:| -----:| | $v + c \\leq$ | $1,000$ | $5,000$ | $100,000$ | $100,000$ | | počet všetkých sedadiel $\\leq$ | $10,000$ | $1,000,000$ | $100,000,000$ | $100,000,000$ |

## Formát výstupu

Vypíšte jediné číslo - pozíciu voľného sedadla, ktoré je najďalej od najbližšieho chorého človeka. Ak je takých sedadiel viac, vypíšte to s najnižším číslom, nech sa Zuzka toľko nenachodí.

```vstup
5 4
1 11 7 6 13
3 10 4 12
```

```vystup
7
```

*Situáciu si môžeme zakresliť takto: `-OXXO--OOX-X-O`, pričom `O` je zdravá osoba a `X` chorá. Sedadlo $1$ je od najbližšej chorej osoby (ktorá sedí na sedadle $3$) vzdialené $2$, sedadlo $6$ tiež $2$ (v tomto prípade ide o človeka na sedadle $4$), sedadlo $7$ má vzdialenosť od najbližšieho chorého človeka $3$ (ľudia na sedadlách $4$ a $10$) a sedadlá $11$ a $13$ majú najbližšieho chorého hneď vedľa seba.*

```vstup
3 3
4 7 3
5 9 1
```

```vystup
3
```

*Tu je situácia takáto: `XO--XO-OXO`. Optimálne sedadlá sú na pozíciach $3$ a $7$ s najbližším chorým človekom vzdialeným $2$, no keďže sedadlo $3$ má menšie číslo, vyberieme ho.*

```vstup
1 1
1
2
```

```vystup
1
```

*Zuzka si tu nenavyberá, musí si sadnúť hneď vedľa maróda.*
","# O Žer Celaskon

bodyprogram=8}

Aby sme našli sedadlo pre Zuzku, pre každé voľné sedadlo zistíme vzdialenosť od najbližšieho chorého. Z týchto vzdialeností potom vyberieme tú najlepšiu.

## Prvé riešenie

Najjednoduchší spôsob na zisťovanie vzdialeností je, keď pre každé voľné sedadlo prejdeme zoznam všetkých chorých a určíme, ktorý z nich je najbližšie.

Toto riešenie má časovú zložitosť $O(v \\cdot c)$. Pamäťová zložitosť bude $O(v + c)$.

## Lepšie riešenie

Pri spracovaní jedného voľného sedadla nás ale väčšina chorých nezaujíma. Dôležití sú len tí, ktorí sú najbližsie napravo a naľavo od daného voľného sedadla. Čakáreň si vieme predstaviť ako úseky voľných sedadiel (a sedadiel obsadených zdravými ľuďmi), ktoré sú oddelené chorými. Každý takýto úsek má spoločných najbližších chorých.

Na hľadanie najbližších chorých sa nám oplatí si dáta usporiadať. Vieme potom použiť princíp dvoch bežcov, kedy si v zozname chorých aj v zozname voľných miest pamätáme index sedadla, s ktorým práve pracujeme. V zozname voľných sedadiel si budeme pamätať index práve spracúvaného sedadla a v zozname chorých index najbližšieho chorého napravo od tohto sedadla (rovnako dobre by fungovalo pamätať si index najbližšieho chorého naľavo). Keď v zozname voľných sedadiel presiahneme pozíciu aktuálneho chorého, posunieme sa na ďalší úsek -- medzi ďalších dvoch chorých.

V rámci jedného úseku budeme určovať vzdialenosť najbližšieho chorého ako menšiu zo vzdialeností k jednému z chorých na kraji úseku.

Takéto riešenie bude mať časovú zložitosť $O(v \\log v + c \\log c)$, pretože zoznamy chorých a voľných sedadiel si potrebujeme usporiadať. Prechádzanie týchto zoznamov a určovanie vzdialeností spravíme raz -- časová zložitosť je $O(v + c)$ a toto nám celkovú časovú zložitosť nezhorší.

Pamäťová zložitosť bude $O(v + c)$, pretože si potrebujeme pamätať oba zoznamy.
",2
568c569c1e9fe16e,ksp,"# Absurdistanské diaľnice

V Absurdistane majú už dlho v pláne postaviť novú sieť diaľnic. Ale viete, ako to chodí: každé štyri roky sú voľby, s ktorými príde nový minister dopravy. Ten vždy najprv preplánuje celú dialničnú sieť a potom už do konca volebného obdobia nič nestihne. Následne príde nový minister a taktiež nanovo prerobí celé plány. Predchádzajúci minister si však rok pred voľbami povedal, že túto tradíciu poruší a diaľnicu stavať naozaj začne. Lenže žiadnu cestu za rok nepostaví, a preto, aby po ňom niečo ostalo, rozhodol sa postaviť aspoň diaľničné križovatky.

Preto zobral svoje plány a náhodne z nich vybral pár miest kde sa do volieb postavili križovatky.

Po ňom však prišiel nový minister. Ten podľa zvyku staré plány zahodil a teraz má pred sebou tažkú úlohu: musí naplánovať celú diaľničnú sieť tak, aby dopĺňala už existujúce križovatky. Keďže chce mať v plánoch poriadok, určil si nasledujúce dva ciele: musí použiť čo najmenej rôznych diaľnic a všetky z nich musia ísť buď v severo-južnom alebo západo-východnom smere. Dokážete aj vy za takýchto podmienok zostrojiť nový plán diaľnic?

## Úloha

Na vstupe dostanete zoznam všetkých diaľničných križovatiek postavených predchádzajúcim ministrom.

Vašou úlohou je navrhnúť diaľničnú sieť tak, aby obsahovala všetky tieto križovatky.

Cez každú križovatku musia prechádzať dve diaľnice (keď už je tam ten nadjazd, je to už vybudovaná diaľnica a teda ju nemožno zrušiť), môžu však byť akokoľvek krátke (stačí keď sa diaľnica končí hneď za nadjazdom). Žiadne dve diaľnice sa nemôžu križovať mimo križovatky (to by bolo divné, nie?). Nemôžete postaviť žiadnu novú križovatku, lebo na to nemáte financie.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ -- počet križovatiek. Na nasledujúcich $n$ riadkoch sú vymenované jednotlivé križovatky. Na každom riadku sú súradnice $1 \\le x_i, y_i \\le 10^9$: zemepisné súradnice jednotlivých križovatiek.

## Formát výstupu

Na výstup vypíšte navrhnutú diaľničnú sieť. V prvom riadku vypíšte číslo $H$: počet západo-východných diaľnic.

Potom vypíšte $H$ riadkov. Na každom riadku vypíšte štyri čísla $1 \\le x_i, y_i, x'\_i, y'\_i \\le 10^9$, ktoré reprezentujú západo-východnú diaľnicu. Musí platiť, že $y_i = y'\_i$.

V ďalšom riadku vypíšte číslo $V$: počet severo-južných diaľnic. Potom vypíšte $V$ riadkov. V každom riadku vypíšte štyri čísla $1 \\le x_i, y_i, x'\_i, y'\_i \\le 10^9$, ktoré reprezentujú severo-južnú diaľnicu. Musí platiť, že $x_i = x'\_i$.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:--------------- | --: | --: | --: | --: | --: | --: | --: | --: | | $0 \\leq n \\leq$ | $6$ | $6$ | $16$ | $16$ | $100$ | $10$ | $1,000$ | $1,000$ | | $0 \\leq x_i, y_i \\leq$ | $6$ | $10^9$ | $16$ | $10^9$ | $100$ | $10^9$ | $1,000$ | $10^9$ |

Príklad:

```vstup
4
2 1
2 3
1 2
3 2
```

```vystup
3
1 1 2 1
1 2 3 2
1 3 2 3
4
1 2 1 2
3 1 3 3
2 1 2 1
2 3 2 3
```

*Všimnite si, že viacero z diaľníc už nepokračuje mimo križovatku.*

*V diaľničnej sieti však musia byť, keďže v každej križovatke sa musia križovať diaľnice.*
","# Absurdistanské diaľnice

Na vstupe máme niekoľko diaľničných križovatiek. Naším cieľom je navrhnúť severojužné a západovýchodné diaľnice tak, aby:

1. každá križovatka bola križovatkou dvoch diaľníc,
1. aby sa žiadne dve diaľnice nekrižovali mimo križovatie,
1. a aby bolo diaľníc čo najmenej.

Skúsme najprv ignorovať poslednú podmienku a pozrieť sa na riešenie iteratívne: Na začiatku máme veľa križovatiek a na každej z nich sa križujú dve samostatné diaľnice. Ak máme $n$ križovatiek tak máme $2n$ diaľníc. Chceme aby diaľníc bolo čo najmenej, preto chceme tieto diaľnice pospájať. Križovatku môžeme napojiť iba na tú ktorá je k nej najbližšia v každom zo štyroch smeroch. Každé takéto spojenie nám zníži počet diaľníc o jedna. Keby sme ignorovali druhú podmienku tak v podstate každú križovatku môžeme spojiť s najbližšími križovatkami vo všetkých štyroch smeroch a tým pádom by nám pre každú x-ovú súradnicu zostala práve jedna zvisĺa diaľnica a pre každú y-novú súradnicu zostala práve jedna vodorovná diaľnica.

Druhá podmienka však situáciu komplikuje. V praxi pre nás znamená že na každej križovatka spojníc diaľníc ktorá nie je na vstupe si musíme vybrať ktorú spojnicu ponecháme a ktorú nie. Toto nám však úlohu transformuje na vcelku štandartný grafový problém: Pre každú spojnicu majme jeden vrchol v grafe. Pre každú križovatku dvoch spojníc ktorá nie je na vstupe majme hranu ktorá spojí dva vrcholy reprezentujúce tieto dve spojnice. Teraz z grafu chceme vybrať čo najviac vrcholov (spojníc), tak aby žiadne dva vybrané vrcholy neboli spojené hranou. Chceme teda vybrať najväčšiu nezávislú množinu (*maximum independent set*).

Tento postup si môžme ozrejmiť aj na nasledovnom príkladnom obrázku. Na obrázku máme jednotlivé križovatky. Na začiatku sa v každej z nich stretávajú dve diaľnice. Keďže chceme počet diaľníc minimalizovať, chceme vybudovať ich spojnice, kde každá spojnica nám zníži počet jedinečných diaľníc o jedna. V ideálnom prípade chceme využiť všetky spojnice, ale v tomto prípade to nie je možné, keďže diaľnice sa nesmú križovať mimo križovatiek. Túto úlohu si pretransformujeme do bipartitného grafu, kde vrcholy reprezentujú spojnice. Hrany sú medzi vrcholmi práve vtedy keď sa dve spojnice križujú a teda nemôžeme postaviť obidve. Chceme teda vybrať čo najviac vrcholov tak aby medzi žiadnou dvojicou vybraných vrcholov nebola hrana.

Problém najväčšej nezávislej množiny v grafe je vo všeobecnosti v kategorí NP-úplných problémov a teda je pravdepodobné, že sa nám naň nikdy nepodarí nájsť riešenie v polynomiálnom čase. Náš graf má však užitočnú vlastnosť -- je bipartitný. To znamená, že vrcholy v ňom vieme rozdeliť do dvoch kategoríi: severojužné spojnice a východozápadné spojnice, pričom hrany sú iba medzi vrcholmi z rôznych kategórii. Tento problém už má známe riešenie, ktoré sme sa pokúsili zhrnúť [tu](https://www.ksp.sk/kucharka/parenie/). Časová zložitosť pre riešenie tohto problému je $O(E \\sqrt {V})$, pre bipartitný graf s $E$ hranami a $V$ vrcholmi ak hľadáme maximálne párovanie pomocou Edmonds–Karp. V našom prípade však absolútne postačí pomalší algoritmus na hľadanie párenia s časovou zložitosťou $O(EV)$. Keď máme križovatiek $n$, tak môže byť medzi nimi $4n \\in O(n)$ spojníc. Tieto spojnice sa však môžu krížiť pomerne veľa krát. Napríklad na obrázku nižšie vidíme situáciu v ktorej máme až $(n/4)^2 \\in O(n^2)$ križovatiek spojníc. Viac ich však nemôže byť, keďže $4 n$ spojníc sa môže križovať najviac v $16n^2 \\in O(n^2)$ miestach. Tým pádom je časová zložitosť výsledného riešenia $O(E \\sqrt {V}) = O(n^2 \\sqrt {n}) = O(n^{2.5})$. Pamäťová zložitosť je $O(n^2)$, keďže potrebujeme vyrobiť graf všetkých hrán (krížení spojníc).
",10
c4e6176bb0e0e88b,ksp,"# Ako sa to ráta?

Julka má veľa domácich úloh. Nebaví ju ale stále počítať komplikované príklady ručne. Rozhodla sa siahnuť po modernom pomocníkovi - kalkulačke. Zistila však, že na svojom iPade stále nemá predinštalovanú kalkulačku, ktorú by mohla použiť. Preto musela oprášiť svoju malú starú kalkulačku. Hneď pri prvom príklade ale nastal problém. Jej kalkulačka nedokáže vypočítať všetky výrazy. Viete jej pomôcť zistiť, ktoré výrazy dokáže Julka vyrátať?

## Úloha

Julkina kalkulačka dokáže vykonávať iba základné operácie - sčítavanie, odčítavanie, násobenie a delenie. Ako bežná jednoduchá kalkulačka, ani táto nepodporuje zátvorky a operácie vždy vykonáva medzi posledným výsledkom a zadanou hodnotou. Teda, ak zadáme `1 + 2 =`, na display-i svieti `3`, pre pripočítanie čísla $4$ stlačíme `+ 4 =` a na display-i sa zobrazí `7`.

V pamäti kalkulačky má Julka uložený nový svetový rekord počtu desatinných miest pre konštantu Pí, ktorý by bola škoda stratiť (teda pamäť kalkulačky nepoužívajte). Takisto, nemôžeme sa s medzivýsledkami spoliehať na Julkinu pamäť. Všetky operácie musia byť vykonané na kalkulačke a nesmieme si pamätať žiadne medzivýsledky ""v hlave.""

Výraz je potrebné na kalkulačke vykonať tak, ako je zadaný na vstupe -- teda, nemôže si ho Julka upraviť do iného tvaru, maximálne môže prehodiť poradie operandov. $1 + 2$ môže zadať aj ako $2 + 1$, ale napríklad $3 + (1 - 2)$ nemôže zadať ako $3 - (2 - 1)$, aj napriek tomu, že ide o výraz získaný ekvivalentnou úpravou.

## Formát vstupu

Na vstupe sú dva riadky. V prvom riadku je číslo `N` - počet operácií a operandov na vstupe. V druhom riadku nasleduje `N` medzerou oddelených operandov (kladných celých čísiel) a operácií (`+`, `-`, `*`, `/`).

Matematické výrazy sú na vstupe zadané v tzv. [prefixovom zápise (Polish notation)](https://en.wikipedia.org/wiki/Polish_notation). Na rozdiel od bežne používaného infixového zápisu, ktorý umiestňuje znamienka operácií medzi operandy (`3 + 2`), v prefixovom zápise ich píšeme pred operandami (`+ 3 2`). Napríklad `1 + 2 * 3` zapíšeme ako `+ 1 * 2 3`. V prefixovom zápise nie je potrebné používať zátvorky, keďže poradie operácií je vždy zľava doprava: `(1 + 2) * 3` zapíšeme ako `* + 1 2 3`.

Môžete predpokladať, že výraz na vstupe je validný.

## Formát výstupu

Na výstup vypíšte `ANO` alebo `NIE` podľa toho, či dokáže Julka vyrátať zadaný výraz na svojej kalkulačke.

## Hodnotenie

Sú $4$ sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:---------------------- |------: | ---------: | ---------: | ---------: | | $3 \\leq n \\leq$ | $1,000$ | $10,000$ | $100,000$ | $1,000,000$ |

## Príklady

```vstup
5
+ + 1 2 3
```

```vystup
ANO
```

*Najprv zrátame 1 + 2, potom k výsledku pripočítame 3.*

```vstup
7
+ + 1 2 + 3 4
```

```vystup
NIE
```

*Potrebovali by sme si niekde pamätať medzivýsledok 1+2 alebo 3+4.*
","# Ako sa to ráta?

Naše riešenie si rozdelíme na dve časti – v prvej sa pokúsime spracovať vstup a v druhej zistiť, či sa dá daný výraz vypočítať.

## Načítanie vstupu

Bežné aritmetické výrazy je vhodné v počítači reprezentovať tzv. aritmetickým stromom. Aritmetický strom je binárny strom, kde v listoch sa nachádzajú operandy (čísla) a v ostatných vrcholoch sa nachádzajú operácie. Aritmetický strom pre výraz `2 * (3 + 4)` by vyzeral takto:

Príjemná vlastnosť takéhoto stromu je, že z neho vieme pomerne jednoducho vyčítať výrazy v rôznych zápisoch. Nás ale bude zaujímať prefixový zápis, ktorý z takéhoto stromu dostaneme napríklad týmto jednoduchým rekurzívnym algoritmom: pre každý vrchol vypíšeme svoju hodnotu a následne rekurzívne pokračujeme do ľavého a pravého potomka. Môžeš sa doma zamyslieť, ako by sme z takéhoto stromu získali infixový a postfixový zápis.

Keď už toto vieme, stačí sa nám zamyslieť, ako vieme takýto strom zostrojiť zo zápisu.

## Spracovanie vstupu

Keď už máme aritmetický strom vytvorený, potrebujeme z neho zistiť, či ho Julka dokáže vyrátať na svojej kalkulačke. Pozrime sa najprv na výrazy zo zadania. Výraz `+ + 1 2 3` vieme prepísať na infixový zápis `(1 + 2) + 3` a výraz `+ + 1 2 + 3 4` zas na `(1 + 2) + (3 + 4)`. Môžeš si všimnúť, že sme v zápise naschvál nechali zátvorky, ktoré tam implicitne z prefixového zápisu sú. Takýto výraz na našej kalkulačke vypočítať nevieme – Julka má zakázané robiť úpravy výrazu na vstupe, takže ani tieto zátvorky nemôže dať preč. Z toho si už vieme všimnúť, že Julka nevie vypočítať také výrazy, v ktorých sú zátvorky na oboch stranách operácie.

Ako takéto situácie nájdeme v našom aritmetickom strome? Postupne prejdeme stromom (napríklad [algoritmom DFS](https://www.ksp.sk/kucharka/dfs/)) a ak nastane situácia, že máme aj v ľavom aj v pravom potomkovi operáciu, vieme, že sa daný výraz vypočítať nedá. Za takéto riešenie bolo možné získať dva body.

## Nie všetky operácie sú rovnaké

Na plný počet bodov bolo potrebné si ešte uvedomiť jednu vlastnosť tejto kalkulačky. Výraz `4 * (2 + 3)` vieme vypočítať. Ak ste niekedy vlastnili takúto najlacnejšiu formu kalkulačky, pravdepodobne viete, že zadaním `4 * 2 + 3 =` nedostaneme správny výsledok (lebo výrazy vyhodnocuje zľava doprava bez ohľadu na prioritu operácií). Bežne by ste si proste vypočítali najprv `2 + 3` a potom výsledok vynásobili číslom `4`. Výsledok `2 + 3` si budete musieť buď pamätať, alebo si vo výraze prehodíte poradie operandov: `(2 + 3) * 4`. Toto už viete bez problémov vypočítať zadaním `2 + 3 * 4 =`.

Toto ale nefunguje pre všetky operácie. Násobenie a súčet vieme takto upraviť, ale delenie a rozdiel nie. `4 - (2 + 3)` si už nevieme prehodiť tak, aby sa to dalo na takejto kalkulačke vypočítať. Vieme takýto výraz upraviť ale to, ako sme si už spomenuli vyššie, nie je dovolené. Rovnako to platí aj pre delenie. Preto si musíme do nášho riešenia pridať ešte túto situáciu: ak je vo vrchole delenie/rozdiel a jeho pravý potomok je operácia, nepôjde to.

Časová zložitosť riešenia je $O(n)$, keďže vytvorenie stromu nám zaberie $O(n)$ času a prejdenie všetkých jeho vrcholov tiež $O(n)$. Pamäťová zložitosť je $O(n)$, keďže si pamätáme len vrcholy stromu, ktorých počet je rovný $n$.
",5
913b97b32d50108a,ksp,"# Dehumanizovaná klasifikácia

Jozef, ktorý už niekoľko týždňov pracuje ako vyšetrovateľ v organizácii PETA, sa nedávno zúčastnil jej každoročnej konferencie. Na tomto stretnutí sa do hĺbky skúmajú rôzne útoky na práva zvierat.

Jeho úloha spočíva v posúdení životného prostredia a etickosti zaobchádzania so zvieratami v zoologickej záhrade v Bratislave, ktorá sa nachádza veľmi blízko pri tajnej jadrovej elektrárni na matfyze. Špecialisti v PETA zistili, že v tejto elektrárni je už viac ako 20 rokov prevádzkovaný softvér, ktorého autori disponujú len pochybnými zručnosťami v oblasti softvérového inžinierstva. Toto vyvolalo obavy, že elektráreň môže na zvieratá pôsobiť nadmernou radiáciou.

Jozef teda nahodil ponožky a sandále a vydal sa na špionážnu návštevu ZOO. Keďže vstupenka bola časovo obmedzená, musel pracovať rýchlo. Ešte pred návštevou vymyslel jeho tím geniálny plán ako posúdiť čo najviac zvierat za krátky čas. Každé zviera odfotil špeciálným fotoaparátom, ktorý využíva špičkové metódy kompresie. Teraz už len zostáva fotografie roztriediť podľa druhu zvieraťa, ktoré na nich je. Na toto ale v PETA nikto nemá čas, keďže musia riešiť ďalšie naliehavé problémy a preto táto úloha zostáva na vás!

## Úloha

Vytvorte program, ktorý načíta fotografiu z Jozefovho špeciálneho fotoaparátu a vypíše, aké je na nej zviera.

## Formát vstupu

Na prvom riadku vstupu je číslo $n$ ($1 \\leq n \\leq 4$), ktoré udáva počet riadkov obrázka. Nasleduje $n$ riadkov obrázka, pričom každý má nanajvýš $1000$ znakov. Všetky riadky obrázka sú rovnako dlhé a prázdny priestor predstavujú medzery. Na načítanie riadku aj so všetkými medzerami odporúčame v jazyku C alebo C++ funkciu `getline(cin, premenna)` ktorá do premennej načíta riadok až po znak konca riadku.

## Formát výstupu

Vypíšte na jeden riadok výstupu druh zvieraťa na obrázku.

## Príklad

```vstup
1
>O========-
```

```vystup
had
```
","# Dehumanizovaná klasifikácia

Ako ste si rozhodne všimli, v zadaní nie sú jednotlivé druhy zvierat charakterizované a vašou úlohou bolo objaviť ich empiricky. Uvažujme vzorového riešiteľa Sama. Samo si po prečítaní úlohy uvedomil, že nemá veľa iných možností ako poslať aspoň nejaký program a dúfať, že sa stane niečo zaujímavé. Krvopotne teda napísal program, ktorý je v súlade s príkladom v zadaní a odoslal ho. A hľa, jeho riešenie zomrelo už na druhom vstupe s výsledkom `Zlá odpoveď.` Testovač ale Sama obdaril fotografiou, na ktorej jeho program zlyhal, tvrdiac, že je to ovca:

```
4
       _
 /mmmmmO
o wwwww
  || ||
```

Samo si uvedomil, že nie je ideálne mať celú fotografiu uloženú v programe a vstup s ňou porovnať, ale radšej ich odlíšiť na základe nejakej jednoduchej vlastnosti. Vlastnosť, ktorú si všimol ako prvú, je počet riadkov obrázka. Zatiaľ čo fotka hada má jeden riadok, fotka ovce má štyri. A tak napísal nový program, ktorý vie rozoznať ovcu a hada. Takto chvíľu pokračoval, nasledovala stonožka, ryba a mačka, no vtom narazil na problém. Stonožka aj mačka majú obe tri riadky. No Samo je šikovný a rýchlo si všimol, že mačka má, narozdiel od stonožky, uši. A tak, pomocou operátora `in` v pythone a pomocou funkcie v C++, ktorú si pripravil, skontroloval, či sa v prvom riadku obrázka nachádzajú uši. Následne stretol niekoľko variácii už známych zvierat, barany a veľryby, ktoré rozoznal od svojich náprotivkov podobne ako mačku od stonožky. Potom prišiel mravec, čo bola vlastne stonožka dlhá presne tri články. Samo sa teda jednoducho pozrel na šírku obrázka.

Po ošetrení prípadu mravca sa potešil, pretože už získal za úlohu 8 bodov, no čakalo ho nemilé prekvapenie. Ako sa aj zamestnanci organizácie PETA obávali, reaktor na matfyze pôsobil na ZOO nadmernou radiáciou a nachádzali sa v nej zmutované zvieratá:

```
1
-=+====O<
```

V týchto prípadoch mal Samov program vypísať slovo `mutant`. Rozoznať zmutovaného hada bolo celkom jednoduché, keďže len niektorá časť tela mala namiesto znaku `=` znak `+`. A tak Samo použil rovnakú metódu ako doteraz. ""Aaa!"" Nahlas sa zľakol dvojhlavej ovce.

```
4
_     _
OmmmmmO
 wwwww
 || ||
```

V tomto prípade sa nestačí len pozrieť, či obrázok obsahuje nejaký znak, ale bolo by ideálne výskyty spočítať. Za týmto účelom Samo použil v pythone metódu `str.count` a v C++ si vytvoril ďalšiu funkciu (prípadne použil `count`). A teda jednoducho spočítal hlavy ovce, berúc do úvahy to, že barana mohol stretnúť podobný osud. Neskôr sa Samo stretol s ovcami so zmutovanou vlnou, ktorá sa opäť dala detekovať prítomnosťou znaku.

Nasledovali stonožky s chýbajúcimi nohami. Samovi napadlo, že spočíta, koľko nôh stonožka má a porovná s tým, koľko by ich mať mala, podľa šírky obrázka. Neskôr sa objavili stonožky s hlavami na náhodných miestach:

```
3
\|||/
ooOoO
/|||\
```

Toto sa opäť dalo vyriešiť spočítaním hláv. Dvojhlavé ryby boli o niečo komplikovanejšie, keďže hlava ryby sa skladá z rovnakých znakov ako chvost (ryba môže byť aj otočená), ale v prípade, že sa v obrázku nachádzajú obidva znaky (`<` a `>`) dvakrát, ryba musí mať dve hlavy. V prípade, že je takto zmutovaná veľryba, správnym výstupom je `velmutant`. Objavili sa mačky, ktoré nemali štyri nohy, prípadne mali viac ako dve uši, toto nebol žiadny problém, stačilo spočítať znaky. Nakoniec sa objavila ovca s trochu inou mutáciou vlny, no problém sa neodklonil od spočítania výskytov niektorého znaku. Týmto Samo dokončil svoj program na rozoznávanie druhov a získal 20 bodov. Celkovo mu to trvalo 18 submitov.
",4
285495ac3c91f23b,ksp,"﻿# Okná sa vymieňajú

Na matfyze sa v rámci prestavby začali vymieňať všetky okná. A to zahŕňa aj KSPácku miestnosť T2. A aby sme uvoľnili miesto robotníkom, musíme ju celú vypratať. Problém však je, že v T2 sa nachádza **všetko**. A tím myslím naozaj všetko. Od gitary, počítačov, hlavnovedúcovskej tyče, soba, masky Darth Vadera, cez chemikálie, terčovnicu, vŕtačku, papuče, po pílku na železo, hasiaci prístroj, TODO list a nič.^[Možno si myslíte, že niektoré z týchto vecí som si vymyslel pre lepší epický tón rozprávky. Mýlite sa. Toto všetko sa naozaj nachádza v T2. A verte mi, je toho ešte oveľa viac.] Naviac má každá z týchto vecí iný objem a keďže sa tu nachádza všetko, pre každé prirodzené číslo existuje v T2 jeden predmet s takýmto objemom.

Našťastie ako informatici máme dobrý komprimovací prístroj, ktorý dokáže bezstratovo zmenšiť objem ľubovoľného objektu s objemom väčším ako $1$. Tento komprimátor funguje tak, že ak mal predmet pôvodne objem $a$, po skomprimovaní bude mať tento predmet objem $b$, kde $b$ je počet jednotiek v binárnom zápise čísla $a$. Ak sa napríklad $a=19\_{10}=10011_2$, tak $b=3$. Teraz je snáď jasné, prečo sa predmet s objemom $1$ nedá komprimovať. Táto komprimácia sa dá samozrejme opakovať, čím dostávame stále menšie a menšie predmety, až kým sa dostaneme na objem $1$. Pre $a=19$ musíme komprimáciu opakovať $3$ krát, pričom dostanem postupne objemy $3$, $2$ a $1$.

Avšak skôr ako sa komprimátor začal používať, nadšení a akciechtiví prváci vypratali časť T2 a zostali v nej len predmety, ktorých objemy sú medzi $l$ a $h$ vrátane. Všetky tieto predmety chceme teraz skomprimovať na objem $1$, musíme si však dať pozor, aby sme ich vedeli dekomprimovať. Dôležité je, aby sme každý predmet dekomprimovali presne toľko krát, koľko krát sme ho komprimovali. Všetky veci (v tom čase už s objemom $1$) si teda uložíme do krabíc tak, aby veci, ktoré potrebovali rovnaký počet komprimácii, kým skončili s objemom $1$, boli v tej istej krabici. Dopredu by sme však chceli vedieť, aké veľké krabice si máme pripraviť na ktorú sadu predmetov.

## Úloha

Pre čísla $l$, $h$ a $k$ určite počet takých predmetov s objemom medzi $l$ a $h$ vrátane, že na ich skomprimovanie na veľkosť $1$ je potrebných práve $k$ komprimácií.

## Formát vstupu

Na prvom riadku vstupu je číslo $t$ ($1 \\leq t \\leq 1,000$) -- počet vstupných testov.

Nasleduje $t$ riadkov, každý obsahujúci tri čísla $l$, $h$ a $k$ ($2 \\leq l \\leq h \\leq 10^{18}$, $1 \\leq k \\leq 10^6$).^[Z obavy vytvorenia čiernej diery sa neodvažujeme komprimovať predmety s objemom väčším ako $10^{18}$, pretože hmotnosť sa zachováva.] $l$ a $h$ udávajú interval objemov, z ktorého vyberáme a $k$ je žiadaný počet komprimácií.

## Formát výstupu

Pre každý z $t$ testov vypíšte jedno číslo -- počet takých čísiel medzi $l$ a $h$, že sa skomprimujú na $1$ po práve $k$ komprimáciách.

## Bodovanie

Vstupy sú rozdelené do $10$ testovacích sád. Jednotlivé sady majú svoje obmedzenia a väčšinou platí, že vyriešiť skoršiu sadu je jednoduchšie. Zároveň by riešenia niektorých nižších sád mali pomáhať pri vymýšľaní zložitejších riešení.

- Pre sadu $01$ platí, že $t=100$, $b\\leq 10^6$, $b-a \\leq 1,000$
- Pre sadu $02$ platí, že $t=100$, $b\\leq 10^{18}$, $b-a \\leq 1,000$
- Pre sadu $03$ a $04$ platí, že $t=1,000$, $b\\leq 10^{18}$, $b-a \\leq 10^6$
- Pre sadu $05$ a $06$ platí, že $t=1,000$, $a=2$, $b\\leq 10^{18}$
- Pre zvyšné sady neplatia žiadne špeciálne podmienky.

## Príklad

```vstup
2
4 11 2
4 11 3
```

```vystup
4
2
```
","# Okná sa vymieňajú

Opäť úloha podľa môjho gusta. Dôvod, prečo sa mi páči je ten, že na jej riešenie nie je potrebné dostať správny nápad, ale postupne zlepšovať riešenie v sérii malých krokoch. Nuž a tieto kroky si v tomto vzorovom riešení ukážeme.

## Pomalý začiatok

Keď si nevieme poradiť s nejakou úlohou, vždy je dobré začať pomalým riešením, poprípade sa pozrieť na malé príklady a zistiť, ako sa to správa na nich. Začneme teda tak, že si naprogramujeme jednu funkciu, ktorá bude simulovať náš komprimátor -- bude zisťovať počet jednotiek v binárnom zápise čísla $a$, a druhú funkciu, ktorá bude počítať, koľkokrát musíme použiť tento komprimátor na to, aby sme z čísla $a$ dostali číslo $1$. Takéto niečo by malo byť veľmi jednoduché na naprogramovanie a nemali by ste s tým mať problém.

Následne spustíme náš program na prvých $100$ číslach a pozeráme, aké výsledky dostávame. Prekvapivo, sú to všetko veľmi malé čísla, najväčšie, ktoré nájdeme je $3$. Skúsime to pre prvých milión čísiel a zistíme, že najväčší počet komprimácií, ktorý vieme dosiahnuť je $4$. To vyzerá nanajvýš podozrivo, skúsme sa teda zamyslieť, prečo sú tieto čísla také malé.

Keď sa pozrieme na formát vstupu, zistíme, že najväčšie číslo, ktoré môžeme dostať je $10^{18}$ -- čo je číslo, ktoré sa pohodlne zmestí do $64$ bitovej premennej. To ale znamená, že najviac $64$ bitov môže byť rovných $1$.^[Dokonca je to len $63$, keďže prvý bit sa používa ako znamienko.] Teda po prvej komprimácii ľubovoľného čísla v našom rozmedzí $l$ až $h$ dostaneme číslo menšie ako $64$. A pre takto malé čísla už vieme, že na komprimáciu na $1$ potrebujeme najviac $3$ komprimácie. To znamená, že najväčšie $k$, pre ktoré existuje nenulová odpoveď je $4$.^[Je zaujímavé si všimnúť, že na to, aby sme dostali odpoveď $5$ potrebujeme číslo $2^{127}$. A na odpoveď $6$ až číslo $2^{2^{127}}$, čo je oveľa viac ako počet atómov vo vesmíre. Táto pomerne pomaly rastúca funkcia sa volá hviezdičkový logaritmus.]

Toto pozorovanie bude veľmi kľúčové pre ďalší postup. Aj bez neho však máme veľmi jednoduché riešenie, ktoré pre každé číslo $l$ až $h$ zistí, koľko potrebuje komprimácií aby z neho vzniklo číslo $1$ a ak sa toto číslo rovná $k$, zväčší o jedna svoju odpoveď.

## Od stredu k riešeniu

Interval $l$ až $h$ je pomerne veľký, môže obsahovať veľké množstvo čísiel. Predchádzajúce pozorovanie nám však vraví, že po prvom kroku budú všetky čísla komprimované na niečo menšie ako $64$. Skúsime to teda riešiť od tohoto zlomového okamihu, po prvej komprimácií, a skúsime spočítať všetky vhodné čísla. Z hodnoty čísla $k$ vieme, že musíme spraviť ešte $k-1$ komprimácií. Pozrieme sa teda na prvých $63$ čísiel a zistíme, ktoré z nich potrebujú ešte $k-1$ komprimácií na to, aby sme dostali $1$. Do nášho riešenia teda chceme zarátať všetky čísla, ktoré sa po prvej komprimácii zmenia na niektoré z týchto čísiel. Dokopy totiž budú potrebovať práve $k$ komprimácií.

Nuž a čo vieme povedať o čísle, ktoré sa skomprimuje na číslo $a$? Že v jeho binárnom zápise sa nachádza práve $a$ jednotiek. Uvedomme si teraz, že ak by sme vedeli odpovedať na nasledovnú otázku, máme vyhrané: \`\`Koľko je takých čísiel medzi $l$ a $h$, že majú práve $a$ jednotiek v binárnom zápise?''

Náš program by teraz vyzeral nasledovne. Predrátali by sme si riešenie pre prvých $63$ čísiel. Následne by sme cez ne prešli a vždy, keď by nejaké číslo $a$ potrebovalo $k-1$ komprimácií, k výsledku by sme pripočítali počet čísiel medzi $l$ a $h$, ktoré majú $a$ jednotiek v binárnom zápise. Každé také $a$ nám dá vlastnú nezávislú množinu čísiel, všetky dokopy dávajú odpoveď. Ostáva už len zistiť, ako odpovedať na našu otázku.

## Jedno ohraničenie namiesto dvoch

Tento trik by mal byť pomerne známy a dá sa veľmi pekne využiť aj v našej úlohe. Otázka, ktorú sa pýtame má dve ohraničenia $l$ a $h$. Veľmi ľahko to však vieme zmeniť len na to horné. Presnejšie, budeme chcieť vedieť, koľko je takých čísiel menších alebo rovných ako $h$, že potrebujú $k$ komprimácií. Toto nám samozrejme dá nejaké čísla navyše. To sú ale tie čísla, ktoré potrebujú $k$ komprimácií a sú menšie alebo rovné ako $l-1$. Ak teda máme funkciu, ktorá odpovedá na našu otázku pre horné ohraničenie, na interval to vieme zmeniť odčítaním riešení pre $h$ a $l-1$.

Takéto zjednodušenie nám môže výrazne pomôcť pri programovaní aj rozmýšľaní, lebo nám stačí dodržiavať len jednu podmienku. V tomto prípade to bude značná pomoc.

## Posledný kúsok

Postupne sme si teda našu úlohu značne zmenili a teraz sa pýtame, koľko existuje čísiel menších ako $h$, ktoré majú práve $a$ jednotiek v binárnom zápise. Poďme si tieto čísla postupne vytvárať, jednu cifru za druhou. A, samozrejme, myslíme binárne cifry.

Predstavme si, že číslo $h$ máme zapísané po binárnych cifrách v poli $H[]$, ktoré má $n$ políčok a na $0$-tej pozícii je najmenej významná cifra. Budeme postupne vytvárať všetky čísla, ktoré sú nanajvýš takto veľké a obsahujú $a$ cifier $1$. Všetky tieto čísla naviac budú mať $n$ cifier aj keby mali začínať prebytočnými nulami.

Zjavne $H[n-1]=1$, lebo najdôležitejšia cifra musí byť $1$. A ako môže vyzerať naše vytvárané číslo? To bude mať na pozícii $n-1$ buď cifru $1$ alebo $0$. Ak tam dáme 0, tak bez ohľadu na to ako bude číslo pokračovať, naše hľadané číslo bude menšie ako $h$. Takže chceme splniť už len to, aby malo aj správny počet jednotiek. Koľkými spôsobmi vieme uložiť $a$ jednotiek na $n-1$ pozícii? To je jednoduché kombinačné číslo $n-1$ nad $a$. Všetky tieto čísla teda môžeme pričítať do výsledku. V prípade, že na pozíciu $n-1$ dáme $1$, musíme pokračovať v skúšaní ďalších cifier. Minuli sme si jednu jednotku, takže ich chceme rozdať už len $a-1$.

Pokračujeme teda v skúšaní možností pre pozíciu $n-2$, $n-3$, ... Pokiaľ narazíme na cifru $1$ vyriešime to ako v predošlom prípade, ak nájdeme v $H$ cifru $0$, tak naše hľadané čísla (tie ktoré sme ešte nezapočítali) musia mať na rovnakej pozícii tiež nulu, inak by boli väčšie ako $h$.

Takto pokračujeme až kým neprídeme na začiatok poľa $H$. No a medzičasom sme zrátali všetky možné čísla, ktoré môžu slúžiť ako výsledok.

## Rekapitulácia

Ako teda vyzerá celé riešenie pokope? Na začiatku načítame vstup a spravíme nejaké predrátania. Presnejšie, zrátame odpoveď pre prvých $63$ čísiel a predpočítame si Pascalov trojuholník do hĺbky $63$. Ten nám bude slúžiť na to, aby sme vedeli rýchlo povedať hodnotu jednotlivých kombinačných čísiel. Stačí nám to počítať do dvojrozmerného poľa postupne od malých hodnôt k väčším, klasickým prístupom -- sčítame dve susedné z predošlého riadku.

Pokračujeme tým, že vyrátame výsledok pre horné ohraničenie $h$. Toto číslo si zmeníme na binárne. Potom prechádzame prvých $63$ čísiel a vždy, keď vidíme, že nejaké číslo $a$ má riešenie $k-1$ komprimácií, zistíme počet čísiel menších ako $h$, ktoré obsahujú $a$ jednotiek v binárnom zápise. Toto zistíme vyššie popísaným dynamickým programovaním cez jednotlivé cifry.

Od výsledku odrátame výsledok pre horné ohraničenie $l-1$ a máme výsledok pôvodnej úlohy. Zostáva už len odhadnúť časovú a pamäťovú zložitosť. Nebudeme sa tváriť, že $63$ je konštanta, lebo to vzniklo ako logaritmus čísla $h$ a tak to aj budeme označovať. Pamätať si musíme binárny zápis čísla $h$ a Pascalov trojuholník, ktorý je kvadratický, takže pamäťová zložitosť bude $O(\\log^2 h)$. A časová zložitosť bude úplne rovnaká, keďže pre najviac $\\log h$ čísiel pustíme dynamiku so zložitosťou $O(\\log h)$.
",10
410ae74054fc7965,ksp,"﻿# Zašpinení programátori

Zlé jazyky hovoria, že programátori sa neumývajú. Celé dni a noci vraj nerobia nič iné, iba sa aktívne vyhýbajú sprche. To ale vôbec nie je pravda! Kde sa nabrali také hrozné fámy? Programátori sú predsa čistotní! Vedci z Katedry Sprchovania a Plávania sa teda rozhodli vyšetriť, ako to naozaj je.

V sprche používanej $n$ programátormi je kopa sprchových gélov poukladaných jeden na druhom. Vždy, keď sa niekto sprchuje, vyberie svoj sprchový gél z kopy, čím sa všetky gély, ktoré boli nad ním, posunú nižšie. No a keď sa dosprchuje, položí svoj gél na samý vrch kopy. Každý programátor sa pritom sprchuje najviac raz denne (inak by sa rozpustil, však áno) a v kope má práve jeden vlastný sprchový gél, ktorý je označený tak, aby si ho nepomýlil.

Vedci si zaznamenali, ako vyzerala kopa gélov ráno a ako vyzerala večer, po tom ako sa všetci programátori (ktorí chceli) dosprchovali. Z týchto údajov chcú zistiť, koľko najviac a koľko najmenej programátorov sa počas dňa mohlo osprchovať.

## Úloha

Na vstupe dostanete dva popisy kopy so sprchovými gélmi, jeden z rána a jeden z večera.

Každý sprchový gél je označený jedným číslom od $1$ po $n$. Čísla sa vrámci jedného popisu neopakujú. Popisy ranného a večerného zásobníka budú teda dve permutácie čísiel od $1$ po $n$. Zistite, koľko najmenej a koľko najviac programátorov sa mohlo počas dňa osprchovať, aby to zodpovedalo danému stavu zásobníka.

## Formát vstupu

Prvý riadok vstupu obsahuje prirodzené číslo $n$, udávajúce počet programátorov a teda aj počet sprchových gélov v kope.

Ďalšie dva riadky obsahujú popis kopy ráno a večer -- permutáciu $n$ čísiel od $1$ po $n$ oddelených medzerami. Čísla sú napísané v poradí od spodku kopy po vrch.

| Číslo sady | 1 | 2 | 3 | 4 | 5 | 6 | |---------------------| ---:| ---:| ---:| ---:| ---:| ---:| | Počet gélov ($n$) | $5$ | $50$ | $500$ | $5,000$ | $50,000$ | $500,000$ |

## Formát výstupu

Vypíšte dva riadky, každý obsahujúci jedno celé číslo. V prvom riadku bude najmenší počet programátorov, ktorí sa mohli v ten deň osprchovať, v druhom najväčší možný počet.

## Príklad

```vstup
5
1 5 3 2 4
1 3 4 5 2
```

```vystup
2
5
```

*Presunutím jedného čísla z prvej permutácie na jej koniec sa nám nikdy nepodarí vytvoriť druhú permutáciu. Sprchovať sa preto museli aspoň dvaja programátori a to najskôr programátor s gélom číslo 5 a potom s gélom číslo 2.*
","# Zašpinení programátori

Poďme si princíp vysvetliť na príkade. Majme 7 sprchových gélov, ktoré boli na začiatku na kope v stave `0, 1, 2, 3, 4, 5, 6` a po jednom dni sprchovania v stave `0, 1, 3, 4, 6, 5, 2` (v týchto príkladoch za ""spodok"" kopy považujeme ľavú stranu riadku).

## Najmenší možný počet

Keď sa programátor sprchuje, tak vytiahne svoj sprchový gél z ľubovoľnej pozície v kope a položí ho na vrch kopy. To nič nemení na kope pod ním ani nad ním, okrem najvyššej pozície. Preto, ak sa spodky počiatočnej aj výslednej kopy zhodujú, znamená to, že tieto gély neboli použité -- v našom prípade gély `0, 1`. Použitý gél sa prejaví tak, že chýba vo výslednej postupnosti na svojom očakávanom mieste -- gél `2` v druhej postupnosti chýba. Gély nad ním (ak nie sú použité) sú ale stále v nezmenenom poradí -- gély `3, 4`. Ďalej je pôvodné poradie opäť narušené, lebo bol použitý gél `5`.

Vo výslednej postupnosti na pôvodných miestach teda chýbajú gély `2, 5`, a preto je v tomto príklade odpoveďou $2$.

## Najväčší možný počet

Tu je odpoveď celkom zrejmá. Každý programátor sa sprchuje najviac raz za deň. Nech výsledná kopa vyzerá akokoľvek, vždy ju vieme vytvoriť tak, že sa osprchujú všetci programátori práve v poradí, v akom sú gély vo výslednej kope. Teda, ak sa chce sprchovať čo najväčší počet programátorov, každý sa bude sprchovať práve raz. Odpoveď je teda $n$.

## Poďme implementovať

Základná myšlienka algoritmu je, že máme 2 ukazovatele, jeden do každého z dvoch polí. Najskôr ukazujú na počiatočnú pozíciu. Máme tiež premennú, kde si pamätáme, koľko použitých šampónov sme našli.

Ak sa čísla šampónov, na ktoré ukazovatele ukazujú, zhodujú, oba sa posunú o jednu pozíciu doprava. Našli sme nepoužitý gél.

Ak sa niekde nezhodujú,^[Tak hurá! Niekto prekonal svoju averziu k vode a osprchoval sa!] zvýšime počet osprchovaných programátorov a preskočíme použitý gél v pôvodnej postupnosti (posunieme ukazovateľ o jedno doprava). Postupnosti sa budú zhodovať, až kým nenájdeme ďalší použitý gél.

Postup opakujeme, kým neprejdeme celú pôvodnú postupnosť. Na konci budeme mať najmenší možný počet osprchovaných programátorov.

### Zložitosti

Z popisu algoritmu je zrejmé, že časová zložitosť bude $O(n)$, lebo každú postupnosť prejdeme nanajvýš raz. Lepšia časová zložitosť sa dosiahnuť nedá, lebo musíme načítať celý vstup. Pamäťová zložitosť bude tiež $O(n)$. Lepšie to opäť nejde, lebo keď postupnosti prechádzame, musíme si aspoň jednu pamätať celú.
",5
5b89269675a7db92,ksp,"# Uzimený večer

Keď Emo pozrel von z okna a uvidel sneh, zmenil svoje plány a rozhodol sa, že päty z izby nevystrčí. Povedal si, že tento dlhý zimný večer strávi pri partičke šachu s so svojím spolubývajúcim Marcelom. Jediná šachovnica, ktorú zohnali, však bola pomaľovaná všetkými možnými farbami, a tak sa nedokázali sústrediť. Rozhodli sa preto, že ju opravia.

Zohnali si fixy všetkých potrebných farieb a povedali si, že niektoré políčka prefarbia tak, aby výsledná šachovnica bola iba dvojfarebná a farby políčok sa striedali ako biele a čierne na šachovnici. Keďže si ale fixky požičali, chcú ich čo najmenej vypísať. Koľko najmenej políčok musia prefarbiť tak, aby dostali peknú šachovnicu?

## Úloha

Máme zadanú šachovnicu veľkosti $n \\times n$, ktorej každé políčko má nejakú farbu. Zistite, koľko najmenej políčok je potrebné prefarbiť tak, aby políčka šachovnice obsahovali iba $2$ rôzne farby, ktoré sa striedajú horizontaĺne aj vertikálne (tak ako biele a čierne políčka na šachovnici).

## Formát vstupu

Farby si budeme reprezentovať celými číslami. V prvom riadku vstupu je jedno celé číslo $n$ ($1 \\leq n \\leq 500$) -- rozmer šachovnice. Nasleduje $n$ riadkov, každý z nich obsahuje $n$ medzerou oddelených celých čísel -- $j$-te číslo v $i$-tom riadku vstupu označuje farbu políčka v $i$-tom riadku a $j$-tom stĺpci šachovnice. Môžete predpokladať, že všetky čísla sú medzi $0$ a $(n ^{2}-1)$.

## Formát výstupu

Vypíšte jeden riadok obsahujúci jedno číslo -- najmenší počet políčok, ktoré je potrebné zmeniť.

## Hodnotenie

Riešenia budú testované na štyroch sadách testovacích vstupov, pre jednotlivé sady platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:-----:| | $n \\leq$ | $50$ | $200$ | $300$ | $500$ |

## Príklady

```vstup
4 
1 2 1 3
2 1 2 2
3 1 2 5
5 4 2 1
```

```vystup
8
```

*Zmenením vhodných $8$ políčok vieme dostať nasledovnú šachovnicu:*

```
1 2 1 2
2 1 2 1
1 2 1 2
2 1 2 1
```

```vstup
5
6 3 6 1 6
3 6 1 6 3
6 1 6 1 6
3 6 1 6 3
6 3 6 1 6
```

```vystup
6
```

*Buď prefarbíme všetky jednotky na trojky, alebo všetky trojky na jednotky. V oboch prípadoch musíme opraviť $6$ políčok.*
","# Uzimený večer

### O farbách políčok

Políčka, ktoré majú mať rovnakú farbu ako políčko v ľavom hornom rohu, budeme v tomto vzoráku volať _biele_ a políčka, ktoré majú mať opačnú farbu, budeme volať _čierne_. Ak si očíslujeme riadky a stĺpce šachovnice číslami $0$ až $n-1$ tak, že ľavý horný roh má súradnice $(0,0)$ a pravý dolný roh má súradnice $(n-1, n-1)$, biele políčka budú mať párny súčet súradníc a čierne nepárny^[Pri číslovaní od jednotky to platí tiež.]. Ak teda chceme o nejakom políčku zistiť, či je biele alebo čierne, stačí sa pozrieť na súčet jeho súradníc.

## Hrubá sila

Našim cieľom bolo nájsť čo najmenej políčok, ktoré treba zmeniť na to, aby bola šachovnica len dvojfarebná. Môžeme teda vyskúšať všetky možnosti -- pre všetky možnosti, na ktorú farbu nakoniec prefarbíme biele políčka vyskúšame všetky možnosti, na ktorú farbu prefarbíme čierne políčka. Pre každú takúto dvojicu farieb si prejdeme celú šachovnicu a spočítame, koľko políčok by sme museli prefarbiť. Zapamätáme si tú možnosť, pre ktorú sme toho museli prefarbiť najmenej.

Možností, ktorú farbu použijeme na biele políčka je $n^2$, pre každú z nich je $n^2-1$ možných farieb pre čierne. Skúšame teda $n^2 \\cdot (n^2-1)$ možností, čo je $O(n^4)$. Pre každú možnosť prechádzame celú šachovnicu veľkosti $n^2$, časová zložitosť algoritmu je teda $O(n^6)$. Musíme si pamätať celú šachovnicu a zopár premenných navyše, takže naša pamäťová zložitosť je $O(n^2)$.

## Polohrubá sila

Aby sme nemuseli pre každú dvojicu farieb prechádzať celú šachovnicu, môžeme si pre každú z $n^2$ farieb spočítať, koľkokrát sa nachádza na bielom políčku a koľkokrát na čiernom políčku. Keď potom chceme pre nejakú dvojicu farieb zistiť, koľko políčok by sme museli prefarbiť, stačí nám od počtu všetkých políčok ($n^2$) odrátať počet bielych políčok, ktoré už majú správnu farbu a počet čiernych políčok, ktoré už majú správnu farbu.

Časová zložitosť sa nám zníži na $O(n^4)$. Pôvodnú šachovnicu si už pamätať nepotrebujeme, musíme si však pamätať počet výskytov na bielych a čiernych políčkach pre každú z $n^2$ farieb. Pamäťová zložitosť teda ostáva $O(n^2)$.

## Vzorové riešenie

### Jedna farba

Pozrime sa najprv na jednoduchší prípad, v ktorom by jedna farba šachovnice bola už opravená, napríklad biela, a my by sme potrebovali opraviť tú druhú.

Máme na šachovnici na čiernych políčkach rôzne farby a chceme vybrať jednu, na ktorú potom prefarbíme všetky ostatné čierne políčka. Z toho je zrejmé, že ak vyberieme farbu, ktorá sa na čiernych políčkach vyskytuje najviac, budeme potrebovať najmenej prefarbovania. Riešením by bolo zrátať pre každú farbu, koľkokrát sa na čiernych políčkach vyskytuje a následne vybrať farbu s maximálnym výskytom (ale nie tú, ktorou sú vyfarbené biele políčka). Stačí potom ostatné políčka prefarbiť na ňu.

## Celá šachovnica

Ak by sme chceli predchádzajúce riešenie použiť na celú šachovnicu, narazíme na jeden problém. Mohlo by sa nám stať, že pre biele aj čierne políčka šachovnice vyberieme rovnakú farbu. To by ale potom nebola šachovnica, lebo by bola celá jednofarebná. Tento problém vyriešime tak, že si pre biele aj čierne políčka nájdeme dve najčastejšie sa vyskytujúce farby. Ak sa nám potom stane, že najčastejšie sa vyskytujúca farba je pre oba typy políčok rovnaká, pre jeden z nich využijeme druhú najčastejšiu farbu.

Máme pritom dve možnosti: buď vezmeme najlepšiu farbu pre biele políčka a druhú najlepšiu pre čierne, alebo najlepšiu pre čierne a druhú najlepšiu pre biele. Vyskúšame teda obe z nich a vyberieme si tú lepšiu.

## Implementácia

Najprv chceme hľadať najčastejšiu farbu pre biele aj čierne políčka. Mohli by sme pre každú farbu prejsť celú šachovnicu a spočítať, koľkokrát sa vyskytuje na oboch typoch políčok. Ak by ale malo každé políčku inú farbu, trvalo by nám to až $O(n^2 \\cdot n^2)$. Vytvoríme si preto pole veľkosti $n^2$, v ktorom si budeme pre jednotlivé farby pamätať, na koľkých bielych políčkach sa vyskytujú. Také isté pole si vytvoríme aj pre výskyty na čiernych políčkach. Teraz nám stačí jedno prejdenie šachovnice. Pri každom políčku sa pozrieme, či je to biela alebo čierna pozícia a potom do vhodného prvku príslušného poľa prirátame jedna. Po prejdení celej šachovnice máme zrátané výskyty všetkých farieb na oboch typoch pozícií.

Potrebujeme teraz nájsť dve najväčšie hodnoty v oboch poliach. Mohli by sme naše polia utriediť a potom použiť najväčšie hodnoty. To by nám ale trvalo až $O(n^2 \\log n^2)$. Namiesto toho nám stačí obe naše polia raz prejsť. Pritom si budeme v dvoch premenných pamätať, aké su dve najčastejšie farby a pri prechádzaní poľa to postupne aktualizovať. Takto nám nájdenie najčastejších farieb bude trvať už len $O(n^2)$.

Potom nám už len stačí na základe početnosti najčastejších a druhých najčastejších farieb vybrať, akou farbou ofarbíme čierne políčka a akou biele. Počet políčok, ktoré treba prefarbiť, zrátame ako $n^2$ mínus počet políčok (bielych aj čiernych), ktoré už majú správnu farbu.

V riešení najprv načítame celú šachovnicu, pričom si rátame počty farieb na bielych a čiernych pozíciách. To nám trvá čas $O(n^2)$. Následne hľadáme najčastejšie farby jedným prejdením v dvoch poliach veľkosti $n^2$ a to nám bude tiež trvať $O(n^2)$. Celková časová zložitosť bude preto $O(n^2)$. Keď sa pozrieme na pamäť, pamätáme dve polia pre výskyty farieb, ktoré majú veľkosť $2n^2$. Výsledná pamäťová zložitosť je teda $O(n^2)$.
",2
f4b8398078b751e7,ksp,"# Obojstranná čokotuba

Samo a Jano sú influenceri. Od čokofirmy dostali masívnu reklamnú obojstrannú tubu rôznofarebných čokoládiek pre dvojičky. Vraj aby sa odfotili, ako im chutí a aké skvelé to je, že sa nemusia hádať, kto si vytiahne čokoládu prvý. Každý vie, že rôzne farby čokoládiek znamenajú rôzne obsiahnuté živiny. Keďže Samo a Jano chcú všetkým ukázať, ako vyvážene sa stravujú, zrátali si, koľko ktorých čokoládiek chcú zjesť. Dve purpurové, šesť egyptských modrých, jedna nachová, tri indigové, sedem sivých...

Tuba s čokoládkami je otvorená z dvoch strán. Samo a Jano začali zbesilo vyťahovať čokošky z jednej strany. Keď nejakú vytiahnú, tak ju rovno aj zjedia, aj keď nepatrí do ich požiadaviek na vyváženú stravu. Keby ju nezjedli, určite by sa niekde stratila. To by bola škoda. Rýchlo si však uvedomili, že čím viac nechcených čokoládiek zjedia, tým horšiu mienku o nich budú mať ich sledovatelia.

Nuž, Samo začal hútať, koľko čokoládiek z ktorej strany to majú vlastne vybrať, aby sa najedli čo najmenej, ale aby zároveň uspokojili svoje potreby vyváženej stravy. Ak budú musieť tých zlých čokolád zjesť priveľa, nebudú ani chcieť pristúpiť na takúto ponuku sponzora. A podobných ponúk určite príde ešte veľa. Hodil by sa im preto program, ktorý pre danú tubu čokoládiek a ich potreby vyváženej stravy vypočíta, koľko najmenej čokoládiek budú musieť vytiahnúť, aby sa dostali k tým, čo chcú. Pomôžete im udržať priazeň publika?

## Úloha

Tuba je priehľadná a otvorená z dvoch strán. Vnútri sú čokoládky naskladané v rade vedľa seba. Samo a Jano chcú vybrať z tuby **aspoň** $a_1$ čokoládiek farby $f_1$, **aspoň** $a_2$ čokoládiek farby $f_2$, ..., **aspoň** $a_m$ čokoládiek farby $f_m$.

Vašou úlohou je zistiť, koľko najmenej čokoládiek musia dokopy z tuby vybrať tak, aby splnili svoje požiadavky. V každom momente môžu vybrať buď čokoládku úplne zľava, alebo čokoládku úplne sprava.

## Formát vstupu

Na prvom riadku dostanete čísla $n$ - počet všetkých čokoládiek v tube, $m$ - počet Samových a Janových požiadaviek a $f$ - počet rôznych farieb čokoládiek, ktoré sa môžu vyskytovať v tube. Platí, že $1 \\leq f \\leq n \\leq 500,000$ a $0 \\leq m \\leq f$.

Na druhom riadku je $n$ čísiel $c_1$ až $c_n$ - farby čokoládiek tak, ako sú v tube zľava doprava. Farby majú čísla od $1$ po $f$. To však neznamená, že sa na vstupe musia nutne vyskytovať všetky farby od $1$ po $f$.

Nasleduje $m$ riadkov. V $i$-tom z nich sú čísla $a_i$ a $f_i$. Tie znamenajú, že Samo a Jano chcú z tuby vybrať **aspoň** $a_i$ čokoládiek farby $f_i$. Môžete predpokladať, že všetky $f_i$ sú navzájom rôzne a tiež, že pre zadanú tubu sú všetky požiadavky vždy splniteľné.

## Formát výstupu

Na výstup vypíšte jedno číslo - koľko najmenej čokoládiek musia Samo s Janom z tuby vybrať, aby splnil všetky svoje požiadavky.

## Príklady

```vstup
6 2 3
1 2 2 1 3 2
1 1
3 2
```

```vystup
4
```

*Naši súrodenci chcú jednu čokoládu farby 1 a tri čokolády farby 2. Môžu teda zobrať napríklad 3 čokolády zľava a jednu sprava.*

```vstup
5 1 3
1 2 2 3 1
1 2
```

```vystup
2
```

*Teraz chcú iba jednu čokoládu farby 2. Tá ale nie je na kraji, tak sa k nej musia dostať cez najľavejšiu čokoládu farby 1.*
","# Obojstranná čokotuba

## Iba jedna strana

Pozrime sa, ako by sa úloha zmenila, keby sme mohli brať čokolády iba zľava. Skúsme všetky možnosti a pre každú overme, či vyhovuje. Najskôr teda overíme, či nám stačí zobrať iba prvú čokoládu. Potom skúsime zobrať prvú a druhú, potom skúsime prvú, druhú a tretiu... Z vyhovujúcich možností zoberieme tú najkratšiu. Ako ale zistiť, či možnosť vyhovuje?

Pre každú testovanú možnosť si zrátame, koľko čokolád ktorej farby obsahuje. Majme pole $p$ veľkosti $f$ so samými nulami. Číslo $p_i$ nám hovorí, koľko čokolád farby $i$ momentálne máme. Ak zoberieme čokoládu farby $u$, tak ku $p_u$ pripočítame $1$. Keď si teda napočítame čokolády v testovanom úseku, môžeme prejsť všetky požiadavky a pre každú požiadavku overiť, či je splnená. Takéto riešenie jednoduchšej úlohy bude fungovať v čase $O(n(n + m + f))$, pretože pre každú z $n$ možností prejdeme nanajvýš $n$ políčok, vynulujeme pole $p$ veľkosti $f$ a prejdeme všetkých $m$ požiadaviek.

## Iba jedna strana, rýchlejšie

V pôvodnom riešení sme veľa vecí robili zbytočne. Napríklad, ak sme už poznali počty čokolád v úseku $[1,,x]$ a chceli sme zistiť počty čokolád v úseku $[1,,x+1]$, nemuseli sme nulovať celé pole $p$. Úplne nám stačí pridať do poľa $p$ čokoládu na pozícií $x+1$. Všetky ostatné čokolády totiž budú tie isté, ako v starom úseku. Ku $p\_{c\_{x+1}}$ teda iba pripočítame $1$. Teraz, keď nezahadzujeme informácie zo skúmania predchádzajúcej možnosti, vieme každú novú možnosť spracovať v $O(m)$. Možností je stále $n$, takže časová zložitosť je $O(f + nm)$. Stále totiž pre každú možnosť prechádzame cez všetky požiadavky. Pole $p$ však nastavujeme už iba raz.

## Iba jedna strana, ešte rýchlejšie

Asi je celkom očividné, že slabou časťou nášho doterajšieho riešenia je to, že pre každú možnosť prechádzame všetky požiadavky, aby sme overili, či sú splnené. Ako to zlepšiť?

Vieme, že keď sme ešte nezobrali žiadnu čokoládu, tak nie je splnená žiadna požiadavka. Majme teda počítadlo $nesplnene$, ktoré bude hovoriť, koľko máme ešte nesplnených požiadaviek. Na začiatku, je samozrejme nastavené na $m$. Postupne pridávame čokolády, až niekedy nastane zaujímavá udalosť. Pridaním čokolády farby $w$ sa nám mohol zvýšiť počet týchto čokolád na minimálnu hranicu požadovanú Samom a Janom. To znamená, že požiadavka na čokolády farby $w$ doteraz nebola splnená, ale teraz už splnená je. Môžeme teda od $nesplnene$ odčítať $1$.

Keď niekedy $nesplnene$ dosiahne hodnotu $0$, vieme, že už sú všetky požiadavky splnené. Nemusíme teda už ani skúšať brať ďalšie čokolády. Určite by sme tým už nenašli lepšie riešenie, ako máme teraz.

Ako ale zistiť, že nejaká požiadavka doteraz nebola splnená a teraz už je? Na začiatku si spravíme pole $t$ veľkosti $f$, ktoré nám pre každú farbu povie, koľko jej je žiadanej. To vieme spraviť už počas načítavania požiadaviek. Potom s týmito hodnotami vieme porovnávať hodnoty z poľa $p$. Ak doteraz platilo, že $p_i < t_i$ a zobratím nejakej čokolády farby $i$ začalo platiť, že $p_i = t_i$, tak požiadavka na farbu $i$ je už splnená. Časová zložitosť teda bude $O(n + m + f)$.

## Dve strany, hrubá sila

Jednoduchým riešením pôvodnej úlohy je vyskúšať všetky možnosti pre zobratie prefixu a suffixu a každú takúto možnosť overiť. Podľa toho, ako dobre spravíme overovanie môže mať toto riešenie časovú zložitosť zhruba niekde medzi $O(n^2)$ a $O(n^3)$. Rôzne spôsoby overovania sme si popísali vyššie.

## Dve strany, vzorové riešenie

Poďme sa ale pozrieť, ako môžeme riešenie úlohy, kde berieme čokolády iba zľava rozšíriť na obojstrannú verziu.

V jednoduchšej úlohe sme spravili pozorovanie, že ak vieme splniť požiadavky najľavejšími $x$ čokoládami, tak už nemusíme skúšať brať ďalšie, pretože by sme tým určite nezískali lepšie riešenie. Ako toto pozorovanie využiť? Nuž, skúsme nezobrať žiadne čokolády sprava. Zľava teraz zoberieme iba toľko čokolád, koľko nám stačí na splnenie všetkých požiadaviek. Máme teda nejaké riešenie. Možno je najlepšie, možno nie, no určite spĺňa všetky požiadavky. No dobre, zľava už určite nechceme zobrať viac čokolád.

Čo ale sprava? Čo sa môže stať, keď zoberieme naviac ešte jednu čokoládu sprava? Ak to bola čokoláda, ktorej farba sa nijak nevyskytuje v požiadavkách, tak nič neriešime. Zhoršili sme si síce doterajšie riešenie, ale to nás nijak netrápi, pretože výsledok lepšieho riešenia si pamätáme ako doteraz najlepšie nájdené. Čo sa ale stane, ak sa farba najpravejšej čokolády nachádza niekde v požiadavkách na vyváženú stravu? Znamená to, že možno môžeme na ľavú stranu vrátiť čokoládu, ktorú sme odtiaľ zobrali ako poslednú. Môžeme ju vrátiť, ak má rovnakú farbu, ako tá, ktorú sme teraz zobrali sprava. No a aby sme sa z ľavej strany dostali k čokoláde, ktorú sme tam teraz vrátili, museli sme možno prejsť cez nejaké čokolády, ktoré sme vôbec nechceli. Môžeme tam teda vrátiť aj tie. A ľaľa, možno sme práve našli nové najlepšie riešenie.

Pozrime sa na to naopak. Máme riešenie, ktoré berie čokolády iba zľava. Vieme, že všetky požiadavky sú splnené. Skúsme vrátiť čokoládu, ktorú sme zobrali ako poslednú. Tým možno prestala byť splnená nejaká požiadavka. To znamená, že teraz budeme brať čokolády sprava, až kým neopravíme túto pokazenú požiadavku. Tento postup teda začne s riešením, ktoré berie iba čokolády zľava a opakuje dva jednoduché kroky:

1. Vráť na ľavú stranu čokoládu, ktorú si odtiaľ zobral ako poslednú
1. Ber čokolády sprava, kým opäť nie sú splnené všetky požiadavky

Môžeme si všimnúť, že niekedy nám vrátenie čokolády na ľavú stranu žiadnu požiadavku nepokazí. Vtedy teda nemusíme brať žiadne ďalšie čokolády sprava.

Akú to má celé časovú zložitosť? Najskôr nájdeme nejaké riešenie, ktoré berie čokolády iba zľava. To už vieme v $O(n + m + f)$. Potom vždy vrátime jednu čokoládu na ľavú stranu a zoberieme niekoľko, možno aj 0, čokolád sprava. Každú čokoládu teda najviac raz zoberieme a najviac raz vrátime. Bude to teda celé v $O(n + m + f)$. Vieme ale, že $m$ ani $f$ nikdy nebudú väčšie, ako $n$. Môžeme teda povedať, že časová zložitosť je $O(n)$.

Pamäťová vyzerá ako $O(n + m + f)$. Požiadavky si ale nemusíme pamätať ako zoznam, takže sa dostávame na $O(n + f)$ a stále platí, že $f \\leq n$, takže aj o pamäti môžeme povedať, že je $O(n)$.
",4
a1433226a4f18810,ksp,"# Výtvarný ateliér

Adam a Samo mali už odjakživa vzťah k výtvarnému umeniu, aj keď sa mu nevenujú profesionálne. Obaja išli na vysokú školu študovať nejakú odnož informatiky, no každý na inej univerzite a v inej krajine. Počas svojho štúdia sa aktívne podieľajú na príprave Korešpondenčnej Súťaže Papieroskladania. Keď sa ale naskytla ďalšia aktivita spojená s umením, neváhali a išli do toho.

V rámci medzinárodného a medziuniverzitného projektu výtvarného ateliéru Adam a Samo spolupracujú na vytváraní farebných ozdobných reťazí. Ide o reťaze, ktorých oká sú vyrobené z farebného papiera, pričom farieb je 26. Lenže, obaja už dokončili reťaze, keď zistili, že reťaze by mali byť vlastne rovnaké!

Adam je ale momentálne zahltený inými povinosťami, tak ostáva na Samovi, aby svoju reťaz patrične upravil.

Poraďte mu, ako má upraviť svoju reťaz!

## Úloha

Máte dve reťaze - Adamovu a Samovu. Reťaz má daný začiatok a koniec (neviete ju teda otočiť). Je opísaná postupnosťou farieb ôk od jej začiatku po koniec. Samo má k dispozícii nožnice, fixky, a dokonca aj predpripravené kusiská reťazí, takže vie buď:

- odstrihnúť súvislú časť reťaze a spojiť odstrihnuté miesta dokopy. Reťaz nemôže byť v procese obrátená!
  - z abcd tak môže vzniknúť _acd_, _bcd_, _bc_ ale nie _adc_ alebo _cda_
- vložiť nejaký súvislý kus reťaze medzi dve oká (alebo na koniec alebo začiatok reťaze)
  - z _abcd_ tak môže vzniknúť _ab**bb**cd_, alebo _a**efg**bcd_, alebo _**ksp**abcd_
- prefarbiť oko na inú farbu
  - z _abcd_ tak môže vzniknúť _abc**e**_

Tieto operácie vie Samo ľubovoľne kombinovať.

Chcel by ale, aby bol s výsledkom spokojný. Napríklad so svojou pôvodnou reťazou bol spokojný a je smutný, ak ju musí upravovať. Spokojnosť Samo kvantifikuje nasledovne:

- Za každé nezmenené oko (neodstránené, ani neprefarbené) je o $m$ bodov spokojnejší
- Za každý súvislý odstránený úsek je o $d$ bodov menej spokojný.
- Za každý súvislý vložený úsek je $i$ bodov menej spokojný.
- Za každé prefarbenie oka je o $r$ bodov menej spokojný.

Čísla $i$ a $r$ sú konštanty a nezávisia od dĺžky vloženého, respektíve odstráneného úseku.

Farieb existuje 26 a sú označené malými písmenami anglickej abecedy. Zistite, ako najviac spokojný môže Samo zostať, a nejaký spôsob, ako môže svoju reťaz upraviť.

## Formát vstupu

V prvom riadku vstupu sa nachádzajú štyri čísla:

- číslo, o koľko bude spokojnejší za každé nezmenené oko, $m$
- cena odstránenia súvislej časti ôk $d$,
- cena vloženia súvislej reťaze ôk $i$
- cena prefarbenia oka $r$.

Nasledujú dva riadky. V prvom z nich sa nachádza popis Samovej reťaze a na druhom popis Adamovej reťaze. Oba popisy sú reťazec z malých písmen anglickej abecedy.

Platí, že reťaze nepresahujú dĺžku $5,000$ a $0 \\leq m, d, i, r \\leq 100,000$.

## Formát výstupu

Vypíšte jeden riadok: najväčšiu spokojnosť, ku ktorej sa vie Samo dopracovať.

## Hodnotenie

Úloha má štyri sady. Maximálne dĺžky reťazí v nich budú postupne $500$, $2,000$, $2,000$ a $5,000$.

V druhej sade, navyše platí, $d = i = r = 0$, teda Samo nestráca žiadnu spokojnosť.

## Príklady

```vstup
1 2 2 1
abccb
accba
```

```vystup
0
```

*Samo by mal vymazať prvé oko s farbou 'b' zo svojej reťaze, a pridať oko s farbou 'a' na koniec. Takto sa štyroch svojich ôk nedotkne (+4 body spokojnosti), a raz odstráni 'b' (-2 body) a raz pridá 'a' (-2 body). Všimnite si, že napriek tomu, že je prefarbenie lacnejšie, než vymazanie, neoplatí sa mu.*

```vstup
3 2 2 1
asdffflp
kpfffor
```

```vystup
3
```

*Samo by mal vymazať 'asd' zo začiatku svojej reťaze a pridať tam 'kp'. Na druhej strane, mal by 'lp' zmeniť po jednom na 'or'. Takto bude $-2-2+3+3+3-1-1 = 3$ bodov spokojný*

```vstup
1 1 1 10
kms
ksp
```

```vystup
0
```

*Samo nechce prefarbovať. Najlepšie mu je teda vystrihnúť preč $m$ a pridanie $p$*

```vstup
10 1 1000 100
kspoooksp
kspkspksp
```

```vystup
-240
```

*Samo tu potrebuje zmeniť 'ooo' na 'ksp'. Pridávanie mu výrazne uberá na spokojnosti, tak radšej ich po jednom prefarbí.*
","# Výtvarný Ateliér

Ako si mohol skúsenejší riešiteľ isto všimnúť, úloha sa rieši *dynamickým programovaním*.

Zjednodušene, spočítame si hodnotu výsledku pre menšie časti zadania a skombinujeme aby sme dostali výsledok.

## Pomalé riešenie

Predstavme si, že by sme pre pozície $l$, $j$ vedeli nasledovné:

Koľko najviac spokojnosti vieme dostať, ak by sme mali len prvých $l$ ôk zo Samovej reťaze, a len prvých $j$ ôk z Adamovej reťaze a:

- Samo vymazal nejaký neprádzny koncový úsek svojich ôk. Označme toto číslo ako $D[l][j]$

- Samo na koniec svojej reťaze pridal nejaký neprázdny úsek ôk. Označme toto číslo ako $I[l][j]$

- Samo buď posledné oko nezmenil (ak sú koncové^[koncové v tomto prípade znamená $l$-te Samovo a $j$-te Adamovo oko] oká rovnaké), alebo prefarbil (ak sú rôzne). Označme toto číslo ako $M[l][j]$

Navyše, označme si najväčšiu spokojnosť akú vie Samo dostať pre takéto začiatky reťazí ako $S[l][j]$.

Všimnime si, že $S[l][j] = \\max(D[l][j], I[l][j], M[l][j])$

Predstavme si, že máme spočítanú hodnotu $S$ pre všetky skoršie začiatky (vrátane $S[l][j-1]$ a $S[l - 1][j]$). Ako z toho získať hodnotu $S[l][j]$?

Keďže $S[l][j]$ je minimum z $D[l][j], I[l][j]$ a $M[l][j]$, chceme spočítať tie.

Všimnime si, že

$$ M[l][j] = \\begin{cases} S[l-1][j-1] + m & \\text{ak sú } i \\text{-te Samovo oko a } j \\text{-te Adamovo oko rovnakej farby} \\ S[l-1][j-1] - r & \\text{ak sú rôznej farby} \\ \\end{cases} $$

Pre $I$ a $D$ vieme vyskúšať všetky možné dĺžky pridaného, resp. odstráneného úseku, teda $I[l][j]$ je maximum z $S[l][j-k] - i$, pre všetky $1 \\leq k \\leq j$. A nápodobne pre $D[i][j]$.

Takto vieme postupne prejsť všetky začiatky a napokon nájsť aj riešenie pre celé reťazce v čase $O(|S||A|(|A| + |S|))$, kde $|S|$, $|A|$ sú postupne dĺžky Samovho a Adamovho reťazca, a v pamäti $O(|S||A|)$.

## Ako rýchlejšie?

Chceli by sme zrýchliť naše riešenie. Čo robíme navyše?

Predstavme si, že okrem hodnôt $S$ si pamätáme aj hodnoty $I$, $D$ pre predchádzajúce začiatky. Potom si všimnime, že akonáhle je Samovi lepšie vložiť väčší úsek ako $1$, potom $I[l][j] = I[l][j-1]$. Inak je ideálne vložiť jediné oko, teda $I[l][j] = \\max(I[l][j-1], S[l][j-1] - i)$. Nápodobný vzorec získame pre hodnoty $D$.

Takto nám stačí pre výpočet $S[l][j]$ spraviť konštantne veľa operácií, takže dostávame časovú zložitosť $O(|S||A|)$ s rovnakou pamäťovou zložitosťou ako predtým.

## Ako to ešte zlepšiť?

Čas už nezlepšíme, ale máme tu ešte pamäť. Všimnime si, že pri počítaní $S[l][j]$ sa pozeráme len na hodnoty s indexami najmenej $[l-1][j-1]$. Teda nám stačí si pamätať posledný riadok a stĺpec výpočtu, teda iba lineárne veľa údajov.

Takže dostávame pamäťovú zložitosť $O(|S| + |A|)$.

## Máme to naozaj vyriešené?

A naozaj, v riešení hore sme sa nezmienili čo robiť so $S[l][j]$, keď je jedno z indexov $0$. Schválne, čo jediné môže Samo spraviť ak má on alebo Adam prázdny string?
",8
20286f66a18076bd,ksp,"# Zásuvky

V T2^[Tajná KSP miestnosť na Matfyze.] sa počas dňa vyskytuje veľa programátorov a tí chcú, samozrejme, používať svoje notebooky. Notebooky musia byť zapojené do elektriny, keďže baterka sa im minula pri používaní počas prednášok. V T2 je našťastie obrovská predlžovačka s $n$ zásuvkami.

Problém však nastal, keď si $m$ KSP-ákov kúpilo nové Macbooky, ktoré majú najmodernejšie, revolučné a absolútne nepraktické zástrčky.^\[Ak si ešte stále nie ste istí pri používaní slov zástrčka a zásuvka, [tento článok](http://slovensky.diskusneforum.sk/clanky/zastrcka-nie-je-zasuvka/) vám určite pomôže.\] Sú o niečo širšie ako tie klasické a aj keď sa dajú strčit do slovenskej zásuvky, na každej strane z nej trochu prečnievajú. Keď ich teda zastrčíte do predlžovačky, obe susedné zásuvky na predlžovačke sú blokované a nedá sa do nich vložiť žiadna iná zástrčka. To ale výrazne obmedzuje efektivitu spomínanej predlžovačky a KSP-ákov trápi, či si vôbec vedia všetci nabíjať svoje notebooky súčasne.

## Úloha

Máme predlžovačku s $n$ zásuvkami, $m$ počítačov so širokými macovskými zástrčkami a $k$ počítačov s normálnymi (úzkymi) zástrčkami. Zistite, či sa všetkých $m+k$ zástrčiek dá povkladať do predlžovačky. Normálna zástrčka zaberie práve jednu zásuvku a macovská zástrčka zaberie jednu zásuvku a zablokuje obe susedné zásuvky. Medzi dvoma macovskými zástrčkami však stačí mať jednu voľnú zásuvku.

## Formát vstupu

Na prvom riadku dostanete $n$ ($1 \\leq n \\leq 10^9$) -- počet zásuviek v predlžovačke. Na druhom riadku budú čísla $m$ a $k$ ($0 \\leq m, k \\leq 10^9$) -- počet macovských a počet normálnych zástrčiek.

## Formát výstupu

Vypíšte `ano` ak sa notebooky zapojiť dajú a `nie`, ak to žiadnym spôsobom nejde.

## Príklad

```vstup
7
3 1
```

```vystup
ano
```

\_Rozložiť sa dajú napríklad takto: momonom (macovské -- m, normálne -- n, prázdna zásuvka -- o). Všimnite si, že širokým koncovkám stačí medzi sebou iba jedna medzera. \_

```vstup
5
1 2
```

```vystup
ano
```

\_Napríklad rozloženie nomon. \_

```vstup
2
1 2
```

```vystup
nie
```

_Žiadnym spôsobom sa nepomestia, nemáme totiž ani dostatok zásuviek._

```vstup
4
2 1
```

```vystup
nie
```
","# Zásuvky

Máme predlžovačku s $n$ zásuvkami, do ktorej chceme vsunúť $k$ normálnych úzkych zástrčiek a $m$ širokých zástrčiek, ktoré po zasunutí zaberú miesto aj v susedných zásuvkách. Ako sa však dalo všimnúť v ukážkovom príklade, dve široké zástrčky vieme zastrčiť tak, že je medzi nimi len jedna voľná zásuvka.

Je jasné, že hlavný problém je, ako pozastrkávať široké zástrčky tak, aby zabrali čo najmenej miesta. Zdá sa, že vhodné miesto pre širokú zástrčku je na kraji predlžovačky. Ak ju totiž dáme na kraj, zaberie iba dve zásuvky. Z jednej strany totiž prečnieva ponad koniec predlžovačky. Jediná susedná zásuvka krajnej zásuvky bude určite zablokovaná, no do tretej zásuvky v poradí však môžeme dať aj úzku aj širokú zástrčku. Zbavili sme sa teda jednej širokej zástrčky a našu predlžovačku sme si skrátili na $n-2$ zásuviek.

Túto myšlienku sa nám však oplatí zopakovať opäť, až kým nevyčerpáme všetky široké zástrčky. Tie umiestníme čo najviac na jeden kraj predlžovačky, čo najbližšie k sebe. Každá zaberie dve zásuvky a preto nám zostane $n-2m$ zásuviek, do ktorých chceme vložiť $k$ úzkych zástrčiek. Je jasné, že to sa bude dať spraviť iba ak je $k \\leq n-2m$.

Takéto riešenie nie je problém naprogramovať, stačí predsa v čase $O(1)$ overiť túto jedinú podmienku. Teda takmer. Špeciálny prípad nastane, ak bude $k=0$, teda máme iba široké zástrčky. Vtedy nám postačuje $2m-1$ zásuviek. Takéto riešenie nám už dá na testovači plný počet bodov.

Riešenie, ktoré sme vymysleli, nazývame *pažravé*^[Po anglicky greedy.]. Všimli sme si, že je výhodné dať _jednu_ širokú zástrčku na kraj predlžovačky. _Pažravo_ sme ale usúdili, že je výhodné dať _všetky_ široké zástrčky k sebe na kraj predlžovačky. Platí to však vždy? To musíme dokázať v popise.

Najlepšie sa takéto tvrdenie dokazuje nasledovne. Zoberieme si nejaké ľubovoľné platné rozmiestnenie zástrčiek do predlžovačky. Ukážeme, že takéto rozmiestnenie vieme upraviť na naše rozmiestnenie, ktoré má široké zástrčky vedľa seba na (ľavom) kraji predlžovačky.

Prvé, čo spravíme s ľubovoľným platným rozmiestnením, bude, že posunieme všetky zástrčky čo najviac doľava, aby sme odstránili zbytočné medzery (samozrejme, nejaké zásuvky zostanú voľné, lebo budú zakryté širokými zástrčkami). Následne, ak toto rozmiestnenie ešte nevyzerá ako naše riešenie, tak niektoré dve široké zástrčky nie sú pri sebe. Medzi nimi je teda jedna, alebo viac úzkych zástrčiek.

Ak `""o""` označuje prázdnu zásuvku, `""u""` zásuvku s úzkou zástrčkou a `""s""` zásuvku so širokou zástrčkou, tak kus predlžovačky, kde niečo takéto vznikne, môže vyzerať ako `""souuoso""`. Nič však nepokazíme, ak tieto zástrčky prepojíme do tvaru `""sosouuo""`. Akurát sme odstránili problém širokých zástrčiek, ktoré neboli vedľa seba. Opakovaním tohto postupu naozaj vytvoríme rovnaké riešenie ako náš program -- široké zástrčky na kraji predlžovačky.

Vidíme teda, že ľubovoľné riešenie vieme prerobiť na nami navrhnuté riešenie. Preto je takéto riešenie určite správne.
",1
d29fe57459a63dfb,ksp,"# Oválna pracovňa

Nie je to tak dávno, čo sa do našej oválnej pracovne nasťahoval nový Týpek. Ako to už býva zvykom, nový týpek -- nové nápady. A tak hneď ako ho napadol ten najlepší, zvolal svojich poradcov do oválnej pracovne. Za okrúhlym stolom im predostrel ideu postavenia veľkého múru pred nepriateľmi. Ako ale istá americká štúdia ukázala: čím bývajú nepriatelia viac na východ, tým sú nebezpečnejší. Preto musí byť múr na východe vyšší, alebo aspoň rovnako vysoký ako na západe.

Po nekonečných rokovaniach sa všetci v oválnej pracovni zhodli, že naša krajina je v ohrození a treba začať so stavbou ihneď. Ešteže zostalo v oválnej pracovni pod stolom zopár betónových stĺpov jednotkovej šírky. Stavbu teda môžeme zahájiť, no tak ako to pri veľkých projektoch býva potrebujeme plán, ten najlepší plán.

Hoci postavenie múru nie je vôbec populistické, zlé jazyky nás môžu začať ohovárať, preto musí mať náš múr aj nejaký hlboký zmysel, napríklad umelecký. Aby sme teda pred svetom nevyzerali ako barbari, musí sa postaviť múr esteticky, teda tak, aby rozdiel výšok medzi ľubovoľnými susednými betónovými stĺpmi bol rovnaký. Okrem toho je tu už spomínaný fakt, že nepriatelia na východe sú nebezpečnejší. Preto musia výšky jednotlivých stĺpov v múre tvoriť od západu na východ neklesajúcu postupnosť.

Na obrázku môžete vidieť päť rôznych múrov.

Prvé dva z nich sú dobré. Tretí je zlý, pretože výšky stĺpov netvoria neklesajúcu postupnosť. Štvrtý tak isto (tam stĺpy tvoria klesajúcu postupnosť). Piaty múr je zlý, lebo rozdiely medzi výškami susedných stĺpov nie sú všade rovnaké.

Pomôžte zachrániť krajinu pred čo najviac nepriateľmi a navrhnite čo najdlhší múr z materiálov, ktoré sú k dispozícií.

## Úloha

Máme $n$ betónových stĺpov s danými výškami. Zistite najväčšiu možnú dĺžku (počet použitých stĺpov) neklesajúceho múru ktorý vieme postaviť tak, aby v postavenom múre mali každé dva susedné betónové stĺpy rovnaký rozdiel výšok. Nemusíte použiť všetky stĺpy zo vstupu.

## Formát vstupu

Na prvom riadku vstupu dostanete kladné celé číslo $n$. V druhom riadku bude $n$ medzerou oddelených nezáporných celých čísel $a_1, a_2, ..., a_n$ reprezentujúcich výšky jednotlivých stĺpov.

Je päť testovacích sád. Pre jednotlivé sady platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | $5$ | |:----------:|:---:|:---:|:---:|:------:|:------:| | $n \\leq$ | $20$ | $100$ | $500$ | $1,000$ | $3,000$ | | $a_i \\leq$ | $10^3$ | $10^3$ | $10^3$ | $10^9$ | $10^9$ |

## Formát výstupu

Na výstup vypíšte jediné číslo -- počet použitých stĺpov v najdlhšom možnom múre spĺňajúcom podmienky zo zadania.

## Príklad

```vstup
4
2 3 4 1
```

```vystup
4
```

_Zjavne dokážeme postaviť múr zo všetkých našich stĺpov a tiež splniť estetickú podmienku, stačí postaviť stĺpy v poradí 1, 2, 3, 4_

```vstup
5
2 1 5 2 4
```

```vystup
2
```

_Najdlhší múr vieme postaviť napríklad zo stĺpov výšok 2 a 4_
","# Oválna pracovňa

Zadanie od nás vyžaduje postaviť taký múr, že rozdiely susedných stĺpov budú všade rovnaké. To ale znamená, že výšky našich stĺpov majú tvoriť aritmetickú postupnosť. A síce výšky stĺpov vyberáme z množiny danej množiny, ak si stĺpy usporiadame podľa výšky, zmení sa náš problém na hľadanie najdlhšej aritmetickej podpostupnosti. Dokonca v zadaní je napísané, že hľadáme neklesajúcu postupnosť a preto usporiadaním stĺpov nestratíme žiadne riešenie.

## Aké aritmetické podpostupnosti sa tu nachádzajú?

Aritmetická postupnosť je definovaná 2 číslami -- prvým prvkom a diferenciou. Na to, ktorý prvok vybrať ako prvý máme $n$ možností. A pri určovaní diferencie si uvedomme, že diferencia musí byť naozaj rozdiel niektorých dvoch prvkov z našej postupnosti. V opačnom prípade totiž nevytvoríme ani podpostupnosť dĺžky 2. Máme teda najviac $n^2$ možných diferencií. Pre každý začiatočný prvok a diferenciu vieme zistiť, aká dlhá aritmetická postupnosť má takúto charakteristiku a vybrať to najdlhšie riešenie. Zložitosť takéhoto riešenia bude $O(n^4)$.

## Rýchlejšie riešenie

Treba si ale uvedomiť, že prvý prvok nás až tak nezaujíma. Stačí si určiť hodnotu diferencie $d$. Následne si vieme klásť otázku, aká by bola dĺžka najdlhšej aritmetickej podpostupnosti s diferenciou $d$, ktorej posledný prvok leží v usporiadanom poli výšok na pozícii $x$. Túto najväčšiu dĺžku si označme $P[d][x]$.

Pre dané $d$ budeme túto hodnotu počítať postupne pre čoraz väčšie hodnoty $x$ -- teda naše pole budeme predcházdať zľava doprava. Nech $x$-tá výška má hodnotu $A[x]$. Potom vieme, že predposledný prvok tejto aritmetickej postupnosti musel mať hodnotu $A[x]-d$. Musíme, preto zistiť, na ktorom mieste v našom poli sa nachádza táto hodnota.

Jedna možnosť je, že hodnota $A[x]-d$ sa medzi našimi výškami nenachádza. V takom prípade je $P[d][x]=1$, lebo pre danú hodnotu diferencie nemohol existovať skorší prvok. V druhej možnosti, nech je hodnota $A[x]-d$ na indexe $y$. Potom zase vieme, že dĺžka najdlhšej podpostupnosti končiacej na indexe $x$ bude $P[d][x] = 1 + P[d][y]$. A keďže $y < x$, tak hodnotu $P[d][y]$ už máme vypočítanú.

Pre každú kladnú diferenciu $d$ (0 ošetríme zvlášť) teda prejdeme poľom `A[]` a vyplníme pole `P[d][]`. Jediné, čo potrebujeme vedieť robiť rýchlo je povedať, na ktorom indexe, ak vôbec, leží nejaké číslo. Toto môžeme robiť pomocou `set`u v čase $O(\\log n)$, alebo pomocou hash tabuľky v čase $O(1)$. Dokopy dostaneme časovú zložitosť $O(n^3)$.

## Vzorové riešenie

To už ale nie sme ďaleko od vzorového riešenia. Stačí si uvedomiť, že diferenciu si nepotrebujeme určovať dopredu. Aritmetickú postupnosť predsa jednoznačne určujú aj jej posledné dva prvky.

Takže našu otázku upravíme: aká by bola dĺžka najdlhšej aritmetickej postupnosti, ak by posledné dva prvky boli na indexoch $x$ (posledný prvok) a $y$ (predposledný prvok)? Označme si túto hodnotu $D[x][y]$.

Je jasné, že diferencia takejto postupnosti je $d=A[x]-A[y]$. Opäť nás teda bude zaujímať, na ktorom indexe, ak vôbec, leží číslo $A[y]-d$. V prípade, že táto hodnota sa v poli nenachádza, tak $D[x][y]=2$, pretože tieto dva prvky tvoria našu postupnosť a nič iné pred nimi nemôže byť. Ak sa však hľadaná hodnota nachádza na indexe $z$, tak platí, že $D[x][y] = 1 + D[y][z]$.

Tak ako v predchádzajúcom riešení budeme pole `D[][]` vypĺňať postupne od najmenších hodnôt $x$ a $y$, aby sme na riešenie s veľkými hodnotami mohli použiť tie s malými. Na určenie indexu, na ktorom sa nachádza nejaká hodnota použijeme hash tabuľku. Každú hodnotu v našej tabuľke preto vieme vypočítať v konštantnom čase, čo vedie k zložitosti $O(n^2)$.
",8
74ac80a9ad54201b,ksp,"# Anihilácia

Z reaktora sme vybrali trubice s rádioaktívnym odpadom, ktorý potrebujeme ekologicky zlikvidovať. V každej trubici sú zaradom kusy rôznorodých rádioaktívnych látok, pre jednoduchosť ich budeme označovať písmenami `a` až `z`. Ak sa v trubici nachádza za sebou kritické množstvo (dva alebo viac kusov) rovnakej látky, môžeme na tento úsek trubice vystreliť prúd neutrónov a celý tento úsek tým zničiť. Látky v trubici, ktoré boli pred tým na koncoch zničeného úseku budú po tomto vedľa seba.

Ak máme napríklad v trubici látky `aabccccbacc` môžeme najprv zničiť úsek štyroch látok `c` a v trubici budú látky `aabbacc`. Potom môžeme zničiť úsek dvoch látok `b`, následne troch látok `a` a napokon zničíme zvyšné látky `c`.

Týmto postupom by sme zničili celý obsah trubice, avšak ak by sme napríklad najprv zničili úsek látok `a`, už by sme celý obsah trubice nevedeli zlikvidovať.

## Úloha

Máte zadaných niekoľko reťazcov malých písmen anglickej abecedy. Zistite, pre ktoré reťazce dokážeme opakovaným odstraňovaním súvislých úsekov dvoch alebo viacerých rovnakých písmen odstrániť celý reťazec.

## Formát vstupu

Na prvom riadku vstupu je prirodzené číslo $n$ ($1 \\leq n \\leq 20$) udávajúce počet testovacích sád. Nasleduje $n$ riadkov predstavujúcich jednotlivé testovacie sady, na každom riadku je jeden reťazec písmen `a` až `z`. Dĺžka každého reťazca je aspoň $1$ a najviac $200$ znakov.

Presnejšie, v jednotlivých vstupoch (`1.in` až `8.in`) platí, že dĺžka každého reťazca je zhora obmedzená postupne 5, 10, 20, 40, 80, 160, 200 a 200.

## Formát výstupu

Pre každú testovaciu vypíšte jeden riadok obsahujúci slovo `ano` ak sa dá celý reťazec odstrániť a `nie`, ak sa nedá.

## Príklady

```vstup
4
aabccccbacc
bccccbacc
hahaahh
xzzxyzzyzzyx
```

```vystup
ano
nie
nie
ano
```
","# Anihilácia

Reťazec písmen $S$ dokážeme celý zmazať práve vtedy, keď platí aspoň jedna z týchto podmienok:

- $S$ je prázdny reťazec
- $S$ má dĺžku aspoň 2, začína a končí tým istým písmenom, a keď zmažeme všetky výskyty tohto písmena zo začiatku a z konca, dostaneme reťazec, ktorý sa dá zmazať celý. (Čiže napr. ""aaaaaUaaa"", kde $U$ sa dá zmazať, alebo ""bbbbbb"").
- $S$ sa dá rozseknúť na neprázdne reťazce $U$ a $V$, aj $U$ aj $V$ sa dajú celé zmazať.
- $S$ sa dá rozseknúť na 5 častí $x,U,x,V,x$, kde $x$ je ľubovoľné písmeno a $U$ aj $V$ sú neprázdne reťazce, ktoré sa dajú celé zmazať.

**Dôkaz:**

Ľahko overíme, že ak reťazec spĺňa niektorú podmienku, dá za zmazať celý. Stačí nám ukázať, že ak sa reťazec dá zmazať, musí spĺňať aspoň jednu podmienku, čo skúsime ukázať sporom. Majme reťazec, ktorý sa dá zmazať celý ale nespĺňa žiadnu zo štyroch podmienok.

Keď by sme tento reťazec mazali, ako posledné nám musel ostať úsek aspoň dvoch rovnakých písmen, označme si toto písmeno $x$. Pôvodný reťazec má tvar $T_0x_1T_1x_2...x_kT_k$, kde $x_i$ je niekoľko znakov $x$ a $T_i$ je reťazec, ktorý sa dá celý zmazať (lebo na konci nám ostali len znaky $x$.).

Ak $T_0$ resp. $T_k$ sú neprázdne, tak daný reťazec sa dá rozseknúť na $T_0$ a zvyšok, resp. $T_k$ a zvyšok a teda reťazec spĺňa tretiu podmienku (spor). Ďalej teda predpokladajme, že $T_0$ aj $T_k$ sú prázdne.

Ak k je 1, máme reťazec tvaru $x_1$, ktorý spĺňa druhú podmienku (spor).

Ak k je 2, máme reťazec tvaru $x_1T_1x_2T_2x_3$. Ak ktorýkoľvek z $x_1$, $x_2$, $x_3$ má aspoň dva znaky, tak reťazec spĺňa tretiu podmienku, inak spĺňa štvrtú (spor).

Ak k je viac ako 2, reťazec spĺňa tretiu podmienku (spor).

\\hfill$\\square$\\hspace{0.5cm}

Ľahko napíšeme rekurzívnu funkciu, ktorá overí všetky tieto podmienky v čase $O(n)$, kde $n$ je dĺžka reťazca, plus čas strávený v rekurzívnych volaniach. Pridáme memoizáciu, aby sme pre každý podúsek vstupného reťazca počítali odpoveď (či sa dá celý zmazať) len raz. Takto dosiahneme časovú zložitosť $O(n^3)$.

Pamäťová zložitosť je $O(n^2)$.
",10
334ba76761e70079,ksp,"# Eeh?! Traktor na diaľnici?!

Cestár Jožo čoskoro ukončí svoju kariéru profesionálneho držiaka lopaty, a tak sa rozhodol, že vo svoj posledný deň spraví niečo také veľké, že to až samotný Pán Minister očuje. Zobral teda svoj traktor, pripojil naň orač a hybal poorať diaľnicu -- však jak inako by spravil veľký kus roboty? Avšak, keď už bol na nájazde, tak sa zbadal, že diaľnicu treba poorať strategicky. Veď nový orač je drahý a nemôže zničiť ten jediný čo má pred tým, ako dokončí svoje veľdielo. Rozhodol sa teda, že si vyberie iba $K$ úsekov, ktorým sa povenuje -- t.j. tých $K$ úsekov poriadne poorie a zvyšok popoludia strávi vo svojom obľúbenom šenku. Však i tak sa o ňom určite na titulkách bude písať.

## Úloha

Na vstupe dostanete počet úsekov diaľnice. Každý úsek má kvalitu, ktorá je reprezentovaná nejakým prirodzeným číslom. Skupina po sebe idúcich úsekov $u_1, u_2, \\ldots, u_N$ má **skupinovú kvalitu** rovnú súčtu súčinov všetkých dvojíc v danej skupine. Napríklad, ak by sme mali len jeden úsek, tak ten má **skupinovú kvalitu** rovnú $0$, keďže nemá s žiaden úsek do dvojice. Skupina dvoch úsekov má zas **skupinovú kvalitu** rovnú $u_1u_2$ a trojica úsekov má **skupinovú kvalitu** rovnú $u_1u_2 + u_1u_3 + u_2u_3$.

Ako už bolo spomínané, tak Jožo sa môže venovať len niektorým úsekom. Vždy, keď sa povenuje nejakému úseku s indexom $i$, tak rozdelí skupinu úsekov $u_1, \\ldots, u_N$ na dve menšie skupiny $u_1, \\ldots, u_i$ a $u\_{i+1}, \\ldots, u_N$, pričom týmto skupinám sa potom ráta **skupinovú kvalita** samostatne. **Celková kvalita** je teda súčet **skupinových kvalít** všetkých skupín.

Pomôžte Jožovi zistiť, akú najnižšiu **celkovú kvalitu** môže dosiahnuť, nech vyrobí naozaj veľký kus práce.

## Formát vstupu

Na prvom riadku vstupu je jedno číslo $N, 1 \\leq N \\leq 500$ -- počet úsekov. Na druhom riadku je $K, 1 \\leq K \\leq N$ -- počet úsekov, ktorým sa môže Jožo povenovať. Na treťom riadku je $N$ medzerou oddelených prirodzených čísel v rozsahu od $1$ po $100$.

## Formát výstupu

Vypíšte jedno celé číslo -- najmenšiu **celkovú kvalitu**, ktorú vie Jožo dosiahnuť.

## Príklady

```vstup
5
1
6 8 2 7 2
```

```vystup
80
```

_Najvýhodnejšie je povenovať sa úseku s kvalitou $8$, potom dostaneme skupiny $(6,8)$, $(2,7,2)$ ktoré majú súčet **skupinových kvalít** rovný $(6\\cdot 8) + (2\\cdot 7 + 2\\cdot 2 + 7\\cdot 2) = 48+32 = 80$_

```vstup
5
2
6 8 2 7 2
```

```vystup
30
```

_Jožo vyrobí skupiny $(6)$, $(8,2)$, $(7,2)$_
","# Eeh?! Traktor na diaľnici?! {bodypopis=12 bodyprogram=8}

## Naivné riešenie

Riešime úlohu, ako ""rozrezať"" súvislú skupinu úsekov $u_1, u_2, \\dots, u_N$ na $K+1$ skupín tak aby *celková kvalita* bola čo najmenšia. Asi najednoduchší prístup je vyskúšať všetky možnosti rozdelenia a pre každé rozdelenie zrátať *celkovú kvalitu*. Všetky možnosti vyskúšame napríklad tak, že postupne budeme vyberať všetky kombinácie $K$ prvkov spomedzi indexov $1$ až $N$. Pre jednu voľbu kombinácií $c_1 < c_2 < \\dots < c_K$ potom rozdelíme vstup do skupín $\\left( u_1, \\dots , u\_{c_1} \\right), \\left( u\_{c_1+1}, \\dots , u\_{c_2} \\right), \\dots , \\left( u\_{c_K+1}, \\dots , u\_{N} \\right)$, každej skupine zrátame jej *skupinovú kvalitu* a potom *skupinové kvality* sčítame do *celkovej kvality*.

Takéto riešenie je celkom pomalé - pôvodnú cestu rozdeľujeme celkovo $N \\choose K$ krát a v každom rozdelení rátame *celkovú kvalitu*, ktorú rátame ako súčet *skupinových kvalít*. *Skupinovú kvalitu* jednej skupiny vieme zrátať ako súčet súčinov všetkých dvojíc úsekov v skupine, čo trvá $O(m^2)$ kde $m$ je počet úsekov v skupine. Na zrátanie celkovej kvality teda minieme určite menej ako $O(N^2)$ času, čím je celková časová zložitosť najviac $O\\left({N\\choose K} \\cdot N^2 \\right)$.

S pamäťovou zložitosťou sme na tom lepšie, lebo ak máme dostatočne šikovnú implementáciu, tak si nám stačí pamätať iba pôvodné pole a indexy, ktoré vyberáme, čím je pamäťová zložitosť najviac $O(N+K)$.

Odhad časovej zložitosti by sa dal vyrátať presnejšie, ale v tomto prípade na tom tak veľmi nezáleží. Vieme že časová zložitosť bude aspoň taká veľká ako kombinačné číslo, ktoré s rastúcim $N, K$ rastie rýchlejšie ako hociaký polynóm, teda rozdiel v polynomiálnej konštante nemá taký veľký dopad. Napríklad ${2N \\choose N} > 2^{N}$, pričom exponenciály rastú rýchlejšie ako polynómy.

Ak ste ešte nepočuli o kombinačných číslach, tak je dobrý čas sa o nich niečo naučiť napríklad na [wikipédií](https://en.wikipedia.org/wiki/Combination)

## Dynamické riešenie

*Skupinovú kvalitu* jednej skupiny budeme rátať rovnako ako predtým, budeme avšak lepšie uvažovať nad tým, ako rozdeľovať úseky. Nech $DP[s][k]$ odpovedá na nasledovnú otázku: Akú najmenšiu *celkovú kvalitu* viem dosiahnúť na úsekoch $u_1, \\dots , u_s$ ak sa Jožo povenuje presne $k$ úsekom? Potom odpoveď ktorú hľadáme je rovná $DP[N][K]$. Samozrejme nemá zmysel definovať $DP[s][k]$ pre $s < k$, keďže ani Jožo sa nevie povenovať viacerím úsekom ako je samotný počet úsekov. Zároveň nutne bude platiť, že $DP[s][s-1] = DP[s][s]$, keďže už samotné $DP[s][s-1]$ má *celkovú kvalitu* rovnú nule (každý úsek môže byť v samostatnej skupine). Stačí teda vyrátať hodnoty $DP[s][k]$ pre $s > k$ a budeme rovno vedieť aj hodnoty $DP[s][s]$.

Pri rátaní $DP[s][k]$ sa môžme riadiť veľmi užitočným pozorovaním - nikdy nemá zmysel venovať sa úseku $u_s$, keďže namiesto neho sa môžem venovať inému úseku a znížiť tak hodnotu $DP[s][k]$. Dôkaz je jednoduchý - keďže $k < s$, tak existuje úsek, ktorému sa Jožo nepovenuje. Ak sa venuje úseku $u_s$, tak si nijako nepomôže, teda je rozhodne lepšie venovať sa ľubovoľnému inému úseku (z predošlej vety je jasné, že si nájde iný úsek, ktorému sa môže venovať).

Na začiatku vieme zrátať všetky hodnoty tvaru $DP[s][0]$ pre $s \\in \\lbrace 1, \\dots , N \\rbrace$ jednoducho ako *skupinové kvality* úsekov $(u_1), (u_1, u_2),$ a tak ďalej až $(u_1, \\dots, u_N)$. Ak už vieme hodnoty $DP[i][k-1]$ pre $i \\in \\lbrace 1, \\dots , s-1\\rbrace$, tak vieme zrátať $DP[s][k]$ ako $\\min (DP[k][k-1] + C(k+1, s), DP[k+1][k-1] + C(k+2, s), \\dots , DP[s-1][k-1] + C(s, s))$. Kde $C(i, j)$ je *skupinová kvalita* úsekov $u_i, \\dots, u_j$.

Za týmto vzorcom sa schováva pomerne jednuduchá myšienka: V rozdelení do skupín pre každé $DP[s][k]$ určite existuje taký úsek $u_i$, že napravo od neho sa Jožo nevenoval žiadnemu ďalšiemu úseku. Môžme teda skúsiť všekty pozície takéhoto úseku - tj. že by to boli úseky $u\_{s-1}, u\_{s-2}, \\dots , u_k$. Úseky s menším indexom nemá zmysel skúšať, lebo pre nimi nie je $k-1$ úsekov, ktorým sa môže Jožo venovať.

Takýto postup nám zaručí že v $DP[N][K]$ budeme mať správnu odpoveď. Pamäťovú zložitosť budeme mať tento o čosi horšiu - potrebujeme $O(N\\cdot K)$ pamäte na to aby sme si zapamätali celú tabuľku $DP$.

Ak budeme DP rátať za radom, to znamená že pred rátaním $DP[s][k]$ vždy budeme mať zrátané všetky $DP[a][b]$ pre $a\\leq s, b \\leq k$, tak vždy budeme vedieť priamo zrátať $DP[s][k]$ v čase $O((s-k)^3) < O(s^3)$, lebo musíme vyskúšať $s-k$ pozícií a pre každú pozíciu zrátať *skupinovú cenu* skupiny ktorá je veľká najviac $s-k$. Celkovo teda máme riešenie v čas $O(N^4\\cdot K)$ na výpočet celej tabľky $DP$ keďže $s \\leq N, k \\leq K$.

## Vzorová dynamika

Jediné čo zmeníme je výpočet *skupinovej ceny* úseku. Nech $P[s]$ je súčet $u_1 + \\dots + u_s$ a $Q[s]$ je súčet $u_1^2 + \\dots + u_s^2$. Potom vieme zistiť súčet alebo súčet štvorcov ľubovoľného úseku $u_i, \\dots, u_j$ ako $P[j]-P[i-1]$ či $Q[j]-Q[i-1]$. *Skupinovú cenu* úseku $u_i, u\_{i+1}, \\dots, u_j$ potom zistíme ako $(P[j]-P[i-1])^2 - (Q[j]-Q[i-1])$ a to celé vydelíme $2$. Funguje to podobne ako keď násobíme zátvorky - na zistenie súčtu $ab+ac+bc$ môžme zrátať $(a+b+c)^2 = a^2+b^2+c^2+2(ab+ac+bc)$. Stačí teda odčítať štvorce a vydeliť dvomi.

Takýto postup má tú výhodu, že sčitať a násobiť čísla do určitej veľkosti zaberá konštantne veľa času, teda zlepšenie prišlo v tom, že na zrátanie $DP[s][k]$ nám stačá konštantne málo základných aritmetických operácií, teda $DP[s][k]$ vieme zrátať v čase $O(s-k) = O(s)$.

Polia $P, Q$ vieme spočítať v čase $O(N)$, lebo z $P[i], Q[i]$ vieme $P[i+1], Q[i+1]$ spočítať ako $P[i+1] = P[i]+u\_{i+1}$, $Q[i+1] = Q[i]+u\_{i+1}^2$.

Celková časová zložitosť tak bude $O(N^2\\cdot K)$ (prejdeme $O(NK)$ hodnôt $Dp$, každú spracujeme v $O(N)$). Pamäťová zložitosť bude $O(NK)$.
",5
2fdf703f37431fee,ksp,"# Utrápený Michallius

Každý dobre vie, že Michallius sa rád bije. Chcel sa prihlásiť na bitkársky turnaj konajúci sa na konci semestra, zaškrtol však zlú kolónku a ocitol sa na prestížnom gladiátorskom deathmatch-i^[To znamená, že súboj pokračuje, dokým jeden z dvojice nezomrie], na ktorý sa bude pozerať aj sám cézar. Na začiatku dostane každý gladiátor 1 bitkoin^[bitkoin -- drobná zlatá minca používaná medzi bitkármi (odtiaľ názov)] a za porazenie súpera získava všetky jeho bitkoiny. Takže gladiátori sa vedia pekne nabaliť. Bojuje sa v dvoch typoch súbojov: v boji s mečom a boji s kopijou. Na začiatku súboja sa vždy vyberie typ zbrane a táto zbraň sa počas súboja nezmení.

Chudák Michallius bol sprvu veľmi utrápený a bál sa. Kašľal na svoj bitkoin, chcel iba prežiť. Musel preto teda niečo robiť. Rozhodol sa preskúmať svoje sily a sily ostatných súperov. O každom gladiátorovi (vrátane seba) si poznačil jeho silu s mečom a s kopijou. Robil to dôkladne, žiadni dvaja bojovníci nemajú rovnakú silu v jednom type boja. Michallius cez skúškové trénoval, poctivo posilňoval, a aj sa správne stravoval. Zistil, že nakoniec je v tom bojovaní celkom dobrý, preto ho už začína zaujímať koľko by si vedel maximálne odniesť z tohto turnaja.

Zistite, aký maximálny zárobok si vie Michallius odniesť. A vlastne, keď už to zistíte o Michalliovi, zistite to isté o každom ďalšom gladiátorovi.

## Úloha

Na turnaj sa prihlásilo $n$ gladiátorov. O každom gladiátorovi vieme jeho silu v boji s mečom a silu v boji s kopijou (obe tieto sily sú celé čísla). Každý gladiátor dostane na začiatku 1 bitkoin. Turnaj má pomerne voľnú štruktúru, ktorá vyzerá nasledovne:

1. Vylosujú sa dvaja gladiátori, ktorí ešte neprehrali.
1. Vylosuje sa, či budú bojovať s kopijami, alebo s mečmi.
1. Pobijú sa. Gladiátor, ktorý je v danom type boja silnejší, zvíťazí.
1. Víťaz získa všetky bitkoiny porazeného a porazený vypadáva z turnaja (z pochopiteľných dôvodov).

Tieto štyri kroky sa opakujú, až kým turnaj cézara neomrzí. Môže sa tak stať, že na konci prežije viacero gladiátorov.

Chceme vedieť o každom gladiátorovi, koľko bitkoinov môže na turnaji maximálne zarobiť, ak by všetky losovania dopadli preňho najlepším možným spôsobom.

## Formát vstupu

Na prvom riadku vstupu sa nachádza celé číslo $n$ -- počet gladiátorov na turnaji. Platí: $1 \\leq n \\leq 100,000$. Nasleduje $n$ riadkov. V $i$-tom riadku sa nachádzajú dve celé čísla oddelené medzerou: sila $i$-teho gladiátora v boji s mečom $m_i$ a jeho sila v boji s kopijou $k_i$. Platí $1 \\leq m_i , k_i \\leq n$. Môžete predpokladať, že žiadni dvaja gladiátori nemajú rovnakú silu s mečom, ani rovnakú silu s kopijou.

## Formát výstupu

Vypíšte $n$ riadkov. V $i$-tom riadku vypíšte počet bitkoinov, ktoré môže $i$-ty gladiátor získať.

## Príklady

```vstup
4
2 3
3 2
1 1
4 4
```

```vystup
3
3
1
4
```

*Michallius (prvý gladiátor) dokáže poraziť druhého gladiátora ak budú bojovať s kopijou, tretieho v ľubovolnom boji. Druhý gladiátor porazí Michallia v boji s mečom a tretieho v ľubovolnom boji. Tretí gladiátor je bezmocná ovca, a štvrtý je Spartakus.*

```vstup
4
3 3
4 1
1 4
2 2
```

```vystup
4
4
4
4
```

*Všimnime si, že posledný gladiátor dokáže získať aj Michalliov bitkoin, hoci je slabší v oboch typoch boja.*
","# Utrápený Michallius

## Koľko bitkoinov vie vyhrať gladiátor $\\boldsymbol{a}$?

Aby sme zistili _koľko_ bitkoinov môže zarobiť nejaký gladiátor $a$, skúsme najskôr zistiť _ktoré_ bitkoiny môže $a$ získať.

Aby gladiátor $a$ získal bitkoin, ktorý na začiatku turnaja patril gladiátorovi $b$, musí k nemu tento bitkoin nejako doputovať. Táto púť bude vyzerať tak, že najskôr $b$ prehrá súboj s nejakým iným gladiátorom, ten (ak to ešte nie je gladiátor $a$) potom prehrá s ďalším gladiátorom, ten prehrá s ďalším, atď., až nakoniec posledný gladiátor z tejto reťaze prehrá s gladiátorom $a$.

Povedané formálne, $a$ dokáže získať bitkoin od $b$, vtedy a len vtedy, keď existuje postupnosť gladiátorov $b = g_1, g_2, \\ldots, g_k = a$ taká, že pre všetky prípustné $i$ vie $g\_{i+1}$ poraziť $g_i$ v aspoň jednom type súboja.

\\smallskip

Máme teda dobre popísaný vzťah ""$a$ vie získať bitkoin $b$"". Viac bitkoinov než počet takýchto gladiátorov $b$ gladiátor $a$ nevie získať. Ale to, že $a$ vie získať bitkoiny od $b_1, \\ldots, b_m$ ešte neznamená, že ich vie získať všetky **v priebehu jedného turnaja**. Ukazuje sa ale, že sa to dá.

\\smallskip

Dobre sa to vysvetľuje z grafového hľadiska. Uvažujme orientovaný graf, v ktorom vrcholy reprezentujú gladiátorov, a je v ňom hrana $x \\rightarrow y$ vtedy, keď $x$ vie poraziť $y$ aspoň v jednom type súboja. Potom $a$ vie získať bitkoiny práve tých gladiátorov, ktorí sú dosiahnuteľní z $a$ (rozmyslite si).

Postupnosť zápasov, v ktorej $a$ získa bitkoiny od všetkých takýchto gladiátorov, vieme nájsť nasledovne:

1. Začneme s prázdnou postupnosťou zápasov.
1. Spustime prehľadávanie (napríklad [do hĺbky](https://www.ksp.sk/kucharka/dfs/)) z $a$ a vždy, keď prejdeme po hrane do nejakého ešte nenavštíveného vrcholu, zafarbime túto hranu na červeno. Po skončení prehľadávania budú červené hrany tvoriť strom obsahujúci práve vrcholy dosiahnuteľné z $a$.
1. Z tohto stromu odstránime hranu $x \\rightarrow y$ vedúcu do listu a do postupnosti pridáme zápas medzi $x, y$, pričom typ zápasu zvolíme tak, aby $x$ vyhral.
1. Opakujeme predchádzajúci krok, kým sú v grafe hrany.

\\smallskip

*(Prvá tabuľka zobrazuje sily jednotlivých gladiátorov. Druhá tabuľka obsahuje gladiátorov usporiadaných podľa ich síl. Tretia tabuľka zobrazuje zápasy v takom turnaji, v ktorom by gladiátor $g_7$ získal všetky bitkoiny, ktoré vie získať.)*

## Prvý správny algoritmus

Predchádzajúca úvaha nám dáva jednoduchý algoritmus na riešenie úlohy: zostrojíme graf a postupne z každého vrcholu $a$ spustíme prehľadávanie, ktorým zistíme, koľko vrcholov z neho vieme dosiahnuť. To je zároveň aj počet bitkoinov, ktorý si vie gladiátor $a$ z turnaja odniesť.

Graf obsahuje $n$ vrcholov a $O(n^2)$ hrán, časová zložitosť je preto $O(n^3)$. Pamäťová zložitosť je $O(n^2)$ (ak v pamäti vytvoríme všetky hrany), prípadne $O(n)$ (ak si pamätáme iba sily gladiátorov).

Predchádzajúce riešenie možno o rád zrýchliť nasledujúcim trikom: usporiadajme si gladiátorov do postupnosti $g'\_1, g'\_2, \\ldots, g'\_n$ podľa rastúcej sily v boji s mečom. Potom nemusíme mať v grafe všetky hrany $g'\_i \\rightarrow g'\_j$ pre $i > j$, stačí, ak v ňom budú hrany $g'_i \\rightarrow g'_{i - 1}$ pre všetky prípustné $i$.

\\smallskip

*(Graf, v ktorom neuvažujeme zbytočné hrany. Pre každú silu $k > 1$ a každý typ boja máme hranu vedúcu od gladiátora so silou $k$ ku gladiátorovi so silou $k - 1$. Zelené hrany zodpovedajú boju s mečom, modré hrany boju s kopijou.)*

\\medskip

Prečo? Ak v pôvodnom grafe existovala cesta z $a$ do nejakého $b$, tak v novom grafe dostaneme cestu z $a$ do $b$ tak, že každú hranu na pôvodnej ceste, ktorá má tvar $g_i \\rightarrow g_j$ pre $i > j$, nahradíme postupnosťou hrán $g_i \\rightarrow g\_{i - 1}, g\_{i - 1} \\rightarrow g\_{i - 2}, \\ldots, g\_{j + 1} \\rightarrow g_j$. Takže pre ľubovoľný vrchol $a$ je množina vrcholov dosiahnuteľných z $a$ rovnaká, ako v pôvodnom grafe.

Rovnako vieme zredukovať počet hrán, ktoré zodpovedajú súbojom s kopijou. V novom grafe budeme mať $2 \\cdot (n - 1) = O(n)$ hrán, a vylepšíme tým časovú zložitosť algoritmu na $O(n^2)$.

## Vzorové riešenie

Majme gladiátorov $g_1, g_2, \\ldots, g_n$ usporiadaných vzostupne podľa sily v boji s mečom. Všimnime si, že všetky bitkoiny, ktoré vie získať $g_i$, vie získať aj $g\_{i + 1}$. To ale znamená, že keď hľadáme vrcholy dosiahnuteľné z $g\_{i + 1}$, tak nám stačí hľadať iba také vrcholy, ktoré nie sú dosiahnuteľné z $g_i$. Vrcholy dosiahnuteľné z $g_i$ totiž môžeme zarátať automaticky.

Budeme teda púštať prehľadávanie postupne od najslabších gladiátorov k najsilnejším, teda v poradí $g_1, g_2, \\ldots, g_n$. Pre každého gladiátora si pamätáme, či sme ho už v niektorom prehľadávaní navštívili, a pamätáme si tiež počet už navštívených gladiátorov. Keď prehľadávame z $g_i$, tak nenavštevujeme vrcholy, ktoré sme už navštívili v niektorom z predchádzajúcich prehľadávaní.

Rozmyslite si, že takýmto spôsobom sú po $i$-tom prehľadávaní navštívení práve tí gladiátori, ktorí sú dosiahnuteľní z $g_i$. Práve od nich vie $g_i$ získať bitkoin. Ich počet je teda počet bitkoinov, ktoré vie $g_i$ získať.

## Zložitosť

Na začiatku si potrebujeme utriediť gladiátorov podľa sily. To nám bude trvať $O(n \\log n)$. Počas prehľadávaní navštívime každý vrchol grafu najviac raz, čo je $O(n)$ roboty (lebo graf má len $n$ vrcholov a $O(n)$ hrán). Preto je časová zložitosť celého algoritmu $O(n \\log n)$. Pamäťová zložitosť ostáva $O(n)$.

Pritom časová zložitosť $O(n \\log n)$ je iba kvôli triedeniu, my však máme čísla z rozsahu od $1$ po $n$. Vieme ich teda utriediť count sortom, a dostaneme tak lepší čas $O(n)$.
",9
fc30a0768dd1e69d,ksp,"# Daj het

Máme štvorcovú tabuľku. V tabuľke máme prirodzené čísla. Pekne spôsobne, v každom políčku jedno.

Každý riadok aj každý stĺpec má pri sebe napísané jedno číslo. Toto číslo hovorí, aký súčet chceme v danom riadku/stĺpci dosiahnuť.

## Úloha

Daj het niektoré čísla z tabuľky tak, aby všetky súčty sedeli.

## Formát vstupu

Toto je open data úloha, dostanete teda od nás úplne všetky vstupy. Môžete sa na ne ľubovoľne pozerať a robiť s nimi čo len chcete. Vstupov je 8 a volajú sa `1.in` až `8.in`. Každý vstup začína číslom $t$ predstavujúcim počet testov, ktoré obsahuje. Každý test má nasledujúci formát:

- V prvom riadku je číslo $n$: rozmer tabuľky. (V každom vstupe majú všetky testy rovnaké $n$.)
- V druhom riadku je $n$ čísel: predpísané súčty pre riadky zhora dole.
- V treťom riadku je $n$ čísel: predpísané súčty pre stĺpce zľava doprava.
- V každom z nasledujúcich $n$ riadkov je $n$ kladných celých čísel nepresahujúcich $20$, v poradí, v akom sú rozmiestnené v tabuľke.

Môžete predpokladať, že pre každú zo zadaných tabuliek existuje aspoň jedno riešenie.

Vstupy pre [windows tu](http://media.ksp.sk/ulohy/36rocnik/2kolo/7vstupy_windows.zip), pre [linux tu](http://media.ksp.sk/ulohy/36rocnik/2kolo/7vstupy_linux.zip).

## Formát výstupu

Odovzdajte zip archív a v ňom príslušné výstupy. Tie musia byť pomenované `1.out` až `8.out` a umiestnené v koreňovom adresári zipu. Za každý výstup, ktorý sa v zipe naozaj bude nachádzať a bude úplne správny, dostanete dva body.

Formát výstupu: pre každý test vypíšte $n$ riadkov a v každom $n$ čísel: čísla vo výslednej tabuľke, pričom namiesto čísel, ktoré ste ""dali het"" (čítaj: z tabuľky odstránili) vypíšte nuly.

Môžete vypisovať aj nadbytočné medzery a voľné riadky medzi výstupmi pre jednotlivé testy, náš testovač ich spokojne odignoruje. Ak existuje pre nejakú tabuľku viacero riešení, môžete vypísať ľubovoľné jedno z nich.

Posledné nanajvýš 4 body za úlohu udelíme za popis toho, ako ste úlohu riešili, a obzvlášť programu/ov, ktoré ste použili. Rozumne podrobný popis ľubovoľného postupu, ktorý nejaké vstupy naozaj vyriešil, môže dostať aspoň 3 body.

## Príklady

```vstup
1
5
15 12 14 14 24 
10 20 18 14 17
7 3 2 5 1
3 5 4 3 3
5 3 3 9 5
5 6 4 3 4
4 9 8 8 7
```

```vystup
7 0 2 5 1
3 5 4 0 0
0 0 0 9 5
0 6 4 0 4
0 9 8 0 7
```
","# Daj het

Inšpiráciou pre túto úlohu bola logická hra Rullo. Zadania, ktoré dostali vaše programy, len boli o čosi väčšie, ako tie, ktoré riešia ľudia.

## Riešenie hrubou silou

Ako dať z mriežky preč tie správne čísla? Zamyslíme sa nad niečím šikovným, nič nevymyslíme, a tak sa rozhodneme vyskúšať hrubú silu.

Aj pri hrubej sile je ale veľa možností. Všetkých možností, ako z tabuľky rozmerov $n\\times n$ niektoré čísla vyhodiť a niektoré nechať je až $2^{n^2}$, a to už od $n=6$ začína byť nezvládnuteľne veľa možností.

Omnoho lepšie sú riešenia založené na tzv. backtrackingu (prehľadávaní s návratom). Pri takýchto riešeniach sa rozhodujeme postupne, políčko po políčku. Výhodou je, že po každom rozhodnutí môžeme spraviť rôzne kontroly a ak zistíme, že už určite nevieme vyrobiť žiadne platné riešenie, môžeme sa z aktuálnej ""vetvy"" prehľadávania rovno vrátiť a tak ušetriť veľa ďalšieho skúšania možností.

Pri našej úlohe si napríklad pre každý riadok aj stĺpec môžeme zvlášť pamätať súčet čísel, ktoré sme sa v ňom už rozhodli nechať, a zvlášť súčet čísel, o ktorých sme sa ešte nerozhodli. Potom vždy, keď spravíme nejaké rozhodnutie o ďalšom políčku, upravíme si tieto súčty pre jeho riadok a stĺpec, a následne pomocou nich zistíme, či ešte želané súčty pre ne ležia v zostrojiteľnom rozsahu.

Ďalšie zefektívnenie takéhoto typu riešení môže spočívať v šikovnejšej voľbe poradia, v ktorom sa o jednotlivých políčkach rozhodujeme. V princípe platí, že čím skôr o nejakej vetve zistíme, že k riešeniu nevedie, tým viac času ušetríme.

## Kombinácia hrubej sily a dedukcie

Keby túto úlohu riešil človek, často by používal dedukciu: ""Toto číslo nemôžem použiť, lebo by mi nesedela posledná cifra, tamto zas použiť musím, lebo by inak bol súčet primalý, a hento tiež, lebo by mi v stĺpci nesedela parita."" A vždy, keď nám z takejto dedukcie niečo vypadne, tak nám to môže pomôcť. Ak napríklad z pohľadu na riadok zistíme, že nejaké jeho políčko treba odstrániť, môžeme sa potom pozrieť na stĺpec a v ňom zrazu máme tiež o políčko menej.

Našou druhou cestou k riešeniu bude snaha spraviť program, ktorý bude vedieť robiť takéto dedukcie. Vopred síce nevieme, či nám pomôžu, ale za pokus to stojí -- ak sa ukáže, že áno, máme lepšie riešenie, ak sa ukáže, že nie, aspoň sme sa naučili niečo nové o vlastnostiach tejto úlohy.

Hja, ale ako naučiť program robiť takéto dedukcie? K plnohodnotnej AI máme ďaleko a implementácia nejakých jednoduchých pravidiel nám asi žiadne ohromujúce výsledky nedá.

Existuje ale pekný systematický spôsob, ktorý môžeme použiť a ktorý zahrnie všetky možné veci, ktoré sa dajú vydedukovať len z toho jedného riadku či stĺpca. Trik je jednoduchý: Pozrieme sa na všetkých $2^n$ možností, čo spraviť s dotyčným riadkom (respektíve menej, ak už sme o niektorých jeho políčkach rozhodnutí). Spomedzi všetkých možností si vyberieme všetky tie, ktoré vyrobia správny súčet. No a teraz sa pozrieme na to, na ktorých políčkach sa všetky tieto možnosti zhodujú. Takto sa dozvieme aj to, ktoré políčka určite musíme nechať, aj to, ktoré určite zahodiť.

(Elegantná implementácia je pomocou bitových vzoriek. Na čísla od $0$ po $2^n -1$ sa môžeme dívať ako na všetky možné $n$-tice bitov, teda ako na všetky možné postupnosti hovoriace, ktoré políčka zahodiť a ktoré zobrať. Keď si potom zoberieme všetky čísla, ktoré zodpovedali platným riešeniam pre dotyčný riadok, z ich bitového ANDu vidíme, kde mali všetky 1, a z ich bitového ORu zase to, kde mali všetky 0.)

Vyššie popísanú úvahu vieme postupne opakovať pre všetky riadky a stĺpce, až kým buď celú tabuľku nevyriešime, alebo sa nedostaneme do situácie, kedy už v žiadnom riadku ani stĺpci nevieme nič nové odvodiť. No a čo spravíme v tomto druhom prípade? Použijeme predchádzajúce riešenie -- teda vyberieme si nejaké nerozhodnuté políčko a postupne rekurzívne vyskúšame obe možnosti preň.

Pri implementácii si potom ešte treba dať pozor na to, že vždy, keď sa ideme z rekurzie vrátiť, treba zabudnúť nie len na stav políčka, o ktorom sme sa priamo rozhodli, ale tiež na stav všetkých políčok, o ktorých sme po tom rozhodnutí vyššie popísanou dedukciou zistili, že zrazu už sú jednoznačne určené.

## Nechám oboje na niekoho iného

""Robenie dedukcií"" a ""skúšanie možností"" sú natoľko bežné súčasti riešenia problémov, že už zrejme niekto prišiel na to, ako spraviť špecializované nástroje, ktoré sú fakt dobré v jednom aj druhom.

Jedným zo základných typov takýchto nástrojov sú tzv. SAT solvery. Ich použitie funguje nasledovne: Zoberieme problém, ktorý chceme vyriešiť, zakódujeme jeho ""pravidlá"" do jedného veľkého logického výrazu, a potom poprosíme SAT solver, aby nám našiel, pre aké ohodnotenie premenných je celý tento výraz splnený. Ak to nedáva zmysel, nebojte sa, o chvíľu začne.

Ako môžeme našu úlohu zapísať ako logický výraz? Keď máme tabuľku $n\\times n$, začneme tým, že budeme mať $n^2$ boolovských premenných: pre každé políčko jednu premennú, ktorá nám hovorí, či je súčasťou riešenia.

Logický výraz, ktorý sme pred chvíľou spomínali, bude veľkou konjunkciou (t.j. logickým ANDom) veľa podmienok, ktoré musia tieto premenné spĺňať, aby sme dokopy dostali platné riešenie. Presnejšie, vstup pre bežný SAT solver musí byť v špecifickom tvare, tzv. konjuktívnej normálnej forme. To znamená, že musí byť vyššie popísaného tvaru a navyše môžeme používať len veľmi jednoduché podmienky. Každá podmienka musí byť tvaru ""spomedzi týchto premenných a týchto ich negácií musí byť aspoň jedna pravdivá"". Teda napríklad môžeme mať v našej úlohe podmienku tvaru ""zober políčko (3,2) alebo zober políčko (3,7) alebo zahoď políčko (3,1)"".

Logický výraz, ktorý zostrojíme, bude ANDom $2n$ sád podmienok: jedna sada pre každý riadok aj stĺpec. Každá sada podmienok bude hovoriť ""táto sada premenných musí byť taká, aby sedel súčet tohto riadku / stĺpca"". Ako toto dosiahnuť? Jednoducho tak, že si hrubou silou vygenerujeme všetky zlé kombinácie premenných a každú z nich jednou podmienkou zakážeme. (Ak nechceme, aby nastala situácia ""zahoď (3,2) a zahoď (3,7) a zober (3,1)"", pridáme podmienku, ktorá je jej negáciou -- čiže podmienku, ktorú sme uviedli ako príklad v minulom odseku.) Pre každý riadok a stĺpec takto vygenerujeme najviac $2^n$ zlých kombinácií, každú s najviac $n$ premennými a celkovo teda bude mať logický výraz dĺžku $O(n^2 \\cdot 2^n)$. Logický výraz -- vstup pre SAT solver -- musíme, samozrejme, skonštruovať pomocou vlastnoručne napísaného programu.

Viac o tejto téme sa dozviete v zadaní a riešení staršej úlohy KSP: úloha ""Ono to rieši samo!"" (31. ročník KSP, úloha 5 v prvom kole zimnej časti).

## Za záver

Riešenie už síce skončilo, my si ale povieme ešte niečo navyše. Prečo sme sa uspokojili len s riešeniami používajúcimi hrubú silu a nehľadali sme napríklad lepšie riešenie, ktoré by úlohu vždy vyriešilo v čase $O(n^2)$? Preto, že vieme dokázať, že táto úloha je ťažká.

Jednou zo známych algoritmických úloh, o ktorých sa vie, že sú ťažké (natoľko, že sa všeobecne verí, že nemajú žiadne polynomiálne riešenie) je úloha SubsetSum: ""Tu máš sadu prirodzených čísel $a_0,\\dots,a\_{n-1}$ a cieľovú hodnotu $s$, existuje nejaká podmnožina daných čísel, ktorá má súčet presne $s$?"" No a riešiť našu úlohu je aspoň tak ťažké, ako riešiť SubsetSum. Totiž ľubovoľné zadanie SubsetSum vieme prerobiť na zadanie našej úlohy. Stačí si spraviť tabuľku, kde v riadku $i$ a stĺpci $j$ máme číslo $a\_{(i+j)\\bmod n}$, a predpísať, že v každom riadku aj stĺpci chceme dostať súčet $s$.

Ak by teda existoval efektívny algoritmus pre našu úlohu, dostali by sme aj efektívny algoritmus pre SubsetSum. A keďže ten zrejme neexistuje, nemá zmysel sa snažiť ani pre našu úlohu.

(To, čo sme si práve predviedli, bola redukcia, ktorá dokazuje, že náš problém je rovnako ako SubsetSum jedným z tzv. NP-ťažkých rozhodovacích problémov.)
",9
b6aa68b96e78ad88,ksp,"# Dezinfekcia

Krajské Mesto Pravičiarov (KMP) čelí architektonickej výzve. Z dlhodobých pozorovaní obyvatelia zistili, že počas roka sa vyskytujú, čím ďalej, tým výraznejšie extrémy, čo sa týka množstva pitnej vody v ich oblasti. Niekedy majú pitnej vody veeeľmi veľa a inokedy veeeľmi málo. Preto prišli s nápadom, že potrebujú zväčšiť mestskú nádrž na vodu, aby počas priaznivejšieho obdobia dokázali uskladniť prebytočnú vodu na horšie časy.

Nádrž sa nachádza v podzemí mesta tvoreného skalami[^1]. Ich podzemie je tiež zaujímavé tým, že skaly je možné odstraňovať (pri pohľade z hora) iba po štvorcových kusoch s rozmermi $1m \\cdot 1m$. Nádrž je tvorená iba súvislým voľným priestorom medzi skalami. Skaly sú vodotesné a teda cez ne nepresakuje voda.

Jeden by si povedal, že tu o nič nejde. Stačí bezhlavo vykopať väčšiu dieru. No ako to už v takýchto KSP úlohách býva, je tu háčik - v podzemí sa nachádzajú aj viaceré menšie nádrže na dezinfekciu, ktoré boli vytvorené iba nedávno. Problém je teda v tom, že obyvatelia neobľubujú konzumáciu dezinfekčných prostriedkov. Preto je pri plánovaní rozšírenia nádrže potrebné dbať na to, aby sa dezinfkecia nezmiešala s pitnou vodou.

Analytici z KMP zistili, že je potrebné, aby bola plocha nádrže zväčšená aspoň na $s$ metrov štvorcovích. V úlohe projektovania nových stavebných úprav si však až tak neveria. Preto ste tu vy. Pomôžte obyvateľom KMP vyriešiť tento problém!

\[^1\]: Napriek tomu je podložie mesta stabilné. Áno, je to divné, ale funguje to, tak sa do toho nestarajme.

## Úloha

Poznáme pôdorys podzemia - 2D štvorčeková mriežka, kde jeden štvorček má rozmery $1m \\cdot 1m$. Odstráňte z neho najmenší možný počet skál tak, aby vo výslednom pôdoryse zaberala nádrž na pitnú vodu aspoň $s$ metrov štvorcovích a aby sa do nej nevylial obsah niektorej nádrže na dezinfekciu.

Každá nádrž na dezinfekciu je reprezentovaná znakom `D` a má rozmery presne $1m \\cdot 1m$, čiže okolo každého znaku `D` sa na každom z existujúcich štyroch susedných políčok nachádza skala (`#`).

Nádrž na pitnú vodu je tvorená políčakmi označenými znakom `.`. Všetky políčka nádrže na vodu tvoria práve jednu súvislú nádrž. Inými slovami, z každého políčka nádrže na pitnú vodu je možné sa dostať na každé políčko nádrže na pitnú vodu prechodom iba cez políčka nádrže na pitnú vodu.

Výsledná nádrž musí byť takisto súvislá. Obyvatelia nebudú spokojní s riešením, ktoré zapríčiní existenciu viac ako jednej nádrže na pitnú vodu v podzemí ich KMP.

Vypíšte mapu podzemia, ktoré spĺňa zadané požiadavky!

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú 3 čísla. Rozmery mapy podzemia - počet riadkov $m$ a počet stĺpcov $n$ - a požadovaná plocha nádrže $s$. Platí, že $1 \\leq m, n \\leq 1,000$ a $1 \\leq s \\leq m \\cdot n$. Nasleduje $m$ riadkov po $n$ znakov reprezentujúcich mapu. Môžu sa tu vyskytovať iba znaky `.` (nádrž na pitnú vodu), `#` (skala) a `D` (dezinfekcia).

## Formát výstupu

Na výstup vypíšte mapu, ktorá vznikla splnením úlohy! Vypíšte ju v rovnakom formáte, v akom bola na vstupe - $m$ riadkov po $n$ znakov!

Pre jeden vstup môže existovať viacero správnych riešení. V takom prípade vypíšte ľubovoľné z nich!

Môžete počítať s tým, že pre každý testovací vstup existuje riešenie.

## Príklady

```vstup
6 6 10
###.##
#D#..#
###..#
##..##
##.###
######
```

```vystup
##..##
#D#..#
##...#
##..##
##.###
######
```

_Jedným riešením je odstránenie skál v rohoch okolo `D`. (Ak sa skaly dotýkajú hranami, spojenie je stále vodotesné a obyvatelia nebudú otrávení.)_

```vstup
6 6 20
###.##
#D#..#
###..#
##..##
##.#D#
######
```

```vystup
##....
#D#...
.#....
....#.
...#D#
######
```
","# Dezinfekcia

Ak si to zhrnieme, v úlohe nám ide o to, aby sme odstraňovali skaly, ktoré susedia s nádržou, kým nádrž nezaberá aspoň požadovanú plochu. Komplikácie s dezinfkeciou vieme jednoducho vyriešiť tak, že skaly susediace s nejakou dezinfekciou si označíme ako zakázané políčka, s ktorými nemôžeme nič robiť. Tým pádom sa nám neskôr nemôže stať, že by sme vypustili dezinfkeciu do pitnej vody.

## Pomalé riešenie

Ako teda odstraňovať skaly? Ako zistiť, ktoré skaly môžeme odstraňovať? V podzemí sa má nachádzať práve jedna súvislá nádrž. To znamená, že každá skala, ktorej odstránením zväčšíme nádrž, sa musí nachádzať hneď vedľa niektorého políčka nádrže.

Prvoplánovým riešením by mohlo byť niečo také, že by sme dookola prehľadávali všetky políčka mapy a pri každom políčku skaly by sme zisťovali, či sa nachádza vedľa nádrže, a v pozitívnom prípade by sme skalu odstránili. To by sme mohli opakovať, kým by nádrž nenabudla dostatočné rozmery.

Toto riešenie by určite fungovalo, keďže vždy by sme pridávali iba políčka susediace s nádržou a postup by sme opakovali až kým by sme nedostali dostatočne veľkú nádrž.

V najhoršom prípade by sme pri požadovanej ploche $s$ museli $s$-krát prehľadať celú mapu o veǩosti $mn$. Z toho nám vychádza časova zložitosť $O(smn)$.

Čo sa týka pamäte, vystačili by sme si s pamätaním si iba políčok mapy, čo nám dáva $O(mn)$.

## Vzorové riešenie

Zrejme tušíte, že opakované prehľadávanie celej mapy neznie ako správna cesta. Skaly na odstránenie potrebujeme ""hľadať"" o čosi sofistikovanejšie. Pripomínam, že nádrž musí byť práve jedna, čo vieme do reči informatiky preložiť aj ako ""všetky políčka nádrže musia tvoriť jeden súvislý graf"". Súvislý graf je graf, ktorý sa skladá z práve jedného komponentu, čiže medzi ľubovoľnými dvoma vrcholmi v ňom existuje cesta.

Hm... Keby sme si existujúcu nádrž predstavili ako jeden podgraf, tak všetci jeho susedia by boli skaly, ktoré môžeme odstrániť v danom momente. Ak odstránime takúto susednú skalu, daný vrchol splynie s nádržou a teraz jeho susedia sú susedmi celej nádrže (podgrafu). A tak ďalej by sme pridávali postupne po jednej susednej skale, až kým nemáme dostatočnú nádrž.

Tu vieme teraz použiť prehľadávanie do hĺbky ([DFS](https://www.ksp.sk/kucharka/dfs/)), alebo do šírky ([BFS](https://www.ksp.sk/kucharka/bfs/)). Povedzme, že už máme spočítanú veľkosť pôvodnej nádrže. Môžeme začať prehľadávať mapu (graf) od ľubovoľného políčka existujúcej nádrže. Ak počas prehľadávania vidíme políčko nádrže, sme šťastní. Ak nájdeme políčko skaly (ktorá nie je blokovaná kvôli dezinfekcii), môžeme ju odstrániť a tým zväčšiť nádrž o toto jedno políčko. Keď už máme nádrž dostatočnej veľkosti, skončíme prehľadávanie.

Prečo políčka existujúcej nádrže nerátame? Tieto si musíme zrátať ešte pred prehľadávaním. Ak by sme nevedeli, aká veľka bola pôvodná nádrž, nevedeli by sme, o koľko ju potrebujeme zväčšiť. Potom by sa mohlo stať, že počas prehľadávania by sme prehľadali priveľa skál ešte predtým, než by sme prehľadali existujúcu nádrž, čím by sme vytvorili zbytočne veľkú nádrž.

Toto riešenie bude fungovať, pretože každá odstránená skala určite susedila s nádržou, čiže nemôže vzniknúť druhá nádrž, a okolo dezinfekcie máme označené zakázané políčka, čiže sa nám ani nemôže stať, že otrávime obyvyteľov KMP. Tiež určite nebude priveľká, ako už bolo objasnené v predchádzajúcom odseku.

Časová zložitosť BFS je $O(V + E)$, kde $V$ je počet vrcholov grafu a $E$ je počet jeho hrán. V našom prípade je $V$ počet políčok na mape $mn$ a $E \\leq 4V$, pretože každý vrchol má v štvorčekovej mape nanajvýš štyroch susedov. To nám dáva časovú zložitosť $O(mn)$.

Pri pamäťovej zložitosti sa nám nič zásadné nezmenilo. Záleží od implementácie, ale vo všeobecnosti použijeme iba zanedbateľné množstvo pamäte pre BFS/DFS. Takže čo sa týka pamäte, zostávame na $O(nm)$, keďže si pamätáme celú mapu.
",5
8b5a9cb53ba7ec10,ksp,"# Cyklus v potrubí

Jedného dňa sa Marianka rozhodla osamostatniť a presťahovala sa do svojho vlastného bytu. Po pár dňoch bývania si uvedomila, že potrubie, ktoré vedie z jej záchoda, je pomerne opotrebované, a tak sa rozhodla ho vymeniť. Zavolala si majstrov z KSP (Komerční Smenári Potrubí) a tí jej ho bez meškania (rovnako ako robia všetky svoje povinnosti^[Exceptions may occur.]) prišli vymeniť. Dokonca za veľmi výhodnú cenu Marianke ponúkli nové špeciálne jednosmerné potrubia, cez ktoré síce dokáže voda tiecť iba jedným smerom, ale za to sú masívne rýchle. Aby bolo jasné, kto túto prácu vykonal, vyrezali logo KSP do niekoľkých častí potrubia. Po pár dňoch práce bolo nové potrubie hotové a Marianka si mohla spokojne nažívať ďalej. Lenže, hneď pri prvom použití záchoda Marianka zistila, že odtekanie vody zo záchoda nie je až tak masívne rýchle, ako majstri z KSP prezentovali. Sklamaná z výsledku práce si zavolala na pomoc Sama s jeho inšpekčnou kamerou do potrubia. Keď sa do potrubia pozreli, tak zistili, že KSP robotníci z potrubia pod záchodom urobili hotový labyrint. Marianka kontaktovala KSP aby zistila, že prečo potrubie vyzerá tak, ako vyzerá. Zodpovední zamestanci jej odpovedali, že je to preto, aby sa mohla voda, ktorá odtečie zo záchodu nekonečne veľa krát pozrieť na nejaké z KSP lôg, ktoré sú na stenách niektorých potrubí.

Marianke sa ale nezdalo, že by potrubie reálne malo túto vlastnosť a teda chcela, aby jej Samo pomohol zistiť, že či je to naozaj tak. Samo je ale zaneprázdnený rozbehávaním vecí, a tak Marianke nezostalo nič iné ako túto úlohu zveriť Vám. Pomohli by ste Marianke zistiť odpoveď, aby bola opäť šťastná?

## Úloha

Vašou úlohou je určiť, či sa v potrubí nachádza taká postupnosť potrubí, ktorá obsahuje logo KSP a zároveň po nej voda vie chodiť donekonečna. Táto postupnosť musí začínať v záchode, ktorý sa nachádza na spojení potrubí číslo $0$. Nezabudnite, že potrubie pod záchodom je špeciálne -- voda cez potrubie vie tiecť iba jedným smerom.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve medzerou oddelené čísla $n, m$, kde $n$ označuje počet spojení potrubí a $m$ označuje počet potrubí. Spojenia potrubí sú očíslované číslami od $0$ po $n-1$. Nasleduje $m$ riadkov, kde sa na každom riadku nachádzajú $3$ medzerou oddelené údaje: čísla $u, v, 0\\leq u,v < n$ označujúce čísla spojení potrubí, medzi ktorými potrubie vedie a reťazec $s, s \\in {\\texttt{nic}, \\texttt{KSP}}$, ktorý označuje, či sa v danom potrubí nachádza logo KSP alebo nič. Je garantované, že medzi dvomi spojeniami potrubia nevedie potrubie jedným smerom viac ako raz.

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:--------------- |----: |-----: |-----: |-----: |-----: |-----: |------: |------: | | $1 \\leq n \\leq$ | $20$ | $100$ | $120$ | $125$ | $800$ | $1200$ | $4000$ | $6000$ |

## Formát výstupu

Vypíšte jediný riadok, ktorý obsahuje reťazec `obsahuje` v prípade, že systém potrubí obsahuje takú postupnosť potrubí, ktorá začína na spojení medzi potrubiami číslo $0$, že voda môže donekonečna prechádzať okolo niektorého KSP loga. V opačnom prípade vypíšte reťazec `NEobsahuje`.

## Príklady

```vstup
3 3
0 1 KSP
1 2 nic
2 0 nic
```

```vystup
obsahuje
```

```vstup
3 3
0 1 KSP
1 2 nic
2 1 nic
```

```vystup
NEobsahuje
```

_Týmto potrubím síce môže voda prúdiť donekonečna, ale logo KSP vie vidieť iba raz._
","# Cyklus v potrubí {mail=""marcel.palaj@trojsten.sk"" bodypopis=12 bodyprogram=8}

Začnime tým, že si formálnejšie pomenujeme, čo presne je zadaním tejto úlohy. Na vstupe máme systém potrubí, ktorý spolu tvorí graf. Vieme, že potrubie je trochu iné ako bežne poznáme -- voda cez potrubie vie tiecť iba jedným smerom. To znamená, že graf, ktorý reprezentuje potrubie je orientovaný. Niektoré potrubia sú špeciálne, keďže sa na ich stene nachádza KSP logo.

Našou úlohou je zistiť, či v potrubí existuje taká postupnosť potrubí (ktorá začína na spojení číslo $0$), ktorá obsahuje logo KSP a zároveň po nej voda vie chodiť donekonečna. To znamená, že máme zistiť, či graf obsahuje cyklus, ktorý obsahuje hranu, ktorá má na sebe KSP logo. Tento cyklus ale musí byť dosiahnuteľný z vrcholu $0$.

## Existuje cyklus, ktorý prechádza cez túto hranu?

Predstavme si, že máme zistiť, či v grafe existuje cyklus, ktorý obsahuje nejakú konkrétnu hranu. Povedzme, že táto hrana vedie z vrcholu $u$ do vrcholu $v$. To, čo nám stačí urobiť je, že spustíme nejaké naše obľúbené prehľadávanie z vrcholu $v$ (z konca hrany), a budeme zisťovať, že či sa počas prehľadávania dostaneme do vrcholu $u$, teda na začiatok hrany. Ak sa dostaneme, tak to znamená, že sa z vrcholu $u$ vieme dostať do vrcholu $v$, odkiaľ sa našou hranou vieme dostať zase do vrcholu $u$, a teda v grafe existuje cyklus, ktorý obsahuje túto hranu.

To je už takmer to, čo potrebujeme zistiť. Jediná drobnosť ktorá chýba, je overiť, že či sa vieme k tomuto cyklu dostať z vrcholu $0$. To vieme tiež urobiť tak, že spustíme naše obľúbené prehľadávanie z vrcholu $0$. Ak sa nám týmto prehľadávaním podarí dosiahnuť vrchol $u$ (alebo $v$), tak je celý cyklus dosiahnuteľný z vrcholu $0$.

Týmto už máme všetky ingrediencie na prvé riešenie. Tým riešením je, že prejdeme cez všetky hrany s KSP logom. Pre každú z nich zistíme, či sa z koncového vrcholu tejto hrany vieme dostať do počiatočného. Ak áno, tak zistíme, že či je tento cyklus dosiahnuteľný z vrcholu $0$. V prípade, že toto platí aspoň pre jednu hranu zo vstupu, tak je odpoveď `obsahuje`, inak je odpoveď `NEobsahuje`.

Keďže hrán s KSP logom môže byť najviac $m$, a pre každú z nich v najhoršom prípade prehľadáme celý graf (v zložitosti $O(n+m)$), tak celková zložitosť je najviac $O(m(n+m))$. Pamätať si okrem vstupného grafu nemusíme nič, takže pamäťová zložitosť zostáva $O(n+m)$.

## Detekcia cyklov s nejakými špeciálnymi hranami, to mi znie nejako povedome...

Ďalšie riešenie je založené na nasledujúcej myšlienke: V prípade, že ste niekedy počuli o Dijkstrovom alebo Floyd-Warshallovom algoritme, tak ste možno počuli o problémoch, ktoré nastávajú ak v grafe v ktorom zisťujeme vzdialenosti sú medzi vrcholmi záporné hrany (hrany so zápornou dĺžkou).

Konkrétnejšie, teraz nás bude zaujímať to, že občas sa nám môže stať, že v grafe existuje záporný cyklus (cyklus so zápornou dĺžkou). Ten môže spôsobiť, že najkratšia cesta medzi vrcholom $a$ a $b$ obsahuje tento cyklus, a teda dĺžka najkratšej cesty je rovná $-\\infty$ (keďže najkratšia cesta obsahuje nekonečno prejdení záporného cyklu).

Takéto niečo je ale veľmi podobné tomu, čo máme zistiť. Chceli by sme vedieť, že či na ceste z vrcholu $0$ do nejakého iného vrcholu existuje cyklus, ktorý obsahuje špeciálnu hranu (zápornú hranu, resp. hranu s KSP logom).

To, čo teda vieme urobiť je, že zo vstupného grafu urobíme ohodnotený graf. To urobíme tak, že hrany, ktoré neobsahujú KSP logo ohodnotíme nejakým malým kladným číslom -- napríklad $1$. Hrany, ktoré obsahujú KSP logo ohodnotíme $-\\infty$, resp. dostatočne veľkým záporným číslom.

Potom spustíme nejaké prehľadávanie z vrcholu $0$, a ak nájdeme nejaký záporný cyklus, tak môžeme vyhlásiť, že potrubie obsahuje cyklus s nápisom KSP.

Záporné cykly vieme napríklad detegovať Floyd-Warshallovovym algoritmom, a to tak, že najprv spustíme tento algoritmus, ktorý nájde najkratšie vzdialenosti medzi každou dvojicou vrcholov. Záporný cyklus sa nám na výsledných vzdialenostiach prejaví tak, že najkratšia vzdialenosť z vrcholu do samého seba je záporná. Následne zistíme, či je nejaký z vrcholov, cez ktorý prechádza záporný cyklus dosiahnuteľný z vrcholu $0$.

Floyd-Warshallov algoritmus má časovú zložitosť $O(n^3)$ a následne ešte potrebujeme prejsť celý graf, aby sme zistili, ktoré vrcholy sú dosiahnuteľné z vrcholu $0$. Výsledná časová zložitosť je teda rovná $O(n^3 + n+m) = O(n^3)$. Pamätať si okrem celého grafu potrebujeme ešte maticu vzdialeností medzi vrcholmi (ktorá síce môže byť porovnateľne veľká s počtom hrán, ale pre korektnosť ju spomíname). To znamená, že pamäťová zložitosť je $O(n+m+n^2)$.

## Vzorové riešenie

Ako na väčšinu takýchto úloh, vzorové riešenie je použiť prehľadávanie do hĺbky. Ako prvé si je treba uvedomiť, ako pri prehľadávaní do hĺbky vieme detegovať cykly.

Najprv si uvedomme, že počas prehľadávania grafu môžu byť vrcholy v trochu rôznych ""stavoch"": nenavštívené, otvorené a zatvorené. Ako _nenavštívené_ označujeme také vrcholy, že v nich sme ešte neboli (náš algoritmus ich nenavštívil), a ešte čakajú na svoje objavenie. _Otvorenými_, nazvime také vrcholy, že algoritmus aktuálne prehľadáva niektoré vrcholy v ich podstrome, teda že sme už tieto vrcholy objavili, ale ešte sme neprezreli všetky hrany, ktoré z nich vedú. Tretím druhom sú _uzavreté_ vrcholy. To sú také, že sme už prezreli všetky hrany, ktoré z nich vedú a odišli sme z nich prehľadávať niečo iné (a už sa sem nikdy nevrátime).

Následne, podľa toho, do ktorého vrcholu smeruje hrana, DFS počas prehľadávania stromu nachádza $3$ druhy hrán:

- dopredné/stromové. Tento druh hrán sa vyskytne vtedy, keď prejdením po tejto hrane prídeme do ešte neobjaveného vrcholu.

- spätné. Tento druh hrán sa vyskytne vtedy, keď hrana smeruje do otvoreného vrcholu. Môžete si rozmyslieť, že tento vrchol musí byť nejaký predok (v DFS strome) daného vrcholu..

- priečne/kolmé. Tento druh hrán smeruje do už uzatvorených vrcholov. Môžete si rozmyslieť, že tento vrchol nie je predok (v DFS strome) daného vrcholu.

V prípade, že by sa v grafe nevyskytovali žiadne cykly, tak by graf obsahoval iba dopredné a priečne hrany (opäť si premyslite prečo). Tá vec, ktorá nás teda pri hľadaní cyklov bude zaujímať je, že či v grafe existujú spätné hrany. V prípade, že v grafe existuje nejaká spätná hrana, tak v grafe existuje aj cyklus.

Otázka je, že ako zistiť, že či sa niekde na tomto cykle vyskytla hrana s nápisom KSP. Mohli by sme samozrejme nejako prejsť celú postupnosť hrán, a zisťovať, že či tam taká hrana nebola, ale ide to aj výrazne jednoduchšie. Stačí nám zaznamenávať si počet hrán s nápisom KSP, ktoré sme doteraz videli po ceste z vrcholu $0$. V prípade, že nájdeme spätnú hranu, tak nám stačí zistiť, koľko hrán s nápisom sme videli po ceste do vrcholu, kde aktuálne sme, a koľko ich bolo vo vrchole, kam vedie spätná hrana. Ak sa tento počet líši (alebo má samotná spätná hrana nápis), tak sa niekde na cykle musela vyskytnúť spätná hrana.

Takéto riešenie okrem bežného DFS robí pre každý vrchol iba konštantne viac operácií, a teda celý algoritmus beží v zložitosti ako bežné DFS, teda $O(n+m)$. Pamätať si potrebujeme iba celý vstupný graf, a teda zložitosť je $O(n+m)$.
",6
d5d3dd733442cb6b,ksp,"# Zabudnutá chata

Kde bolo tam bolo, tam, kde sa piesok lial a nesypal, kde vtáky spievali pop-punkové balady, v krajine bohatej na prírodu sa nachádzal borovicový les. V strede tohto lesa sa nachádzala zabudnutá chata. Vedúci KSP (kúlový spolok programátorov) sa o tejto chate dozvedeli cez Groogle, ktorý ju označil ako lacnú. Okamžite sa v nej rozhodli spraviť si veľkolepú oslavu, na ktorej sa chce zúčastniť úplne každý.

Ako to však vo svete chodí, nič nie je zadarmo, a aj prenájom tejto chaty niečo stojí. Každý vedúci má našetrenú nejakú sumu peňazí, z ktorej je ochotný prispieť ľubovoľne veľa (ale nie viac). Problém je však v tom, že na chatu chce dať každý presne rovnakú sumu, ako na ňu dajú ostatní^[Bolo by asi nefér, aby Mišo cvakal všetko za Žabu.].

Keďže je táto chata taká zabudnutá, pani domáca nie je veľmi zvyknutá na ľudí a dokáže byť pomerne nevrlá^[Podľa tej jednej recenzie, čo Groogle našiel.]. Vedúci si ju nechcú pohnevať napríklad tým, že jej budú platiť v centoch, a preto radšej každý zaplatí sumu v celých eurách, aj keby mali celkovo zaplatiť viac, ako je potrebné.

## Úloha

Pre danú cenu chaty $c$ a osobné finančné limity každého vedúceho $s_i$ zistite maximálny počet ľudí, ktorí sa môžu zúčastniť tejto chaty. Dokopy musia byť schopní chatu zaplatiť a každý z nich musí zaplatiť rovnakú celočíselnú sumu (pričom nikto nepresiahne svoj limit). Nezaujíma nás, či za cenu pridania ďalšieho vedúceho zaplatíme dokopy o niečo viac.

## Formát vstupu

Na prvom riadku dostanete postupne celé čísla $n, c$ ($1 \\leq n \\leq 150,000$, $0 \\leq c \\leq 10^9$) -- počet vedúcich a cenu chaty. Na nasledujúcom riadku bude $n$ medzerou oddelených čísiel $0 \\leq s_i \\leq 10^9$. $s_i$ reprezentuje najväčšiu sumu, ktorú je ochotný zaplatiť $i$-ty vedúci.

Medzivýpočty sa nemusia zmestiť do klasických celočíselných premenných. Odporúčame preto používať typy *long long* v *C++*, prípadne *int64* v *Pascale*.

## Formát výstupu

Vypíšte jedno číslo -- maximálny počet vedúcich, ktorí sa chaty zúčastnia. Výstup nezabudnite ukončiť znakom nového riadku.

## Príklad

```vstup
3 47
47 1 42
```

```vystup
2
```

_Zaplatia to prvý vedúci s tretím, každý po 24 eurách._

```vstup
10 7
0 1 0 0 2 1 1 1 0 1
```

```vystup
0
```

_Hoci by vedúci vedeli dať dokopy 7 eur, každý musí zaplatiť rovnako veľa. Preto vedúci zaplatiť nevedia a na chatu nepôjde nikto._
","# Zabudnutá chata

Predstavme si, že **vieme** po akej sume sa budú vedúci skladať. Pomôže nám to? Na chatu chcú ísť všetci vedúci, ktorí môžu, a teda ak sa skladajú po $5$ eurách, pôjdu všetci tí, ktorí majú aspoň $5$ eur, ak po $7$-mich, tak tí, čo majú aspoň $7$.

Nech teda každý, kto môže, zaplatí sumu $S = 5$ eur. Ak postupne prejdeme limity všetkých vedúcich, vieme spočítať, koľko vedúcich na to má. Ostáva nám skontrolovať, či takto dokopy zaplatia za celú chatu. Ak hej, tak máme výsledok, ak nie, tak na chatu nepôjde nikto.

My ale túto sumu $S$ nepoznáme. Nevadí, vieme **vyskúšať všetky** prípustné hodnoty $S$ a pre každú z nich zistiť, koľko vedúcich tak môže ísť na chatu. Stačí nám priebežne si pamätať a upravovať najväčší počet zúčastnených vedúcich, a na konci toto číslo vypísať.

Posledná vec, ktorú musíme domyslieť, je to, aké hodnoty $S$ máme skúšať:

- $0\\leq S\\leq c$ -- nedáva zmysel, aby pani domáca dostala od každého vedúceho viac ako je celková cena chaty

- $0\\leq S\\leq max(s_i)$ -- nemôžeme od chudákov vedúcich chcieť, aby každý zaplatil viac ako má ten *najbohatší* z nich

Keďže sa pre každú hodnotu $S$ pozrieme na finančný limit každého z $n$ vedúcich, je časová zložitosť tohto riešenia $O(min(c, max(s_i)) \\cdot n)$.

Pamätať si stačí finančné limity vedúcich spolu so zopár premennými -- pamäťová zložitosť je preto $O(n)$.

Hodnoty $c$ aj $s_i$ môžu byť však **príliš veľké** (až $10^9$) a preto musíme vymyslieť algoritmus, ktorý od nich buď nebude závisieť, alebo bude závisieť menej ako lineárne.

## Skúšajme menej možností

V predošlom riešení sme robili veľa vecí navyše. Keď overujeme sumu $S$, tak počet vedúcich, ktorí ju vedia zaplatiť sa predsa zmení až vtedy, keď $S$ nadobudne hodnotu finančného limitu nejakého ďalšieho vedúceho. **Stačí nám teda postupne prekontrolovať len $S = s_i$**, kde $s_i$ označuje finančný limit $i$-teho vedúceho.

Toto riešenie sa pre každý limit pozrie na všetkých vedúcich a teda sme prišli na riešenie s časovou zložitosťou $O(n^2)$. Takto sa na vstupoch dali získať 2 body.

Takéto riešenie dostaneme, ak jednoducho prepíšeme v predošlom programe riadok s for-cyklom na

`for kolko_plati_kazdy in limity:`

## Skúšajme ich v správnom poradí

Skúsme sa pozrieť na druhú fázu nášho algoritmu (pre dané $S$ chceme rýchlo zistiť, koľko vedúcich má $s_i \\geq S$). Predstavme si, že by limity boli **usporiadané podľa veľkosti**: $$s_0 \\leq s_1 \\leq \\dots \\leq s\_{n-1}$$

Potom vieme predsa pre $S=s_i$ **hneď** povedať, koľko vedúcich má limit aspoň $S$ -- je ich presne `n-i`. To ale znamená, že nemusíme už nič overovať. Vyhrali sme, pretože [triediť](https://www.ksp.sk/kucharka/triedenie/) vieme v čase $O(n \\log n)$. Použitie takéhoto triedenia nám dokopy dá riešenie v celkovej časovej zložitosti $O(n \\log n)$, ktoré na testovači získa plný počet bodov.

Pamäťová zložitosť tohto riešenia je $O(n)$ -- potrebujeme si pamätať finančný limit každého vedúceho, bez toho by sme nevedeli triediť.

## **BONUS**: Riešenie s lineárnou časovou zložitosťou

- Pre každého vedúceho $i$ si vyrátajme $L_i$ -- minimálny počet vedúcich, ktorí musia na chatu ísť, aby tam mohol ísť aj $i$-ty vedúci. Inak povedané, pre $S = s_i$^[Keď chceme minimálny počet vedúcich, každý musí platiť najviac, ako sa dá, a to bude práve $s_i$ -- limit $i$-teho vedúceho] vyjadruje $L_i$ minimálny počet vedúcich, ktorí sa po tejto sume musia skladať, aby zaplatili chatu^\[preto je vo vzorci použitá horná celá časť zlomku, čo predstavuje najmenšie celé číslo, ktoré je väčšie alebo rovné ako zlomok (totiž keď zlomok povie, že treba $3.4$ vedúceho, znamená to, že traja chatu nezaplatia, ale štyria už áno)\]: $$L_i = \\Big\\lceil \\frac{c}{s_i} \\Big\\rceil$$

- Vytvorme si pole $X$, kde $X_i$ bude reprezentovať počet vedúcich s $L = i$. Inak, $X_i$ hovorí o počte vedúcich, ktorí vyžadujú $i$ vedúcich, aby išli na chatu. Toto vieme vytvoriť už za rátania hodnôt $L$, ak vyrátame $i$-temu vedúcemu $L_i$, zvýšime hodnotu $X\_{L_i}$ o jedna.

- Na tomto poli ($X$) si spočítame [prefixové sumy](https://www.ksp.sk/kucharka/prefixove_sumy/). Hodnota $X_i$ nám teraz bude hovoriť o počte vedúcich, ktorí vedia na chatu ísť, ak pôjde **aspoň** $i$ vedúcich (rozmyslite si).

- Teraz nám už len stačí toto pole prejsť a ak $i \\leq X_i$, tak $X_i$ vedúcich vie na chatu ísť. Nájdeme maximum.

Časová aj pamäťová zložitosť je už spomínané $O(n)$, keďže len prechádzame pole a robíme na ňom aritmetické operácie.

**Pozn.:** Toto riešenie sme od vás nevyžadovali. Ak ste ho však vymysleli, môžete očakávať **bonusové body** za popis.
",2
071a1766e8f09139,ksp,"# Na dušu liek

Mesto je v karanténe. Všetci sú doma odizolovaní a odlúčení od akejkoľvek ľudskej interakcie. Obyvatelia už dva mesiace nevideli žiaden úsmev, lebo všetky tváre sú zahalené v rúškach. Počasie je ponuré, doma niet čo robiť. Všetci sú v depresii.

Mestská správa však nestráca nádej a rozhodla sa s tým niečo urobiť. Obyvateľstvo by určite rozveselilo trocha motivačnej hudby z rádia. V meste však nie je vysielač, tak treba nejaký postaviť.

Avšak so zvyšujúcou sa vzdialenosťou od vysielača sa zhoršuje signál, a zvyšuje depresia. Presnejšie depresia každého občana je rovná druhej mocnine jeho vzdialenosti od vysielača v metroch.

Aby sa signál mohol lepšie šíriť do všetkých strán a nestáli mu v ceste budovy rozhodli sa ho postaviť na križovatke. Ktorá križovatka však bude najvhodnejšia?

## Úloha

Mesto má tvar štvorcovej siete o rozmeroch $r \\times s$. Políčka sú štvorcové pozemky s dĺžkou strany $8$ metrov. Každý pozemok má súradnice $(i,j)$, je na ňom jeden dom a žije v ňom $c\_{i j}$ ľudí. Pre zjednodušenie predpokladáme, že všetci ľudia sa nachádzajú presne v strede pozemku na ktorom bývajú. V severozápadnom rohu mesta je pozemok so súradnicami $(1,1)$ a v juhovýchodnom $(r,s)$. Medzi pozemkami vedú ulice, ich šírku môžeme zanedbať. Tieto ulice sa pretínajú v $(r + 1) \\times (s + 1)$ križovatkách. V severozápadnom rohu mesta je križovatka so súradnicami $(0,0)$, v juhovýchodnom $(r,s)$.

Zistite na ktorej križovatke má mesto postaviť vysielač aby celková depresia jeho obyvateľstva bola najmenšia možná.

## Formát vstupu

Na prvom riadku sú dve celé čísla $r$ a $s$, oddelené medzerou - rozmery mesta. Platí $1 \\leq r,s \\leq 1,000$ Nasleduje $r$ riadkov, každý z nich obsahuje $s$ celých čísel oddelených medzerou. V $i$-tom riadku a $j$-tom stĺpci je číslo $c\_{i j}$, počet obyvateľov domu na súradniciach $(i,j)$. Platí $0 \\leq c\_{i j} \\leq 100,000$.

Je osem testovacích sád. V sadách 1 a 2 naviac platí $r,s \\leq 30$, a v sadách 3, 4 a 5 platí $r,s \\leq 200$.

## Formát výstupu

Na prvý riadok vypíšte jedno číslo; najmenšiu dosiahnuteľnú depresiu. Na druhý riadok vypíšte súradnice vysielača, ktoré túto hodnotu dosiahnu. Ak existuje viac riešení vypíšte ľubovoľné z nich.

Výsledok sa nemusí zmestiť do klasickej 32 bitovej číselnej premennej (v `C++` preto použite premennú typu `long long`).

## Príklady

```vstup
2 3
1 2 2
2 9 1
```

```vystup
928
1 1
```

*Optimálne je tiež aj $(1,2)$. $928$ sme dostali ako $32\\cdot(1+2+2+9)+160\\cdot(2+1)$*

```vstup
4 4
0 0 0 2
1 2 5 3
2 0 1 4
1 1 0 0
```

```vystup
2880
2 2
```
","# Na dušu liek

## Hrubá sila

Najpriamočiarejšie riešenie, je riešenie hrubou silou. Skúšame postupne všetkých $(r+1)\\cdot(s+1)$ možných súradníc vysielača. Pre každú možnosť prejdeme cez všetkých $r\\cdot s$ domov aby sme spočítali celkovú depresiu.

Časová zložitosť takéhoto riešenia je $O(r^2s^2)$. Pamäťová zložitosť je $O(rs)$ (pre každý dom si pamätáme počet obyvateľov).

## Rozdelíme si to

Celkovú depresiu pre vysielač na súradniciach $(x,y)$ si vyjadríme takto: $$\\sum\_{i=1}^{r}\\sum\_{j=1}^{s}c\_{ij}\\left((8x-8i+4)^2+(8y-8j+4)^2\\right)$$ Stačí si uvedomiť, že toto môžeme rozdeliť na dve časti: $$\\left(\\sum\_{i=1}^{r}\\sum\_{j=1}^{s}c\_{ij}(8x-8i+4)^2\\right)+\\left(\\sum\_{i=1}^{r}\\sum\_{j=1}^{s}c\_{ij}(8y-8j+4)^2\\right)$$ Na $x$-ovú časť depresie, ktorá závisí iba od $x$ a nezávisí od $y$ a na $y$-ovú časť, ktorá závisí iba od $y$. Vďaka tomu môžme hľadať najlepšie $x$ a $y$ nezávisle od seba. Inak povedané, nemusíme skúsiť všetky dvojice $(x,y)$, namiesto toho najprv nájdeme najlepšie $x$ (ktoré minimalizuje $x$-ovú časť depresie), a potom najlepšie $y$.

Takto sme si zlepšili časovú zložitosť na $O(rs^2+r^2s)$.

## Vzorové riešenie

Čo sa týka x-ovej časti depresie, nerozlišujeme, v akom je dom stĺpci. Záleží nám len na čísle riadka. Všetky domy v tom istom riadku môžme sčítať dokopy. Keď si predpočítame súčty riadkov, budeme môcť počítať $x$-ovú časť depresie rýchlejšie. Označme si $R_i$ súčet počtov obyvateľov domov v riadku $i$. $x$-ová časť depresie teda je: $$\\sum\_{i=1}^{r}R_i(8x-8i+4)^2$$ Pre jedno $x$ zrátame $x$-ovú časť depresie jedným cyklom v čase $O(r)$. Musíme vyskúšať $r$ možností, hľadanie najlepšieho $x$ nám teda tentoraz zaberie $O(r^2)$

Samozrejme, rovnaký trik spravíme aj pri počítaní $y$-ovej časti depresie. Predpočítame si teda aj súčty stĺpcov.

## Časová a pamäťová zložitosť

Časová zložitosť takéhoto riešenia je $O(r^2+s^2)$. Pamäťová, ak si budeme šikovne počítať súčty riadkov a stĺpcov už pri načítavaní vstupu, je $O(r+s)$ (nemusíme si držať celé dvojrozmerné pole domov v pamäti).
",4
0aa4ff7af8f7f237,ksp,"# Reaktor v problémoch

Píše sa 31. december 1999. Frajerskí Kóderi Systémov nezískali tender na napísanie programu pre tajnú jadrovú elektráreň na matfyze. Jednalo sa o jeden z najdôležitejších programov -- program na ovládanie žiarovky vnútri kontrolnej miestnosti. Len si predstavte tú galibu, keby bola v kontrolnej miestnosti tma. Alebo nebodaj, keby sa žiarovka zapla dvakrát. Brr -- určite aj vás striaslo pri tejto myšlienke. Zákazku namiesto vás získal Klub Machrov Skoro-programátorov.

Mišofovi, vtedy ešte mladému a udatnému junákovi, to akosi nedalo. Vkradol sa preto pod rúškom noci do KMS servera a prezrel program, ktorý napísali. Chcel by program otestovať. Najprv však musí po sebe upratať, aby nikto nezistil, že tam lozil. Pomôžte mu zatiaľ napísať program, ktorým by otestoval to čo vytvorili KMS-áci!

## Úloha

Na vstupe dostanete rozvrh časov, kedy má byť žiarovka zapnutá. Zistite, či v tomto rozvrhu nastane situácia, kedy by žiarovka mala byť zapnutá viackrát naraz.

## Formát vstupu

Na prvom riadku vstupu dostanete dve čísla - $n$ a $m$. Číslo $n$ ($1 \\leq n \\leq 10^6$) udáva dĺžku tmy v sekundách a číslo $m$ ($1 \\leq m \\leq 500,000$) je počet intervalov, kedy má byť žiarovka zapnutá. Každý z následujúcich $m$ riadkov obsahuje dve čísla $a$ a $b$ $(0 \\leq a < b \\leq n)$. Žiarovka by mala byť zapnutá v polootvorenom intervale $\[a, b)$, teda od času $a$ do času $b - 1$ vrátane.

## Formát výstupu

Vypíšte reťazec `ANO` ak je žiarovka zapnutá v nejakom momente viac ako raz. Inak vypíšte reťazec `NIE`.

## Príklad

```vstup
5 3
0 1
1 2
2 3
```

```vystup
NIE
```

```vstup
10 3
3 5
0 2
1 2
```

```vystup
ANO
```
","# Reaktor v problémoch

Problémy v reaktore našťastie nie sú tentokrát také zlé. Niektorým ľudom ale dali trochu zabrať.

Jedným z riešení je skúsiť každý interval so všetkými ostatnými a skontrolovať, či sa prekrývajú. Toto riešenie ale nie je moc efektívne, pretože porovnávame každý interval s každým iným, čo je $O(n^2)$. Keďže $n$ môže byť až milión, toto nie je úplne postačujúce na plný počet bodov.

Kľúčovým pozorovaním je, že časových blokov je *iba* milión. Milión je pre počítač vcelku malé číslo - bežný počítač vie urobiť približne $10^8$ operácií za sekundu. Pre vyriešenie úlohy na plný počet bodov si teda stačí vytvoriť jedno pole veľkosti $n$ (najviac milión) a označovať si, v ktorých blokoch už je žiarovka zapnutá. Pokiaľ narazíme na druhé zapnutie žiarovky na nejakom bloku (inými slovami, nájdeme kolíziu), vypíšeme `ANO`, pokiaľ sme žiadnu kolíziu nenašli, vypíšeme `NIE`.

Toto riešenie má časovú zložitosť $O(n)$, keďže na každý blok sa pozrieme jedenkrát. Pamäťovú zložitosť má tiež $O(n)$, keďže potrebujeme vytvoriť pole veľkosti $n$. Treba si dávať pozor, aj keď $n$ môže byť iba milión, nejedná sa o konštantú časovú zložitosť. Toto ''umelé'' obmedzenie $n$ je iba z dôvodov testovania vašich riešení.
",1
2704f0b337b605a1,ksp,"# Ideálne cestovanie metrom

V blízkej budúcnosti krajiny v rámci boja s globálnym otepľovaním zvýšili investície do hromadnej dopravy metrom (lebo je úspornejšia a hlavne v tomto teple pod zemou), a do jadrovej energie (lebo emisie).

Akonáhle všetky jadrové elektrárne povybuchovali, metro sa stalo najväčším centrom civilizácie^[nemalo na povrchu príliš konkurenciu]. Obyvatelia metra však rýchlo objavili závažný problém -- nie všetky tunely metra sú dostatočne hlboko pod zemou, aby cesta nimi bola zabezpečená voči radiácií z povrchu. Toto komplikuje cestovanie z jednej stanice metra do druhej, keďže priamy spoj môže byť viac zdraviu škodlivý ako ísť okľukou. Čo už, zabiť hodinu neoptimálnou trasou je lepšie ako zabiť seba otrávením radiáciou.

Artyom dostal o každom tuneli hlásenie o nameranej radiácií, a veľa dotazov od obyvateľov o najbezpečnejšej trase medzi dvoma stanicami metra. Radšej by však išiel s kamošmi loviť zmutované potkany ako sa prehrabávať mapami a radiť susedom ako najbezpečnejšie odniesť prádlo do práčovne. Poprosil vás preto o pomoc.

## Úloha

Trasa medzi dvoma stanicami metra je postupnosť staníc taká, že prvá stanica je začiatočná, posledná je konečná, a každá za sebou idúca dvojica staníc je spojená tunelom.

Nebezpečnosť cesty je najvyššie meranie radiácie v niektorom z tunelov, ktorý je na trase použitý.

Pre každú danú začiatočnú a konečnú stanicu metra nájdite najmenej nebezpečnú trasu medzi nimi, a vypíšte jej nebezpečnosť.

## Formát vstupu

V prvom riadku sú čísla $n$ a $m$ -- počet staníc metra a počet tunelov. V nasledujúcich $m$ riadkoch sú trojice čísel $a_i\\ b_i\\ c_i$, znázorňujúce tunel medzi stanicami $a_i$ a $b_i$ s výškou radiácie $c_i$. Stanice sú očíslované od $1$ po $n$, a je zaručené že z každej stanice sa dá dostať do každej inej nejakou postupnosťou tunelov.

Za nimi sa nachádza číslo $q$ -- počet dotazov. Každé z daľsích $q$ riadkov obsahuje dve čísla $z_i\\ k_i$, dotaz na najbezpečnejšiu cestu začínajúc na stanici $z_i$ a končiacou stanicou $k_i$.

Vo všetkých vstupoch platí $1 \\leq n,q$ (aspoň niečo budete mať robiť), $n-1 \\leq m \\leq \\frac{n(n-1)}{2}$ (ciest je dosť na prepojenie metra, ale nie viac ako možný počet priamych spojení), $a_i \\neq b_i$ (tunel nevedie zo stanice naspäť na ňu) $1 \\leq c_i \\leq 10^9$.

| Sada | 1 | 2 | 3 | 4 | |:------ | -------:| --------:| ---------:| -----------:| | $n$ | $15$ | $2,033$ | $100,000$| $300,000$ | | $m$ | $15$ | $2,033$ | $100,000$| $300,000$ | | $q$ | $15$ | $50,000$| $100,000$| $300,000$ |

## Formát výstupu

Pre každý dotaz vypíšte najmenšie číslo $0 \\leq r_i$ také, že sa dá dostať zo stanice $z_i$ do $k_i$ a pritom nepoužiť tunel s radiáciou vyššou ako $r_i$.

## Príklad

```vstup
5 5
1 2 5
3 1 10
2 3 6
3 4 9
4 5 3
5
3 1
3 4
3 5
4 5
5 5

```

```vystup
6
9
9
3
0

```

_Takto vyzerá sieť metra z príkladu. V prvom dotaze sa nám oplatí ísť okľukou cez stanicu 2._
","# Ideálne cestovanie metrom

Krátka rekapitulácia úlohy: Máme ovahovaný graf -- $n$ staníc metra prepojených $m$ tunelmi rôznej nebezpečnosti -- a $q$ otázok na dve stanice, odpoveďou je také číslo $r$, že nevieme precestovať medzi týmito dvoma stanicami bez toho, aby sme použili tunel s nebezpečnosťou aspoň $r$.

### Hrubá sila

V prvej sade máme všetkého -- staníc, tunelov, otázok -- najviac $15$. Môžeme si teda dovoliť skoro hocičo. Napríklad si môźeme pre každú otázku vyskúšať všetky podmnožiny tunelov, overiť či sa vieme dostať medzi dvoma stanicami z otázky, a ak áno, pozrieť aký najnebezpečnejší tunel sme v podmnožine nechali. Odpovedáme najmenšiou nebezpečnosťou s ktorou sa nám to niekedy podarí. Takéto niečo by zbehlo v $O(q \\cdot (n+m)2^n)$.

### Jediná správna cesta

Predstavte si, že začíname s metrom v ktorom niesu vybudované žiadne tunely, a teda sa medzi žiadnymi rôznymi stanicami nevieme dostať. Začneme teraz budovať všetky tunely od najmenej nebezpečnejšieho po najnebezpečnejší. Vždy keď ideme stavať tunel, pozrieme sa či už sa medzi danými dvoma stanicami vieme nejako dostať, a ak áno, nepostavíme ho. V istom bode prepojíme celé metro, čiže sa vieme dostať medzi všetkými dvojicami staníc, a žiadny z nevystavaných tunelov by sme ajtak nepoužili -- každý z nich je nebezpečnejší ako nejaká množina tunelov, ktoré nám dovoľujú sa pohybovať medzi tými stanicami ktoré tento nebezpečný tunel spája. Získame jednoducho najlacnejšiu kostru mesta, ktorá má stromovú štruktúru.

Najmenej nebezpečná cesta medzi dvoma stanicami $a$ a $b$ je potom presné tá jediná cesta v našej vystavanej kostre, ktorá medzi nimi vedie. Jediné čo potrebujeme zistiť je najdrahšia hrana, ktorá na nej leží.

Túto informáciu si môžeme predpočítať -- keď dostaviame kostru, spustíme v cykle s každej stanice prehľadávanie do šírky, v ktorom si navyše pamätáme akú najnebezpečnejšiu hranu sme dosiaľ použili, aby sme sa dostali na danú stanicu. Vždy keď použijeme tunel, túto hodnotu prepíšeme na maximum z nej, a nebezpečnosti tohoto tunela, a túto hodnotu si zapíšeme do tabuľky. Keď nám prehľadávanie do širky skončí, máme $n \\times n$ tabuľku, v ktorej na indexe `[a][b]` máme zapísanú najdrahší tunel, ktorý bol prehľadávaním použitý na cesta z $a$ do $b$.

Každú otázku potom jednoducho odpovedáme v konštantnom čase.

Pamäťová zložitosť našeho riešenia je $O(n^2)$ a časová zložitosť je $O(m \\log n)$ na postavanie najlacnejšej kostry, $O(n^2) na prehľadávania do šírky a $O(q)$ na odpovedanie otázok. Dokopy teda $O(n^2+q)$, keďže $m ~ n$.

Ak sa cítime trochu lenivejšie, môžeme namiesto stavania najlacnejšej kostry rovno pustiť prehľadávanie dijkstrou, v ktorej preferujeme vrcholy ktoré sme dosiahli s najmenšou nebezpečnosťou, čo nám síce o logaritmus zhorší zložitosť, ale v druhej sade prejde.

### A však máme strom

Keďže najlacnejšia kostra nášho metra je nutne strom, môžeme siahnuť po nejakom algoritme ktorý na stromoch vieme púšťať. Každá otázka požaduje zistiť informáciu o nejakej ceste v našom strome -- najnebezpečnejšiu hranu na nej. Táto informácia má dobrú vlastnosť, že keď máme dve cesty ktoré sa napájajú (cesta z $a$ do $b$ a z $b$ do $c$) a pre ktoré vieme odpoveď, a spojíme ich do jednej cesty ($a$ do $c$), tak pre ňu vieme ľahko spočítať odpoveď -- je to maximum z odpovedí pre jednotlivé cesty.

Algoritmus ktorý takéto niečo spokojne zráta je [LCA -- najnižší spoločný predok](https://www.ksp.sk/kucharka/lca/). Ak tento algoritmus neovládate, určite si o ňom prečítajte, zvyšok vzoráku ho len priamočiaro použije. Zakoreníme si našu najlacnejšiu kostru o ľubovoľný vrchol, a pri predrátavaní si predkov si rátame aj najnebezpečnejšiu hranu v každom jednotlivom skoku.

Keď dostaneme dotaz na cestu medzi stanicami $a$ a $b$, poskáčeme našimi skokmi mocnín dvojky k ich najnižšiemu spoločnému predkovi, čo teda predstavuje niekoľko ciest ktoré sa dokopy napoja na práve tú jedinú cestu medzi nimi v našom strome, a naša odpoveď je najväčšie číslo ktoré v týchto skokoch stretneme. Každý teda odpovieme v logaritmickom čase.

Pamäťová zložitosť je $O(n \\log n)$ na logaritmický počet skokov z každej stanice.

Postaviť kostru nám trvá $O(m \\log n)$, predrátať skoky na predkov $O(n \\log n)$, a odpovedať na všetky dotazy $O(q \\log n)$, celkovo teda $O((m+n+q) \\log n)$.
",9
96652713d0fa4cfd,ksp,"# Automat

V Erikovej škole majú automat na čokoládové tyčinky. Taký klasický automat: vhodíte peniaze, vyberiete si, akú tyčinku chcete, a automat vám ju vydá.

Nedávno sa však automat pokazil, takže väčšinou vám okrem tyčinky, ktorú ste si vybrali, vysype aj nejaké ďalšie. Erik, súc charakterný mladý muž, túto poruchu ihneď nahlásil a prestal automat používať. Keďže je však Erik zároveň aj od prírody veľmi zvedavý, napadla mu jedna hypotetická otázka: koľko by toho dokázal z automatu vytiahnuť za peniaze, ktoré má práve pri sebe?

## Úloha

Automat predáva $n$ rôznych druhov tyčiniek, očíslovaných $1$ až $n$. Z každého druhu je v automate niekoľko kusov a každý druh má nejakú cenu (rôzne druhy môžu mať rôzne ceny). Ak si v automate kúpite tyčinku druhu $x$, automat vám navyše vydá po jednej tyčinke z druhov $1, 2, \\dots, x-1$ (ak ešte nejaké má. Ak z nejakého druhu už nemá žiadnu tyčinku, jednoducho vám z tohto druhu nevydá nič). Ak automatu dôjdu tyčinky nejakého druhu, prestane tento druh predávať (takže tyčinky tohto druhu sa už nedajú kúpiť).

Erik má momentálne pri sebe $k$ centov. Aká je najväčšia možná celková hodnota tyčiniek, ktoré Erik dokáže ,,kúpiť'' z automatu za peniaze, ktoré má?

## Formát vstupu

V prvom riadku vstupu sú dve medzerou oddelené celé čísla $n, k$ ($1 \\leq n \\leq 50$, $1 \\leq k \\leq 200,000$) -- počet druhov tyčiniek a množstvo peňazí, ktoré má Erik k dispozícii.

Druhý riadok obsahuje $n$ medzerami oddelených celých čísel $c_1, c_2, \\dots, c_n$ ($1 \\leq c_i \\leq 50$), kde $c_i$ je cena $i$-teho druhu tyčiniek.

Tretí riadok obsahuje $n$ medzerami oddelených celých čísel $p_1, p_2, \\dots, p_n$ ($0 \\leq p_i \\leq 50$), kde $p_i$ je počiatočný počet tyčiniek $i$-teho druhu.

## Formát výstupu

Vypíšte jeden riadok obsahujúci jedno celé číslo: najväčšiu možnú hodnotu tyčiniek, ktoré dokáže Erik získať s peniazmi, ktoré má.

## Príklady

```vstup
5 30
15 25 10 50 5
3 6 3 5 2
```

```vystup
285
```

\_Erik najprv za 20 centov kúpi dve tyčinky 3. druhu (pričom mu z automatu vypadnú aj po dve tyčinky

1. a 2. druhu). Následne kúpi dve tyčinky 5. druhu. Pri nákupe prvej z nich dostane aj po jednej tyčinke z prvých štyroch druhov, pri nákupe druhej z nich dostane tyčinku 2. a 4. druhu (tyčinky 1. a 3. druhu sa už minuli). Nakoniec má teda Erik 3 tyčinky 1. druhu, 4 tyčinky 2. druhu, 3 tyčinky 3. druhu, a po 2 tyčinky 4. a 5. druhu.\_
","# Automat

Spôsobov, ako môže Erik postupne nakupovať tyčinky, je veľa. Na začiatok je preto dobré uvedomiť si, že je dôležité, koľko akých tyčiniek Erik kúpi, ale nie je dôležité, v akom poradí:

- Ak nám Erik povie, že kúpil (t. j. vybral a **zaplatil**) $t_1, t_2, \\dots, t_n$ tyčiniek druhov $1, 2, \\dots, n$, vieme už jednoznačne určiť, koľko akých tyčiniek mu automat vysypal:

  - Tyčinky druhu $n$ dával automat Erikovi iba vtedy, keď si ich naozaj kúpil, teda Erik ich dostal dokopy $t_n$.

  - Tyčinky druhu $n-1$ sa automat snažil Erikovi dať vždy, keď si kúpil tyčinku druhu $n-1$ alebo $n$. To znamená, že ak má automat na začiatku $t_n + t\_{n-1}$ alebo viac tyčiniek druhu $n-1$, Erik bude mať na konci $t_n + t\_{n-1}$ tyčiniek tohto druhu. V opačnom prípade dostane Erik všetkých $p\_{n-1}$ tyčiniek druhu $n-1$.

  - Túto úvahu môžeme zovšeobecniť: tyčiniek druhu $i$ Erik dostane presne $$\\min(p_i,,, t_i + t\_{i+1} + \\dots + t_n) \\text{.}$$

Samozrejme, ak by Erik nakupoval tyčinky v zlom poradí, mohol by sa nejaký druh minúť skôr, než z neho Erik kúpi všetky tyčinky ktoré chcel. Tomuto sa však vždy dá ľahko vyhnúť: jednoducho najprv nakúpime všetky tyčinky druhu $1$ ktoré chceme, potom tyčinky druhu $2$, potom druhu $3$ atď.. Ako sme si ukázali, toto poradie je rovnako dobré ako každé iné.

Pri hľadaní optimálneho riešenia teda môžeme spokojne zabudnúť na to, že tyčinky sa kupujú v nejakom poradí a stačí nám nájsť optimálnu sadu tyčiniek, ktoré má Erik kúpiť.

## Dynamické programovanie

Naše riešenie bude založené na technike zvanej _dynamické programovanie_. Keď riešime úlohu pomocou dynamického programovania, musíme si položiť dobrú otázku. V našom prípade to bude otázka:

_Pre dané $X, Y, Z$: Akú najväčšiu hodnotu vieme získať v tyčinkách prvých $X$ druhov, ak na tyčinky prvých $X$ druhov minieme nanajvýš $Y$ peňazí a z posledných $n-X$ druhov kúpime dokopy presne $Z$ tyčiniek?_

Táto otázka znie dosť krkolomne,^[Ak viete používať dynamické programovanie, vymyslieť túto otázku bola pravdepodobne najťažšia časť tejto úlohy.] má však niekoľko kľúčových dobrých vlastností. Označme si odpoveď na našu otázku pre nejaké $X, Y, Z$ ako $o(X, Y, Z)$:

- Je len ohraničený počet možných trojíc $X, Y, Z$, pre ktoré má zmysel sa našu otázku pýtať.

- Hodnota $o(n, k, 0)$ je riešením našej úlohy.

- Ak $X = 0$, odpoveď vieme ľahko zistiť: je rovná $0$.

- Odpoveď pre nejaké $X > 0, Y, Z$ vieme ľahko zistiť, ak poznáme odpovede pre menšie $X$. Stačí nám rozobrať všetky možnosti, koľko tyčiniek druhu $X$ kúpime:

  - Ak sa rozhodneme nekúpiť žiadnu tyčinku druhu $X$, získame od automatu $\\min(Z, p_X)$ tyčiniek tohto druhu (keďže kupujeme $Z$ tyčiniek druhov s vyšším číslom). Tie budú mať hodnotu $c_X \\cdot \\min(Z, p_X)$. V tyčinkách druhov $1$ až $X-1$ potom získame nanajvýš $o(X-1, Y, Z)$ peňazí, dokopy teda získame $c_X \\cdot \\min(Z, p_X) + o(X-1, Y, Z)$.
  - Ak kúpime jednu tyčinku druhu $X$, získame $\\min(Z+1, p_X)$ tyčiniek druhu $X$, v hodnote $c_X \\cdot \\min(Z+1, p_X)$. Na tyčinky druhov $1$ až $X-1$ nám pritom ostane $Y - c_X$ peňazí, pričom tyčiniek druhov $X$ až $n$ kupujeme dokopy $Z+1$. To znamená, že v tyčinkách druhov $1, \\dots, X-1$ získame nanajvýš $o(X-1, Y-c_X, Z+1)$ peňazí, dokopy $o(X-1, Y-c_X, Z+1) + c_X \\cdot \\min(Z+1, p_X)$.
  - Všeobecne, ak kúpime $k$ tyčiniek druhu $X$, získame $c_X \\cdot \\min(Z+k, p_X)$ v tyčinkách druhu $X$ a $o(X-1, Y-k c_X, Z+k)$ v tyčinkách nižších druhov. Toto má, samozrejme, zmysel iba pre také $k$, že $k c_X \\leq Y$ a $k \\leq p_X$.

  Hodnota $o(X, Y, Z)$ je teda maximum z hodnôt $$c_X \\min(Z+k, p_X) + o(X-1, Y-k c_X, Z+k)$$ pre všetky zmysluplné $k$.

Odpoveď na našu otázku by sme teda vedeli počítať jednoduchou rekurzívnou funkciou:

```
function o(X, Y, Z):
	if X = 0:
		return 0
	best := 0
	max_k := min(Y / c[X], p[X])
	for k := 0, 1, ... , max_k:
		best := max(best, c[X] * min(Z + k, p[X]) + o(X-1, Y - k * c[X], Z + k))
	return best
```

Túto funkciu nám stačí zavolať pre $X = n, Y = k, Z = 0$ a ona nám vypočíta výsledok. Keďže v rekurzívnych volaniach sa táto funkcia volá so stále menším $X$ (a pre $X = 0$ sa už rekurzívne nevolá), skončí to v konečnom čase. Časová zložitosť však bude nepekná.

### Memoizácia

Časovú zložitosť nášho algoritmu môžeme podstatne zlepšiť tým, že prestaneme počítať rovnaké veci veľakrát. Konkrétne, vždy keď zavoláme našu funkciu pre nejakú kombináciu $X, Y, Z$ prvý raz, spočítame výsledok a zapamätáme si ho. Keď niekedy neskôr zavoláme funkciu s tými istými parametrami, nebudeme ju znovu počítať, ale vrátime už zapamätaný výsledok. Tomuto triku sa hovorí _memoizácia_. Uvedomte si, že tým preskočíme aj rekurzívne volania, ktoré by vyprodukovali kopec ďalších rekurzívnych volaní, takže nám to často ušetrí veľmi veľa času.

Ako si však pamätať vypočítané hodnoty našej funkcie? Jednoducho: použijeme obyčajné trojrozmerné pole, kde na indexe `[X][Y][Z]` bude buď hodnota $o(X, Y, Z)$ ak sme ju už niekedy spočítali, alebo špeciálna hodnota (napr. `-1`, `NULL` alebo `None`) signalizujúca, že sme $o(X, Y, Z)$ ešte nikdy nepočítali.

Aké veľké má byť toto pole? Parameter $X$ bude v každom volaní funkcie `o(X, Y, Z)` niekde medzi $0$ a $n$. Parameter $Y$ bude v prvom volaní $k$ a v každom ďalšom už len menší alebo rovnaký, teda stále bude medzi $0$ a $k$. Parameter $Z$ bude v prvom volaní funkcie $0$ a v ďalších volaniach bude rásť. Nikdy však nebude väčší, než počet všetkých tyčiniek v automate. Označme si počet tyčiniek najpočetnejšieho druhu (najväčšie z čísel $p_1, \\dots, p_n$ ) ako $P$. Potom môžeme parameter $Z$ zhora odhadnúť číslom $n P$. Naše pole s výsledkami funkcie `o(X, Y, Z)` teda bude mať veľkosť $(n+1) \\times (k+1) \\times (n P + 1)$.

### Zložitosť

Akú zložitosť má tento algoritmus? Pamäťová zložitosť je jednoduchá: najviac pamäte zaberie naša tabuľka s výsledkami, ktorá má veľkosť $O(n^2 k P)$. Pri časovej zložitosti potrebujeme sčítať časy všetkých volaní funkie `o(X, Y, Z)`. Tie si môžeme rozdeliť na dve skupiny:

- Volania, pri ktorých sme funkciu naozaj počítali (dané $X, Y, Z$ sme videli prvýkrát). Takýchto volaní je nanajvýš $O(n^2 k P)$ (lebo toľko je zmysluplných kombinácií $X, Y, Z$) a každé z nich trvá čas $O(P)$ (musíme vyskúšať všetky možné počty tyčiniek $X$-tého druhu). Tieto volania majú teda zložitosť $O(n^2 k P^2)$.

- Volanie, pri ktorých sme iba vytiahli výsledok z tabuľky. Každé z týchto volaní má zložitosť $O(1)$. Navyše vieme, že funkciu `o(X, Y, Z)` sme rekurzívne volali iba vo volaniach prvého druhu, v každom z nich nanajvýš $P$-krát. To znamená, že všetkých volaní funkcie $o(X, Y, Z)$ bolo dokopy nanajvýš $O(n^2 k P^2)$ a teda volaní druhého druhu mohlo byť tiež nanajvýš $O(n^2 k P^2)$. To znamená, že ich časová zložitosť je dokopy $O(n^2 k P^2)$.

Celý náš algoritmus má teda časovú zložitosť $O(n^2 k P^2)$.

## Jednoduché zlepšenia

Časovú zložitosť nášho algoritmu môžeme zlepšiť, ak si všimneme zopár vecí. Cenu najdrahšieho druhu tyčiniek označme $C$. Ak má Erik $P C$ alebo viac peňazí, dokáže kúpiť všetky tyčinky v automate: stačí mu vždy kupovať tyčinku s najvyšším číslom, ktorú automat ešte má. Takýmto spôsobom dostane pri každom nákupe jednu tyčinku z každého druhu (okrem tých, čo sa už minuli), a teda po $P$ nákupoch bude mať všetky tyčinky.

To znamená, že ak $k \\geq P C$, nemusíme volať našu rekurzívnu funkciu, ale stačí nám iba sčítať ceny všetkých tyčiniek. Vďaka tomu nebudeme nikdy volať funkciu `o(X, Y, Z)` s parametrom $Y$ väčším ako $P C$, teda nám aj stačí tabuľka s výsledkami veľkosti $(n+1) \\times (P C + 1) \\times (n P + 1)$ (pri obmedzeniach $k \\leq 200,000$ a $P, C \\leq 50$, ktoré boli v praktickom testovaní, je to zlepšenie).

Ďalej si môžeme všimnúť, že ak kúpime $P$ alebo viac tyčiniek druhov $X+1, \\dots, n$, potom už automaticky dostaneme všetky tyčinky druhov $1, \\dots, X$. To znamená, že našu funkciu nemá zmysel volať s paramtrom $Z$ väčším ako $P$. Našu tabuľku teda môžeme zmenšiť na $(n+1) \\times (P C + 1) \\times (P+1)$.

Týmito dvoma zlepšeniami stlačíme pamäťovú zložitosť na $O(n P^2 C)$ a časovú na $O(n P^3 C)$. Toto stačilo na plný počet bodov v praktickom testovaní.

## Zložitejšie zlepšenie

Zoberme si nejaké fixné čísla $X, Y, Z$. V našom výpočte $o(X, Y, Z)$ počítame v cykle maximum z čísel

$$c_X \\min(Z + k, p_X) + o(X-1, Y-k c_X, Z + k)$$

pre $k$ od $0$ po $p_X$, resp. pokým $Y-k c_X \\geq 0$ a $Z+k \\leq P$. Pri výpočte $o(X, Y-c_X, Z+1)$ počítame maximum z čísel

$$c_X \\min(Z+1 + k, p_X) + o(X-1, Y-c_X - k c_X, Z + 1 + k)$$

pre $k$ od $0$ po $p_X$ (resp. pokým dáva daný výraz zmysel), čo je vlastne presne tá istá postupnosť čísel, akurát posunutá o jeden člen. Pri výpočte $o(X, Y-2 c_X, Z+2)$ budeme opäť rátať maximum z tej istej postupnosti, posunutej o ďalší člen.

Ak si zoberieme čísla

$$c_X \\min(Z + k, p_X) + o(X-1, Y-k c_X, Z + k)$$

pre **všetky** (aj záporné) $k$, pre ktoré dáva výraz $o(X-1, Y-k c_X, Z + k)$ zmysel, dostaneme nejakú postupnosť čísel, označme ju $T$. Pre každé zmysluplné (aj záporné) $j$ potom platí, že hodnota $o(X, Y - j c_X, Z + j)$ je maximum z nejakých $p_X + 1$ po sebe idúcich členov postupnosti $T$ (resp., ak sme bližšie než $p_X$ od konca postupnosti, tak maximum všetkých členov od nejakého bodu až do konca). V [úlohe 6](https://www.ksp.sk/ulohy/zadania/1425/) predchádzajúceho kola sme si ukázali, ako sa dajú v lineárnom čase spočítať maximá všetkých $l$-tíc po sebe idúcich členov nejakej postupnosti. To môžeme urobiť pre $l = p_X + 1$. Ak teda poznáme hodnoty prvkov postupnosti $T$, všetky hodnoty $o(X, Y - j c_X, Z + j)$ (pre zmysluplné $j$) dokážeme spočítať v čase lineárnom od ich počtu. To je rovnako dobré, ako keby sme vedeli funkciu $o$ v jednom z týchto bodov spočítať za konštantný čas.

Vylepšený algoritmus teda bude vyzerať nasledovne:

- Tabuľku s hodnotami `o(X, Y, Z)` budeme vypĺňať postupne po ""poschodiach"": najprv vyplníme všetky hodnoty, kde $X = 0$, potom hodnoty kde $X = 1$ atď.
- Pri vypĺnaní jedného poschodia:
  - Najprv si jednotlivé políčka tabuľky rozdelíme do skupín, pričom v jednej skupine budú všetky políčka s indexami tvaru `[X][Y - j * c[X]][Z + j]` pre nejaké $Y, Z$.
  - Pre každú skupinu si zostrojíme príslušnú postupnosť $T$ (na to využijeme predošlé poschodie tabuľky).
  - Následne v lineárnom čase vypočítame hodnotu funkcie `o` na všetkých indexoch v našej skupine.

Keďže vypočítanie jednej hodnoty $o(X, Y, Z)$ bude v priemere trvať konštantný čas, celková zložitosť nášho algoritmu je $O(n P^2 C)$, rovnako ako pamäťová. Pamäťová zložitosť sa dá ešte vylepšiť na $O(P^2 C)$, ak si nebudeme pamätať celú našu tabuľku, ale iba aktuálne vypĺňané poschodie a poschodie tesne pod ním.
",10
8c4882990a98a0e3,ksp,"# Veľmi pokazená tlačiareň

Od neskorého večera do neskorého rána, tlačiaren v T2 tlačila. Mišof a Hodobox vstúpili dnu. Po chvíli skúmania zistili, že vytlačené sú iba dva druhy obrázkov. Mišofovi hneď napadlo, že by časť, alebo aj všetky obrázky mohli použiť na oblepenie stien. A tak sa s Hodoboxom zhodli, že na vyfarbenie každého obrázku použijú béžovú, ružovú a modrú. Z týchto farieb však mali obmedzený počet voskoviek, ktoré mohli použiť na vyfarbovanie obrázkov. A preto chcú zistiť, koľko najviac obrázkov dokážu vyfarbiť.

## Úloha

Mišof s Hodoboxom Vám povedali, koľko majú voskoviek jednotlivých farieb. Pre oba typy obrázka viete, koľko voskoviek ktorej farby potrebujú na jeho vyfarbenie.

Vašou úlohou je povedať, koľko najviac obrázkov Mišof a Hodobox dokážu vyfarbiť.

## Formát vstupu

Na prvom riadku vstupu sú 3 medzerou oddelené prirodzené čísla $b,,r,,m$ -- počet béžových, ružových a modrých voskoviek, ktoré majú Mišof s Hodoboxom k dispozícii.

Nasledujú dva riadky. V $i$-tom z nich sú čísla $b_i,,r_i,,m_i$ -- počty voskoviek jednotlivých farieb, ktoré sa spotrebujú na jeden obrázok typu $i$.

## Formát výstupu

Na jediný riadok výstupu vypíšte najväčší počet obrázkov, ktoré vedia Mišof a Hodobox vyfarbiť.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :------------------------------ | ----: | --------: | ---------: | ------------: | | $1 \\leq b,,r,,m, \\leq$ | $100$ | $10,000$ | $100,000$ | $1,000,000$ | | $1 \\leq b_i,,r_i,,m_i, \\leq$ | $300$ | $30,000$ | $300,000$ | $3,000,000$ |

## Príklad

```vstup
6 6 6
1 2 2
2 1 1
```

```vystup
4
```

_Mišof a Hodobox vyfarbia po dva obrázky z každého druhu._

```vstup
3 4 5
1 1 1
2 2 2
```

```vystup
3
```

_V tomto prípade vedia vyfarbiť 3 obrázky prvého druhu._
","# Pokazená tlačiareň

V tejto úlohe sme mali zistiť, koľko obrázkov vedia Mišof a Hodobox vyfarbiť, keď majú dané koľko ktorých voskoviek majú k dispozícii a koľko ktorých voskoviek je potrebných na vyfarbenie každého typu obrázku.

## Vzorové riešenie

Nech v optimálnom riešení máme $x$ obrázkov typu 1 a $y$ obrázkov typu 2. Našou úlohou je zistiť čísla $x, y$ tak, aby $x + y$ bolo maximálne možné.

Môžeme postupne skúšať všetky dosiahnuteľné hodnoty $x$. Ku každej z nich si ľahko vieme dorátať, koľko ktorých voskoviek nám ostane po vyfarbení $x$ obrázkov typu 1. Všetky tieto zvyšné voskovky môžeme použiť na vyfarbenie čo najviac obrázkov druhého typu. Jednoducho si teda dorátame číslo $y$.

Skúsme sa bližšie pozrieť na to, ako dopočítať číslo $y$. Ak sme na $x$ obrázkov prvého typu použili $x_b = x \\cdot b_1$ voskoviek béžovej, $x_r = x \\cdot r_1$ ružovej a $x_m = x \\cdot m_1$ voskoviek modrej farby, tak na obrázky typu 2 nám ostalo $y_b = b - x_b$ voskoviek béžovej, $y_r = r - x_r$ ružovej a $y_m = m - x_m$ modrej farby. Ako zistíme, koľko obrázkov druhého typu vieme týmito voskovkami zafarbiť? Na vyfarbenie jedného obrázku typu 2 potrebujeme $b_2, r_2, m_2$ voskoviek príslušných farieb. Jedna z týchto farieb voskoviek sa nám minie ako prvá. Obrázkov typu 2 teda vieme vyfarbiť $y = \\min{ \\frac{y_b}{b_2}, \\frac{y_r}{r_2}, \\frac{y_m}{m_2} }$.

Pre nejaké nami zvolené $x$ sme teda dopočítali maximálne možné $y$. Na doriešenie úlohy nám teda stačí postupne skúsiť všetky možné $x$, ku každému dopočítať $y$ a vypísať tú možnosť, kde bolo $x + y$ najväčšie.

Prečo to funguje? Pretože skúšame všetky možnosti. Žiadna nám teda neunikne.

### Zložitosť

Koľko rôznych $x$ potrebujeme skúšať? Na každý obrázok spotrebujeme aspoň jednu voskovku každého druhu. Stačí nám teda vyskúšať $\\min{ b, r, m }$ možností pre $x$. Ku každému vieme potom dopočítať $y$ v konštantnom čase. Časová zložitosť teda bude $O(\\min{ b, r, m })$.

Pamätať si nám stačí jednotlivé počty voskoviek, ktoré máme k dispozícii a doteraz najlepšie nájdené $x, y$. Stačí nám teda konštantná pamäť a pamäťová zložitosť bude $O(1)$.
",1
493eaa036deab8d8,ksp,"# Galaktický volebný chaos

Na vzdialenej planéte KuSaPasa sa konali voľby. Počas sčítania hlasov však prišla nečakaná elektromagnetická búrka, ktorá spôsobila úplný chaos. Väčšina hlasovacích lístkov sa postrácala. Keď búrka doznela, obyvatelia planéty začali zisťovať, čo ostalo z volebných výsledkov. Niektoré počty hlasov sa zachovali, iné sa enormne navýšili či znížili. O počte hlasov Chamtivej Asociálne Orientovanej Strany (CHAOS) sa podarilo zistiť iba to, že vplyvom elektromagnetickej búrky sa počet jej hlasov zrotoval o jednu cifru doprava, čím sa stal $n$-násobným. Samotný počet hlasov je však nadobro stratený. Občania si len ťažko predstavujú, aký chaos by na planéte nastal, keby táto strana získala $n$-násobne viac kresiel v parlamente. Potrebovali by preto zistiť, aký bol skutočný počet hlasov CHAOSu. Ak by existovalo viac takých čísel, vzhľadom na charakter (a názov) strany ľud vyberie ten najmenší.

Mimozemšťania na planéte KuSaPasa nepoužívajú klasickú desiatkovú sústavu, ale sústavu so základom $b$. Jediné, čo vedia o počte hlasov Chamtivej Asociálne Orientovanej Strany je, že keď zrotujeme jeho cifry o jednu pozíciu doprava, dostaneme presne $n$-krát väčšie číslo. Prirodzene, rotujeme cifry v sústave o základe $b$. Inými slovami, rotácia doprava znamená, že presunieme poslednú cifru na začiatok čísla.

## Úloha

Nájdite najmenšie číslo také, že keď zrotujeme jeho cifry zapísané v sústave so základom $b$ o jednu pozíciu doprava, dostaneme presne $n$-krát väčšie číslo.

Hľadané číslo môže byť veľmi veľké a nemusí sa vojsť ani do $64$-bitovej premennej.

## Formát vstupu

Na jedinom riadku vstupu sú dve celé čísla $b$ a $n$, pričom platí $2 \\leq b \\leq 500$ a $1\\leq n \<b$.

## Formát výstupu

Na jediný riadok vypíšte jednotlivé číslice hľadaného čísla v sústave so základom $b$ od najvýznamnejších po najmenej významné (v klasickom poradí). Číslice samotné vypisujte v desiatkovej sústave, teda ak je výsledkom napríklad šestnástkové číslo $D2E\_{16}$, vypíšte `13 2 14`, pretože $D=13$ a $E=14$.

## Hodnotenie

Sú štyri sady vstupov, za každú možno získať $2$ body. Maximálne hodnoty $b$ v jednotlivých sadách sú postupne $6$, $60$, $200$ a $500$.

## Príklady

```vstup
10 4
```

```vystup
1 0 2 5 6 4
```

$4 \\cdot 102564 = 410256$

```vstup
11 3
```

```vystup
1 4
```

Číslo $14$ v jedenástkovej sústave je rovné 15, číslo $41$ je rovné $4 \\cdot 11 + 1 = 45$.

```vstup
16 2
```

```vystup
1 0 8 4 2
```
","# Galaktický volebný chaos

## Hrubá sila

Najpriamočiarejšie riešenie, je riešenie hrubou silou. Skúšame postupne všetky čísla od $1$ vyššie, až kým nenájdeme také, ktoré spĺňa požadovanú vlastnosť. Rotáciu čísla spravíme jednoducho bez zbytočného prevodu čísla na reťazec tak, že číslo celočíselne vydelíme $b$, čím z neho odstránime poslednú cifru a pričítame k nemu jeho poslednú cifru -- zvyšok po delení $b$ -- vynásobenú aktuálnou mocninou $b$ takou, aby sa táto cifra dostala na začiatok čísla. Keď číslo, ktoré ideme skúšať, je mocninou $b$, začíname skúšať o jednu cifru dlhšie čísla, a teda aj mocnina, ktorou násobíme poslednú cifru, sa musí $b$-krát zvýšiť.

Časová zložitosť je lineárna^[Zanedbávame tu však skutočnosť, že výstup môže byť skutočne veľké číslo. Python to síce tají, ale od istej hranice by sme mali aj klasiké aritmetické operácie považovať za logaritmické a nie konštantné.] od hodnoty hľadaného čísla, čo je vo väčšine prípadov až neprijateľne pomalé.

## Lepšie riešenie -- zostavíme si rovnicu

Označme si dĺžku hľadaného čísla bez poslednej (rotovanej) cifry $k$. Hľadané číslo si rozdelíme na dve časti: jadro čísla (celé číslo bez poslednej cifry) označíme ako $a$ a poslednú -- presúvanú cifru ako $d$. Potom naše číslo má hodnotu $ba+d$, pretože $a$ posunieme o cifru doľava a na koniec pripisujeme cifru $d$. Číslo po rotácii má hodnotu $b^kd+a$, pretože cifru $d$ posúvame o $k$ miest doľava (pred $a$). Má teda platiť, že

$$n(ba + d) = b^kd + a$$

V rovnici máme tri premenné, $a$, $d$, a $k$. Ak si zvolíme dve z nich, tretiu budeme vedieť dopočítať. Dopočítať budeme chcieť tú, pre ktorú existuje rádovo najviac možností, teda $a$. $d$ má len $b$ možností a $k$ je dĺžka čísla $a$, čo je omnoho menej. Platí

$$a(bn-1) = d(b^k-n)$$ $$a = \\frac{d(b^k-n)}{bn-1}$$

Vyskúšame teda všetky možnosti pre $k$ od $1$ vyššie a pre každé $k$ vyskúšame všetky cifry $d$. Ak nájdeme nejaké $a$, uvedený zlomok musí byť celé číslo a ešte musíme skontrolovať, či má naozaj dĺžku $k$. Inak ho použiť nemôžeme (nespĺňalo by zadanie).

Čísla generujeme od najkratších, ale nie nutne od najmenších, preto ak aj nájdeme vyhovujúce číslo, musíme ešte doskúšať ostatné cifry pre toto $k$ a vybrať. Najmenšie hľadané číslo bude to lexikograficky najmenšie (v sústave so základom $b$).

Čísla, s ktorými pracujeme, sú veľmi veľké a ak nepoužívame jazyk ktorý s takými vie pracovať, ako napr. Python, potrebujeme si naprogramovať vlastnú aritmetiku.

Časová zložitosť vyzerá byť $O(lb)$, kde $l$ je dĺžka hľadaného čísla. Problém ale je, že pracujeme s veľmi veľkými číslami, ktoré nevieme násobiť, deliť či modulovať v konštantnom čase, ale v čase lineárnom k súčinu dĺžok čísel, v tomto prípade lineárnom ku $k$. Preto časová zložitosť tohto riešenia je $O(l^2b)$.

## Vzorové riešenie -- generovanie čísla odzadu

Predstavme si, že poznáme poslednú cifru hľadaného čísla, označme ju $d$. $d$ je zvyšok hľadaného čísla po delení $b$ (základom sústavy). Potom $n$-násobok hľadaného čísla bude mať zvyšok $nd \\mathrm{mod} b$ po delení $b$.

Predposledná cifra sa po presune prvej cifry na koniec stane poslednou. Tá je zvyškom po delení $b$ nového čísla, teda musí byť rovná $nd \\mathrm{mod} b$.

Takto vieme pokračovať ďalej. Ak poznáme posledných $k$ cifier, vieme zvyšok čísla po delení $b^k$. Vieme teda zistiť zvyšok jeho $n$-násobku po delení $b^k$. Po odobratí poslednej cifry sa zvyšných $k-1$ cifier posunie o jednu pozíciu doprava. Keďže poznáme zvyšok $n$-násobku -- zrotovaného čísla -- po delení $b^k$, vieme zistiť $(k+1)$. cifru odzadu (ktorá je po rotácii $k$-ta).

V podstate vieme určiť posledných $k$ cifier, ale tých $k-1$ už poznáme a určili sme ich presne týmto spôsobom.

Celé toto vieme robiť bez potreby vlastnej aritmetiky. V jednom poli si pamätáme už vygenerované cifry a v druhom prenosy z jedného rádu do vyššieho. Keďže násobíme číslom, ktoré je v sústave so základom $b$ jednociferné, máme len jednociferný prenos.

Navyše, číslom $n$ nemusíme znovu a znovu násobiť celú známu časť čísla $b$. To, čo sme si už vynásobili, ostáva stále rovnaké, takže stačí vynásobiť len poslednú pridanú cifru a pripočítať prenos.

Ostáva zistiť, dokedy takto budeme generovať nové a nové cifry. Prestať môžeme vtedy, ak ideme pridať cifru $d$ (poslednú cifru čísla), pretože ju nemusíme pripisovať ako novú, môžeme využiť tú, ktorá príde z konca čísla. Navyše musí platiť, že práve nemáme žiaden prenos, pretože ten by si vynútil ešte nejaké ďalšie cifry na začiatku.

Treba si dať pozor, či naše vygenerované číslo nezačína nulou. Ak však začína, nemá zmysel pokúšať sa generovať ďalšie cifry. Môžeme si všimnúť, že celý beh algoritmu závisí len od najnovšej cifry, najnovšieho prenosu a poslednej cifry čísla. Práve sme sa dostali do situácie, kedy bude najnovšia cifra $d$ rovná pôvodnej a prenos je nulový, čo je rovnaký stav ako na začiatku. Celý beh algoritmu by sa ďalej začal periodicky opakovať.

Poslednú cifru síce nepoznáme, ale existuje len $b$ možností. Vyskúšame teda všetky a najmenšie číslo bude také, ktoré má najmenej cifier a spomedzi nich je lexikograficky (podľa abecedy) najmenšie.

## Časová a pamäťová zložitosť

Časová zložitosť tohto riešenia je $O(lb)$, kde $l$ je dĺžka hľadaného čísla, pretože už násobíme len čísla, ktoré sa vojdu do obyčajnej premennej (cifry v sústave $b$, ktoré sú menšie ako $b$).

Pamäťová zložitosť je $O(lb)$, ak si pamätáme všetky vygenerované čísla, ak si budeme pamätať len aktuálne vytvárané číslo a doteraz najlepšie nájdené, bude iba $O(l)$.
",5
9c1bf589b8196ca8,ksp,"# Ploskí kamoši

V noci len tak ležíš a zrazu počuješ, ako ti do uška šušká ploštička. Jej druhá kamoška ti jemne obkuskáva lakeť. Keďže si programátor a fakt nemáš kamarátov, tak si povieš, že ploštice budú tvoje kamošky. Nezostáva ti nič iné ako ich chytiť do pohára. Ráno sa zobudíš a rozpamätáš sa, že ti tá ploštička niečo hovorila. Majú vlastný jazyk! ...alebo to bude len náhoda. Zoberieš si plošticu číslo 2 a začneš počúvať jej slová a zapisovať ich. Z noci si však už len matne spomínaš na to, čo ti hovorila ploštica číslo 1, ale zapíšeš aj tieto slová. Ak úplne nevieš, aké písmenko vyslovila, zapíšeš si všetky, ktoré to mohli byť. Teraz ich už len porovnáš a prídeš na to, či sa jazyky zhodujú. Jednoduché, však?

## Úloha

Vašou úlohou je zistiť, či obe ploštice používajú rovnaký jazyk -- teda pokúsiť sa zistiť, či slovo, ktoré nám povedala ploštica číslo 2 sa môže zhodovať so slovom, ktoré si pamätáme z noci.

## Formát vstupu

Na prvom riadku vstupu dostanete jedno číslo predstavujúce dĺžku slov ($l$). Na druhom riadku dostanete jedno číslo -- počet dvojíc slov ($w$). Za nimi bude nasledovať $w$ dvojíc riadkov. Na prvom z dvojice riadkov bude jedno slovo, zložené len z veľkých písmen anglickej abecedy. Na druhom riadku z dvojice bude slovo, ktoré si pamätáme z noci. Tieto slová vyzerajú takto: ak som si istý, aké písmenko ploštica povedala, je na tom mieste len písmenko napríklad `A`. Ak si nie som istý a mohli to byť rôzne písmenká (alebo iba jedno písmenko), sú uzavreté v zátvorkách napríklad `(BD)`.

## Formát výstupu

Na výstup vypíšte $w$ riadkov -- na riadku $i$ vypíšte `OK` ak sa $i$-te slovo, môže zhodovať s $i$-tym nekompletným slovom -- otázkou. Inak vypíšte `NOT OK`.

## Hodnotenie

Sú 4 sady vstupov, v ktorých platia tieto obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |------------------------------|---------:|---------:|----------:|-----------:| | $1 \\le l \\le$ | $5$ | $15$ | $15$ | $50$ | | $1 \\le w \\le$ | $25$ | $50$ | $5,000$ | $10,000$ | | $1 \\le l\\cdot w \\le$ | $100$ | $1,000$ | $50,000$ | $100,000$ |

## Príklady

```vstup
1
4
C
(AB)
B
(DB)
B
B
B
D
```

```vystup
NOT OK
OK
OK
NOT OK
```

1. Slovo `C` a slovo `(AB)`, ktoré si pamätáme z noci sa nemôžu zhodovať.
1. Slovo `B` a slovo `(DB)`, ktoré si pamätáme z noci sa zhodovať môžu.
1. Slovo `B` a slovo `B`, ktoré si pamätáme z noci sa zhodujú.
1. Slovo `B` a slovo `D`, ktoré si pamätáme z noci sa nemôžu zhodovať.
","# Ploskí kamoši

## Zo zadania

Ako zadanie hovorí, budeme spracovávať dvojice slov - jedno, ktoré vieme ako vyzerá (nazvime ho $w$) a druhé, ktoré si matne pamätáme z noci (nazvime ho $q$). Úlohou je zistiť, či sa slová môžu zhodovať.

## Riešenie

Pre každé písmeno vo $w$ sa budeme musieť pozrieť na písmeno alebo množinu písmen z $q$ a zistiť, či medzi nimi existuje zhoda. Budeme si pamätať, na akej pozícii v slove $w$ sa nachádzame a budeme prechádzať cez znaky slova $q$. Ak sa i-ty znak z $q$ nerovná `(`, vieme, že na tejto pozícii bude len jedno písmeno. Teda porovnáme písmeno z $q$ s písmenom z $w$. Ak sa nerovnajú, vypíšeme `NOT OK` a posunieme sa na ďalšiu dvojicu slov. Inak pokračujeme ďalším písmenom. Ak sa i-ty znak $q$ rovná `(`, budeme prechádzať len cez $q$, až kým nepriídeme po `)` pričom si budeme ukladať do množiny písmená medzi zátvorkami. Po tom, ako sme našli v $q$ znak `)`, pozrieme sa, či sa písmeno na pozícii, ktorú porovnáme, nachádza v tejto množine znakov. Ak sa v ňom nenachádza, vypíšeme `NOT OK` a posunieme sa na ďalšiu dvojicu slov. Takto prejdeme cez všetkých $l$ znakov $w$ a ak sme ich prešli všetky a nenašli nezhodu, môžeme vypísať `OK`.

## Optimalnejsie riesenie

Optimálne riešenie je v podstate takmer totožné. V hore opísanom riešení prechádzame niektoré znaky viackrát. Práve vtedy, keď získavame znaky medzi zátvorkami a následne hľadáme, či sa v nich nachádza písmeno z $w$ na porovnávanej pozícii. Riešenie vieme modifikovať tak, aby sme miesto pridávania do množiny rovno písmeno porovnávali s daným písmenom slova $w$.

## Časová a pamäťová zložitosť

Časová zložitosť bude lineárna, keďže vstupom prechádzame len raz. Pamäťová zložitosť je konštantná -- rovná $l$, keďže si musíme pamätať celé slovo $w$ a jedno akutálne písmeno zo slova, ktoré si pamätáme z noci.
",1
6778e72d6e9fbaa8,ksp,"#Zarovnaný kalendár

Najnovšia móda v oblasti kalendárov je kalendár, v ktorom má každý mesiac $28$ dní. Nie je to až taká novinka. Táto myšlienka je veľmi stará, ale KSPáci sa k nej dostali až nedávno. Rok sa v tomto kalendári skladá z $13$ mesiacov, každý má presne $28$ dní a na konci roka nasleduje špeciálny jeden deň, ktorý sa môže využiť na oslavy nového roka. Ak ste správne počítali, výsledný kalendár by mal presne toľko dní v roku ako náš bežný gregoriánsky kalendár. Niektorým KSPákom sa nový kalendár samozrejme nepáči, pretože ich pekné dátumy narodenia ako napr. $11.11.$ (tento dátum je super, pretože je zrkadlový a skladá sa iba z jednotiek) sa zmenia na nezaujímave $7.12.$ Preto by všetci chceli rýchlo vedieť, ako bude vyzerať ich dátum narodenia v novom kalendári (aby prípadne mohli protestovať alebo bojovať za jeho zavedenie). Takisto by ich zaujímalo, ktoré dni z nášho kalendára budú nejaké pekné dátumy v novom.

## Úloha

Táto úloha sa bude skladať z dvoch častí. V prvej časti budete prevádzať dátumy z nášho kalendára do $28$ dňového a v druhej časti zase naopak. Všetky dátumy budú patriť do roku $2015$, takže nebudete musieť riešiť prestupné roky. Posledný deň v roku $28$ dňového kalendára bude označený ako `1 14` (teda ako keby to bol prvý deň neexistujúceho $14.$ mesiaca).

## Vstup

Na prvom riadku vstupu je číslo $1$, ktoré znamená, že sa bude prevádzať z nášho kalendára do $28$ dňového alebo $2$, ak to bude naopak. Nasleduje číslo $n$, $1 \\leq n \\leq 10^5$ -- počet riadkov s dátumami. Ďalej máme $n$ riadkov, každý obsahujúci dátum buď v našom alebo $28$ dňovom formáte (dátumy sú uvedené klasicky, najskôr deň, potom mesiac). Vstupy budú rozdelené podľa toho, z ktorého kalendára prechody obsahujú. Ak sa vám podarí napr. prevádzať iba z gregoriánskeho kalendára do $28$ dňového, môžete stále získať nejaké body.

## Výstup

Pre každý dátum zadaný na vstupe vypíšte jeho ekvivalent v opačnom formáte.

## Hodnotenie

Zo 6 bodov za popis budú 4 udelené štandartne za popis a zvyšné 2 za eleganciu vášho kódu. Body za kód sa rozdelia rovnomerne medzi obidva prevody (teda 2 za jeden smer a 2 za druhý).

## Príklady

```vstup
1 3
11 11
1 2
31 12
```

```vystup
7 12
4 2
1 14
```

```vstup
2 3
7 12 
4 2 
1 14
```

```vystup
11 11
1 2
31 12
```
","#Zarovnaný kalendár

Úloha sa dala riešiť veľmi veľa spôsobmi. Väčšina z nich, ak sa naimplementovali šikovne, mali dobrú časovú aj pamäťovú zložitosť. Išlo teda hlavne o eleganciu vášho riešenia.

##Najmenej elegantné riešenie Úloha sa dala riešiť úplne priamo. Urobíme si zoznam prekladov dátumov z jedného kalendára do druhého. Aj toto sa dá urobiť rôzne elegantne. Ukážeme si príklad úplne najhoršieho možného riešenia:

Prečo je toto riešenie zlé? Pretože zakaždým, keď chceme preložiť nejaký dátum, musíme prechádzať cez veľmi veľa ifov. A čo je ešte horšie, všetky tie ify musíme aj napísať. Takže takéto riešenie nie je ani veľmi efektívne (urobí síce pre každý dátum iba konštantný počet operácií, ale tá konštanta je dosť veľká, pre 31.12. musíme prejsť cez 365 ifov). A už vôbec to nie je elegantné.

##Trochu elegantnejšie riešenie

Trochu lepšie riešenie nám ponúka Python, kde vieme použiť dictionary (slovník), čo je dátová štruktúra, ktorej každý prvok sa skladá z kľúča a hodnoty, pričom ku hodnote vieme pristúpiť, ak poznáme kľúč. Je to naozaj podobné ako prekladový slovník, predstavte si, že máme prekladový slovník z angličtiny do slovenčiny, potom anglické slová by boli kľuče a slovenské hodnoty. Výhoda slovníka je, že prístup ku každej hodnote vieme vykonať v čase $O(1)$, teda sa nemusíme otravovať s ifmi a je to aj efektívnejšie. Ako by to vyzeralo implementované?

Toto riešenie má už síce dobrú časovú zložitosť, ale stále nie je pekné. Čo keby mal rok 20000 dní? Museli by sme vypísať do slovníka všetky. A to sa nám samozrejme nechce.

##Vzorové riešenie

Vzorové riešenie bude robiť konverziu v obidvoch smeroch v dvoch krokoch. Najskôr si každý dátum prevedieme na deň v roku, (napr. 3.2. v gregoriánskom kalendári je 34. deň v roku). A následne si tento deň prevedieme na dátum podľa pravidiel druhého kalendára. Prevod z 28 dňového kalendára do dňa v roku je jednoduchšia časť, stačí nám nasledovná rovnica $denvroku=28(mesiac-1)+den$. Prevod z klasického gregoriánskeho kalendára je trošku zložitejší, musíme si nejakým spôsobom zadrôtovať v programe dĺžky mesiacov, a kedže sa nestriedajú pravidelne a je ich len 12, tak sa nám to celkom oplatí. Najjednoduchší spôsob je urobiť si pole dĺžky 12, v ktorom si budeme udržiavať dĺžky jednotlivých mesiacov. Ale trochu viac sa nám hodí urobiť si pole dĺžky 12, kde budú uložené hodnoty hovoriace, koľko dní v roku prešlo do začiatku daného mesiaca (môžete si uvedomiť, že to by sme v konečnom dôsledku museli rátať aj z pôvodného poľa). Akú ma toto výhodu? Deň v roku potom vieme vyrátať rovnicou $denvroku=pole[mesiac-1]+den$. Ok, takže už sa vieme dostať z obidvoch kalendárov ku dňu v roku.

A ako sa teraz dostaneme k dátumu? V 28 dňovom kalendári to bude celkom priamočiare. Mesiac dostaneme vydelením dňa v roku číslom 28 a deň ako zvyšok z tejto hodnoty (plus tam máme problémy s nejakými jednotkami, ale na to ste určite prišli aj sami :)). Vyjadrené pomocou vzorcov to bude vyzerať nasledovne:

$$mesiac=(denvroku-1)/28+1$$ $$den=(denvroku-1) \\bmod 28+1$$

V gregoriánskom kalendári znova použijeme naše pole s predrátanými dňami v roku po začiatok daného mesiaca. Ktoré políčko z toho poľa budeme potrebovať? Predsa najväčšie menšie ako náš hľadaný deň v roku. To samozrejme musí označovať mesiac, v ktorom sa náš deň v roku nachádza. Teda mesiac už máme. A deň potom získame ako $den=denvroku-pole[mesiac-1]$. Ak ste sa dostali vo vašom riešení sem, stačilo neseknúť sa v detailoch a 10 bodov za riešenie je vašich :).

Ešte dodám, že časová zložitosť tohto riešenia je $O(n)$ a pamäťová zložitosť tohto riešenia je $O(1)$, ako aj každého iného tu prezentovaného riešenia, kedže nezávisle na vstupe urobí každé riešenie iba konštantný počet krokov (najviac $365\\cdot konstanta$ pri najhoršom a najmenej $12\\cdot konstanta$ pri najlepšom). Takisto každú hodnotu môžeme spracovať hneď po načítaní, nemusíme si nikde pamätať všetkých $n$ hodnôt.
",2
2192b191d5cf55e7,ksp,"# Ozajstná veda

Kleofáš sa rád hrá s číslami. Na matfyzáka by sa to aj celkom patrilo. Preto sa už dlho tešil, ako si v zimnom semestri zapíše numeriku a začne sa na nej oddávať šťastnému rátaniu, pričítavaniu, odčítavaniu a iterovaniu vzorcov pri riešení diferenciálnych rovníc -- no proste samým úžasným veciam.

Ani numerika však Kleofáša neuspokojila. Stále bol akýsi nesvoj. Nemal pocit absolútneho naplnenia svojej bezhraničnej číselnej zvedavosti. Veci mu nedávali zmysel. Videl čísla a nevedel čo znamenajú. Nevedel, čo sa mu snažia povedať. Nevedel z nich získať poznanie. Vrcholom bolo, keď začal v číslach aj snívať. Začali sa mu totiž snívať dlhé číselné postupnosti. Vtedy sa Kleofáš rozhodol, že vyhľadá pomoc odborníka. Sadol za internet a o chvíľu mal dohodnuté stretnutie s numerologičkou 83470u.

83474 mu povedala nasledovné múdrosti: Každé číslo niečo znamená. To, čo dané číslo znamená, sa dá určiť z jeho cifier. Traktor. Každý si je strojcom svojho šťastia a vyberá si, čo sa mu stane. Rovnaké šťastie znamená, že sa porušil metrix. Čím viac možností, tým viac abibash.

Kleofáš síce nerozumel ani slovo, ale rozhodol sa, že tomu bude veriť a pokúsil sa 83471n3 slová nejako interpretovať. Každé číslo asi bude znamenať nejakú udalosť, ktorá sa mu udeje. To, aká bude, sa dá určiť z cifier daného čísla. Všetci vedia, že najšťastnejšie číslo je 47. Šťastné cifry teda musia byť štvorka a sedmička. No a úplne šťastné udalosti teda budú zodpovedať takým číslam, ktorých úplne každá cifra je štvorka alebo sedmička.

Kleofášov život ešte nie je jednoznačne určený. Vie si vybrať, ktorých $k$ spomedzi $n$ udalostí, ktoré sa mu prisnili, sa mu naozaj stane. Určite však nechce, aby sa mu stali dve rovnaké šťastné udalosti, lebo by tým pokazil metrix. (Nech už to znamená, čo chce.) Abibash? Jasné, že Kleofáš chce byť čo najviac abibash! (Nech už to znamená, čo chce.)

## Úloha

Prirodzené čísla delíme na šťastné a ostatné. Šťastné sú tie, ktorých každá cifra je 4 alebo 7.

Kleofáš má postupnosť $n$ prirodzených čísel a tiež číslo $k$. Zo svojej postupnosti chce vybrať presne $k$-prvkovú podpostupnosť. Vo vybranej postupnosti sa nesmú vyskytovať dve rovnaké šťastné čísla.

Vašou úlohou je zistiť, koľkými spôsobmi môže Kleofáš vybrať vyhovujúcu $k$-prvkovú podpostupnosť.^[A teda zistiť, ako veľmi je Kleofáš abibash. (Nech už to znamená, čo chce.)] Dva spôsoby považujeme za rôzne, ak vyberieme prvky na rôznych indexoch, bez ohľadu na to, aké majú hodnoty.

## Formát vstupu

V prvom riadku vstupu sú prirodzené čísla $n$ a $k$. Platí $1 \\leq k \\leq n \\leq 10^5$. Číslo $n$ udáva počet čísel, ktoré sa Kleofášovi snívali a číslo $k$ je počet čísel, ktoré z nich chce Kleofáš vybrať.

V druhom riadku je postupne $n$ kladných celých čísel, ktoré sa Kleofášovi snívali. Každé z nich je menšie ako $10^9$.

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno celé číslo: počet spôsobov ktorými vie Kleofáš vybrať vyhovujúcu podpostupnosť. Keďže toto číslo môže byť veľmi veľké, vypočítajte a vypíšte ho modulo $10^9+7$.

## Príklady

```vstup
5 2
7 7 3 7 77
```

```vystup
7
```

_Existuje desať možností ako vybrať 2-prvkovú podpostupnosť danej postupnosti. Z nich však tri nevyhovujú, lebo obsahujú dve rovnaké šťastné udalosti. Vyhovujúcich výberov je teda len $10-3 = 7$._

```vstup
5 3
3 7 77 7 77
```

```vystup
4
```

_Tu si Kleofáš musí vybrať udalosť 3, jednu z dvoch udalostí 7 a jednu z dvoch udalostí 77._

```vstup
34 17
14 14 14 ... 14 14 14
```

```vystup
333606206
```

_V tomto príklade vstupu je v druhom riadku postupnosť 34 štrnástok. Číslo 14 nie je šťastné. Kleofáš si teda môže vybrať ako svoju podpostupnosť ľubovoľných 17 prvkov danej postupnosti. Všimnite si, že počet možných výberov je veľký, a že vypísaná odpoveď je rovná zvyšku, ktorý tento počet dáva po delení $1,000,000,007$._
","# Ozajstná veda

## Skoro riešenie

Najprv si úlohu zjednodušme. Čo by sa stalo, keby sme nemali šťastné čísla? Potom by sme vedeli spočítať, koľkými spôsobmi sa dá vybrať $k$ čísel zo skupiny $n$ čísel. Je to takzvané kombinačné číslom $$ {{n} \\choose {k}} = \\frac{n!}{k!(n-k!)}$$

Čo teraz s tými nešťastnými šťastnými číslami?

Zabudnime na chvíľu na čísla, ktoré nie sú šťastné a zoberme si len tie, ktoré obsahujú štvorky a sedmičky. Nech ich je dokopy $S$. Koľkými spôsobmi vieme z tejto postupnosti $S$ čísel vybrať $k$ prvkovú množinu tak, aby tam nebolo žiadne číslo dvakrát? Odpoveď vieme zistiť dynamickým programovaním.

Usporiadajme si šťastné čísla bez duplikátov do postupnosti $s_1, s_2, \\dots, s_m$. Nech je šťastné číslo $s_i$ na vstupe $p_i$-krát. Do tabuľky s rozmermi $D[m+1][k+1]$ si na políčku $D[i][j]$ vyrátame, **koľkými spôsobmi vieme vybrať množinu obsahujúcu $j$ prvkov ak používame len šťastné čísla $s_1, \\dots , s_i$** a každé šťastné číslo sa môže vo vybranej množine objaviť najviac raz. Pri rátaní $D[i][j]$ máme vždy dve možnosti. Ak sme $s_i$ nevložili do vybranej množiny, tak máme toľko možností, ako pre $i-1$ čísel a veľkosť množiny $j$. Ak sme ale $s_i$ vložili do množiny, tak sme si mohli vybrať jedno z $p_i$ čísel, ktoré majú hodnotu $s_i$ a jednu množinu veľkosti $j-1$, ktorá sa opäť skladá z prvých $i-1$ čísel. Toto zapíšeme vzorcom: $$D[i][j] = D[i-1][j] + p_i \\cdot D[i-1][j-1]$$

V našom dynamickom programovaní zistíme hodnoty $m \\cdot k$ stavov a každý vypočítame v konštantnom čase, takže časová zložitosť bude $O(mk)$.

Posledné, čo si musíme uvedomiť, je, že počet rôznych šťastných čísel na vstupe, teda hodnota $m$, je malý. Zhora ho môžeme odhadnúť číslom $2^{10}-2$, čo je počet všetkých, najviac 9-ciferných štastných čísel. Takisto, aj keď podľa zadania je $k$ veľké až $100,000$, tak v našom dynamickom programovaní sa nám neoplatí skúšať $k$ väčšie ako $m$. Z každého šťastného čísla totiž môžeme zobrať najviac jedno. Časová zložitosť bude teda $O(m^2)$ a keďže $m$ je rádovo $1,000$, takéto riešenie sa nám v pohode zmestí do časového aj pamäťového limitu.

Stačí už len spojiť tieto dve myšlienky a máme úlohu teoreticky vyriešenú. Pre každé $l\\leq m$ vyrátame, koľkými spôsobmi vieme vybrať postupnosť dlhú $k-l$ len z nie šťastných čísel (čo je kombinačné číslo) a postupnosť dlhú $l$ zo šťastných čísel (čo je číslo z našej dynamiky). Tieto dve čísla vynásobíme, výsledok sčítame cez všetky $l$ a máme riešenie.

## Kombinačné čísla v modulárnej aritmetike

Nakoľko sú čísla veľké a stačí nám výsledok modulo $10^9+7$, potrebujeme (chceme (musíme)) používať modulárnu aritmetiku. Konkrétne vieme, že $(a + b) \\bmod P = (a \\bmod P) + (b \\bmod P)$ a $(a \\cdot b) \\bmod P = (a \\bmod P)\\cdot (b \\bmod P)$. Problém ale je, že potrebujeme rátať veľké kombinačné čísla, v ktorých sa delí. Teda by sme chceli vedieť, koľko je

$$ \\frac{a}{b} \\bmod P $$

Na pomoc príde Malá Fermatova veta^[Kuk wikipédia], ktorá hovorí, že ak je $P$ prvočíslo (čo číslo $10^9+7$ je) a $b$ je ľubovoľné číslo, tak $b^{P-1}=1 \\bmod P$. Keď túto rovnicu vynásobíme číslom $a$ a predelíme $b$, dostaneme:

$$ \\frac{a}{b} \\bmod P = a \\cdot b^{P-2} \\bmod P $$

To znamená, že delenie sme si nahradili násobením, ktoré vieme modulovať priebežne, vďaka vyššie spomenutému vzťahu. Číslo $b^{P-2} \\bmod P$ sa inak nazýva inverzný prvok k číslu $b$.

Predposledná vec, ktorú potrebujeme na riešenie, je rýchle umocňovanie, aby sme hodnotu $b^{P-2}$ stihli zrátať. Hlavná myšlienka tohto algoritmu je, že ak chceme vypočítať hodnotu $x^{2y}$, tak nám stačí vypočítať číslo $x^{y}$, a to umocniť na druhú. Pokiaľ by sme chceli vypočítať $x^{2y+1}$, tak opäť vypočítame $x^{y}$, umocníme na druhú a výsledok ešte raz vynásobíme $x$. Samozrejme, všetky operácie robíme modulo $P$.

Túto ideu samozrejme aplikujeme rekurzívne, takže pri počítaní $x^y$ budeme rátať niečo štýlu $x^{y/2}$, čím dostaneme algoritmus, ktorý umocňuje s časovou zložitosťou $O(\\log(y))$, keďže zakaždým sa exponent, ktorý potrebujeme vyrátať zmenší na polovicu.

Na rátanie kombinačných čísel si teda dopredu predpočítame všetky faktoriály do poľa $F[,]$ a k nim si vypočítame inverzné prvky, ktoré si uložíme do poľa $FI[,]$. Následne vieme, že

$${{n} \\choose {k}} = F[n]\\cdot FI[k] \\cdot FI[n-k]$$

## Zložitosť

Úspešným zvládnutím všetkých týchto vecí dostaneme správne a dostatočne rýchle riešenie. Zostáva už len odhadnúť časovú zložitosť. Nech $m$ je počet rôznych šťastných čísel vo vstupnej postupnosti. Potom dynamické programovanie zaberie čas $O(m^2)$. Predrátanie si hodnôt $p_i$, ktoré počas neho potrebujeme nám pri použití štruktúry `map` zaberie čas $O(n\\log m)$.

Naviac si potrebujeme predrátať všetky faktoriály, čo zaberie čas $O(n)$. No a pri postupnom skúšaní hodnoty $l$ potrebujeme pre každú z $m$ možností vyrátať jedno kombinačné číslo v čase $O(\\log(P))$, čo nám pridá zložitosť $O(m\\log P)$.

Keď to dáme všetko dokopy, dostaneme zložitosť $O(n\\log m + m^2 + m\\log P)$. Pamäťová zložitosť bude $O(n+m^2)$, ale ak by sme si v našej dynamike pamätali len posledné dva riadky, dostali by sme zložitosť $O(n+m)$.
",10
67a1c69f79d24257,ksp,"# Neprísť do školy

V Krajine Školských Povinností (KŠP) sa zaviedol nový sviatok, takzvaný ""opposite day"" -- opačný deň -- v ktorý by sa všetko malo robiť naopak.

Študenti Feľmi Kvalitnej Školy (FKŠ) sa zhodli, že to teda nesmú prísť do školy. Ľahké splniť, všakže?

Na FKŠ však existuje populárny poobedňajší krúžok -- Kamaráti Musia Športovať (KMŠ) -- ktorí zhrozene pozerajú do rozvrhu na vymeškané športové popoludnie.

Rozhodli sa tak, že všetci členovia krúžku niekam predsalen prísť musia, za účelom udržania kondičky.

Otázka je, kam?

## Úloha

Mesto v ktorom sídli FKŠ si vieme reprezentovať budovami, v ktorých bývajú študenti, a cestami ktoré ich prepájajú. Mesto bolo navrhnuté tak, že sa z každej budovy dá cestami dostať do každej inej práve jedným spôsobom.

V každej bytovke býva nezáporné množstvo členov KMŠ, a každá cesta má nejakú kladnú dĺžku v metroch.

Daný je takýto popis mesta, a je určené ktorá z budov je FKŠ.

_Športový výkon_ si zadefinujeme ako súčet dĺžok trás, ktorú prejdú členovia KMŠ aby prišli k zvolenej budove.

Zvyčajne by sa snažilo KMŠ o najväčší športový výkon, keďže je však opposite day, budú sa snažiť o výkon čo najmenší...

Ktorú budovu si majú zvoliť ako stretávacie miesto, aby toto dosiahli?

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $f$: počet budov v meste a číslo budovy FKŠ.

V druhom riadku je $n$ čísel $k_i$: počet členov KMŠ, ktorí bývajú v budove $i$^[Áno, niektorí študenti sú premotivovaní, a bývajú v škole. To preto, že je feľmi kvalitná.].

V každom z nasledujúcich $n-1$ riadkov sú čísla $a_i\\ b_i\\ d_i$, znázorňujúce cestu medzi budovami $a_i$ a $b_i$ dlhú $d_i$ metrov. Budovy sú očíslované od $1$ po $n$.

Je zaručené, že sa z každej budovy dá dostať ku každej inej budove.

## Formát výstupu

Vypíšte číslo budovy, rôzne od $f$, ku ktorej je súčet dĺžok trás všetkých členov KMŠ najmenší. Ak je takýchto budov viac, vypíšte tú s najmenším číslom.

## Obmedzenia

Platí $2 \\leq n \\leq 100,000$ a $1 \\leq f \\leq n$.

$0 \\leq k_i \\leq 10^4$.

$1 \\leq a_i \\neq b_i \\leq n$ a $1 \\leq d_i \\leq 10^4$.

Sú štyri sady vstupov.

V prvej navyše platí $n \\leq 1,000$.

V druhej zasa platí že $a_i, b_i = i, i+1$ -- teda celé mesto leží na čiare.

## Príklady

```vstup
4 1
1 2 3 4
1 2 7
2 3 6
3 4 5
```

```vystup
3
```

_Tento vstup je príkladom z druhej sady. Športové výkony ktoré by KMŠ podalo pre danú vybratú budovu sú postupne 125, 69, 45, 55. Pre budovu 3 je športový výkon najmenší, tak si vyberú ju. Jej športový výkon je 45, pretože KMŠák z budovy 1 prejde trasu 13, z budovy 2 prejdú dvaja študenti trasu 6, KMŠáci v tretej budove zídu na prízemie výťahom, a zo štvrtej budovy prídu štyria KMŠáci cestou dĺžky 5. Dokopy teda KMŠ podalo výkon $1*13 + 2*6 + 3*0 + 4*5 = 45$._

```vstup
3 2
0 1 0
1 2 47
3 2 47
```

```vystup
1
```

_Vedúci KMŠ by radšej zostal vo FKŠ, je však opačný deň, tak ku FKŠ prísť nemôže. Pre obe iné budovy by jeho športový výkon bol 47, tak si vyberie tú s menším číslom._

```vstup
6 4
5 8 2 3 1 4
4 5 3
5 6 8
1 3 1
2 5 1
3 6 9
```

```vystup
5
```
","# Neprísť do školy

Najprv si prejdeme základnou terminológiou. Mesto je graf, presnejšie strom - budovy sú vrcholy, a cesty medzi nimi sú hrany. Hrany majú dĺžku, a počet členov KMŠ v každej budove nazveme jej váhou. Vrchol číslo $f$ budeme jednoducho volať škola.

## Skúšame všetky budovy

Ako je už zvykom, prvá sada je stvorená na preskúšanie vašej hrubej sily. Môžeme totiž jednoducho spustiť prehľadávanie z každého vrcholu, pamätať si akú vzdialenosť sme zatiaľ prešli, a každému vrcholu ku ktorému prídeme pričítať výkon ktorý sme podali cestou k nemu - rovný prejdenej dĺžke krát váhou vrcholu, z ktorého prehľadávame.

Nakoniec len prejdeme všetky budovy, a zapamätáme si prvú s najmenším podaným výkonom (dávajúc si pozor aby sme nezarátali školu).

V takomto riešení $n$ krát prehľadáme celý graf o $n$ vrcholoch aby sme zrátali výkony, a potom ich raz prejdeme na nájdenie výsledku. Prvá časť nám zaberie $O(n^2)$, druhá $O(n)$, naša časová zložitosť je teda $O(n^2)$.

Okrem vstupu si musíme ku každému vrcholu pamätať konštantný počet premenných (napr. súčet výkonov ktoré sme zrátali, a či sme ho už prehľadali v tejto iterácií). Pamäť je teda $O(n)$.

## Počítame za chodu

Druhá sada bola zamýšľaná ako nápoveda. Vieme na takomto grafe pre každý vrchol zrátať výkon podaný aby k nemu všetci prišli, ale akosi naraz? Áno! Predstavme si že graf zavesíme za vrchol číslo $1$, a zrátame si koľko ľudí k nemu musí prísť, a aký celkový výkon pritom podajú (rovnaké prehľadávanie ako v prvej sade). Čo sa zmení, keď sa všetci rozhodnú prísť do budovy $2$? Všetci ktorí sem prišli z budov $2$ až $n$ sa prejdú menej - neprejdú totiž poslednú hranu medzi $1$ a $2$. KMŠáci z budovy $1$ naopak túto hranu predtým prejsť nemuseli, ale ak chcú prísť k budove $2$, už to budú musieť spraviť.

Vo všeobecnosti máme teda nasledovný stav: sme v nejakom vrchole $i$, a vieme aký je celkový výkon podaný aby sem všetci prišli, $V$. Tiež vieme, koľko ľudí k nám prišlo zdola (z vrcholov s väčším číslom), $D$, a koľko ľudí k nám prišlo zhora (z vrcholov s menším číslom), $H$..

Keď sa teraz presunieme do vrchola $i+1$, hranou dĺžky $L$, tieto hodnoty sa zmenia nasledovne:

1. $H = H + $ počet ľudí vo vrchole $i$ (ľudia vo vrchole $i$ odteraz idú smerom dole)
1. $V = V - H \\cdot L + D \\cdot L$ (ľudia zhora prejdú $L$ naviac, ľudia zdola prejdú $L$ menej)
1. $D = D - $ počet ľudí vo vrchole $i+1$ (ľudia vo vrchole $i+1$ už nejdú smerom hore)

Takto vieme v $O(1)$ postupne, krok po kroku, zrátať celkový výkon pre každý vrchol. Stačí si nám zapamätať si ho a potom vybrať ten optimálny, alebo si toto pamätať už za chodu.

Takto prejdeme graf dva krát - najprv aby sme zistili výkon a počet ľudí idúc zdola do vrcholu $1$, a potom postupne spravíme krok k vrcholu $2, 3, \\cdot, n$, udržujúc si všetky potrebné informácie. Každý krok je $O(1)$, máme teda zložitosť $O(n)$.

Okrem vstupu si teraz pamätáme konštantne veľa premenných naviac, pamäť je teda opäť $O(n)$.

## A trochu všeobecnejšie...

Techniku z predošlej sady vieme implementovať aj všeobecnejšie. Musíme byť len šikovnejší, pretože v našom zakorenenom strome budú vrcholy mať viacero synov do ktorých môžeme vkročiť.

Na začiatku si pustíme prehľadávanie z vrcholu $1$, a pre každý vrchol si zapamätáme koľko ľudí býva v jeho podstrome, a aký výkon dokopy podali aby k nemu prišli.

Teraz pustíme nové prehľadávanie, v ktorom si budeme udržiavať počet ľudí ktorí k nám prichádzajú zhora, a aký výkon na to podali. Celkový výkon pre daný vrchol je potom výkon podaný zhora plus výkon zdola, ktorý sme si predtým predpočítali.

Keď začíname vrcholom $1$, 0 ľudí prichádza zhora, a podali nulový výkon.

Keď sa teraz presúvame z vrcholu $i$ do niektorého syna $S$ hranou dĺžky $L$, platí nasledovné:

1. Všetci, čo prichádzali do $i$ zhora, prichádzajú aj do $S$ zhora, a prejdú $L$ dĺžky navyše.

1. Navyše, všetci ľudia v synoch $i$, ktorí niesu $S$, doteraz prichádzali do $i$ zdola, ale do $S$ budú prichádzať zhora. Aj tí prejdú $L$ navyše.

Hodnotu číslo 1. si udržiavame v našom prehľadávaní, a hodnotu číslo 2. si vieme vypočítať ako počet ľudí čo prišli do $i$ zdola, mínus počet ľudí čo prišli do $S$ zdola (toto sme si zrátali pre každý vrchol v prvom prehľadávaní).

Naše riešenie má rovnaké zložitosti ako v jednoduchšej verzií. Dvakrát prehľadáme náš graf, pre každú hranu spravíme konštantne veľa operácií (prerátame nejaké celočíselné premenné). Časová zložitosť je teda $O(n)$. Pre každý vrchol si niekoľko z týchto premenných zapamätáme navyše, aj pamäťová zložitosť je teda $O(n)$.
",6
5129029332c35051,ksp,"# Prestavba bytu

Krtko rekonštruuje byt. Posledné, čo mu zostáva je vydláždiť novú kúpeľňu. Zhodou náhod sa mu v schránke objavil leták obľúbeného veľkoskladu - Kúpeľňového Sveta Podláh - a v ňom zľava na dlaždice L-kového tvaru. Táto ponuka bola natoľko lákavá, že Krtko nakúpil oveľa viac dlaždíc, ako potreboval. Teraz sedí pred svojou dokonalou dokonalo-štvorcovou kúpeľňou a premýšľa, či on vôbec bude vedieť pomocou týchto kachličiek svoju kúpeľňu vydláždiť. Akoby nestačilo, v jeho inak príjemne dokonalo-štvorcovej kúpeľni sa nachádza otvor na odtok sprchy, ktorý nemôže kachličkami prekryť. Pomôžte Krtkovi vydláždiť jeho kúpeľňu alebo zistite, že to nie je možné.

## Úloha

Štvorcovú kúpeľňu si môžeme predstaviť ako štvorcovú sieť $n \\times n$. Pre dokonalo štvorcovú kúpeľňu navyše platí, že veľkosť jej strany $n$ je mocnina dvojky. Odtok zaberá v myslenej sieti práve jedno celé políčko. Pod dlaždicou L-kového tvaru myslíme tri štvorce veľkosti $1 \\times 1$, spojené do tvaru L.

Vykachličkovanie je možné, ak pomocou L-kových kachličiek vieme prekryť všetky voľné miesta v našej kúpeľni (okrem odtoku) bez toho, aby sme nejaké kachličky akokoľvek delili alebo ľubovolne prekrývali. Taktiež sa nesmie stať, že by nejaká kachlička vyčnievala z kúpeľne. Samozrejme, nakúpené kachličky je možné akokoľvek otáčať. Kachlička teda môže byť orientovaná 4 rôznymi spôsobmi.

Na vstupe od nás dostanete veľkosť kúpeľne. Ďalej od nás dostanete pozíciu odtoku. Ak je možné kúpeľňu takýchto rozmerov s odtokom na danom mieste vykachličkovať iba pomocou nakúpených L-kových kachličiek, vypíšte ľubovolné takéto vykachličkovanie. Ak to možné nie je, podajte o tom správu.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ $(1 \\leq n \\leq 256)$ -- dĺžka hrany štvorca reprezentujúceho kúpeľňu, pričom platí, že $n$ je mocnina 2. V ďalšom riadku nasleduje dvojica čísel $r, s$ $(1 \\leq r, s \\leq n)$ -- číslo riadku a stĺpca v našej mriežke, kde sa nachádza odtok.

## Formát výstupu

Ak vykachličkovanie nie je možné, vypíšte na jeden riadok výstupu reťazec `Neda sa`. Inak si označme všetky použité kachličky číslami od 1 do $x$, kde $x$ je ich počet (je zrejmé, že $x = (n^2-1) \\div 3$). Na výstup vypíšte $n$ riadkov. V každom takomto riadku sa má nachádzať $n$ medzerou oddelených reťazcov. Ako $j$-ty reťazec v $i$-tom riadku vypíšte číslo kachličky, ktorá prekrýva poličko v $i$-tom riadku a $j$-tom stĺpci mriežky alebo vypíšte znak `X` ak sa na danom políčku nachádza odtok. Korektných riešení môže byť viac (napríklad prečíslovaním kachličiek dostaneme z jedného korektného riešenia iné korektné riešenie). Vypíšte ktorékoľvek z nich.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| -----:| ------:| -------:| | $$ 1 \\leq n \\leq $$ | $4$ | $16$ | $64$ | $256$ |

## Príklady

```vstup
2
1 1
```

```vystup
X 1
1 1
```

*Kúpeľna veľkosti $2 \\times 2$ s odtokom v ľavom hornom rohu. Je len jedno možné riešenie.*

```vstup
4
2 3
```

```vystup
2 2 1 1
2 3 X 1
4 3 3 5
4 4 5 5
```

*Jedno z možných riešení. Akékoľvek iné riešenie s iným prečíslovaním či inou pozíciou kachličiek bude tiež akceptované.*
","# Prestavba bytu

Zadanie tejto úlohy bolo pomerne priamočiare. Máme zadanú štvorcovú mriežku nejakých špeciálnych rozmerov a máme ju celú okrem jedného daného políčka vykachličkovať veľa kachličkami tvaru L.

## Riešenie hrubou silou

Prvé riešenie, ktoré môžeme vyskúšať pokiaľ nevieme s ničím lepším prísť, je riešenie hrubou silou, teda skúšanie všetkých možností. V tomto prípade ale nie je úplne jasné, ako takéto skúšanie pekne a dobre implementovať. Ako teda v tomto prípade rozumne postupovať?

Začneme tým, že asi najprirodzenejšou reprezentáciou podlahy kúpeľne je klasické dvojrozmerné pole. To chceme vyplniť číslami kachličiek a následne ho vypísať na výstup. Ďalej vieme už vopred povedať, koľko kachličiek použijeme: stačí si vypočítať počet políčok, odrátať jedno za odtok a vydeliť tromi. Ostáva teda už len zistiť, ako majú byť jednotlivé kachličky otočené a rozmiestnené.

Chceli by sme teraz vymyslieť nejaký systematický postup skúšania všetkých možností. Vezmime si nejaké políčko, ktoré ešte nie je pokryté kachličkou (a ani odtokom). Toto políčko musíme nejako pokryť. Kedže máme iba malý (a hlavne konečný) počet možností, ako to spraviť, môžeme postupne vyskúšať všetky. Presnejšie, budeme postupovať nasledovne: vždy si vyberieme nejakú možnosť, ako toto políčko pokryť, tú si zaznačíme do poľa a rekurzívne sa zavoláme (""vyskúšaj všetky možnosti ako dokončiť toto aktuálne kachličkovanie""). Ak sa z rekurzie vrátime s tým, že žiadne riešenie sme nenašli, odstránime z poľa zaznačený spôsob pokrytia aktuálneho políčka a prejdeme na ďalšiu možnosť, ako ho pokryť.

Naše konkrétne riešenie bude prechádzať pole systematicky: zhora dole a v rámci riadku zľava doprava. Zakaždým, keď nájdeme prázdne políčko, spravíme preň vyššie popísaný postup, pričom pri rekurzívnom volaní si odovzdáme súradnice, kde sme boli, aby sme vedeli, odkiaľ ďalej stačí hľadať nasledujúce voľné políčko. Jeden možný stav počas behu tohto riešenia je znázornený na nasledujúcom obrázku:

Akými možnými spôsobmi ide vo všeobecnosti takéto políčko pokryť? Pri našom systematickom postupe máme zaručené, že všetky políčka v skorších riadkoch aj všetky políčka v aktuálnom riadku naľavo od práve pokrývaného sú už pokryté. Stačí nám teda vyskúšať nanajvýš štyri možnosti, a to tieto:

Na implementáciu tohto riešenia nám stačí jedna funkcia, ktorá ako parametre dostane súradnice prvého políčka (v nami zvolenom poradí), ktoré sme ešte neskontrolovali. Pri každom volaní skontrolujeme jedno políčko. Ak už je pokryté, alebo je to odtok, len sa zavoláme na nasledujúce. Ak nie, tak vyskúšame všetky štyri možnosti, ako ho pokryť, a pre každú, ktorá naozaj pasuje, sa rekurzívne zavoláme na nasledujúce políčko. No a akonáhle sa dostaneme k tomu, že úspešne skontrolujeme, že posledné políčko v poslednom riadku je pokryté, môžeme vyhlásiť, že sme našli riešenie.

Táto funkcia tiež musí mať prístup k poľu, do ktorého zostrojujeme popis kachličkovania. Toto sa dá riešiť rôznymi spôsobmi, napríklad tak, že si referenciu na pole budeme odovzdávať ako ďalší parameter našej rekurzívnej funkcie. (Treba si dať pozor na to, aby sme nekopírovali celé pole pri každom rekurzívnom volaní.)

Technika pre skúšanie všetkých možností, ktorú sme si práve popísali, je známa pod menom backtracking. Pamäťová zložitosť tohto riešenia je zjavne $O(n^2)$, kedže nám stačí pamätať si iba aktuálne pokrytie mriežky, ktoré sa práve pokúšame doplniť. Časová zložitosť môže byť v najhoršom prípade rádovo až $O(4^{(n^2/3)})$ kedže pri prikladaní každej kachličky máme na výber nanajvýš 4 možnosti.

Niektoré implementácie tohto riešenia však fungujú v skutočnosti prekvapivo dobre. Riešenie totiž nielen že vždy existuje, je ich dokonca tak veľa, že sa často stane, že už prvá možnosť priloženia kachličky, ktorú vyskúšame, vedie k riešeniu -- a tak skutočné skúšanie možností budeme robiť až pri okrajoch, kde už niektoré umiestnenia kachličiek budú robiť problémy.

## Vzorové riešenie

Ako by sme mohli začať hľadať nejaké riešenie, ktoré bude zaručene efektívne? Dobrým začiatkom je skúsiť ručne vyriešiť nejaké mriežky menších rozmerov a získať tak trochu obraz o tom, ako riešenia vyzerajú a pre ktoré kombinácie (veľkosť mriežky, poloha odtoku) riešenie neexistuje.

Ak sa pozrieme na mriežky veľkosti $2\\times 2$ či $4\\times 4$, zistíme, že nech je odtok kdekoľvek vždy nájdeme nejaké riešenie. To by nám mohlo napovedať, že by to mohlo ísť aj pre úplne všetky väčšie mriežky -- len budeme musieť náš postup nejak zovšeobecniť.

Skúsme sa pozrieť napríklad na to, ako vieme vykachličkovať mriežku veľkosti $4\\times 4$ s odtokom v ľavom hornom rohu. Ľahko zistíme, že vieme doložiť jednu kachličku tak, aby sme doplnili celý ľavý horný štvorec veľkosti $2\\times 2$. Ako teraz pokryť ostatné tri štvorce rozmerov $2\\times 2$? Každý z nich by sme vedeli pokryť samostatne, ak by obsahoval odtok. Inými slovami, každý z nich vieme pokryť celý okrem jedného jeho políčka. A už sme skoro vyhrali. Všimnite si kachličku, ktorá je na nasledujúcom obrázku zelenou farbou. Jej priložením sme pokryli práve jedno políčko v každom štvorci $2\\times 2$, ktorý neobsahoval odtok. A teda nám ostali štyri štvorce $2\\times 2$, z ktorých každý má práve jedno pokryté a tri nepokryté políčka.

Teraz uvažujme mriežku $4\\times 4$, ktorá má odtok niekde inde. Zjavne aj tú vieme celú pokryť, a to presne rovnakým postupom. Jediný rozdiel bude v tom, že bude inak otočená kachlička v tom štvorci $2\\times 2$, ktorý obsahuje odtok.

Ako je to s väčšími mriežkami? Mriežku $8\\times 8$ si môžeme rozdeliť na štyri mriežky rozmerov $4\\times 4$. Je jasné, že iba v jednom z týchto blokov je práve jedno políčko zabrané odtokom. Vhodným uložením jednej ""zelenej"" kachličky ku stredu mriežky teraz vieme zabrať po jednom políčku aj v každom zo zvyšných troch blokov. No a každý z týchto blokov vieme vyriešiť vyššie popísaným spôsobom.

No a tento postup už ľahko zovšeobecníme: ľubovoľnú mriežku veľkosti $2^k\\times 2^k$ vieme rozdeliť na štyri mriežky veľkosti $2^{k-1}\\times 2^{k-1}$ a následne vieme vhodne priložiť jednu kachličku tak, aby každá mriežka menších rozmerov mala jedno políčko, ktoré už netreba pokryť. Potom sa na každú z menších mriežok rekurzívne zavoláme, čiže pre každú z nich znova zopakujeme túto istú úvahu.

Vhodnou implementáciou tohto riešenia je jedna rekurzívna funkcia, ktorá si bude pamätať, akú časť mriežky vypĺňa a kde v nej sa nachádza ""odtok"", teda to jedno políčko, ktoré je už pokryté. Pamäťová zložitosť tohto riešenia je $O(n^2)$, kedže si pamätáme iba mriežku, do ktorej zároveň hneď dopĺňame kachličky.

Časová zložitosť je tiež $O(n^2)$, čiže priamo úmerná veľkosti mriežky. Prečo? Pri každom zavolaní našej funkcie totiž spravíme konštantne veľa výpočtov a priložíme jednu kachličku. No a keďže kachličiek je $(n^2-1)/3$, toľko bude aj volaní našej funkcie.
",6
651a6f24db889d2d,ksp,"# Insektológia v Slovakistane

Tuhá zima už odišla, a tak majú farmári Slovakistanu plné ruky práce vysádzaním plodín na svojich poliach. Na veľké potešenie škodcov všetkého možného druhu, ktorí majú zas plné ústa práce ich vyjedaním.

Insektológ Kubík bol však odhodlaný svojim spoluobčanom pomôcť, a tak cez celé zimné prázdniny pracoval na revolučnom spôsobe, akým by sa škodci a polia dali vyjadriť číslami. Vďaka tomu by určite vedel poradiť farmárom, ako najlepšie ochrániť úrodu pred škodcami.

Svoj návrh predviedol pred KSP^[Komisia Slovakistanského Poľnohospodártsva], avšak neuspel -- jeho abstraktné teórie boli síce fascinujúce, no keď prišlo na predvádzanie v praxi, ani so svojimi vytrénovanými kalkulačkovými schopnosťami nevedel dostatočne rýchlo odpovedať, ako najlepšie by sa dala ochrániť Slovakistanská úroda.

Kubík sa však nevzdal a poslal holuba do ďalekej krajiny, v ktorej vraj nažívajú šikovní programátori, ktorí by mu boli schopní pomôcť...

## Úloha

Kubík každému škodcovi priradil prvočíslo -- čím viac škody narobí, tým väčšie. Každému poľu potom vie priradiť číslo reprezentujúce škodcov, ktorí sa na ňom priživujú -- prvočíslo každého prítomného škodcu umocní na mocninu zodpovedajúcu závažnosti zamorenia týmto škodcom a tieto mocniny potom vynásobí dokopy. Výsledné číslo budeme volať *kontaminácia poľa*. Prvočíselný rozklad kontaminácie poľa nám teda hovorí, ktoré druhy na poli škodia a mocniny jednotlivých prvočísel v rozklade poukazujú na závažnosť zamorenia. Navyše, kontaminácia poľa vyjadruje celkovú škodu, ktorú škodce na danom poli napáchajú.

Polia v Slovakistane sú všetky popri veľtoku Dujana. KSP vlastní lietadlo, ktorým vie postriekať súvislý úsek polí nejakým pesticídom, ktorý je špecificky určený na boj proti jednému druhu škodcov. Každý rok si lámu hlavu nad tým, ktoré pesticídy by mali kam nastriekať, aby zachránili čo najviac úrody.

Kubíkova teória na to však má odpoveď -- keď postriekame pole pesticídom proti škodcovi s priradeným prvočíslom $p$, kontamináciu tohto poľa vydelíme mocninou $p$, ktorá je v jej rozklade. Rozdiel medzi originálnou a novou kontamináciou je potom množstvo úrody, ktoré sme vďaka pesticídu zachránili.

KSP má veľa návrhov, ktorý pesticíd kam nastriekať. Pre každý z nich povedzte, koľko úrody by tento zákrok zachránil.

## Formát vstupu

V prvom riadku sú tri čísla $n$, $q$ a $p$ -- počet polí v Slovakistane, počet návrhov kam nastriekať pesticíd, a najväčšia možná kontaminácia poľa.

V druhom riadku vstupu je $n$ kladných celých čísel $v_1, v_2, \\dots, v_n$ ($1 \\leq v_i \\leq p$) -- hodnoty kontaminácie jendotlivých polí, v poradí v akom sú popri veľtoku Dujana.

Nakoniec nasleduje $q$ riadkov s tromi číslami $l_i, r_i, p_i$. Tieto tri čísla popisujú návrh KSP, aby sa všetky polia od $l_i$-tého až po $r_i$-té (vrátane) postriekali pesticídom proti škodcovi s číslom $p_i$. Platí $1 \\leq l_i \\leq r_i \\leq n$ a $1 \\leq p_i \\leq p$. Číslo $p_i$ je vždy prvočíslo.

## Formát výstupu

Pre každý návrh povedzte, koľko úrody by bolo zachránenej, ak by sa vykonal. Formálne, povedzte o koľko by sa zmenil súčet čísel $v\_{l_i} + \\dots + v\_{r_i}$, ak by sme každé vydelili tou mocninou prvočísla $p_i$, ktorá sa v ňom nachádza.

## Hodnotenie

Pre jednotlivé testovacie sady platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:---------- | ---:| ---:| ---:| -----:| | $n,q \\leq$ | $1,500$ | $100,000$ | $100,000$ | $300,000$ | | $p \\leq$ | $10^6$ | $100$ | $10^6$ | $10^6$ |

Upozorňujeme, že riešenia v pomalých jazykoch, ako Python, nemusia stíhať.

## Príklady

```vstup
5 5 100
10 20 30 40 50
1 1 2
1 5 5
1 5 47
2 4 3
2 4 2
```

```vystup
5
128
0
20
65
```

*V štvrtom návrhu dostávame rozdiel súčtu $(20+30+40)-(20+10+40) = 20$.*
","# Insektológia v Slovakistane

## Stará dobrá hrubá sila

Ako inak, úloha sa dá riešiť aj hrubou silou. Pre každú otázku prejdeme zadaný interval, každé číslo delíme daným prvočíslom kým to len ide, a k odpovedi pripočítame rozdiel pôvodného a výsledného čísla.

Aká je časová zložitosť? Pre každú otázku prejdeme najviac $n$ čísel a každé z nich niekoľkokrát vydelíme--najviac ale logaritmicky veľakrát, a kedže všetky čísla v poli sú nanajvýš $p$, budeme deliť $O(\\log p)$-krát.

Každá otázka nám teda zaberá $O(n \\log p)$ času, a teda $q$ otázok zodpovedáme v $O(qn \\log p)$, a tešíme sa, že prejdeme prvou sadou. Otázky môžeme riešiť po jednej, a teda si okrem zamorení polí pamätáme len konštantne veľa premenných; pamäťová zložitosť je teda $O(n)$.

## Všetko si predpočítame

Chceli by sme zrýchliť odpovedanie na otázky, nakoľko $O(n \\log p)$ si okrem prvej sady nemôžeme nikde dovoliť.

Ako by vyzerala úloha, keby každá otázka bola o rovnakom prvočísle $x$? Každá kontaminácia poľa $v_i$ by (ak je v intervale otázky) prispela nejakou hodnotou $x_i$, ktorá sa nikdy nezmení. Každá otázka by teda bola priamočiaro 'súčet čísel v intervale', ktoré vieme v $O(1)$ zodpovedať pomocou [prefixových súčtov](https://www.ksp.sk/kucharka/prefixove_sumy/).

Môžeme si teda predpočítať prefixový súčet hodnôt $x_i$ pre každé prvočíslo $x$ menšie rovné $p$. Takýto prístup je dosť efektívny na druhú sadu, kde $p$ je malé.

Pre ilustráciu, hodnoty $x$ v príkladovom vstupe by vyzerali takto:

A k nim prislúchajúce prefixové súčty:

Aká je teda časová zložitosť? V čase $O(p^{3/2})$ vieme nájsť všetky prvočísla do $p$---iba pre každé číslo $2, 3, \\ldots, p$ overíme, či má deliteľa menšieho/rovného jeho odmocnine. Potom pre každé prvočíslo vypočítame hodnoty $x$. Všetkých hodnôt $x$ je $O(np)$^[Dá sa dokázať, že prvočísel v $1, \\ldots, p$ je $O(\\frac{p}{\\log p})$, a tým sa dá odhad vylepšiť na $O(n \\cdot \\frac{p}{\\log p})$. Záujemcovia môžu navštíviť https://en.wikipedia.org/wiki/Prime_number_theorem]. Na výpočet každej z hodnôt $x$ potrebujeme $O(\\log p)$-krát deliť, teda toto predpočítanie nám potrvá $O(np \\log p)$. Otázky už zodpovedáme v $O(1)$. Časová zložitosť je teda $O(np \\log p + q)$.

Pamäťová zložitosť je $O(np)$, nakoľko si pamätáme prefixové súčty hodnôt $x$.

## Predpočítame len nenulové prvky

Vo vyššieuvedenom riešení už odpovedáme na otázky dosť rýchlo, pridlho nám však trvá predpočítanie prefixových polí. Máme v nich priveľa prvkov, potrebujeme ich ale všetky?

Musíme si uvedomiť, že tak, ako v čísle veľkosti $p$ môže byť prvočíslo umocnené na najviac $\\log p$, tak isto v ňom môže byť najviac $\\log p$ **rôznych** prvočísel. Príkladne pre $p = 10^6$ máme [78498](<http://www.wolframalpha.com/input/?i=pi+function(10%5E6)>) prvočísel, avšak v konkrétnom čísle do $10^6$ ich vie najviac byť len 7^[$2 \\cdot 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 \\cdot 17 = 510,510$. Použili sme tu čo najmenšie prvočísla, a ôsme už do milióna nezmestíme.]! Pre každé z $n$ čísel nám teda reálne najviac $\\log p$ hodnôt $x$ dodalo nejakú podstatnú informáciu, zvyšné sú nutne nuly. Stačí nám teda uvažovať len týchto $n \\log p$ hodnôt, a pre každú si navyše pamätáme, ktorému indexu zodpovedá.

Pre ilustráciu, hodnoty $x$ v príkladovom vstupe by sa skomprimovali takto:

(Prvé číslo je index $i$, druhé je hodnota $x_i$.) Keď máme (komprimované) hodnoty $x$, ľahko k nim zostrojíme (komprimované) prefixové súčty. V príkladovom vstupe be sme dostali:

Žiadne ďalšie prvočísla v číslach na vstupe neboli, teda zvyšné prefixové súčty sú (efektívne) prázdne.

Keď už poznáme prefixové súčty, na každú otázku vieme odpovedať nasledovne. Ak chceme súčet intervalu $\\langle l_i, r_i \\rangle$, nájdeme v príslušnom prefixovom poli prvé $L_i \\geq l_i$ a posledné $R_i \\leq r_i$, a odpovieme súčtom v $\\langle L_i, R_i \\rangle$ (ktorý je rovnaký). Tieto dve hodnoty vieme binárne vyhľadať v $O(\\log n)$, zodpovedanie všetkých otázok nám teda bude trvať $O(q \\log n)$.

Ostáva teda len jedna otázka: ako rýchlo si vieme hodnoty $x$ predpočítať?

Budeme postupovať podobne, ako pri [Eratostenovom site](https://www.ksp.sk/kucharka/eratosten/). Upravíme ho tak, aby nám navyše pre každé číslo našlo najmenšie prvočíslo, ktoré ho delí---vždy, keď zistíme, že nejaké $q$ je prvočíslo, navštívime všetky násobky $q$. Všetky násobky, ktoré sme doteraz nenavštívili, určite nie sú deliteľné žiadnym prvočíslom menším ako $q$, ich najmenší prvočíselný deliteľ je teda $q$.

Tak, ako pri štandardnom Eratostenovom site, stačí nám navštíviť len tie násobky, ktoré sú väčšie alebo rovné ako $q^2$. Menšie násobky sú totiž deliteľné aj nejakým prvočíslom menším ako $q$, ktoré sme už spracovali---a teda už poznáme najmenšieho prvočíselného deliteľa takého násobku.

Toto spravíme v čase $O(p \\log \\log p)$ a pamäti $O(p)$.

Keď teraz chceme zistiť prvočíselný rozklad nejakého $v_i$, budeme ho zakaždým deliť jeho najmenším prvočíselným deliteľom, až kým nedosiahne hodnotu $1$. Pritom si pamätáme, ktorými prvočíslami sme ho vydelili a koľkokrát. Každé zistenie rozkladu nám bude trvať $O(\\log p)$.

Z rozkladu $v_i$ následne zostrojíme komprimovanú tabuľku hodnôt $x$ v čase $O(n \\log p)$, a zostrojíme komprimované prefixové súčty v čase lineárnom od veľkosti tabuľky, čiže tiež $O(n \\log p)$. Nakoniec v $O(q \\log n)$ zodpovieme otázky.

Spolu s Eratostenovým sitom dostávame časovú zložitosť $O(p \\log \\log p + n \\log p + q \\log n)$. Pamäťová zložitosť je $O(p + n \\log p)$, nakoľko si pamätáme pole s najmenšími prvočíselnými deliteľmi, a prefixové súčty hodnôt $x$.
",6
b4ee7f74a17b0f4a,ksp,"# O žabách a hadoch

Žabiak Michal a žabka Lucka dostali na Vianoce hru Hady a Žaby. Táto hra je pre dvoch hráčov. Jeden hráč si zvolí postupnosť štyroch farebných žiab zo šiestich možných farieb. Farby žiab sa môžu aj opakovať. Druhý hráč háda, aká je táto postupnosť. Aby to však nemal až také ťažké, po každom tipe mu prvý hráč povie dve čísla. Prvé hovorí, koľko žiab trafil presne, teda na danom mieste je žaba správnej farby. Druhé hovorí koľko žiab mu zjedli hady (teda sú na zlom mieste). Inak povedané, toto číslo hovorí o koľko viac žiab mohol trafiť, ak by svoj tip usporiadal inak. Žabiakovi Mišovi sa táto hra veľmi zapáčila, no žabku Lucku už pomaly aj prestala baviť. Žabiak si oblúbil úlohu prvého hráča, ktorý to má síce celkom jednoduché, ale za to sa môže protihráčovi smiať vždy, keď neuhádne.

Žabiak si teda naprogramoval svojho druhého hráča, s ktorým sa môže hrať, koľko len bude chcieť. Tento jeho protihráč bol však veľmi hlúpy a hádal náhodné postupnosti. Začalo to byť rýchlo nudné. Dokážete žabiakovi naprogramovať lepšieho protihráča?

## Úloha

Táto úloha je interaktívna. Váš program musí vypísať svoj tip, potom si prečítať odpoveď od žabiaka a vypísať ďalší tip, a tak ďalej, až kým nebude odpoveď `4 0`. Táto odpoveď znamená, že tip je správny, teda že váš program trafil všetky štyri žaby.

## Formát vstupu

Po každom tipe dostanete na vstup dve medzerou oddelené čísla -- počet žiab a počet hadov.

Aby testovanie fungovalo ako má, **je nutné**, aby sa po vypísaní tipu výstup presunul z pamäte na štandardný výstup pomocou príkazu `cout.flush()` v C++ alebo `sys.stdout.flush()` v Pythone. Pre iné jazyky hľadajte ekvivalent k príkazu `flush`.

## Formát výstupu

Každý tip vypíšte ako $4$ medzerou odelené čísla od $1$ do $6$, ktoré predstavujú farby štyroch žiab.

## Hodnotenie

Je $10$ sád vstupov. Každá sada má obmedzený počet tipov, ktoré sa môžete opýtať. Ak budete potrebovať viac tipov na zistenie riešenia, dostanete odpoveď WA. Maximálny počet otázok je v prvých sadách postupne $1000, 100, 50, 30$ a $10$. V ďalších sadách je počet vždy o jedno menší až po $5$ v poslednej sade.

V popise riešenia sa sústreďte na to, aby bolo jasné prečo vaše riešenie vždy nájde odpoveď. Časovú zložitosť určite v závislosti od počtu farieb a od počtu hádaných žiab.

## Príklad

```iobox
>>> 1 3 2 3
<<< 1 2
>>> 3 4 2 1
<<< 0 4
>>> 1 2 3 4
<<< 4 0
```

_Heslo je 1 2 3 4._
","# O žabách a hadoch

Táto úloha mala veľa rôznych spôsobov ako získať nejaký počet bodov. Ak napríklad skúšame všetky možnosti, hneď máme jeden, s trochou šťastia aj dva body. Ak však začneme využívať informácie zo vstupu, veľmi ľahko sa dostaneme na 4 body. Stačí totiž zistiť aké 4 farby potrebujeme, a postupne vyskúšať všetky ich variácie. Ak si však podobnú stratégiu skúsime ručne odohrať, zistíme, že od súpera dostávame viac informácii o riešení ako využívame a môžeme implementovať rôzne vylepšenia.

## Vzorové riešenie

Nebudeme to ďalej naťahovať, a povieme si, ako sa dopracovať ku riešeniu ktoré to zvláda na 5 tipov. Na začiatok si treba uvedomiť, že všetkých možností je len $6^4$ teda 1296. To vôbec nie je veľa, teda ide nám najmä o hľadanie stratégie a nie ani tak o časovú zložitosť.

S každým tipom dostaneme od protihráča celkom veľa informácie. Každá odpoveď nám totiž rozdelí tých 1296 možností na tie, ktoré heslo môžu byť, a tie, ktoré heslo byť nemôžu. To, do ktorej skupiny patrí ktoré štvorčíslie, zistíme veľmi jednoducho, keď si spočítame, akú odpoveď by nám dal protihráč na náš tip, ak by dané štvorčíslie bolo heslo. Keď toto spravíme pre každú jednu možnosť, budeme mať nový zoznam prípustných možností, ktorý už bude výrazne kratší.

S takýmto pozorovaním sa už ľahko dostaneme na 8 až 10 bodov, podľa toho, ako si vyberieme ďalší tip. Ak si povieme, že vylosujeme náhodne z ostávajúcich možností, tak to niekedy vydá a niekedy nie. My by sme však chceli riešenie, ktoré funguje vždy na 5 tipov. Na to potrebujeme vybrať ten správny tip. Ak napríklad vieme, že `1122` má dve zhody, asi nebude najlepší tip `1123`, ale viac nám povie napríklad `3344`.

Najlepší je teda taký tip, ktorý vyradí najviac možností. Ako však taký tip nájsť, keď nepoznáme heslo? Povedzme, že po prvom tipe sme si vytvorili vyššie popísaný zoznam možných hesiel. Teraz chceme o nejakom nasledujúcom tipe zistiť, ako dobrý je. To budeme merať tak, že si pre každé možné heslo zistíme, akú odpoveď by sme dostali a pre každú možnú odpoveď (tých je 14) spočítame, koľko možných hesiel by nám ostalo, ak by sme danú odpoveď dostali. Nevieme však, akú odpoveď dostaneme, tak rátajme s najhoršou možnosťou. Teda takou, ktorá by vyradila najmenej hesiel. Keď si takéto číslo zrátame o každom možnom tipe, vieme si ľahko vybrať ten, ktorý vyradí najviac možností v najhoršom prípade. Treba si však uvedomiť, že niekedy môže byť najlepší aj tip, ktorý heslom určite nebude (ako v príklade v predošlom odseku). Aj bez tohoto pozorovania však už dostaneme 9 bodov.

Táto technika sa volá minmax, lebo najprv si pre každý tip zistíme minimum jeho prínosu a potom zoberieme maximum z týchto možností. Dá sa takmer univerzálne aplikovať na hry, kde nepoznáme ťah súpera, ale vieme nejakým spôsobom odsimulovať všetky jeho možnosti. Treba však myslieť na to, že výsledok nemusí byť optimálny, nakoľko napríklad v tejto úlohe sa vôbec nepozeráme na ťahy ktoré budú nasledovať^[Môže sa totiž stať, že druhá najlepšia možnosť aktuálne nám zabezpečí lepšiu najhoršiu možnosť v ďalšom ťahu, ako tá aktuálne najlepšia.].

## Časová zložitosť

Časová zložitosť nás trochu potrápi, podľa toho, ako dôslední chceme byť. Označme $f$ počet farieb a $n$ dĺžku hesla. Povedzme pre jednoduchosť, že porovnanie dvoch tipov robíme v $O(n^2)$^[Dá sa to však aj v $O(n)$.]. Prefiltrovať tipy podľa odpovede, ktorú dostaneme, nám potom trvá $O(f^nn^2)$. Ďalší krok je, že pre každý možný tip ($O(f^n)$) zisťujeme, pre každé možné heslo ($O(f^n)$), akú odpoveď by sme dostali ($O(n^2)$). Možných odpovedí je tiež $n^2$, teda najlepšiu z nich tiež nájdeme v $O(n^2)$. Výsledná časová zložitosť jedného tipu teda bude $O(f^{2n}n^2)$. Pamäťová zložitosť je $O(f^n)$.

Najhorší možný počet ťahov je takmer nemožné ručne odhadnúť na 5, preto sa jednoducho odvoláme na to, že skúsiť všetky skryté heslá nie je tak [ťažké](http://www.cs.uni.edu/~wallingf/teaching/cs3530/resources/knuth-mastermind.pdf).
",5
f68af9a0cb0eee33,ksp,"# Ukladanie kartičiek

Vlejd sa rád hrá s najrôznejšími kartičkami. Najčastejšie sú to [Magic](https://cs.wikipedia.org/wiki/Magic:_The_Gathering) kartičky, ale rád spoznáva aj nové hry. Toto leto sa vybral na stáž do Ameriky, a samozrejme využil príležitosť aby sa pri tom naučil hrať nejaké nové kartičky. Jednu hru sa naučil už cestou v lietadle, kde mu ju ukázal spolusediaci John. Povedal mu: ""Pravidlá sú veľmi jednoduché, to pochopíš počas hry"".

Hra bola naozaj jednoduchá. Kartičky boli rozložené na stole a každá mala na vrchu jedno číslo. Hráči sa striedali v ťahoch. V jednom ťahu si hráč vyberie jednu kartičku, ktorú odstráni z hry. Spolu s ňou odstráni aj všetky kartičky s menším číslom. Vyhráva hráč, ktorý odstráni poslednú kartičku. Vlejd to naozaj rýchlo pochopil, a za chvíľu už vždy vedel nájsť najlepší ťah. John, ako skúsený hráč, taktiež vždy spravil optimálne rozhodnutie. Vtom si Vlejd uvedomil, že zistiť kto túto hru nakoniec vyhrá sa dá už na začiatku. Viete to aj vy?

## Úloha

Na vstupe je zoznam kartičiek. Rozhodnite, či môže Vlejd vyhrať, za predpokladu, že ťahá prvý, a obaja hráči hrajú optimálne -- teda napr. ak existuje taký Vlejdov ťah, že bezohľadu na to aký ťah vzápätí spraví John, Vlejd nakoniec vyhrá, spraví ho.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$, počet kartičiek $(1 \\leq n \\leq 10^5)$. Na druhom riadku je $n$ čísel $a_1, a_2, \\dots, a_n (1 \\leq a_i \\leq 10^5)$, kde $a_i$ je číslo na $i$-tej kartičke.

## Formát výstupu

Na výstup vypíšte jedno slovo ukončené novým riadkom, a to 'Vlejd' ak Vlejd môže vyhrať a 'John' ak Vlejd nemôže vyhrať.

## Príklady

```vstup
5
1 3 2 1 4
```

```vystup
Vlejd
```

_Vlejd zoberie kartičku $4$ a s ňou aj všetky ostatné._

```vstup
4
3 3 3 3
```

```vystup
John
```

_V tejto hre Vlejd nemal na výber._

```vstup
1
100000
```

```vystup
Vlejd
```
","# Ukladanie kartičiek

Našou úlohou bolo zistiť pre daný vstup, či existuje výherná stratégia pre prvého hráča. Teda či počnúc prvým ťahom, bez ohľadu na to ako zareaguje John, môže Vlejd spraviť taký ťah že Johna dostane do situácie, z ktorej nemôže vyhrať (ak bude Vlejd hrať dobre).

## Kedy Vlejd vyhrá

Ak je v hre jediná kartička s najväčším číslom, je to ideálna situácia, Vlejd ju zoberie a vyhrá. Ak je ale najväčších kartičiek viac, rozlíšujeme dve situácie. Ak je kartičiek nepárny počet, Vlejd opäť zoberie prvú z nich a ďalej budú striedavo brať po jednej kartičke, až zoberie poslednú (John zase nemá na výber ani v jednom ťahu).

Problém nastane ak ich je párny počet. Vtedy Vlejd potrebuje aby prvú z nich zobral John. Znamená to teda že Vlejd je nútený zobrať nejakú z menších kartičiek, aby hneď neprehral. Musí si však dať pozor, aby sa nedostal do situácie, kedy mu John zoberie poslednú menšiu kartičku a on už bude nútený zobrať prvú z najväčších kariet. Jeho cieľom je teda opäť zobrať poslednú kartu, ale teraz zo všetkých okrem najväčších. Dostali sme sa ku problému, ktorý sme už vyššie vyriešili.

Vieme teda, že ak je najväčších kariet nepárny počet, Vlejd vyhrá. Ak je najväčších párny, ale druhých najväčších nepárny, Vlejd taktiež vyhrá. Ak by sme takto pokračovali, zistíme, že ak v postupnosti kartičiek usporiadanej od najväčšej narazíme na nejakú, ktorej je nepárny počet, Vlejd určite vyhrá.

Pozrime sa, ako by teda prebiehala nejaká hra: Karty: 1 2 2 3 3 3 4 4 5 5 5 5 Vlejd: 3 Karty: 3 3 4 4 5 5 5 5 John: ?

Vlejd sa pozrel na kartičky a najväčšia, ktorej je nepárny počet, bola trojka, tak ju zobral. Po takomto ťahu Johnovi ostala každá karta v párnom počte, a neostáva mu nič iné ako to zmeniť a dať Vlejdovi opäť víťaznú pozíciu. Ďalej Vlejdovi stačí ťahať to isté, čo potiahne John.

## Vyhrávajúca a prehrávajúca pozícia

Kartičky, ktoré ostávajú na stole budeme volať pozícia v hre. Ak je teda na stole len jedna najväčšia kartička, hráč, ktorý je na ťahu, môže vyhrať, a teda je vo vyhrávajúcej pozícii. Ak sú na stole len dve rovnaké kartičky a nič iné, hráč na ťahu je v prehrávajúcej pozícii, lebo nech by spravil čokoľvek, protihráč sa dostane do výhernej pozície.

Z popisu vyššie môžeme vidieť, že pozícia, v ktorej je každá kartička v párnom počte, je prehrávajúca. Všetky ostatné -- teda pozície, v ktorých je *nejaká* kartička v nepárnom počte -- sú vyhrávajúce.

## Riešenie

Potrebujeme zistiť, či je úvodná pozícia vyhrávajúca -- teda či sa na vstupe nachádza aspoň jedno číslo nepárny počet krát. Existuje niekoľko spôsobov ako niečo takéto naprogramovať.

Jeden spôsob je, že si čísla zoradíme od najmenšieho po najväčšie, a budeme počítať, koľko rovnakých je za sebou. Takéto riešenie dostane plný počet bodov, existuje však o niečo krajšie riešenie:

Vyrobíme si dosť veľké pole a na $i$-tom políčku si budeme pamätať, koľko krát bolo na vstupe číslo $i$. Takýto postup sa volá tiež [*Counting sort*](https://sk.wikipedia.org/wiki/Counting_sort), ale môžeme si ho dovoliť len vtedy, keď sa nám *dosť veľké pole* zmestí do pamäte, teda keď rozsah čísel na kartičkách je dosť malý. Toto riešenie má časovú zložitosť $O(n)$, pretože iba raz prejdeme naše vstupné pole. Pamäťová zložitosť je taktiež $O(n)$, kde $n$ je najväčšie možné číslo kartičky na vstupe.

Je zaujímave uvedomiť si, že počet výskytov čísla si v skutočnosti nemusíme pamätať. Zaujíma nás iba, či sa dané číslo vyskytuje na vstupe párny alebo nepárny počet krát. Takúto hodnotu si môžeme uložiť ako $True/False$ a keď príde nový výskyt daného čísla, iba hodnotu na pozícií tohoto čísla znegujeme -- párny počet sa zmení na nepárny a naopak. Je dôležité si uvedomiť, že toto nám zmenší množstvo pamäte, ktorá bude použitá, ale asymptotická pamäťová zložitosť bude stále $O(n)$, teda lineárna.
",2
062b44c4102aad75,ksp,"# A čo tak viac Torty?

Určite si pamätáte úlohu Organizácia Kapustnice z minulej série. Keď ju Kristína úspešne vyriešila na plný počet hneď sa išla svojím riešením pochváliť svojej sestričke Janke. Vysvetľovala jej ho na príklade zo zadania. Tá sa jej však začala pýtať veľa rôznych otázok: a čo keby v tomto reťazci bolo tuto `T` namiesto `V`? Ako by sa zmenilo riešenie keby sme uvažovali len tento podreťazec? Čo keby sme tu pridali `V` ako 3tie písmenko? Čo keby sme tu zobrali tento podreťazec a zrkadlovo ho otočili?

## Úloha

Naštudujte si úlohu [Organizácia Kapustnice](https://www.ksp.sk/ulohy/zadania/2387/) z minulej série. V nej začneme so stolom s vedúcimi a tortami -- reprezentovaný reťazcom z písmen 'T' - reprezentujúce tortu, a 'V' -- reprezentujúce vedúceho. Vedúci sa hýbu zľava doprava, zoberú prvú tortu ku ktorej prídu a odídu z radu. Chceme doniesť do radu niekoľko vedúcich a/alebo tort, tak aby každá torta bola zjedená, a každý vedúci mal presne jednu tortu, a to tak, aby výsledný rad (počet vedúcich + počet tort) bol čo najmenší. Práve dĺžka najmenšieho radu ktorý vieme dostať, je čo nás zaujíma.

Navyše, chceme vedieť, ako sa táto hodnota mení, ak zmeníme rad vedúcich a tort. Na vstupe bude postupne $q$ z nasledovných požiadaviek:

1. `vysledok a b` - vypíšte najmenšiu dosiahnuteľnú dĺžku opraveného radu, ak nás zaujíma rad medzi reprezentovaný tortami/vedúcimi medzi indexami $a$ a $b$ -- vrátane. (Indexy číslujeme od 0.) Napriklad ak je momentálne stav radu `VVTVTTVV` a chceme vyhodnotiť operáciu `vysledok 1 5`, tak program vypíše 6, pretože to je dĺžka správneho výsledku úlohy keď sa uvažuje podreťazec `VTVTT` začínajúci na indexe $1$ a končiaci na indexe $5$.

1. `vymen a z` - zmeňte znak na pozícii $a$ na znak `z`. `z` je buď 'V' alebo 'T'. Napríklad reťazec `VVTVTTVV` sa operáciou `vymen 1 T` zmení na `VTTVTTVV`.

1. `pridaj a z` - pridaj na $a$-te miesto radu (teda po $a$ miestach v rade) bude pridaný znak `z` (vedúci ak je to 'V', torta ak 'T'). Napríklad reťazec `VTTVTTVV` sa operáciou `pridaj 2 V` zmení na `VTVTVTTVV`.

1. `zmaz a b` - z radu odstránime všetkých vedúcich/všetky torty medzi indexami $a$ a $b$ (vrátane). Napríklad reťazec `VTVTVTTVV` sa operáciou `zmaz 5 6` zmení na `VTVTVVV`.

1. `reverzni a b` - zrkadlovo obrátime časť radu medzi indexami $a$ a $b$. Napríklad reťazec `VTVTVVV` sa operáciou `reverzni 1 4` zmení na `VVTVTVV`.

## Vstup

V prvom riadku vstupu sú dve čísla: Počet znakov v počiatočnom reťazci $1 \\le n \\le 10^5$ a počet operácii $0 \\le q \\le 10^5$. Na druhom riadku vstupu sa nachádza počiatočný stav radu $r$. Nasledujúcich $q$ riadkov popisuje operácie. Každý z týchto riadkov obsahuje jedno z nasledujúcich:

1. `vysledok a b` kde $0 \\le a \\le b$ a $b$ je menej ako dĺžka reťazca vytvoreného predchádzajúcimi operáciami

1. `vymen a z` kde $0 \\le a$, $z\\in{V, T}$ a $a$ je menej ako dĺžka reťazca vytvoreného predchádzajúcimi operáciami

1. `pridaj a z` kde $0 \\le a$, $z\\in{V, T}$ a $a$ nepresiahne dĺžku reťazca vytvoreného predchádzajúcimi operáciami

1. `zmaz a b` kde $0 \\le a \\le b$ a $b$ je menej ako dĺžka reťazca vytvoreného predchádzajúcimi operáciami

1. `reverzni a b` kde $0 \\le a \\le b$ a $b$ je menej ako dĺžka reťazca vytvoreného predchádzajúcimi operáciami

## Výstup:

Pre každú operáciu `vysledok a b` vypíšte jedno číslo: najmenšiu možnú dĺžku na ktorú možno ""opraviť"" podreťazec radu medzi indexami $a$ a $b$ (vrátane).

## Bodovanie

Existuje 8 testovacích sád.

- V prvej sade počet operácii $q \\le 100$ a dĺžka reťazca neprekročí 100.

- V druhej sade bude používaná iba operácia `vysledok` na celom vstupe, a operácia `pridaj` ale nové torty/vedúci sú pridané iba na koniec radu

- V tretej sade bude používaná iba operácia `vysledok` ale na ľubovolnom podintervale.

- V sadách 4, 5 budú používané iba operácie `vymen` a `vysledok`.

- V sade 6 budú požívané iba operácie `vymen`, `vysledok`, `pridaj`.

- V sade 7 budú používané operácie `vymen`, `vysledok`, `pridaj` a `zmaz`.

- V sade 8 budú používané všetky operácie.

## Príklad

```vstup
8 9
VVTVTTVV
vysledok 1 5
vymen 1 T
vysledok 1 5
pridaj 2 V
vysledok 1 5
zmaz 5 6
vysledok 1 5
reverzni 1 4
vysledok 1 5
```

```vystup
6
8
6
8
6
```

- _Prvá otázka sa pýta na najlepšie opravenie (pod)radu VTVTT. Z riešenia [Organizácie Kapustnice](https://www.ksp.sk/ulohy/zadania/2387/) vieme, že výsledok je 6._
- _Po druhej požiadavke bude rad VTTVTTVV._
- _Tretia otázka sa pýta na opravenie radu TTVTT, z ktorého najlepšie vieme spraviť napríklad *VVV*TTVTT._
- _Po štvrtej požiadavke bude rad VTVTVTTVV._
- _Piata otázka sa pýta na opravenie radu TVTVT, do ktorého stačí pridať jediného vedúceho._
- _Po šiestej požiadavke dostaneme rad VTVTVVV._
- _Siedma otázka sa pýta na podpostupnosť TVTVV._
- _Po ôsmej požiadavke dostaneme rad VVTVTVV._
- _Napokon, deviata otázka sa pýta na odpoveď pre podpostupnosť VTVTV._
","# A čo tak viac Torty? {bodypopis=12 bodyprogram=8}

Poďme sa pozrieť, ako vieme postupne riešiť jednotlivé operácie, a tak prísť ku vzorovému riešeniu. Pre jednoduchosť si predstavme, že každé `V` nahradíme $1$, a každé `T` nahradíme $-1$, a takto z reťazca dostaneme postupnosť čísel, $x_1,\\dots,x_l$, kde $l$ je aktuálna dĺžka postupnosti.

## Výsledok

Zo vzorového riešenia [Organizácie Kapustnice](https://www.ksp.sk/ulohy/zadania/2387/), vieme, že výsledok pre postupnosť $x_1, \\dots, x_l$ je

$$ l + V + \\max{\\sum\_{i=1}^l x_i + V, 0} $$

kde $V = -\\min\_{0\\leq i\\leq l}{\\sum\_{j=1}^i x_j}$ je najmenší súčet prefixu postupnosti, teda počet vedúcich, ktorý treba pridať na koniec stola.

Podobne, ak chceme vyriešiť úlohu pre podreťazec $x\_{i_z},x\_{i_z + 1}, \\dots, x\_{i_k}$, vtedy sa nám vzorec jednoducho zmení na

$$ l + V + \\max{\\sum\_{i=i_z}^{i_k} x_i + V, 0} $$

kde $$V = -\\min\_{i_z-1\\leq i\\leq i_k}{\\sum\_{j=i_z}^{i_k} x_j}$$

## Prvá sada -- malé vstupy

V prvej sade si vieme dovoliť spraviť každú operáciu v linárnom čase v závislosti od dĺžky reťazca. Každú query, ktorá nie je _vysledok_ vieme vykonať v lineárnom čase, a rovnako tak vieme aj spočítať horeuvedený vzorec. Takto dostaneme riešenie so zložitosťou $O(q(q+n))$ (keďže dĺžka reťazca nikdy nepresiahne $q+n$).

## Druhá sada -- pridávame na koniec

Ako si môžeme všimnúť, ak pridáme na koniec postupnosti novú hodnotu $x\_{l+1}\\in{1, -1}$, vieme výsledok vypočítať v konštantnom čase -- za predpokladu,, že si pamätáme pár údajov pre predchádzajúci reťazec. Menovite, ak si pamätáme

$$V_l = -\\min\_{i_z-1\\leq i\\leq i_k}{\\sum\_{j=i_z}^{i_k} x_j}$$

a

$$S_l = \\sum\_{i=1}^l x_i$$

Následne vieme tieto hodnoty updatnúť v konštantnom čase na

$$ S\_{l+1} = S_l + x\_{l+1} $$

a

$$ V\_{l+1} = -\\min{-V_l, S\_{l+1}} $$

Z týchto hodnôt už vieme v konštatnom čase zistiť výsledok pre $x_1 x_2 \\dots x_l x\_{l+1}$. Teda dostaneme riešenie v čase $O(n+q)$, a pamäti $O(n)$ riešiace druhú sadu.

## Tretia sada -- ľubovoľný podinterval

Pozrime sa teraz na tretiu sadu: máme nemenný reťazec, ale chceme vedieť vyriešiť úlohu na ľubovoľnom podintervale. Skúsenejší riešiteľ už v tomto vidí interval... čo znie ako intervaláč! A naozaj, napriek tomu, že namiesto priamočiareho minimového, alebo súčtového intervaláča, musíme vymyslieť niečo prefíkanejšie.

Chceli by sme si vedieť v intervaláči pamätať také hodnoty aby sme z nich vedeli zrekonštruovať

- súčet na danej podpostupnosti
- minimá prefixových súčtov v danej podpostupnosti

Prvú hodnotu vieme vypočítať jednoduchým súčtovým intervaláčom (pozri [https://www.ksp.sk/kucharka/intervalovy_strom/](Kuch%C3%A1rku)). Čo s druhou hodnotou? Základná myšlienka je, že ak vieme súčet na nejakej podpostupnosti $x\_{i_1}\\dots x\_{i_2}$ (označme ho $s$), a taktiež navyše vieme minimá prefixových súčtov na podpostupnosti $x\_{i_1}\\dots x\_{i_2}$ a $x\_{i_2}+1, \\dots, x\_{i_3}$ (označme ich postupne $v_1$ a $v_2$), potom minimum prefixových súčtov na podpostupnosti $x\_{i_1}, \\dots, x\_{i_2},\\dots,x\_{i_3}$ je minimum z $v_1$ a $v_2 + s$.

Na základe tejto myšlienky vieme následne skonštruovať intervalový strom, ktorý si okrem prefixových súčtov navyše pamätá v každom vrchole minimum prefixových súčtov na jeho podintervale -- vypočítať tieto hodnoty si vieme rekurzívne, na základe horeuvedeného vzorca.

Výsledok na zadanom intervale vieme získať skombinovaním údajov z $O(\\log n)$ vrcholov stromu, tak ako v klasickom intervaláči. Takto teda získame riešenie pre tretiu sadu, ktoré beží v čase $O(n+q\\log n)$ a $O(n)$ pamäti.

## Pridávame _vymeň_

Toto intervaláčové riešenie vieme jednoducho vylepšiť, aby vedelo vyriešiť aj sady 4 a 5. V nich navyše pribúda operácia _vymen_. Všimnime si, že jej pridaním sa nám stále nezmení dĺžka postupnosti. Preto by sme mohli použiť horeuvedené riešenie, ak by sme do intervaláča vedeli implementovať aj query na menenie hodnôt v postupnosti. To je štandardná intervaláčová operácia, ktorú vieme dosiahnuť aj s naším intervaláčom: súčtovú časť intervaláča vieme updatnuť ako v klasickom súčtovom intervaláči, a hodnotu prefixových miním tiež meníme len na $O(log n)$ vrcholoch ktoré idú z listu (kde je menená hodnota) do koreňa. Spočítame ju rovnakým rekurzívnym vzorčekom, ako keď sa počítali počiatočné hodnoty intervaláča.

Dostaneme teda riešenie riešiace sady 3, 4 a 5 bežiace v čase $O(n+q\\log n)$ a pamäti $O(n)$.

## Ďalšie sady -- nastupuje treap

Problém s operáciami _pridaj_ a _zmaz_ je, že intervaláč má fixné poradie prvkov, a hoci by sme teoreticky vedeli doimplementovať odoberanie a pridávanie prvkov na konci poľa (zamyslite sa :)), problém je pridávanie/vymazanie prvku na/z ľubovoľného indexu. Mohli by sme nejako náš intervaláč zovšeobecniť?

Odpoveď je áno. Predstavme si, že by sme mali binárny strom, pre ktorý platí, že každý vrchol reprezentuje pozíciu v postupnosti (nazvime ju $i$), všetky vrcholy v jeho ľavom podstrome (ak existuje) sú pozície _pred_ $i$ a všetky pozície v pravom podstrome (ak existuje) sú _za_ $i$. Napríklad, pre vstup zo zadania by mohol strom vyzerať nasledovne.

Všimnime si, že pre takýto strom vieme rovnako ako pre intervaláč vypočítať v každom vrchole hodnoty súčtu jeho intervalu a minimum prefixových súčtov na jeho intervale, a následne vieme zistiť hodnotu na nejakom v intervale v čase lineárnom od _hĺbky stromu_ (podobne ako v intervaláči, rozmyslite si to).

Problém je práve s hĺbkou tohto stromu (a pridávaním a zmazaním). Potrebovali by sme taký strom, kde je hĺbka približne logaritmická a navyše vieme horeuvedené operácie vykonávať dostatočne rýchlo. Ako odpoveď nám príde _treap_.

### Treap

Treap je, ako názov napovedá, strom (tree) aj [https://www.ksp.sk/kucharka/halda/](halda) (heap) zároveň. Predstavme si, že pre každú pozíciu si náhodne vygenerujeme jej _prioritu_, a v strome budeme udržiavať pravidlo, že v každom podstrome má najväčšiu prioritu jeho vrchol. Dá sa ukázať, že pre dané poradie vrcholov (ako v strome opísanom vyššie) a prioritu vrcholov, existuje práve jeden tvar, ktorý strom musí mať, a zároveň, ak priority vyberáme náhodne, bude hĺbka stromu $O(\\log V)$ kde $V$ je počet vrcholov.

Mohli by sme sa teraz zastaviť a spýtať sa ""počkať, ale prečo práve treap? Je to jediné riešenie?"", a odpoveď je: nie, ale je pomerne príjemný na implementáciu, ako môžete vidieť v \[https://www.ksp.sk/kucharka/treap/\](tomto návode z kuchárky).

Môžete si všimnúť, že síce väčšina implementácií treapov ktoré nájdete (napríklad v kuchárke) používa treap ako binárny vyhľadávací strom, kde sú prvky zoradené od najmenšieho po najväčší. V našom prípade však prvky chceme mať zoradené podľa poradia v postupnosti. Na to však netreba robiť veľké zmeny. Stačí keď pri vyhľadávaní konkrétneho prvku sa algoritmus nebude rozhodovať na základe toho či je väčší ako $x$ ale či je pred ním aspoň $k$ prvkov.

Hlavné dve funkcie treapu (pomocou ktorých vieme už v princípe všetko ostatné potrebné implementovať), ako v kuchárke môžte vidieť sú _split_ a _merge_. V [https://www.ksp.sk/kucharka/treap/](kuch%C3%A1rke) nájdete ako tieto funkcie implementovať, ale my si tu v skratke opíšeme čo robia a ako ich použiť na implementáciu _pridaj_ a _zmaz_.

#### Split

Prvou z nich je _split_, ktorá zoberie treap a číslo $0 \\leq k$ a vráti dva treapy: prvý obsahujúci prvých $k$ pozícií vstupného treapu, a druhý obsahujúci ostatné pozície. (Na obrázku $p$ označuje prioritu vrcholu.)

Split vieme naprogramovať jednoduchou rekurzívnou funkciou (ako tiež možno vidieť v kuchárke) zobrazenou na nasledovnom pseudokóde.

```
Split(T, k):
    Ak k = 0, vráť (prázdny treap, T)
    Ak veľkosť(T) je najviac $k$, vráť (T, prázdny treap)
    Ak veľkosť(T -> prvý syn) je najviac k
        T1, T2 je výsledok z Split(T -> prvý syn, k)
	    Vymeň prvého syna stromu T za T2 a vráť (T1, modifikovaný T)
    Ak veľkosť(T -> prvý syn) je viac ako k,
	    T1, T2 je výsledok z Split(T -> druhý syn, k - 1 - (veľkosť(T -> prvý syn))
	    Vymeň druhého syna stromu T za T1 a vráť (modifikovaný T, T2)
```

Všimnime si, že si chceme okrem informácií o súčtoch a miním prefixových súčtov pre jednotlivé podstromy navyše udržovať informáciu o veľkostiach jednotlivých podstromov. Keďže pri funkcii split sa mení najviac ""hĺbka stromu""^[o ktorej vieme očakávať že je $O(\\log V)$ ak priority volíme náhodne] podstromov, a preto nám stačí tieto informácie (nápodobne ako pri intervaláči) zmeniť len raz v každej vrstve rekurzie funkcie.

#### Merge

Druhá funkcia na ktorej treap stojí je _merge_. Tá zoberie na vstupe dva treapy (reprezentujúce dve postupnosti) a vráti jeden treap reprezentujúci zreťazenie ich postupností. Príklad tejto operácie vidíme na nasledovnom obrázku.

Vieme ju, podobne ako _split_ naprogramovať pomocou jednoduchej rekurzívnej funkcie, ako vidíme na nasledovnom pseudokóde.

```
Merge(T1, T2)
    Ak T1 je prázdny treap, vráť T2. Ak je T2 prázdny treap, vráť T1.
    Ak priorita(T1) > priorita(T2)
	    Vymeň druhého syna T1 za výsledok Merge(T1 -> druhý syn, T2) a vráť modifikovaný T1
    Inak, vymeň prvého syna T2 za výsledok Merge(T1, T2 -> prvý syn) a vráť modifikovaný T2
```

Všimnite si, že podobne ako pri _split_, aj počet rekurzívnych volaní pri _merge_ nepresiahne hĺbky $T1$ a $T2$, a teda najviac toľkým podstromom treba aktualizovať hodnoty.

### Ako to teda vyriešiť?

Poďme si to celé dať dokopy. Pre každý vrchol v treape si chceme pamätať nasledovné informácie:

- Priorita (náhodne vygenerovaná)
- Prvok postupnosti na pozícii odpovedajúcej vrcholu
- Veľkosť podstromu
- Súčet pozícií na intervale odpovedajúcom podstromu
- Minimum z prefixových súčtov na intervale odpovedajúcom podstromu

Vždy keď sa vrchol, alebo jeho synovia zmenia, updatneme posledné tri informácie (súčet a minimum vypočítame tak, ako v intervaláči).

Pozrime sa najskôr na to, ako do existujúceho treapu, označme to T, pridať prvok $p$ na pozíciu $i$. Stačí nám použiť _split_ a _merge_, tak že si rozdelíme treap na prvky ""pred"" a ""za"" novopridaným prvkom, a následne pomocou mergu, už treap ""zlepíme"" dokopy spolu s novým prvkom. Môžeme to vidieť na nasledovnom pseudokóde:

```
T1, T2 = split(T, i)
T = merge(T1, merge(treap(p), T2))
```

kde `treap(p)` je jednoprvkový treap reprezentujúci postupnosť $p$.

Zmazanie intervalu od $z$ po $k$ (vrátane) vieme implementovať podobne, tak že si najskôr rozbijeme treap na tri treapy -- reprezentujúce pozície pred intervalom, pozície v intervale, a pozície za intervalom, a prvý a tretí zlepíme _merge_-om späť dokopy.

```
T1, T2 = split(T, z)
T2, T3 = split(T2, k - z + 1)
T = merge(T1, T3)
```

Aby sme nezabudli na query _zmen_, tú vieme implementovať buď cez skombinovanie _zmaz_ a _pridaj_, alebo priamo rekurzívnou funkciou -- podobne ako update v intervaláči, ktorú nechávame ako úlohu na zamyslenie.

No, a na koniec, keď dostaneme počiatočný reťazec, vieme z neho vytvoriť treap napríklad pomocou $n$ operácií _pridaj_ na koniec.

Časová zložitosť je $O((n + q)\\log (n + q))$^[s dostatočne veľkou pravdepodobnosťou, ak priority naozaj generujete dostatočne náhodne], a pamäť nám stačí $O(n)$.

## Plný počet bodov -- nebojte sa lenivého treapu

V poslednej sade nám prišla posledná z operácií _reverzni_. Táto operácia vyzerá na prvý pohľad zákerne, ale našťastie, ukáže sa, že na ňu stačí treap a nemusíme vymýšľať divokejšie dátové štruktúry.

S predpokladom, že ideme upravovať nejaký treap, poďme sa najskôr zamyslieť, ako sa nám zmení výsledok pre nejaký interval, ak ho celý reverzneme. Ako sme si už predtým všimli, ak nejaký interval rozdelíme na podintervaly, ak vieme pre ne hodnoty súčtov a miním prefixových súčtov, vieme z toho poskladať výsledok na celom intervale. Konkrétne sa pozreme na jeho nový súčet a minimum prefixových súčtov.

Súčet, prirodzene, ostáva ten istý. Zato nové minimum prefixových súčtov bude minimum _sufixových súčtov_^[skoro prefixové súčty, ale odzadu]. Síce ich nevieme spočítať priamo z minima prefixových súčtov, všimnite si, že podobne ako minimá prefixových súčtov, ich vieme ""poskladať"" zo súčtov, a miním sufixových súčtov pre postupnosť.

Konkrétne, ak vieme že postupnost $x\_{i_1}, \\dots, x\_{i_2}$ má súčet $s_1$ a minimum sufixových súčtov $S_1$, a postupnosť $x\_{i_2+1},\\dots,x\_{i_3}$ má súčet $s_2$ a minimum sufixových súčtov $S_2$, potom je minimum sufixových súčtov postupnost $x\_{i_1}, \\dots x\_{i_2}, x\_{i_2+1}, \\dots x\_{i_3}$ rovné $\\min(S_2, s_2 + S_1)$.

Mohli by sme si teda v každom vrchole aj zapamätať _minimum sufixových súčtov na príslušnom intervale_.

Teraz vieme, ako sa nám mení výsledok pre obrátený interval, tak poďme sa zamyslieť nad tým, ako by sme mohli obrátiť (pre začiatok) _celý_ treap. Pozrime sa na príklad reverzu. Pre prehľadnosť sme aj reverznutému stromu ponechali pôvodné indexy v postupnosti

Všimnite si, že reverznutý treap je vlastne zrkadlový obraz pôvodného. Vieme ho tak dosiahnuť tak, že v každom podstrome vymeníme prvého a druhého syna, ako ilustruje nasledujúci obrázok.

Vedeli by sme teda, rekurzívne otočiť celý strom (a vždy tiež vymeniť hodnotu miním sufixových a prefixových súčtov) v lineárnom čase od jeho veľkosti. To je však príliš pomalé.

Odpoveďou je lenivosť -- nemeňme veci, kým nemusíme. Namiesto toho aby sme otáčali celý strom naraz, zaznačme si, v jeho koreni, že ho chceme otočiť. Keď sa do koreňa nabudúce pozrieme, otočíme jeho synov a vymeníme hodnoty prefixových a sufixových súčtov, a zaznačíme si do synov, že keď do nich nabudúce prídeme, majú byť otočení. Nápodobne, vždy keď dôjdeme do vrcholu v ktorom máme zaznačené, že ho treba otočiť^[zvyčajne sa to označuje ako ""lazy flag""], mu vymeníme deti a príslušné hodnoty miním a deti (ak nejaké má) označíme lazy flagom, že ich treba tiež otočiť. Všimnite si, že takto vždy odpovieme správnu hodnotu (keďže nepotrebujeme otáčať celý strom, aby sme získali hodnotu pre otočený podstrom), a zároveň nám to zaberie najviac konštatne-krát viac operácií (otočíme hodnoty v jednom vrchole len vtedy keby sme s ním aj tak interagovali).^\[Celý prístup je podobný ako v lazy-propagácii intervalového stromu, viď [https://www.ksp.sk/kucharka/lazy_intervalovy_strom/](kuch%C3%A1rku)\].

A čo s tým, keď nemáme celý treap, ale chceme iba otočiť jeho časť? Vieme použiť naše nápomocné funkcie _split_ a _merge_ -- interval, ktorý chceme otočiť ""vysekneme"" z treapu pomocou _splitu_, označíme jeho koreň, že ho bude treba otočiť, a pomocou _merge_ zlepíme strom nanovo, ako je zobrazené na nasledujúcom pseudokóde na otočenie intervalu medzi $z$ a $k$ (vrátane).

```
T1, T2 = split(T, z)
T2, T3 = split(T2, k - z + 1)
T2 -> otočiť = true
T = merge(T1, merge(T2, T3))
```

Pozor si treba dávať na to, že do funkcií _split_ a _merge_ treba implementovať, aby otočili podstrom(y) do ktorého/ých sa funkcia pozerá, ak sú označné na otočenie.

Takto dostaneme vzorové riešenie v rovnakom čase aj pamäti ako aj riešenie bez reverzu.

Záverečná otázka na zamyslenie: vedeli by sme funkciu _reverzni_ implementovať v intervalovom strome?
",10
0ec96398a2a2ae1c,ksp,"# Obsadenie toboganov plavčíkmi

Za mestom vznikol nový aquapark. Hore na kopci sú štartovacie stanovištia a dole sú veľké bazény. Zo stanovíšť do bazénov vedú tobogany, na ktorých sa radostne šmýkajú deti. Občas, keď sa plavčík nepozerá, deti skúšajú všelijaké vylomeniny, spúšťajú sa dolu hlavou, po trojiciach, alebo brzdia, keď nemajú. Inokedy ani plavčík nepomôže, niektoré deti robia hlúposti len vtedy, keď ich plavčík vidí lebo je to vraj viac cool a väčšia pocta.

Samozrejme, keď deti skúšajú nezbedy, stávajú sa úrazy a to nerobí aquaparku dobrú povesť. Prevádzkovatelia aquaparku by radi vedeli, aká je celková bezpečnosť aquaparku počas jednej sezóny.

Na každé stanovisko a ku každému bazénu môžme aj nemusíme posadiť plavčíka. Rozloženie plavčíkov sa každú chvíľu mení, až sa postupne vystriedajú úplne všetky možnosti. Bezpečnosť jedného toboganu závisí len od toho, či na jeho hornom a dolnom konci sedí plavčík. Bezpečnosť aquaparku v konkrétnom okamihu je súčin bezpečností všetkých toboganov v tom okamihu.

## Úloha

Máte zadaný bipartitný graf,^[To je taký graf, ktorého vrcholy sa dajú rozdeliť na dve časti (partície) tak, aby v rámci jednej časti neviedli žiadne hrany. V našom prípadne jednu partíciu tvoria štarty toboganov a druhú partíciu bazény. Tobogan vždy vedie medzi bazénom a stanovišťom. Tiež sa dá všimnúť, že bipartitné grafy sú práve tie grafy, ktoré neobsahujú cykly nepárnej dĺžky.] ktorý predstavuje náš aquapark. Hrany tohto grafu sú tobogany. Vrcholy tohto grafu sú bazény a štartovacie stanovištia a každý vrchol ofarbíme jednou z dvoch farieb -- čiernou, ak vo vrchole sedí plavčík, a bielou, ak nesedí. Počet vrcholov označíme $n$ a počet hrán $m$.

Pre každú hranu $e$ vedúcu medzi vrcholmi $u_e$ a $v_e$ poznáme 4 hodnoty $b\_{e00}$, $b\_{e01}$, $b\_{e10}$ a $b\_{e11}$, ktoré určujú, aká je bezpečnosť príslušnej hany podľa farieb jej koncových vrcholov.

- $b\_{e00}$ je bezpečnosť hrany $e$, ak sú oba vrcholy $u_e$, $v_e$ biele.
- $b\_{e01}$ je bezpečnosť hrany $e$, ak je vrchol $u_e$ biely a $v_e$ čierny.
- $b\_{e10}$ je bezpečnosť hrany $e$, ak je vrchol $u_e$ čierny a $v_e$ biely.
- $b\_{e11}$ je bezpečnosť hrany $e$, ak sú oba vrcholy $u_e$, $v_e$ čierne.

Všimnite si, že nehovoríme nič o tom, ktorý z vrcholov $u$, $v$ je začiatok toboganu a ktorý koniec.

Pozrime sa na všetkých $2^n$ ofarbení grafu (pre všetky možnosti ako rozmiestniť plavčíkov) a pre každé ofarbenie vypočítajme súčin bezpečností všetkých $m$ hrán. Keď tieto súčiny sčítame, dostaneme celkovú bezpečnosť aquaparku počas sezóny.

Vypočítajte túto celkovú bezpečnosť modulo $10^9+7$.

## Formát vstupu

Na prvom riadku vstupu sú čísla $n$ a $m$, ($2\\leq n\\leq 40$, $1\\leq m\\leq 100$). Vrcholy očíslujeme postupne $1$ až $n$.

Nasleduje $m$ riadkov a na každom je $6$ čísel $u_e$, $v_e$, $b\_{e00}$,$b\_{e01}$,$b\_{e10}$,$b\_{e11}$ popisujúcich jednu hranu ($1\\leq u_e,v_e\\leq n$, $0\\leq b\_{eij}\\leq 10^9$).

Čiastočné body sa budú dať získať aj za riešenia, ktoré zvládajú len malé $n,m$, prípadne malé hodnoty $b$. Budú aj vstupy, v ktorých je celková bezpečnosť pomerne malá.

## Formát výstupu

Vypíšte jedno celé číslo -- celkovú bezpečnosť lunaparku počas sezóny modulo $1,000,000,007$.

## Príklady

```vstup
2 1
1 2 1 2 3 4
```

```vystup
10
```

```vstup
3 2
1 2 1 0 0 1
2 3 1 0 0 1
```

```vystup
2
```
","# Obsadenie toboganov plavčíkmi

Ľahko by sme napísali program, ktorý by vyskúšal všetky možné ofarbenia (tých je $2^n$), pre každé ofarbenie by sme len cyklom prešli hrany, vynásobili bezpečnosti a na konci to celé sčítali.

Tento algoritmus by bol príliš pomalý, pretože $2^{40}$ je dosť veľa (približne tisíc miliárd) a to ešte treba zakaždým prechádzať hrany.

To, čo by sme však zvládli je skúšať $2^{20}$ možností, to je predsa len milión. Ale čoho je najviac $n/2$? No predsa vrcholov v menšej polovici vrcholov^[Namiesto menšej polovice sme mali napísať menšiu partíciu ale bolo by to zrozumiteľnejšie?].

\\medskip

Dôležitá informácia v zadaní bola, že graf je bipartitný. To znamená, že jeho vrcholy sa dajú rozdeliť do dvoch množín $A$, $B$ tak, aby medzi žiadnymi vrcholmi v $A$ neviedla hrana a tiež medzi žiadnymi vrcholmi v $B$ neviedla hrana (hrany teda idú len z $A$ do $B$ a naopak). Tieto množiny voláme partície.

Tým pádom vrcholy v jednej partícii (napríklad v $B$) sú navzájom nezávislé. Keď zmeníme farbu vrchola $x$ z $B$, tak to nijako neovplyvní bezpečnosti hrán, ani súčiny bezpečností pri iných vrcholoch z $B$.

Predstavme si, že nejako zafixujeme farby všetkých vrcholov v $A$, napríklad nech sú všetky biele. Potom sa môžeme zaujímať, aká je čiastočná odpoveď pre takéto ofarbenia, teda súčet celkových bezpečností, pre ktoré sú všetky vrcholy z $A$ biele. Toto číslo označíme $G(B)$. Keby sme z grafu zahodili všetky vrcholy z partície $B$ aj s ich hranami a nechali len jeden vrchol $x$, mohli by sme nazvať čiastočnú odpoveď pre tento vrchol $G({x})$.

Túto hodnotu vieme vypočítať pomerne ľahko, buď je $x$ biely (vtedy dostaneme nejaký súčin hodnôt hrán $w\_{xb}$), alebo je $x$ čierny (a dostaneme súčin $w\_{xc}$). $G({x}) = w\_{xb} + w\_{xc}$.

Po úvahách o nezávislosti zistíme, že $G(B) = G({x_1})\\cdot G({x_2})\\cdot \\ldots \\cdot G({x_b})$, teda súčin čiastkových hodnôt pre všetky vrcholy z $B$. Môžete si aj sami rozmyslieť, prečo je to tak.

Tým pádom, pre jedno konkrétne ofarbenie $A$ vieme rýchlym prechodom cez všetky vrcholy $B$ zistiť $G(B)$ pre dané $A$. Tieto hodnoty stačí sčítať pre všetky možné ofarbenia množiny $A$.

Pred týmto počítaním ešte musíme rozdeliť graf na partície a nezabudnúť pomenovať $A$ tu menšiu z nich. Na rozdelenie postačí DFS prechod.

Celková časová zložitosť bude $O(2^{n/2}(n+m))$. Pre veľké $n$ je $2^{n/2}$ je oveľa, oveľa menšie ako $2^n$, takže robiť optimalizáciu, ktorá by nám toto zabezpečila má zmysel.
",9
087a4f93b9c52697,ksp,"# Atypické zasadnutie

Predseda Kúl Spolku Pandemiológov sa v rámci aktuálnej krízy rozhodol zvolať zasadnutie odborníkov zo všetkých krajov. Takéto zasadnutie je veľmi prestížne a prirodzene tak má určité absurdné pravidlá. Jedno z nich je napríklad to, že sa zasadá vždy výlučne za okrúhlim stolom a každý kraj má pri danom stole svoje pevne stanovené miesto. Preto každý, kto si sadne na miesto daného kraju, musí rozprávať iba o tom konkrétnom kraji. Každý odborník, ktorý sedí na mieste svojho kraju je tak výrazne efektívnejší ako keď sedí na mieste iného kraju o ktorom nič nevie.

Odborníci sú tvrdohlavé stvorenia a za stôl si sadajú v poradí, v ktorom prišli do miestnosti a odmietajú si presadnúť. Predseda avšak potrebuje presné informácie z čo najviac krajov a tie mu vie dať iba odborník z daného kraja. Jedinou možnosťou ako tento stav dosiahnuť, je otočiť stôl o niekoľko miest do ktorejkoľvek strany tak, aby čo najviac odborníkov sedelo na svojom mieste. A keďže stôl je veľmi ťažký, ideálne ho chce otočiť o čo najmenej miest.

## Úloha

Tvojou úlohou je pomôcť predsedovi určiť o koľko najmenej miest treba otočiť okrúhly stôl tak, aby čo najviac odborníkov sedelo na svojom mieste. Predsedu taktiež zaujíma koľko odborníkov tak bude sedieť na svojom mieste. Odborníci si sadajú za stôl v poradí v akom prišli, odborník $n_i$ si tak vždy sadne na pozíciu $i$. Odborník sedí na svojom mieste vtedy, ak je z kraja $i$ a zároveň sedi na mieste $i$ pri stole. Stôl je možné otočiť do oboch strán.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $n$, ($1 \\leq n \\leq 10^6$), ktoré označuje počet krajov z ktorých prichádzajú jednotlivý odborníci. Na druhom riadku sa nachádza $n$ čísiel $n_i$, ($1 \\leq n_i \\leq n$) označujúcich kraj z ktorého pochádza $i$-ty oborník. Každé čislo od $1$ po $n$ sa na vstupe nachádza práve raz.

## Formát výstupu

Na výstup vypíš dve čísla, $k$ - posun stola, $t$ - počet odborníkov na svojom mieste, tak aby čo najviac odborníkov sedelo na svojom mieste.

## Príklady

```vstup
5
3 4 5 2 1
```

```vystup
2 3
```

*Ak otočíme stôl o dve miesta, odborníci 3, 4 a 5 budú sedieť na svojom mieste.*

```vstup
4
4 1 2 3
```

```vystup
1 4
```

*Prvý prišiel odborník zo štvrtého kraja, následne už prišli odborníci po poradí. Stôl nám tak stačí otočiť o jedno miesto aby všetci odborníci sedeli na mieste so správnym číslom.*

```vstup
4
2 3 4 1
```

```vystup
1 4
```

*Podobne ako pri predchádzajpcom príklade nám stačí otočiť stôl iba o jedno miesto, tento krát avšak do druhej strany.*
","# Atypické zasadnutie

## Riešenie hrubou silou

Prvé riešenie, ktoré si ukážeme, využíva jednoduchý prístup, kedy si pre každý možný posun stola spočítame, koľko ľudí bude sedieť na správnom mieste. Toto vieme spraviť jednoducho, stačí ak ku každému odborníkovi $n_i$ pripočítame otočenie stola $j$. Ak sa následne $n_i + j$ rovná $i$, vieme, že odborník sedí na správnom mieste. Úlohou je taktiež otočiť stôl o čo najmenej pozícií. Preto v prípade, že máme $k$ otočení s rovnakým a zároveň najväčším počtom správne usadených odborníkov, musíme vybrať najmenšie otočenie do ľubovolnej strany. To vieme spraviť jednoducho. Vieme, že ak sme stôl otočili o viac ako polovicu miest, otočenie do druhej strany je efektívne. Stôl nám tak stačí otáčať iba do jednej zo strán. Stôl tak otočíme o najviac $\\lfloor \\frac{n}{2} \\rfloor$ miest.

Časová zložitosť tohto riešenia je kvadratická. Pre každú pozíciu pri stole sme museli prejsť všetkých sediacich pri stole. Keďže pozícií je $n$, rovnako ako sediacich, časová zložitosť je $O(n^2)$. Pamäťová zložitosť tohto riešenia je $O(n)$ keďže sme si potrebovali pamätať všetky pozície zo vstupu.

## Vzorové riešenie

Pri riešení hrubou silou sme si postupne pre každú pozíciu pri stole vypočítali, koľko ludí sedí na správnom mieste. Tento krok vieme zjednodušiť. Každý odborník pri stole buď sedí na svojom mieste, alebo vieme otočiť stôl práve dvoma spôsobmi tak, aby sedel na svojom mieste. Ako sme si avšak ukázali pri riešení hrubou silou, stôl nám stačí v skutočnosti otáčať iba do jednej strany. Nepotrebujeme preto pre každého odborníka uvažovať každú možnú pozíciu otočenia stola. Pre každého odborníka nám stačí vypočítať, o koľko treba otočíť stôl, ak má daný odborník sedieť na správnom mieste. Vytvoríme si tak pole veľkosti $n$, kedy pre každé otočenie stolu dostaneme počeť odborníkov sediacich na správnom mieste. Následne nám stačí iba nájsť také otočenie, ktoré má najväčší počet odborníkov na správnom mieste a zároveň otáčame stôl o čo najmenej miest do ktorejkoľvek strany.

Časová zložitosť tohto riešenia je lineárna vzhľadom na počet odborníkov $n$. Pre každého odborníka sme v konštantnom čase vypočítali otočenie stola tak, aby sedel na správnom mieste. Následne sme prešli všetky možné otočenia. Keďže odborníkov aj možných otočení je $n$, časová zložitosť je tak $O(n)$. Pamäťová zložitosť je taktiež lineárna vzhľadom na počet obdorníkov $n$. Počiatočné pozície odborníkov si pamätať nemusíme, stačí nám pamätať si pole s počtom odborníkov pre jednotlivé otočenie stolu. Keďže možných otočení je $n$, pamäťová zložitosť je $O(n)$.
",2
7bddd556de67b6de,ksp,"# Odolateľná reklama

Dopravný podnik vám prináša nový **revolučný spôsob platenia za dopravu**!!!

Kúpte si jeden z našich lístkov a **jazdite už navždy^[Platí do ukončenia akcie.] bezplatne**!!!

S $k$-zastávkovým lístkom sa môžete previezť, jednu, dve, **dokonca až $k$ zastávok**!!!

Kúpte si lístok už dnes a v cene dostanete aj vyhrievaný vankúšik, ktorý vám spríjemní čas strávený čakaním na zastávkach!!!

Reklama ťa zaujala množstvom výkričníkov. Vieš, že v nových električkách sú nové označovače lístkov so širšími otvormi a bolo treba upraviť formát lístkov. Okrem zmeny rozmeru však dopravný podnik zmenil aj typy lístkov a vymyslel aj novú, neodolateľnú marketingovú stratégiu, ktorej svedkom si, bohužiaľ, aj ty.

Keďže nemáš vodičák, používaš hromadnú dopravu. Každý deň sa cestou do školy prevezieš $n$ zastávok. Prvá zastávka je pri tvojom dome, posledná pri škole. Doteraz ti vyhovovala ročná električenka, ale tá ti práve vypršala a neostáva ti nič iné než si vybrať nejaký revolučný $k$-zastávkový lístok.

S týmto lístkom sa môžeš previezť najviac $k$ zastávok, no potom musíš vystúpiť a počkať na ďalší spoj^[Začínaš si do hĺbky uvedomovať, aký výborný nápad sú $k$-zastávkové lístky.]. Na zastávke pri dome nikdy nečakáš, lebo vieš naspamäť časy, kedy ti chodia autobusy. Na poslednej zastávke tiež nemusíš čakať a môžeš sa hneď radostne rozbehnúť do školy^[Ale komu sa chce behať, že?].

S vyhrievaným vankúšikom sa premôžeš a na zastávkach dokopy počkáš aj $t$ minút. Občas mávaš pri cestovaní spoločnosť, takže si hovoríš, že čakanie zvládneš. Preto si chceš kúpiť najlacnejší lístok, s ktorým budeš na ceste do školy čakať najviac $t$ minút. Šetríš si totiž na tú vec, ktorú si chceš už dlho kúpiť bez vedomia rodičov.

## Úloha

Trasa má dĺžku $n$ -- postupne prechádza zastávkami $1, 2, \\dots n$. Pre každú zastávku $2$ až $n-1$ dostanete počet minút, ktorý sa na danej zastávke čaká na ďalší spoj. Tiež dostanete ceny $k$-zastávkových lístkov pre $k = 1, 2, 3, \\dots , n-1$. Z ľubovoľnej zastávky s číslom $z$ sa dá s $k$-zastávkovým lístkom dostať na jednu jazdu na zastávky $z-k$ až $z+k$.

Celkovo si ochotný čakať najviac $t$ minút a chceš nájsť najlacnejší lístok, s ktorým sa dostaneš zo zastávky $1$ na zastávku $n$ s prestupovým čakaním najviac $t$.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve čísla $n$ a $t$ ($2 \\leq n \\leq 100, 000, 0 \\leq t \\leq 10^9$) -- dĺžka trasy a celkový čas, ktorý môžeš čakať na zastávkach. Na druhom riadku bude $n-1$ čísel $c_k$ ($0 \\leq c_k \\leq 10^9$) -- cena $k$-zastávkového lístka pre $k = 1, 2, 3, \\dots , n-1$. Na treťom riadku vstupu je $n-2$ čísel $t_i$ ($0 \\leq t_i \\leq 10^9$) -- časy čakania na zastávkach $2$ až $n-1$.

## Formát výstupu

Vypíšte jedno číslo -- cenu najlacnejšieho lístka, s ktorým budete čakať na zastávkach dokopy najviac $t$ minút.

## Príklad

```vstup
6 9
1 42 9 2 54
5 6 5 4
```

```vystup
2
```

_S 1- alebo 2-zastávkovým lístkom by sme čakali pridlho, s 3-zastávkovým lístkom stačí čakať 5 minút, no lacnejší je 4-zastávkový, tak zoberieme ten._
","# Odolateľná reklama

V tomto vzoráku si ukážeme viacero všeobecných techník na riešenie úloh a optimalizovanie programov. Ak sa ich naučíte, pomôžu vám vyriešiť veľa rôznych problémov.

Najprv si ukážeme _bruteforce_ riešenie. Ďalej bruteforce zoptimalizujeme pomocou _memoizácie_, prevedieme rekurziu na _dynamické programovanie_ a ukážeme si, kedy použiť _binárne vyhľadávanie_. Takto získame riešenie so zložitosťou $O(n^2 \\log n)$ hodné $5/8$ bodov s veľmi malou námahou.

Na záver ešte trošku porozmýšľame a dopracujeme sa k $O(n \\log n)$ riešeniu, v ktorom zoptimalizujeme dynamické programovanie pomocou deque.

## Riešenie hrubou silou

**Ak neviete, kde začať alebo ak ste už unavení z úvodného uvažovania, vždy je dobré začať s naprogramovaním riešenia hrubou silou** -- najjednoduchšie naprogramovateľné, funkčné riešenie, čo nám napadne -- väčšinou pomerne neefektívne. V našej úlohe takéto riešenie vyskúša pre každý lístok, či sa s ním dá cieľ dosiahnuť s čakaním menším ako $t$ a z vyhovujúcich lístkov vyberie ten najlacnejší.

Kostra programu by mohla vyzerať nasledovne:

Uvedomíme si, že **zo zastávky s číslom $x$ sa nám nikdy neoplatí vrátiť späť** (ísť na zastávku s menším číslom) a teda sa budeme hýbať len na zastávky $x+1, x+2, \\dots, x+k$.

To, či s $k$-lístkom vieme dosiahnuť cieľ, vieme zistiť jednoduchou rekurziou. Ak sme na nejakej zastávke, to či sa dá odtiaľto dostať do cieľa zistíme tak, že sa skúsime pohnúť na ďalšiu a spýtame sa, či sa odtiaľto vieme dostať do cieľa v časovom limite. Musíme ale vyskúšať všetky susedné zastávky.

Funkcia $f$ ako parameter dostane číslo zastávky $x$, odkiaľ sa chceme dostať do cieľa a zvyšný čas, ktorý máme na čakanie $t$. Vyskúša všetkých $k$ pohybov na zastávky $x+1, \\dots, x+k$ -- zavolá $f(x+1, t-t_x), \\dots, f(x+k, t-t_x)$ a vráti `True` ak sa dá do cieľa dostať z niektorej zo zastávok $x+1, \\dots, x+k$. Inak fukcia vráti `False`.

Rekurzia vyskúša každú cestu zo zastávky 1 do $n$ najviac raz a ciest je najviac toľko, koľko je všetkých podmnožín čísel $1, 2, \\dots, n$. Časovú zložitosť tohto riešenia vieme zhora odhadnúť ako $O(n^3 \\cdot 2^n)$: Pre jeden z $n$ lístkov over $2^n$ ciest. Každá cesta má najviac $n$ zastávok (je potrebných najviac $n$ volaní) a každé volanie zbehne v čase $O(k)$.

## Nepočítajme nič dvakrát 1 - Memoizácia

V predošlom riešení sa môže stať, že rekurzívnu **funkciu voláme viackrát s tými istými parametrami**. Počítame teda viackrát to isté. Tomuto sa môžeme vyhnúť, ak si budeme spočítané výsledky rekurzie pamätať. Ak potom zavoláme funkciu s tými istými parametrami, namiesto výpočtu sa len pozrieme do pamäte. Vypočítané výsledky si môžeme pamätať vo viacrozmernom poli (každý rozmer zodpovedá jednému parametru), alebo v mape, kde je kľúčom $k$-tica parametrov.

Pre každý z $n$ lístkov je počet rôznych volaní funkcie (rôznych dvojíc parametrov (zastávka, čas)) najviac $n \\cdot t$. Každé volanie trvá najviac $O(k)$ času. Pre jeden lístok zistíme $dasa(k)$ v čase $O(n \\cdot t \\cdot k)$ a teda celý náš program bude mať čas behu zhora ohraničený $O(n^3 \\cdot t)$.

Použitie memoizácie si môžete pozrieť aj v riešení úlohy z minulej série [Optimálna šifrovačka](https://www.ksp.sk/ulohy/riesenia/1098/).

## Nepočítajme nič dvakrát 2

Napriek tomu, že pre každú dvojicu parametrov voláme rekurziu len raz, ak máme spočítaný výsledok pre nejaké parametre, môžeme už vedieť výsledok pre iné: Ak vieme, že cestu stihneme so zvyšným časom $47$, cestu určite stihneme aj s hocijakým väčším zvyšným časom. Stačí nám teda zapamätať si ten najmenší čas, s ktorým sa vieme dostať do cieľa z $x$. Rôznych volaní funkcie $f$ tak už nebude $n \\cdot t$ ale len $n$.

Namiesto toho, aby sme pre dvojicu (zastávka $x$, čas $t$) počítali, len či sa dá dosiahnuť cieľ (`true/false`), budeme pre zastávku $x$ počítať, aký je **najmenší čas potrebný na dosiahnutie cieľa, keď začneme v $x$**. Toto opäť vieme rátať podobnou rekurziou ako vyššie -- pozrieme sa na najbližšie zastávky, pre ne rekurzívne spočítame hodnoty $f(x+1), f(x+2), \\dots, f(x+k)$ a vyberieme si, kam sa chceme pohnúť -- na zastávku, odkiaľ sa najskôr dostaneme do cieľa. Teda $f(x) = \\min{f(x+1), f(x+2), \\dots, f(x+k)} + t_x$ a $f(n) = 0$

Jedno volanie stále zbehne v čase $O(k)$, ale rôznych vstupov funkcie $f$ je len $O(n)$. Výpočet pre jedno $k$ teda trvá $O(n \\cdot k)$, a vďaka tomu bude celková zložitosť programu $O(n^3)$.

## Nepočítajme nič zbytočne - Binárne vyhľadávanie

Skúsme teraz zoptimalizovať inú časť programu -- skúšanie všetkých lístkov. Pri tejto úlohe je dobré si uvedomiť, že rôzne ceny lístkov sú tu hlavne na zmätenie. To podstatné je zistiť minimálne $k$ také, že vieme trasu prejsť s čakaním menším ako $t$. Ak máme minimálne $k$, na výpočet výsledku stačí nájsť najmenšiu cenu z $c_k, c\_{k+1}, \\dots, c_n$.

Ak už totiž vieme, že sa dá trasa prejsť s $k$-lístkom, určite sa bude dať prejsť aj s $k+1$-lístkom a s hocijakým lístkom s väčším dosahom. Ak sa trasa nedá prejsť s $k$-lístkom, nebude sa dať prejsť so žiadnym lístkom s menším dosahom. Výsledky funkcie $dasa(k)$ budú teda s rastúcim $k$ najskôr len `False` a od istej hranice budú len `True`.

Vieme sa teda pozrieť najskôr na $dasa(n/2)$, ak je to `False`, $k > n/2$, inak $k \\leq n/2$. Vylúčili sme polovicu možností a pokračujeme pýtaním sa na $dasa(n/4)$ alebo $dasa(3n/4)$ ... Po približne $\\log_2 n$ krokoch nám zostane jediná možnosť.

**Binárne vyhľadávanie sa dá využiť vždy, keď hľadáme hodnotu v monotónnej postupnosti** (nerastúcej alebo neklesajúcej). Vieme hľadať najľavejší výskyt aj najpravejší výskyt hodnoty. Špeciálnym prípadom sú funkcie ako $dasa()$, kde sú hodnoty `False/True`, alebo `0/1`.

Chuťovka: Pre vyhnutie sa chybám v kóde binárneho vyhľadávania môže byť vhodné použiť binárne vyhľadávanie štandardnej knižnice jazyka. V pythone sa dá dokonca zneužiť aj pre náš účel.

V našej úlohe teda $(\\log n)$-krát zavoláme funkciu $dasa()$ a dosiahneme čas $O(n^2 \\log n)$.

Toto riešenie nám umožní dosiahnuť $5/8$ bodov (riešenie v C++ určite, s týmto pythonovským kódom 4) a ani sme nemuseli veľa rozmýšľať (pokiaľ poznáte tieto všeobecné techniky, všetky predošlé úvahy dokopy vám zaberú len niekoľko minút).

## Dynamické programovanie

Vráťme sa naspäť k optimalizovaniu našej rekurzívnej funkcie $f(x)$ -- najmenší potrebný čas na dosiahnutie cieľa zo zastávky $x$. Na vypočítanie $f(x)$ sme potrebovali mať spočítané hodnoty $f(x+1), f(x+2), \\dots, f(x+k)$, a na ich spočítanie sme potrebovali mať vypočítané hodnoty až po $f(x + k + k)$, atď. Od začiatku ale vieme, že $f(n) = 0$. Na spočítanie $f(n-1)$ potrebujeme len $f(n)$, na spočítanie $f(n-2)$ len $f(n-1), f(n)$, atď.

Hodnoty $f(x)$ teda nemusíme počítať v rekurzívnej funkcii, ale stačí použiť jednoduché cykly. Vytvoríme si pole $f[]$, kde $f[x]$ označuje minimálny čas potrebný na dosiahnutie cieľa zo zastávky $x$. $f[n] = 0$ Pre znižujúce sa $x$ postupne spočítame $f[x] = \\min{f[x+1], f[x+2], \\dots, f[x+k]} + t_x$, teda presne to isté, čo počítala rekurzívna $f$.

Toto spôsobí len konštantné zrýchlenie programu, ale povedie nás to k optimálnemu riešeniu. V niektorých prípadoch dokážeme pomocou dynamického programovania aj znížiť pamäťovú zložitosť programu.

## Nepočítajme nič dvakrát, časť tretia

Ešte stále sa opakujeme? Áno: $$ f[x] = \\min{f[x+1], f[x+2], f[x+3], \\dots, f[x+k]} + t_x$$ $$ f[x+1] = \\min{f[x+2], f[x+3], \\dots, f[x+k], f[x+k+1]} + t\_{x+1}$$

Ak už vieme minimum pre $x+1, \\dots, x+k$, minimum pre $x+2, \\dots, x+k+1$ by sme mohli vedieť spočítať rýchlejšie. Totiž, ak je minimom jedno z čísel $f[x+2], f[x+3], \\dots, f[x+k]$, tak $$ \\min{f[x+2], \\dots, f[x+k+1]} = \\min{\\min{f[x+1],\\dots, f[x+k]}, f[x+k+1]}$$ a teda na spočítanie nového minima by nám stačilo jedno porovnanie (s $f[x+k+1]$).

Jediný nepríjemný prípad je, ak je $\\min{f[x+1], \\dots, f[x+k]} = f[x+1]$. Vtedy by sme potrebovali vedieť, aký bol druhý najmenší prvok z $f[x+1] \\dots, f[x+k]$

Budeme postupovať sprava doľava, tak ako doteraz a počítať hodnoty $f[x]$ -- minimálny čas potrebný na presun z $x$ do cieľa aj s časom čakania $t_x$. Chceli by sme si pamätať niekoľko zastávok, ktoré sa môžu niekedy stať minimom a vedieť tieto hodnoty aktualizovať pre $f[x-1]$.

Budeme si udržovať pozície zastávok, na ktorých je závislá hodnota $f[x]$, teda niektoré z $x+1, \\dots, x+k$ a pamätať si ich budeme usporiadané podľa ich hodnôt $f$ v štruktúre **deque** -- obojsmerný spájaný zoznam. Vieme z neho vyberať a vkladať do neho prvky z oboch strán. Nech sú naľavo tie zastávky, ktoré majú najmenšie $f$, teda tie, z ktorých sa najrýchlejšie dostaneme do cieľa.

Na začiatku algoritmu sme na zastávke $n-1$, v deque si pamätáme zastávku $n, f[n] = 0$.

Novú hodnotu $f[x]$ spočítame vždy jednoducho, ako minimálny čas, potrebný na cestu do cieľa z jednej z k zastávok napravo od $x$ a čas čakania na $x$, čo je $f[deque.left] + t_x$.

Po výpočte $f[x]$ musíme deque aktualizovať. Chceme do nej niekam vložiť zastávku $x$ (lebo hodnota $f[x]$ bude potrebná pre zastávky naľavo od $x$). Keďže žiadnu zastávku, ktorú máme v deque nebudeme vo výpočtoch používať dlhšie ako $x$, môžeme z deque vyhodiť všetky zastávky, ktoré potrebujú väčší čas na dosiahnutie cieľa -- žiadna z týchto zastávok by sa už totiž nemohla stať novým minimom. Takisto zastávky, ktoré sú ďalej ako $k$ od $x$ už nikdy nepoužijeme a potrebujeme ich odstrániť z konca aj zo začiatku deque.

Vyhodíme tak všetky nepotrebné zastávky z konca a zo začiatku a nakoniec vložíme $x$.

V tomto riešení každú zastávku najviac raz vložíme do deque a najviac raz ju vyberieme. Preto bude mať funkcia $dasa(k)$ časovú zložitosť $O(n)$. Ak použijeme binárne vyhľadávanie na nájdenie najmenšieho $k$, celý program potrebuje len čas $O(n \\log n)$.
",9
d42d100193f15ec2,ksp,"# Hádam prežijeme zimu

V lese sa už stmieva a hovniválky Timka a Gabika sa vracajú pomaly domov. Ide im to pomaly, lebo každá si pred sebou tlačí dnešný úlovok, guľku trusu. Keď prídu ku svojej skrýši, strarostlivo pridajú novú guľku do zásob na zimu. Obe majú pekne v jednom rade naskladaných pred svojou chodbou už mnoho kôpok gulôčok. Vedia, že sa blíži zima a nebudú sa tak často vídavať, preto Timka navrhla, že si navzájom darujú jednu kôpku guliek, aby na seba nezabudli. Gabika súhlasila s jednou podmienkou. Každá musí mať po tejto výmene dokopy vo všetkých svojich kôpkach párny počet guľôčok, aby si vedela zásoby rovnomerne rozdeliť na prvú a druhú polovicu zimy. Ak sa táto podmienka nedá splniť, k výmene nedôjde.

## Úloha

Na vstupe dostanete samostatne popis Gabikiných a Timkiných kôpok guľôčok. Oba z nich zapísané pomocou kladných celých čísel. Každé číslo hovorí, koľko guliek je na danej kôpke. Gabika a Timka majú rovnako veľa kôpok a navzájom si vymenia práve jednu kôpku guliek, ak každá bude mať po výmene v súčte na všetkých svojich kôpkach párny počet gulôčok. Vašou úlohou je povedať, či dôjde k výmene alebo nie.

## Formát vstupu

Na prvom riadku vstupu je celé číslo $n$ z rozsahu od $1$ po $100,000$, počet kôpok jednej hovniválky. Na druhom riadku je $n$ celých čísel z rozsahu $1$ až $10,000$, popis Gabikiných kôpok a na treťom riadku sa nachádza $n$ celých čísel z rozsahu $1$ až $10,000$, popis Timkiných kôpok. Na druhom a treťom riadku vždy $i$-te číslo v riadku hovorí, koľko guliek je na $i$-tej kôpke danej hovniválky.

## Formát výstupu

Na jeden riadok výstupu vypíšte `ano`, ak k výmene dôjde alebo `nie`, ak k výmene nedôjde.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3--4 | 5--8 | | :-------------- | ----: | -------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $100,000$ |

## Príklad

```vstup
6
1 2 3 4 5 6
5 6 7 8 9 5
```

```vystup
nie
```

_Nech si vymenia ktorúkoľvek dvojicu kôpok, nebudú mať po tejto výmene obe párny počet všetkých svojich guľôčok._

```vstup
3
2 8 64
57 20 3
```

```vystup
ano
```

_V tomto prípade k výmene dôjde, napríklad môže dať Gabika Timke kôpku s $8$-mimi guľkami a Timka Gabike kôpku s $20$-timi guľkami. Gabika bude mať po tejto výmene $2 + 20 + 64 = 86$ guliek a Timka $57 + 8 + 3 = 68$, teda obe majú párny počet guliek._
","# Hádam prežijeme zimu

## Riešenie hrubou silou

Priamočiare riešenie je prejsť všetkými výmenami, ktoré existujú a overiť, či by k nim mohlo dôjsť. Takže skúsime vymeniť každú Gabikinu kôpku guliek postupne s každou Timkinou kôpkou. Pre každú výmenu musíme overiť, či sa môže uskutočniť, teda či majú obe párny súčet všetkých svojich guličiek. Toto by sme mohli overiť tak, že pre každú výmenu sčítame počty guliek na každej kôpke postupne pre Gabiku aj Timku a tento súčet zmodulujeme dvoma. Uvedomme si, že toto vôbec nemusíme robiť, stačí nám raz spočítať zvlášť súčet Gabikiných a Timkiných guliek ešte predtým ako budeme prechádzať výmenami. Pri skúšaní konkrétnej výmeny nám potom stačí Gabike odčítať počet guliek v kôpke, čo dáva Timke a pričítať počet guliek v kôpke, ktorú dostáva od Timky. Toto číslo následne vydelíme dvoma, aby sme zistili, či má Gabika párny počet guliek. To isté spravíme s Timkiným počtom guličiek, odrátame guličky, ktoré dáva Gabike a prirátame tie, ktoré od nej dostáva a vydelíme dvoma. Ak sú oba súčty deliteľné dvoma, zistili sme, že k výmene dôjde a môžeme ukončiť skúšanie. Ak je aspoň jeden nepárny, tak musíme skušať ďalšie výmeny.

Časová zložitosť tohto riešenia je $O(n^2)$, pretože každú z $n$ Gabikiných kôpok guličiek skúsime vymeniť s $n$ Timkinými kôpkami guličiek a vrámci jednej výmeny robíme len jednoduché aritmetické operácie. V dvoch poliach si pamätáme $n$ Gabikiných a $n$ Timkiných kôpok a okrem toho iba pomocné premenné, takže pamäťová zlozitisť je $O(n)$.

## Vzorové riešenie

Na vylepšenie predchádzajúceho riešenia si musíme uvedomiť ako sa správajú párne a nepárne čísla pri súčte. Keď sčítame čísla rovnakej parity, sučet bude párny a keď sčítame čísla opačnej parity dostaneme číslo nepárne. Rovnako to platí aj pri rozdieli. Podľa týchto pravidiel vieme na základe parity súčtov všetkých guliek hovniválok povedať, kedy dôjde k výmene. Pripomeňme si ešte, čo sa stane keď príde k výmene medzi Timkou a Gabikou. Timka aj Gabika jednu kôpku darujú, teda odráta sa počet guliek, ktoré obsahovala a jednu dostanú, teda priráta sa jej počet guličiek. Poďme si teraz rozobrať možné prípady výmeny. Povedzme, že Gabika má súčet svojich guliek $g$ a Timka $t$.

Ak $g$ a $t$ sú rôznej parity, napríklad $g$ je párne a $t$ nepárne (opačný prípad sa správa rovnako), tak k výmene nedôjde. Potrebovali by sme totiž zmeniť paritu $t$. Podľa toho, čo sme si povedali na začiatku vieme, že musíme k $t$ prirátať párne číslo a odrátať nepárne alebo prirátať nepárne a odrátať párne. Ako sa pri týchto výmenách správalo $g$? Buď sme k nemu pripočítali nepárne číslo a odčítali od neho párne alebo opačne, každopádne sme zmenili jeho paritu na nepárnu.

Ak sú $g$ aj $t$ párne k výmene dôjde za istých podmienok. Oba súčty sú párne a teda im nechceme zmeniť paritu, to vieme, že sa stane ak ich zmeníme o párne číslo, teda buď pripočítame a odpočítame párne čísla alebo pripočítame a odpočítame nepárne čísla. Minimálne jeden z týchto prípadov vieme spraviť práve vtedy, keď Gabika má aspoň jednu kôpku rovnakej parity ako Timka. Inak sa výmena nemôže uskutočniť.

Ak sú $g$ a $t$ nepárne tiež môže nastať výmena. Keďže sú oba súčty nepárne potrebujeme im obom zmeniť paritu. Vieme, že nepárne číslo zmeníme na párne súčtom alebo rozdielom s nepárnym číslom. Od oboch čísel teda potrebujeme odpočítať číslo jednej parity a pripočítať k nemu číslo druhej parity. Toto v našej úlohe vieme spraviť ak má Gabika aspoň jednu kôpku s počtom guličiek rôznej parity ako aspoň jedna Timkina kôpka. Keď si vymenia túto dvojicu kôpok nastane presne tá situácia, ktorú potrebujeme. Inak k výmene nemôže dôjsť.

Celé riešenie vieme implementovať bez zapamätania si všetkých počtov guličiek na kôpkach v poli. Stačí nám si pri náčítávaní počtov guliek každej hovniválky zapamätať, či sme našli aspoň jeden párny počet, aspoň jeden nepárny počet a sčítavať celkový súčet všetkých guličiek. Pre ten následne určíme, či je párny alebo nepárny.

Už nekontrolujeme všetky výmeny, iba raz prejdeme vstupom pri jeho načítávaní, takže časová zložitosť tohto riešenia je lineárna $O(n)$ a keďže sme si ukázali, že nám netreba si pamätať vstup, iba pár premenných, tak pamäťová zložitosť je konštantná $O(1)$.
",1
6d4b65d3b55a4d95,ksp,"# Veľmi pokazená tlačiareň

Od neskorého večera do neskorého rána, tlačiaren v T2 tlačila. Mišof a Hodobox vstúpili dnu. Po chvíli skúmania zistili, že vytlačené sú iba dva druhy obrázkov. Mišofovi hneď napadlo, že by časť, alebo aj všetky obrázky mohli použiť na oblepenie stien. A tak sa s Hodoboxom zhodli, že na vyfarbenie každého obrázku použijú béžovú, ružovú a modrú. Z týchto farieb však mali obmedzený počet voskoviek, ktoré mohli použiť na vyfarbovanie obrázkov. A preto chcú zistiť, koľko najviac obrázkov dokážu vyfarbiť.

## Úloha

Mišof s Hodoboxom Vám povedali, koľko majú voskoviek jednotlivých farieb. Pre oba typy obrázka viete, koľko voskoviek ktorej farby potrebujú na jeho vyfarbenie.

Vašou úlohou je povedať, koľko najviac obrázkov Mišof a Hodobox dokážu vyfarbiť.

## Formát vstupu

Na prvom riadku vstupu sú 3 medzerou oddelené prirodzené čísla $b,,r,,m$ -- počet béžových, ružových a modrých voskoviek, ktoré majú Mišof s Hodoboxom k dispozícii.

Nasledujú dva riadky. V $i$-tom z nich sú čísla $b_i,,r_i,,m_i$ -- počty voskoviek jednotlivých farieb, ktoré sa spotrebujú na jeden obrázok typu $i$.

## Formát výstupu

Na jediný riadok výstupu vypíšte najväčší počet obrázkov, ktoré vedia Mišof a Hodobox vyfarbiť.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :------------------------------ | ----: | --------: | ---------: | ------------: | | $1 \\leq b,,r,,m, \\leq$ | $100$ | $10,000$ | $100,000$ | $1,000,000$ | | $1 \\leq b_i,,r_i,,m_i, \\leq$ | $300$ | $30,000$ | $300,000$ | $3,000,000$ |

## Príklad

```vstup
6 6 6
1 2 2
2 1 1
```

```vystup
4
```

_Mišof a Hodobox vyfarbia po dva obrázky z každého druhu._

```vstup
3 4 5
1 1 1
2 2 2
```

```vystup
3
```

_V tomto prípade vedia vyfarbiť 3 obrázky prvého druhu._
","# Pokazená tlačiareň

V tejto úlohe sme mali zistiť, koľko obrázkov vedia Mišof a Hodobox vyfarbiť, keď majú dané koľko ktorých voskoviek majú k dispozícii a koľko ktorých voskoviek je potrebných na vyfarbenie každého typu obrázku.

## Vzorové riešenie

Nech v optimálnom riešení máme $x$ obrázkov typu 1 a $y$ obrázkov typu 2. Našou úlohou je zistiť čísla $x, y$ tak, aby $x + y$ bolo maximálne možné.

Môžeme postupne skúšať všetky dosiahnuteľné hodnoty $x$. Ku každej z nich si ľahko vieme dorátať, koľko ktorých voskoviek nám ostane po vyfarbení $x$ obrázkov typu 1. Všetky tieto zvyšné voskovky môžeme použiť na vyfarbenie čo najviac obrázkov druhého typu. Jednoducho si teda dorátame číslo $y$.

Skúsme sa bližšie pozrieť na to, ako dopočítať číslo $y$. Ak sme na $x$ obrázkov prvého typu použili $x_b = x \\cdot b_1$ voskoviek béžovej, $x_r = x \\cdot r_1$ ružovej a $x_m = x \\cdot m_1$ voskoviek modrej farby, tak na obrázky typu 2 nám ostalo $y_b = b - x_b$ voskoviek béžovej, $y_r = r - x_r$ ružovej a $y_m = m - x_m$ modrej farby. Ako zistíme, koľko obrázkov druhého typu vieme týmito voskovkami zafarbiť? Na vyfarbenie jedného obrázku typu 2 potrebujeme $b_2, r_2, m_2$ voskoviek príslušných farieb. Jedna z týchto farieb voskoviek sa nám minie ako prvá. Obrázkov typu 2 teda vieme vyfarbiť $y = \\min{ \\frac{y_b}{b_2}, \\frac{y_r}{r_2}, \\frac{y_m}{m_2} }$.

Pre nejaké nami zvolené $x$ sme teda dopočítali maximálne možné $y$. Na doriešenie úlohy nám teda stačí postupne skúsiť všetky možné $x$, ku každému dopočítať $y$ a vypísať tú možnosť, kde bolo $x + y$ najväčšie.

Prečo to funguje? Pretože skúšame všetky možnosti. Žiadna nám teda neunikne.

### Zložitosť

Koľko rôznych $x$ potrebujeme skúšať? Na každý obrázok spotrebujeme aspoň jednu voskovku každého druhu. Stačí nám teda vyskúšať $\\min{ b, r, m }$ možností pre $x$. Ku každému vieme potom dopočítať $y$ v konštantnom čase. Časová zložitosť teda bude $O(\\min{ b, r, m })$.

Pamätať si nám stačí jednotlivé počty voskoviek, ktoré máme k dispozícii a doteraz najlepšie nájdené $x, y$. Stačí nám teda konštantná pamäť a pamäťová zložitosť bude $O(1)$.
",1
a155f1b3c24f5231,ksp,"# Småland

Keďže je Kristína nadšená cestovateľka, ako už bolo niekde spomenuté, po nejakom čase sa rozhodla ísť na dlhú dovolenku do provincie Småland na juhu Švédska. Ak ste nevedeli, Småland obsahuje jeden z najväčších systémov súostroví na svete, a tým, že sa Kika celkom nudila, rozhodla sa, že prejde všetky ostrovy v ňom.

Kika nevie plávať (a na jar v Baltskom mori ani veľmi nechce), ale, naštastie, vo vyspelých severských krajinách to chodí tak, že každú chvíľu sa medzi nejakými dvomi ostrovmi postaví most, po ktorom vie prejsť. Samozrejme, nie vždy sú všetky ostrovy poprepájané, a tak súostrovie obsahuje len skupinky prepojených ostrovov.

V takto vytvorených skupinkách väčšinou bývajú takzvané *špeciálne ostrovy* ™, ktoré sú napojené len jedným mostom so zvyškom skupinky, a teda pokiaľ Kika na takýto ostrov príde, jej jediná možnosť je vrátiť sa po tom istom moste naspäť.

Kristína by pre potreby plánovania výletu rada vedela, koľko takých *špeciálnych ostrovov* vie z nejakého ostrovu navštíviť len prechádzaním po mostoch. Môže sa pohybovať ako chce a ostrovmi aj mostami môže prechádzať koľkokrát chce v ľubovoľnom smere (je predsa na dovolenke, nie na diaľnici).

## Úloha

Vašou úlohou bude zisťovať, koľko *špeciálnych ostrovov* vie Kika dosiahnuť z ľubovoľného ostrova v závislosti od toho, aké mosty sú v danom čase postavené. Budete začínať len s izolovanými ostrovmi. Kedykoľvek môžete dostať informáciu, že sa postavil most medzi nejakými ostrovmi $a$ a $b$. Taktiež sa Vás kedykoľvek môže Kika spýtať, na koľko *špeciálnych ostrovov* sa vie z nejakého ostrovu $x$ dostať. Informácie o mostoch a otázky o *špeciálnych ostrovoch* budeme súhrnne označovať *queries*.

## Formát vstupu

V prvom riadku vstupu sú dve čísla $n$ a $q$. Číslo $n$ udáva, koľko je ostrovov v súostroví, číslo $q$ zase koľko dostanete *queries*.

Nasledovať bude $q$ jednoriadkových *queries*, ktoré budú mať buď tvar `! a b` (bol postavený most medzi ostrovmi $a$ a $b$) alebo `? x` (Kika sa pýta, na koľko *špeciálnych ostrovov* sa vie dostať z ostrovu $x$).

Sú 4 sady vstupov, môžete v nich predpokladať nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------|------:|---------------:|---------------:|---------------:| | $1 \\leq n \\leq$ | $100$ | $10^4$ | $10^5$ | $10^6$ | | $1 \\leq q \\leq$ | $200$ | $2 \\cdot 10^4$ | $2 \\cdot 10^5$ | $2 \\cdot 10^5$ |

## Formát výstupu

Na informáciu o stavbe mosta nevypisujete nič. Na otázku o *špeciálnych ostrovoch* vypíšte počet takýchto ostrovov.

## Príklady

```vstup
3 4
! 0 2
? 0
? 2
? 1
```

```vystup
2
2
0
```

*Vytvorili sme most medzi ostrovmi `0` a `2`. Z ostrova `0` sa vieme dostať na 2 špeciálne ostrovy (vrátane toho, na ktorom stojíme). Z ostrova `1` sa nevieme dostať na žiadny špeciálny ostrov, pretože je izolovaný.*

```vstup
6 8
! 0 2
! 2 4
! 1 3
! 1 5
? 0
? 5
! 0 1
? 3
```

```vystup
2
2
3
```

*Pred prvými otázkami nám vzniknú dve skupinky ostrovov, každá má 2 špeciálne ostrovy. Potom spojíme špeciálny ostrov `0` z prvej skupinky s normálnym ostrovom `1` z druhej skupinky, čím nám vznikne veľká skupina ostrovov s 3 špeciálnymi ostrovmi.*
","# Småland

Táto úloha bola grafový problém. Ak ste o grafoch^[Grafmi myslíme dátové štruktúry, nie grafy funkcií, ktoré ste mali na matematike] ešte nepočuli, v [Kuchárke KSP](https://www.ksp.sk/kucharka/grafy_uvod/) je k nim pekný úvod.

V našej úlohe sú teda ostrovy _vrcholmi_ grafu a mosty medzi nimi _hranami_ grafu. Potom skupinky ostrovov budú _komponenty súvislostí_ a špeciálne ostrovy sú vrcholy stupňa 1, ktoré tiež niekedy nazývame _listy_ grafu.

Len pre doplnenie, graf si môžete predstaviť ako ""sieť"", kde vrcholy sú body spájané čiarami, čo sú hrany. Komponent súvislostí je potom taká skupinka vrcholov, v ktorej vieme po hranách prejsť z každého vrcholu do každého. Nakoniec, stupeň vrchola je počet hrán, ktoré sa na neho napájajú (odborne povieme, že tieto hrany sú s ním _incidentné_).

V úlohe sme začínali s $n$ izolovanými vrcholmi, pričom každý z nich je samostatný komponent súvislostí s jedným vrcholom.

Ak sme niekedy dostali query na stavbu mostu `! a b`, vytvorili sme v podstate hranu medzi nejakými vrcholmi $a$ a $b$, čím sme spojili ich dva komponenty súvislostí do jedného spoločného.

Ak sme dostali otázku typu `? x`, pýtali sme sa vlastne na počet listov v komponente, ktorý obsahuje vrchol $x$.

## Jednoduché riešenie

Najjednoduchší spôsob, ako sa dala táto úloha riešiť bolo simulovať graf presne tak, ako vzniká. To znamená, že sme si pamätali všetky hrany grafu, a keď nám prišla query na vytvorenie hrany, tak sme ju pridali do grafu. Keď nám prišla otázka na počet listov, tak sme spustili z tohoto vrcholu nejaké prehľadávanie, napríklad [DFS](https://www.ksp.sk/kucharka/dfs/), ktorým sme zistili počet listov.

Pridávanie hrany do grafu vieme robiť v zložitosti $O(1)$. Keď zisťujeme počet listov, tak musíme v najhoršom prípade prehľadať celý graf, čo vieme urobiť v zložitosti $O(n+m)$ (kde $n$ je počet vrcholov a $m$ počet hrán). Pamäťová zložitosť je $O(n+m)$, keďže si potrebujeme pamätať celý graf.

## Pomalšie riešenie

Iný spôsob, ako túto úlohu riešiť, ktorý je aj základ pre vzorové riešenie je tak, že sme rovno simulovali komponenty.

Komponenty sme si uchovávali v nejakom poli. Každý komponent si pamätá, aké vrcholy obsahuje a koľko z týchto vrchol je listov. Tiež si niekde uchovávame informáciu o tom, aký stupeň má každý vrchol.

Ak potom dostaneme inštrukciu na stavbu mostu medzi vrcholmi $a$ a $b$, stačí nám vyhľadať, v ktorých komponentoch sa tieto vrcholy nachádzajú.

Ak sú v rovnakom komponente, nič sa nedeje, len im upravíme stupeň, pretože sme medzi nimi vytvorili hranu. Tiež, ak bol nejaký z nich list, tak už nie je, a teda komponentu upravíme informáciu o tomto.

Ak sú ale komponenty obsahujúce dané vrcholy odlišné, musíme ich zlúčiť, čiže chceme záznamy o vrcholoch z jedného komponentu premiestniť do druhého. Ostatné informácie o stupňoch vrcholov a listoch upravíme rovnako, ako v predchádzajúcom prípade.

Ak sa niekedy spýtame na počet listov v komponente nejakého vrcholu, stačí nám jednoducho vyhľadať, v ktorom komponente je daný vrchol a pozrieť sa do záznamov, koľko listov má daný komponent.

Ako ste si mohli všimnúť, najpomalšia operácia, ktorú tu vykonávame, je vyhľadávanie vrcholu v komponente. V tomto prípade však časová zložitosť tejto operácie záleží od konkrétnej implementácie a voľby dátovej štruktúry reprezentujúcej komponenty alebo vrcholy.

Vyššie navrhnuté riešenie s použitím polí pre komponenty by malo časovú zložitosť vyhľadávania vrcholu $O(n)$.

Keďže si uchovávame v poli zoznam komponentov a pre každý komponent zoznam ich vrcholov, pamäťová zložitosť bude $O(n)$, pretože pokiaľ premiestňujeme vrcholy medzi poľami, uchovávať budeme stále $n$ vrcholov.

Za takéto a podobne rýchle riešenia ste mohli získať 2 body.

V prípade, že ste robili to, že ste vždy spájali menší komponent do väčšieho, dá sa ukázať, že takéto spájanie komponentov má amortizovanú časovú zložitosť $O(\\log n)$.

## Niečo trochu lepšie

V predchádzajúcom riešení sme mali problém s pomalým prehľadávaním a spájaním komponentov.

O komponentoch súvislostí však vieme, že sú navzájom disjunktné^[Sú nezávislé, nemajú spoločný vrchol], a že spojenie dvoch komponentov urobíme prepojením dvoch vrcholov, ktoré sú v nich obsiahnuté.

Toto vieme využiť na to, že komponenty už nebudeme reprezentovať ako polia vrcholov, ale ako stromy. Opäť, ak ste sa ešte so stromami nestretli, krátky úvod nájdete znova v [Kuchárke KSP](https://www.ksp.sk/kucharka/grafy_uvod/#wiki-toc-zakorenene-stromy).

Na začiatku máme izolované vrcholy, čiže jednovrcholové komponenty súvislostí zodpovedajúce stromom s jedným vrcholom:

Ak spojíme vrcholy 1 a 2 (vykonáme `! 1 2`), spojíme aj ich stromy, čiže len jeden zavesíme na druhý:

Spravme to isté pre vrcholy 3 a 4:

Teraz ak chceme spojiť napríklad vrcholy 2 a 4 do jedného komponentu, mohli by sme ich na seba zavesiť ako chceme, ale najlepšie to bude urobiť takto:

Ako asi vidíte, dva vrcholy sú v rovnakom komponente, ak majú spoločný koreň^ [Najvyšší vrchol v strome, nemá rodičovský vrchol] (označený oranžovo na obrázkoch vyššie). Tiež ak chceme zistiť, v akom komponente sa vrchol nachádza, nepotrebujeme už prehľadávať všetky komponenty, stačí nám len sledovať, akého rodiča má daný vrchol a sledovať jeho rodiča rodiča a tak ďalej, až kým neprídeme ku koreňu, ktorý _reprezentuje_ náš komponent.

Pre každý vrchol nám potom stačí uchovávať si len jeho rodiča, pričom korene, teda vrcholy, ktoré nemajú rodičov, budú rodičmi samým sebe.

Ak teraz budeme chcieť spojiť nejaké dva komponenty hranou medzi vrcholmi $a$ a $b$ (`! a b`), jednoducho budeme sledovať rodičov každého vrcholu, až kým sa nedopracujeme ku koreňu (volajme ho _reprezentant_).

Ak je reprezentant rovnaký, oba vrcholy sú v rovnakom komponente. Ak sú reprezentanti odlišní (nazvime si ich $r_a$ a $r_b$), môžeme napríklad koreňu $r_a$ priradiť ako rodiča $r_b$, čiže nový veľký komponent bude mať $r_b$ ako reprezentanta.

Informácie o stupňoch vrcholov si uchovávame rovnako, ako v predchádzajúcom riešení. Aktuálny počet listov daného komponentu bude uložený pre daného reprezentanta.

Ak sa potom spýtame na počet listov pre komponent nejakého vrcholu, stačí nám nájsť jeho reprezentanta a pozrieť sa v nejakom poli na zodpovedajúce miesto.

To, čo sme tu objavili, sa volá _Union-find_ alebo _Disjoint-set data structure_, resp. jeho _naivná implementácia_ (v ďalšej sekcii si ukážeme, ako môže vyzerať sofistikovanejšia implementácia).

Keďže vyhľadávame v stromoch, časová zložitosť vyhľadávania bude prinajhoršom $O(n)$, keď máme len jeden komponent a všetky vrcholy v ňom majú presne jedného potomka. Potom ten strom vyzerá viac ako stožiar, a teda musíme prejsť všetkých $n$ vrcholov, aby sme sa dostali až k reprezentantovi.

Tu sme si teda rýchlosťou veľmi nepomohli oproti predchádzajúcemu riešeniu, avšak voľba union-find dátovej štruktúry nám dáva možnosť pridať rôzne optimalizácie, ktoré to zrýchlia.

Časová zložitosť spájania komponentov, teda stavania mostov, bude tiež $O(n)$, pretože stále musíme hľadať reprezentantov. Časová zložitosť na _query_ je teda lineárna.

Pamäťová zložitosť je stále $O(n)$ rovnako, ako v predchádzajúcom riešení, pretože stále nám na toto všetko stačia len polia.

## Optimálne riešenie

Dá sa to ešte lepšie? Áno, dá. Vďaka tomu, že si komponenty reprezentujeme ako union-find dátovú štruktúru, dokážeme urobiť nejaké optimalizácie.

Ak sa zamyslíte, zistíte, že komponenty s veľkým počtom vrcholov budú eventuálne reprezentované dosť hlbokými stromami. Napríklad, takto by mohol vyzerať strom reprezentujúci 7-vrcholový komponent:

Ak by sme teraz chceli nájsť reprezentanta tohto komponentu z vrcholu 7, trvalo by nám trochu dlhšie dopracovať sa až do oranžového koreňa. Viete si potom asi predstaviť, aké neefektívne by bolo prechádzať hlboký strom pre komponenty s niekoľkými tisícmi vrcholov.

Tento problém ale vieme jednoducho vyriešiť. Ak napríklad budeme prechádzať strom od vrcholu 7, zároveň s hľadaním reprezentanta môžeme tiež prelinkovať prechádzaný vrchol na prarodiča^[Rodičovský vrchol rodičovského vrcholu] nášho vrcholu. V našom prípade by to mohlo vyzerať takto:

Odteraz ak niekedy budeme znovu potrebovať prechádzať strom od vrcholu 7, ušetríme si jeden krok a nič sme nepokazili, pretože nás zaujíma len príslušnosť vrcholu k reprezentantu, nie štruktúra stromu.

Tento proces sa nazýva _lazy path halving_. _Lazy_ preto, lebo toto robíme len keď máme potrebu prechádzať strom z nejakého vrcholu. _Path halving_ odkazuje zas na to, že vrcholy prelinkovávame na prarodičov, čiže ""preskočíme"" polovicu úrovní na ceste ku koreňu, a teda dĺžka cesty sa skráti na polovicu.

Vo všeobecnosti tento mechanizmus ale nazývame _path compression_ a _path halving_ je len jeho konzervatívnejšia forma. V podobnom duchu ale môžeme robiť aj extrémnejšie úpravy stromu:

Ďalší problém, ktorý nám v praxi môže spomaliť naše riešenie je ten, že pri naivnej implementácii spájame komponenty len tak, že ku koreňu stromu jedného komponentu pripojíme koreň stromu druhého komponentu.

Potom vymyslime si takéto dva stromy reprezentujúce komponenty:

Ich zjednotenie naivnou implementáciou union-findu z predchádzajúceho riešenia bude vyzerať takto:

Tento nový strom má hĺbku 2, čiže na nájdenie reprezentanta by sme potrebovali spraviť dva kroky hore stromom. Pritom kľudne by sme vedeli postaviť aj efektívnejší strom s hĺbkou len 1:

Čo sa stalo? V naivnej implementácii napájame stromy na seba nemenne len jedným spôsobom a neberieme ohľad na to, ako bude vyzerať výsledok. V praxi potom naše stromy budú veľakrát vyzerať ako palice s veľkou hĺbkou, čiže opäť naša najdôležitejšia úloha hľadania reprezentanta bude prebiehať pomalšie.

Ideálne by sme ale chceli mať viac ""rozkošatené"" stromy s čo najviac vrcholmi na jednej úrovni, aby sme mali plytké stromy, v ktorých sa vieme rýchlo dostať do koreňa.

Jedna z možností, ako takúto vlastnosť zabezpečiť, je pripájať koreň menšieho stromu (s menším počtom vrcholov) ku koreňu väčšieho stromu. To vieme jednoducho implementovať napríklad tak, že si pre každý koreň uložíme, koľko má jeho strom vrcholov. Keď potom spájame dva stromy, len si porovnáme ich veľkosti a podľa toho sa rozhodneme, ako ich chceme spojiť.

Tejto technike sa hovorí _weighted union_ alebo konkrétnejšie _union by size_.

Najhoršia časová zložitosť hľadania reprezentanta s _weighted union_ bez _path compression_ bude $O(\\log n)$, pretože budeme hľadať vo vyváženom strome, v ktorom budeme musieť spraviť najviac toľko krokov hore, aká je jeho hĺbka.

Toto sa ale zmení, keď pridáme _path compression_. Kombinácia týchto dvoch mechanizmov potom bude mať amortizovanú časovú zložitosť $O\\left(\\log^\* n\\right)$, kde $\\log^\*$ je iterovaný logaritmus, ktorý vráti počet logaritmovaní, ktoré musíme aplikovať na pôvodnú hodnotu, kým nedostaneme výsledok menší alebo rovný 1. Môžete si to predstaviť tak, že nám vráti počet, koľkokrát musíme na kalkulačke stlačiť tlačidlo logaritmu, aby sme dostali výsledok menší alebo rovný 1.

Časová zložitosť tejto verzie union-findu sa zvykne ešte označovať aj ako $O\\left(\\alpha(n)\\right)$, kde $\\alpha(n)$ je takzvaná [_inverzná Ackermannova funkcia_](https://en.wikipedia.org/wiki/Ackermann_function#Inverse), ktorá rastie podobne extrémne pomaly ako $\\log^\* n$. Keďže $\\alpha(n) \\leq 5$ pre $n < 2^{65536}$^[Len pre porovnanie, počet atómov v pozorovateľnom vesmíre je približne $2^{265}$], tak prakticky pre akékoľvek vstupy dostávame konštantnú časovú zložitosť $O(1)$ na _query_.

Presná analýza časovej zložitosti sa v tomto prípade dosť komplikovane odvádza, ale pokiaľ by Vás to zaujímalo, môžete sa pozrieť napríklad [sem](https://people.ksp.sk/~kuko/gnarley-trees/UnionFind.html#analysis).

Pamäťová zložitosť bude opäť rovnaká, ako v predchádzajúcich riešeniach, teda $O(n)$ pretože si stále vystačíme s niekoľkými lineárnymi poľami.

Za takéto a podobné riešenia využívajúce dostatočne rýchlu implementáciu union-findu ste mohli získať plný počet bodov.
",5
dfdedf464ec21026,ksp,"# Zabudnuté algoritmy

Hodobox je už vysokoškolák, a preto bol tento rok prvýkrát na školskom kole súťaže ACM. A čo sa stalo-nestalo, predbehla ho stredoškoláčka a ešte aj chlapec so zápalom pľúc! Teraz sa Hodobox snaží prejsť si všetky úlohy odznova a skúsiť si ich preriešiť. Má však malý problém. Niečo sa stalo a zabudol všetky algoritmy. Nevie už nakódiť ani len binárne vyhľadávanie, ktoré sa naučil na [letnej škole](https://www.ksp.sk/ls/).

Rozhodol sa teda, že sa všetky potrebné algoritmy znova naučí. Každá úloha sa dá definovať ako množina algoritmov, ktoré sú potrebné na jej vyriešenie. Pre jednoduchosť si algoritmy očíslujeme od $1$ po $1,000,000$ (napríklad $47$ je binárne vyhľadávanie).

Nie je to však až také jednoduché. Rôzne úlohy vyžadujú znalosť rôznych algoritmov do rôznej hĺbky. Napríklad taký merge-sort -- v jednej úlohe ním len usporiadame prvky, v inej však spočítame počet inverzií. Úloha má teda ku každému algoritmu, ktorý je potrebný na jej vyriešenie priradenú ešte aj potrebnú úroveň znalosti tohto algoritmu.

Hodobox má so sebou Paulínkinu príručku 'How to win IOI for dummies'. V nej si Paulínka spísala všetky algoritmy od výmyslu sveta. Hodobox sa nimi teraz prehrýza a veľmi by ho zaujímalo, kedy už bude konečne schopný naprogramovať všetky úlohy zo školského kola ACM.

## Úloha

Na vstupe dostanete popis školského kola, ktoré sa skladá z $n$ úloh. Pre každú úlohu dostanete zoznam algoritmov potrebných na jej vyriešenie (číslo algoritmu a úroveň potrebnú na vyriešenie tejto úlohy).

Potom nasleduje $p$ Hodoboxových akcií, kde si vždy zlepší chápanie nejakého algoritmu o istú úroveň. Na začiatku Hodobox nevie nič (jeho úroveň znalosti každého algoritmu je $0$).

Vašou úlohou je po každej akcii vypísať, koľko úloh zo školského kola je už Hodobox schopný vyriešiť.

## Formát vstupu

Na prvom riadku vstupu je počet úloh $n ~ (1 \\leq n \\leq 10^6)$.

Nasleduje $n$ popisov úloh. Popis $i$-tej úlohy začína číslom $a_i$ na samostatnom riadku -- počet algoritmov nutných na vyriešenie $i$-tej úlohy ($0 \\leq a_i < 10^6$). Potom nasleduje $a_i$ riadkov s popismi jednotlivých algoritmov potrebných pre túto úlohu. Každý z nich obsahuje dve čísla $x ~ (1 \\leq x \\leq 10^6)$ -- číslo daného algoritmu a $y ~ (1 \\leq y \\leq 10^9)$ -- potrebná úroveň znalosti tohto algoritmu.

Zároveň platí, že $\\sum a_i \\leq 10^6$.

Potom nasleduje jeden riadok s číslom $p$ -- počet akcií, kedy sa Hodobox učí nejaký algoritmus. Platí, že $p \\leq 10^6$. Nasleduje $p$ riadkov. V každom sú dve čísla $c_j$ a $u_j$, kde $c_j$ je číslo algoritmu a $u_j$ znamená, o koľko sa Hodoboxovi zlepšila úroveň znalosti algoritmu $c_j$. Platí že $1 \\leq c_j \\leq 10^6$ a $1 \\leq u_j \\leq 10^9$.

Vstupy v tejto úlohe budú **veľmi veľké**. V C++ preto odporúčame použiť miesto knižnice `<iostream>` knižnicu `<cstdio>`. Ak chcete použvívať `<iostream>`, vložte si na začiatok programu nasledovné príkazy, ktoré urýchlia vstup a výstup: `ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);` Na vypisovanie nového riadku tiež nepoužívajte `endl`, ale znak nového riadku `'\n'`.

V pomalších jazykoch sa nemusí dať získať plný počet bodov na testovacích vstupoch. Za optimálne riešenie však stále viete získať plný počet za popis riešenia.

## Formát výstupu

Na výstupe bude $p$ riadkov. Na $j$-tom riadku bude jedno číslo -- počet úloh ktoré vie Hodobox vyriešiť, keď sa už zlepšil v algoritmoch $c_1$ až $c_j$ o príslušné úrovne.

## Príklad

```vstup
3
1
14 1
0
2
13 3
14 1
2
13 3
14 1
```

```vystup
1
3
```

*Už na začiatku vie Hodobox vyriešiť druhú úlohu, pretože na ňu netreba vedieť nič. Po prvej akcii si zlepší chápanie algoritmu 13 z 0 na 3, čo mu nepomôže k ďalšej úlohe, takže výstup je 1. Druhou akciou si zlepší chápanie algoritmu 14 z 0 na 1, čo mu pomôže vyriešiť prvú aj tretiu úlohu.*

```vstup
3
2
47 5
42 3
3
42 13
13 4
7 6
1
47 2
5
47 1
47 3
42 12
13 5
47 12
```

```vystup
0
1
1
1
2
```

*Hodobox nevie pred prvou akciou vyriešiť ani jednu úlohu. Po prvej akcii sa binárne vyhľadávanie (algoritmus 47) naučí na úroveň 1. To mu ale nepomôže k žiadnej úlohe, takže výstup je 0.*

*Ďalšou akciou si zlepší znalosť vyhľadávania na 4. Preto vie vyriešiť tretiu úlohu, ale nič viac. Potom sa naučí algoritmus 42 na úroveň 12, čo mu stále nepomôže k ďalším úlohám. Potom si zlepší algoritmus 13 z nuly na 5, takisto mu to nepomôže. Na prvú úlohu ma slabú znalosť algoritmu. č. 47 a na druhú zas algoritmu 7.*

*Poslednou akciou sa naučí algoritmus 47 na úroveň 16 ($4 + 12$), takže už bude vedieť vyriešiť prvú úlohu.*
","# Zabudnuté algoritmy

## Jednoduché riešenie

Skúsme najprv vymyslieť priamočiare riešenie. Budeme si pre každú úlohu pamätať, ktoré algoritmy na ňu potrebujeme vedieť a na akej úrovni. Vždy, keď sa Hodobox niečo naučí, prejdeme všetky úlohy a spočítame tie, pre ktoré už vie všetky algoritmy dosť dobre.

Pre jednoduchosť si pri každom algoritme pre každú úlohu okrem toho, na akú úroveň ho potrebujeme vedieť, zapamätáme aj to, ako dobre ho vieme -- **znalosť algoritmu**. Na začiatku je to nula pre každý algoritmus každej úlohy. Postupne, ako sa bude Hodobox algoritmy učiť, budeme tieto čísla zvyšovať.

Po načítaní zoznamov algoritmov pre jednotlivé úlohy začneme postupne spracovávať Hodoboxove akcie. Pri každej akcii prejdeme každú z $n$ úloh a spočítame, koľko z nich vie vyriešiť. To vieme pre jednu úlohu spočítať jednoducho: Postupne sa pozrieme na všetky potrebné algoritmy, a overíme, či ich už Hodobox vie na dostatočne dobrej úrovni. Ak nájdeme algoritmus, ktorý má potrebnú úroveň ostro vyššiu ako znalosť, tak sa ho Hodobox ešte musí učiť.

Popri tomto prechádzaní vo všetkých úlohách aj zvyšujeme znalosť algoritmu, ktorý sa Hodobox v tejto akcii naučil.

### Akú má toto riešenie časovú a pamäťovú zložitosť? Časová zložitosť pre načítanie vstupu závisí od jednotlivých počtov algoritmov. Pre úlohu $i$ načítanie trvá $O(1+a_i)$. Jednotka je tu pre načítanie čísla $a_i$. To je podstatné hlavne ak $a_i = 0$. Na celkové načítanie vstupu potrebujeme načítať všetky úlohy, a tak čas potrebný na načítanie celého vstupu bude súčet časov pre jednotlivé úlohy: $\\sum\_{i=1}^{n} (1+a_i) = \\sum\_{i=1}^{n} 1 + \\sum\_{i=1}^{n} a_i = n + \\sum\_{i=1}^{n} a_i$. Ak si označíme $\\sum a_i = A$, tak načítanie vstupu má časovú zložitosť $O(n+A)$.

Koľko trvá spracovanie jednej Hodoboxovej akcie? Prechádzame každú úlohu, a pre ňu každý algoritmus, čo je znova súčet počtov algoritmov pre všetky úlohy. Teda aj spracovanie jednej akcie trvá $O(n+A)$. Spracovanie všetkých akcií bude trvať $O(p(n+A))$.

Celkovo je časová zložitosť $O(n + A + p(n+A)) = O(p(n+A))$.

Pamäťová zložitosť je $O(n+A)$, keďže si musíme zapamätať všetky úlohy a algoritmy, ktoré sú pre ne potrebné.

## Skoro vzorové riešenie

Predošlé riešenie funguje, ale pozrime sa, či by vyriešilo úlohu aj pre najväčšie vstupy. Tam môžu premenné $p$, $n$ aj $A$ nadobúdať hodnoty až po $10^6$. Keďže časová zložitosť je $O(p(n+A))$, bolo by to rádovo až $10^6\\cdot (10^6 + 10^6)) = 2\\cdot10^{12}$ operácií, no bežný počítač zvláda za sekundu približne ""len"" $10^9$ operácií. Pokúsme sa teda navrhnúť efektívnejší algoritmus.

Pozrime sa na to, čo sme počítali v predošlom riešení zbytočne veľakrát.

Prvou takou vecou bolo, že sme po každej akcii prešli všetky úlohy, a spočítali tie, ktoré vie Hodobox vyriešiť. Po jednej akcii sa ale výsledok (počet riešiteľných úloh) nezmení o veľa. Mohli by sme mať teda jedno **počítadlo: počet riešiteľných úloh**. V každej akcii by sme toto počítadlo len zvýšili o úlohy, ktoré sa stali riešiteľnými naučením tohoto algoritmu a potom by sme hodnotu tohto počítadla vypísali ako výsledok. Zavedenie počítadla nám samo osebe ešte nezlepší zložitosť, ale je to prvým krokom k lepšiemu riešeniu.

Druhá vec, ktorú sme robili pri každej akcii, bola, že sme prešli všetky algoritmy každej úlohy. V jednej akcii sa ale Hodobox naučil len jeden algoritmus, ktorý bol potrebný len pre pár úloh. Čo ak by sme si **pre každý algoritmus pamätali všetky úlohy, ktoré ho potrebujú**? Potom by sme pri spracovávaní Hodoboxovej akcie prešli naozaj iba tie úlohy, pri ktorých sa niečo zmenilo.

Zoznamy úloh pre každý algoritmus si budeme pamätať v dvojrozmernom poli dvojíc^\[Dvojica je implementovaná v `C++` ako [`pair`](http://www.cplusplus.com/reference/utility/pair/). Prípadne by ste si mohli spraviť vlastný `struct`. V `Python`-e viete využiť $k$-ticu pod názvom [`tuple`](https://docs.python.org/3.5/library/stdtypes.html#typesseq-tuple).\]. $i$-ty prvok tohto poľa bude jednorozmerné pole takýchto dvojíc: (úroveň algoritmu $i$ (potrebná na vyriešenie úlohy), číslo úlohy).

Keďže každý prvok nášho poľa (zoznam) patrí jednému algoritmu a my vieme, že najväčšie číslo algoritmu je $10^6$, tak veľkosť poľa si môžme zvoliť $10^6+1$.^[Keďže polia sú indexované od 0, v poli veľkosti $10^6$ by algoritmus s číslom $10^6$ už nemal svoj zoznam úloh. Preto pridávame $+1$.]

V inom riešení by sme si počas načítavania vstupu mohli pole naťahovať. V premennej $max_alg$ by sme si udržiavali najväčšie nájdené číslo algoritmu a vždy, keď by sme našli algoritmus s číslom $x$ väčším než $max_alg$, tak by sme naše pole rozšírili na dĺžku $x+1$.

Pre každý algoritmus $i$ máme teda zoznam úloh, pre ktoré potrebujeme algoritmus $i$ vedieť lepšie. Mohli by sme teda povedať, že je to **zoznam úloh, ktoré sú blokované algoritmom $i$**. Každá úloha je na začiatku blokovaná všetkými svojimi algoritmami. Keď si Hodobox zlepší znalosť algoritmu $i$, mohli by sme tento zoznam prejsť a odstrániť tie úlohy, pre ktoré už vie Hodobox algortimus dostatočne dobre.^[Nech si Hodobox zlepšil znalosť algoritmu $i$ z $x$ na $y$. Odstránime úlohy, ktoré algoritmus $i$ potrebovali na úroveň $a$, takú že platí $x < a \\leq y$.]

Na vstupe vždy dostaneme len číslo $u$, o ktoré sa Hodoboxova znalosť algoritmu $i$ zvýšila. Na to, aby sme vedeli povedať, aká je nová úroveň znalosti algoritmu (v predošlej poznámke sme ju označovali $y$) si **pre každý algoritmus chceme pamätať jeho aktuálnu úroveň** v poli. Na začiatku vie Hodobox každý algoritmus na nula a pri každej akcii upravíme znalosť jedného algoritmu (`y += u`). Toto pole pre úrovne môžeme spraviť veľkosti $10^6+1$, alebo veľkosti $max_alg+1$.

Poslednou otázkou zostáva: Kedy vie Hodobox vyriešiť novú úlohu? Vtedy, ak už úloha nie je v žiadnom zozname -- vtedy, keď nie je blokovaná žiadnym algoritmom. Pre každú úlohu by sme teda mohli mať navyše v jednej premennej uložené, **koľkými algoritmami je blokovaná**. Na začiatku tu bude počet všetkých algoritmov, ktoré sú pre ňu potrebné. Pri akciách budeme toto číslo znižovať, keď budeme danú úlohu vyhadzovať zo zoznamov. Keď počet blokácií dosiahne hodnotu 0, znamená to, že sa úloha stala riešiteľnou a tak zvýšime naše globálne počítadlo riešiteľných úloh.

Poďme si teda riešenie zhrnúť. Máme jedno globálne počítadlo riešiteľných úloh a pre každý algoritmus máme zoznam úloh s úrovňami znalosti potrebnými na ich vyriešenie. Navyše si ešte v samostatných poliach pamätáme aktuálne úrovne znalostí algoritmov a počet blokácií každej úlohy.

Pozrime sa na to, čo sa stane v jednej akcii. Nech si Hodobox v tejto akcii zlepšil úroveň algoritmu $i$ o $u$.

- Pozrieme sa do poľa znalostí algoritmov a zvýšime aktuálnu znalosť algoritmu $i$ o $u$. Nech je táto nová hodnota $y$.

- Ďalej sa chceme postupne pozrieť na všetky úlohy v zozname algoritmu $i$. Postupne ich všetky prejdeme a budeme vyhadzovať tie, pre ktoré už vie Hodobox algoritmus dosť dobre (tie, ktoré vyžadujú znalosť nanajvýš $y$).

  - Popri vyhadzovaní chceme každej vyhodenej úlohe znižovať počet blokácii o jedna.

  - Keď zistíme, že úlohe klesol počet blokácií na 0, zvýšime počítadlo úloh, ktoré už vie Hodobox vyriešiť, o jedna.

- Po prejdení všetkých úloh v zozname vypíšeme počítadlo riešiteľných úloh.

Teraz by sme už mali vedieť naprogramovať toto riešenie.

## Posledný krok k vzorovému riešeniu

Vyhadzovanie úloh sme chceli robiť tak, že prejdeme celý zoznam, a vždy, keď nájdeme úlohu, ktorá algoritmus $i$ potrebuje na úroveň najviac $y$, tak ju zo zoznamu odstránime.

Mohlo by sa nám ale stať, že by sme v každej akcii vyhadzovali len jednu úlohu z konca zoznamu, prípadne, ešte horšie, že naučením sa algoritmu by sme neodblokovali (neodstránili) žiadnu úlohu. V každej takejto akcii by sme prešli celý zoznam napriek tomu, že výsledok (počet riešiteľných úloh) sa vôbec nezmenil.

Chceli by sme teda v každom zozname prejsť len tie úlohy, ktoré mali šancu stať sa riešiteľnými, mali šancu na odblokovanie. Prvá úloha, ktorú by sme chceli zo zoznamu vyhodiť je tá, ktorá si vyžaduje najnižšiu znalosť algoritmu $i$. Ak nevieme odstrániť tú, môžeme rovno skončiť, lebo žiadna iná úloha sa určite neodblokuje.

Stačí teda, ak si **úlohy blokované algoritmom $i$ usporiadame podľa potrebnej znalosti algoritmu**. Na konci zoznamu bude úloha, ktorá vyžaduje najnižšiu znalosť. Keď sa Hodobox zlepší v algoritme $i$, pozrieme sa na koniec zoznamu a ak už Hodobox vie algoritmus dostatočne, túto úlohu zo zoznamu vyhodíme a pokračujeme ďalšími úlohami -- takými, ktoré potrebujú vyššiu znalosť algoritmu. Skracovanie zoznamu ukončíme, ak ďalšiu úlohu nevieme vyhodiť, teda ak Hodobox nevie algoritmus dostatočne pre žiadne ďalšie úlohy v zozname.

Hneď po načítaní vstupu si teda pre každý algoritmus usporiadame zoznam ním blokovaných úloh poľa potrebnej znalosti.^\[Ak využívate `sort` v `C++` alebo v `Python`-e, tak si dajte pozor na to, že zoznam dvojíc sa primárne usporiadava podľa prvého prvku z dvojice. Oplatí sa teda mať v dvojiciach uloženú najprv potrebnú úroveň znalosti algoritmu a až potom číslo úlohy, alebo si napísať vlastnú porovnávaciu funkciu.\]

### Ideálna časová zložitosť

Znova si označme súčet počtov algoritmov ako $A = \\sum\_{i=1}^{n} a_i$. Načítanie vstupu zvládneme určite v čase $O(A + n)$ (keďže $A$ môže byť menšie ako $n$, treba v odhade uviesť aj $n$).

Potom si pre každý algoritmus musíme [usporiadať](https://www.ksp.sk/kucharka/triedenie/) zoznam jeho úloh. Potrebný čas bude $O(\\sum\_{i=1}^{n} (b_i\\log b_i))$ kde $b_i$ je počet úloh, ktoré potrebujú algoritmus $i$. Vieme, že platí $A = \\sum b_i$, a pre každé $i$ platí $b_i < A$, takže vieme predošlý súčet zjednodušiť: $$\\sum\_{i=1}^{n} (b_i \\log b_i) \\leq \\sum\_{i=1}^{n} (b_i \\log A) = (\\sum\_{i=1}^{n} b_i) \\cdot \\log A = A \\log A$$ To znamená, že usporiadanie všetkých prvkov stíhame v $O(A\\log A)$.

Čo sa týka spracovávania Hodoboxových akcií, tak v jednej akcii sme mohli odstrániť $0$ až $n$ úloh. Ak by sme zložitosť jednej akcie odhadli ako $O(n)$, v celkovej zložitosti by vystupoval člen $O(pn)$, čo je ale príliš veľké číslo.

Na počítanie zložitosti akcií sa teda treba pozrieť z pohľadu každej úlohy samostatne. Predstavme si prípad, že na konci bude Hodobox vedieť vyriešiť každú úlohu. Vezmime si teda jednu úlohu $i$, na ktorú treba $a_i$ algoritmov. Ak ju Hodobox vie vyriešiť, tak sa niekedy musel naučiť každý z $a_i$ algoritmov. Teda ak úloha $i$ bola v $a_i$ zoznamoch pre $a_i$ rôznych algoritmov tak bola aj práve raz bola z každého z týchto zoznamov vyhodená (práve vtedy, keď sa naučil Hodobox daný algoritmus dostatočne). Môžeme teda povedať, že úloha $i$ bola $a_i$ krát ""spracovaná"".

Každé spracovanie úlohy -- vyhodenie zo zoznamu, znížene počtu blokácií, zvýšenie počítadla riešiteľných úloh -- vieme robiť v čase $O(1)$ (práve vďaka tomu, že úlohy vždy odstraňujeme z konca zoznamu). Sčítaním počtov spracovaní každej úlohy dostávame celkový počet spracovaní: $\\sum\_{i=1}^{n} a_i = A$. V každej akcii tiež zvyšujeme úroveň naučeného algoritmu a vypisujeme výsledok, a preto musíme do zložitosti započítať aj člen $O(p)$. Takže v najhoršom prípade, keď sa Hodobox naučí vyriešiť všetky úlohy, bude spracovanie akcií trvať $O(A+p)$.

V súčte je teda časová zložitosť $O(n + A\\log A + p)$.

### Naozajstná časová zložitosť

Možno ste si už všimli, že tu niečo nesedí. Veď naše veľké, dvojrozmerné pole má prvý rozmer $max_alg$, čo môže byť až $10^6$ a toto pole predsa potrebujeme inicializovať. Každý z riadkov od $0$ po $max_alg$ musí byť vytvorený, aj keď bude prázdny. Na načítanie prvej časti vstupu budeme potrebovať čas až $O(A + n + max_alg)$.

Možno sa pýtate, prečo sa vôbec nad $max_alg$ zamýšľame. Veď v najväčšom vstupe bude $max_alg$ najviac $10^6$, rovnako ako aj $A$ či $n$. Pri malých vstupoch sa ale môže stať, že $n$ bude 1, dokonca aj $A$ bude 1, a predsa, ak na tú jednu úlohu potrebujeme vedieť práve jeden algoritmus s číslom $10^6$, tak $max_alg$ vyskočí na $10^6$ a náš algoritmus bude potrebovať až rádovo $10^6$ jednotiek pamäte a tiež rádovo $10^6$ operácií na vytvorenie a vynulovanie daných polí. Ak by sme navyše mali algoritmy očíslované napríklad číslami $1$ až $10^9$, nemohli by sme si dovoliť používať takéto veľké pole.

Celková časová zložitosť bude teda $O(n + max_alg + A\\log A + p)$, čo je v najhoršom prípade $O(A\\log A + n + p + 10^6)$.

### Pamäťová zložitosť

Načítanie vstupu nám zaberie $O(A)$ pamäte. Netreba ale zabudnúť aj na prázdne zoznamy pre čísla algoritmov, ktoré nikdy nepotrebujeme. Takže v skutočnosti to je $O(A + max_alg)$.

Okrem toho máme pole počtov blokácií jednotlivých úloh, ktoré je veľkosti $n$, a pole, kde si udržiavame aktuálnu znalosť algoritmov veľké $max_alg$+1.

Celková pamäťová zložitosť je teda $O(A+n+max_alg)$, v najhoršom prípade $O(A+n+10^6)$.

### Ako sa zbaviť závislosti na $max_alg$

Určite vás zaujíma, ako teda dosiahnuť časovú a pamäťovú zložitosť naozaj $O(A\\log A + n)$ a $O(A + n)$, teda nezávislú od $max_alg$.

Naším problémom sú dve polia. Pole `problems` kde si držíme pre každý algoritmus zoznam úloh a pole `levels` kde si pre každý algoritmus držíme jeho aktuálnu úroveň. Obe majú veľkosť závislú od $max_alg$.

Možno niektorí z vás poznajú pojem **asociatívne pole**, `slovník` či `mapa`. Asociatívne pole je pole, ktorého prvky nie sú indexované pomocou postupnosti celých čísel, ale pomocou kľúčov. Kľúčom môže byť číslo, textový reťazec a iné. Medzi operácie ktoré vieme s mapou robiť patrí: pozrieť sa na hodnotu pod kľúčom, zmeniť hodnotu pod kľúčom, vytvoriť nový kľúč, prejsť všetky kľúče atď.

V našom prípade by sme teda zvolili mapu, kde kľúče budú celé čísla -- konkrétne čísla algoritmov. Ale iba tých, ktoré naozaj potrebuje nejaká úloha. Pod týmto kľúčom by bol zoznam dvojíc: úloha a úroveň. Vždy, keď prvýkrát narazíme na algoritmus $x$, ktorý zatiaľ žiadna úloha nepotrebovala, tak vytvoríme v mape prázdny zoznam pod kľúčom $x$ a pridáme tam aktuálnu úlohu. Ak sme už algoritmus predtým videli, tak len do jeho zoznamu pridáme úlohu.

To nám vyrieši problém s inicializáciou prázdnych zoznamov pre algoritmy, ktoré žiadna úloha nepotrebuje. Rovnako vieme aj prejsť iba všetky existujúce kľúče v mape, a tak sa vyhnúť usporiadavaniu prázdnych zoznamov pre tieto algoritmy. Podobne vieme mapu využiť aj na pole `levels`.

Okrem časovej zložitosti, použitie asociatívneho poľa zlepšuje aj pamäťovú zložitosť, keďže sme sa v prípade poľa `levels` zbavili núl pre nepotrebné algoritmy. Rovnako pre pole `problems` sme sa zbavili prázdnych zoznamov.

Obyčajná mapa so sebou prináša aj nevýhody, ktoré sa prejavia pri veľkom počte záznamov. Ak do nej chceme niečo vložiť, alebo sa pozrieť na nejakú hodnotu, tak to nie je v konštantnom čase, ale v $O(\\log s)$, kde $s$ je aktuálna veľkosť mapy.

Preto je lepšie v tomto prípade namiesto mapy použiť hashmapu, s ktorou sa pracuje väčšinou podobne ako s mapou, ale operácie sú v konštantnom čase, rovnako ako pri práci s poľom. Teda využitím hasmapy dostaneme naozaj čas. zložitosť $O(A\\log A + n + p)$.

Porovnanie jednotlivých operácii môžeme vidieť v tabuľke, kde $s$ predstavuje aktuálnu veľkosť mapy/hashmapy.

| | Mapa | HashMapa | |:-------------------------:|:-----------:|:--------:| | Vytvoriť kľúč | $O(\\log s)$ | $O(1)$ | | Vrátiť hodnotu pod kľúčom | $O(\\log s)$ | $O(1)$ | | Zmeniť hodnotu pod kľúčom | $O(\\log s)$ | $O(1)$ | | Prejsť všetky kľúče | $O(s)$ | $O(s)$ |

Mapu môžete nájsť implementovanú v rôznych jazykoch. V `C++` sa mapa po anglicky nazýva `map`([dokumentácia](http://www.cplusplus.com/reference/map/map/)) a hashmapa je `unordered_map` ([dokumentácia](http://cplusplus.com/reference/unordered_map/unordered_map/)). V `Python`-e máte hashmapu pod názvom `dict`([dokumentácia](docs.python.org/3/library/stdtypes.html#typesmapping)).
",5
28d0f1e623fe9a95,ksp,"# Základ úspechu

V tejto úlohe sa dozviete ako prebieha dvorenie u robotov.

Každý robot má vo svojej pamäti uložené posledné udalosti, ktoré sa v jeho/jej okolí odohrali. Každá udalosť má nejakú tému. Pre jednoduchosť si budeme pamäť každého robota predstavovať ako reťazec malých písmen anglickej abecedy. Každé písmeno označuje nejakú tému. Napr. ""`abca`"" je pamäť obsahujúca 4 rôzne udalosti, pričom prvá a posledná udalosť majú tú istú tému.

Proces dvorenia je vo svojej podstate veľmi jednoduchý. Každý robot si vyberie nejaký neprázdny súvislý úsek svojej pamäte a prerozpráva ho druhému robotovi. Dvorenie prebehlo úspešne práve vtedy, ak v úsekoch, ktoré si prerozprávali, nájdu nejakú spoločnú tému. Napríklad ak jeden robot povie ""`bca`"" a druhý ""`efccg`"", tak dvorenie bolo úspešné, lebo obaja spomenuli tému `c`.

Android Helboj má veľký úspech u fembotiek\\footnote{Fembotka je robot ženského pohlavia. Niekedy sa taktiež označuje ako gynoid.}. Fembotky za ním samé chodia a ako prvé mu hovoria svoje zážitky. No a Helboj to už má potom ľahké -- stačí, aby si vybral nejaký úsek svojich spomienok, ktorý má s tými od fembotky nejakú spoločnú tému, a má vyhraté.

## Úloha

Na vstupe dostanete dva reťazce. Prvý predstavuje postupnosť $f$ spomienok, ktorú nejaká fembotka povedala Helbojovi. Druhý predstavuje postupnosť $h$ spomienok, ktorá tvorí celú Helbojovu pamäť.

Helboj má presne $h(h+1)/2$ možností, ktorý úsek spomienok prerozprávať fembotke. (Dve možnosti považujeme za rôzne, ak sa líšia indexom začiatku alebo konca, a to aj vtedy, ak im zodpovedajú rovnaké postupnosti znakov -- ide síce o rovnakú tému, ale rôzne výskyty toho istého znaku predstavujú rôzne udalosti.) Váš program by mal vypočítať, koľko spomedzi týchto možností povedie k úspešnému dvoreniu.

## Vstup

Prvý riadok vstupu obsahuje prirodzené čísla $f$ a $h$ ($1 \\leq f, h \\leq 100,000$).

Druhý riadok obsahuje $f$ malých písmen anglickej abecedy -- úsek pamäte prerozprávaný fembotkou.

Tretí riadok obsahuje $h$ malých písmen anglickej abecedy -- celú pamäť Helboja.

## Výstup

Vypíšte jeden riadok a v ňom jedno číslo -- počet takých podreťazcov Helbojovej pamäte, že zdieľajú niektorú tému s fembotkiným reťazcom pamäte.

## Príklady

```vstup
2 2
aa
ba
```

```vystup
2
```

*Helboj môže povedať jeden z reťazcov ""`b`"", ""`a`"" a ""`ba`"". Ak by ale povedal len ""`b`"", nenašli by s fembotkou spoločnú tému. Musí si teda vybrať jednu zo zvyšných dvoch možností.*

```vstup
3 6
bdb
acaabd
```

```vystup
11
```

*V tomto prípade vyhovujú všetky podreťazce Helbojovej pamäte, ktoré končia piatym alebo šiestym znakom.*

```vstup
1 10
a
aaaaaaaaaa
```

```vystup
55
```

*Tu si všimnite, že odpoveď je 55 a nie 10.*
","# Základ úspechu

Najjednoduchšie riešenie, priamočiaro ""hrubou silou"" vyzerá nasledovne: Označme si reťazce fembotky a Helboja $F$ a $H$. Vyskúšame všetky možné podreťazce $H$ -- postupným výberom začiatkov a koncov. Každý podreťazec po znakoch skontrolujeme, či sa také písmenko nenachádza aj v $F$ -- prejdením celého $F$. Ak tam bola aspoň jedna spoločná téma-písmenko, podreťazec zarátame. Časová zložitosť tohoto prístupu je $O(h^3 \\cdot f)$ -- máme $h(h+1)/2$ podreťazcov po najviac $h$ písmen, z ktorých každý skontrolujeme za najviac $f$ krokov.

Všimnime si, že netreba stále prechádzať celý reťazec $F$ -- namiesto toho vieme prejsť $F$ na začiatku raz, pre každé písmenko si zapamätať, či je v ňom a následne to rýchlo kontrolovať pri prechádzaní. Dostaneme čas $O(f+h^3)$.

Ďalej sa zamyslime, čo sa stane, keď v $H$ pre daný začiatok úseku nájdeme koniec taký, že tento úsek už obsahuje spoločnú tému s $F$. Tento koniec môžeme ľubovoľne posúvať ďalej a stále budeme mať aspoň jednu túto istú spoločnú tému. Ako nám to pomôže? Pre každý možný začiatok nájdeme najbližšie písmenko, ktoré sa vyskytuje aj v $F$. Ak žiadne nenájdeme, tak zjavne nemáme podreťazec so spoločnou témou nikde ďalej. Nech začiatok je na pozícií $i$ a najbližšie spoločné písmenko na $j>=i$. Všetkých podreťazcov začínajúcich v $i$ obsahujúcich $j$ je $h-j$ (ak indexujeme od $0$ po $h-1$). Takže tento príslušný počet zarátame a pohneme sa na ďalší začiatok. Začiatkov je $h$ a pre každý prejdeme najviac $h$ písmen, čo nám dáva časovú zložitosť $O(f+h^2)$.

Nakoniec sa pozrime, čo sa deje pri hýbaní sa na ďalší začiatok úseku. Kde mohla byť predošlá najbližšia spoločná téma? Ak bola hneď na predošlom začiatku, tak je už za nami a musíme nájsť novú. Inak je stále najbližšia tá istá. Budeme mať premennú pre pozíciu najbližšej spoločnej témy a keď sa už začiatok ocitne za ňou, budeme ju zvyšovať, kým nenájdeme dalšiu spoločnú tému alebo koniec. Túto premennú zvýšime celkovo iba $h$-krát a každému začiatku vieme povedať, koľko príslušných podreťazcov z neho zarátame. Dostávame rýchle vzorové riešenie v $O(f+h)$.

Treba si dať pozor na veľkosť odpovede -- môže presiahnuť rozsah 32-bitovej premennej.

Všimnite si, ako sme z jednoduchšieho riešenia zrýchľovali. Vždy vyhodíme niečo, čo zbytočne prechádzame. Takto vieme často nájsť použiteľné riešenia. Pamäťová zložitosť bola vo všetkých prípadoch $O(f+h)$, nakoľko sme si pamätali iba načítané reťazce a konštantne veľa pomocnej pamäte.
",4
3faa137bc449f463,ksp,"# Telefonát

""Čau Radka, už si sa začala učiť na maturity?"" ozvalo sa zo slúchadla.

""Blázniš?! Však je polka leta. Aktuálne ma trápi iba to, ako budem čo najdlhšie spať, a kde sa pôjdem kúpať.""

""No hej... Ale vieš, že tohtoročné maturity pripravuje Žaba. To nebude také ľahké. A ak chceš aby ťa zobrali na informatiku na najlepšej škole -- matfyze^\[[https://fmph.uniba.sk/studium/prijimacie-konanie/univerzitna-elektronicka-prihlaska/](https://fmph.uniba.sk/studium/prijimacie-konanie/univerzitna-elektronicka-prihlaska/)\] -- bez prijímačiek, musíš mať z maturity 1.""

""Prosím ťa. Na to aby ťa zobrali na matfyz stačí byť úspešným riešiteľom olympiády v informatike, teda získať 10 zo 40 bodov. Malina. A ešte sa na dva dni uleješ zo školy. Aj ty by si sa mala tento rok zapojiť, Rebeka.""

""Okrem toho,"" pokračovala Radka, ""videla som jedno z nových maturitných zadaní. Spočítaj ciferný súčet zadaného čísla^\[Samozrejme, že Žaba by takúto ľahkú maturitnú otázku nepripravil. Čo je mäkký? Jeho maturanti budú musieť poznať aj [Mersenove prvočísla](https://sk.wikipedia.org/wiki/Mersennovo_prvo%C4%8D%C3%ADslo).\]. Mala som to naprogramované za 3 minúty. Však pozri, poslala som ti kód v správe.""

""Počuj, Radka,"" opáči Rebeka. ""Určite to máš dobre? Však tam máš `*` namiesto `+`.""

""Ale však na všetkých vstupoch to fungovalo. Pre 22 vráti 4. Pre 1142 číslo 8...""

""No hej, ale mám pocit, že to je skôr náhoda. Však pre 33 vypíšeš 9, ale správne by to malo byť 6.""

""Hmmm... máš pravdu. Ale aj tak, skúšala som si to na fakt veľa vstupoch a vždy to dávalo správne výsledky.""

""Asi preto, že sa ti vždy podarilo trafiť číslo, ktorého ciferný súčet aj súčin sú rovnaké. Mala si len šťastie, alebo je takých čísel ozaj tak veľa?"" zaujímalo Rebeku.

""Neviem, ale určite sa to dá vypočítať!""

## Úloha

Samozrejme, čísel, ktoré majú rovnaký ciferný súčet aj súčin je nekonečne veľa. A ak to samozrejmé nie je, tak si to skúste rozmyslieť. Zistovať ich počet by preto nebola zaujímavá KSP úloha. Zaujímavé je ale zisťovať, koľko prirodzených čísel má ciferný súčet aj súčin rovný číslu $n$.

## Formát vstupu

Na jedinom riadku vstupu je zadané číslo $n$. V ôsmych testovacích sadách platia pre toto číslo nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:------------------- | ----:| -----:| -----:| --------:| ---------:| ----------:| ----------:| ----------:| | $n \\leq$ | $10$ | $100$ | $500$ | $1,000$ | $50,000$ | $100,000$ | $300,000$ | $300,000$ |

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet prirodzených čísel, ktorých ciferný súčet aj ciferný súčin je rovný číslu $n$. Keďže takýchto čísel môže byť naozaj veľa, vypíšte ich počet modulo $10^9 + 7$.

## Príklad

```vstup
4
```

```vystup
2
```

_Dve čísla, ktorých ciferný súčet aj súčin je 4 sú čísla 22 a 4._

```vstup
8
```

```vystup
23
```

_Jednou z možností je číslo 1142._

```vstup
72
```

```vystup
100110164
```
","# Telefonát

Na začiatok si uvedomme, že ciferný súčin nám dáva akýsi rozklad čísla $n$ na súčin, ktorého každý člen tvorí samostatná cifra. To ale znamená, že v prvočíselnom rozklade čísla $n$ (čo je jemnejší rozklad) sa môžu nachádzať iba prvočísla menšie ako 10. V opačnom prípade číslo s daným ciferným súčinom neexistuje a odpoveď je 0.

## Neprvočíselné cifry a ciferný súčet

Medzi ciframi našeho čísla sa môžu nachádzať aj neprvočíselné hodnoty, preto nám rozklad $n$ na prvočísla nedá jednoznačnú sadu cifier, ktorú musíme použiť. Toto sa týka cifier 4, 6, 8 a 9, v našom riešení sa preto budeme musieť rozhodnúť, koľko prvočísel 2 a 3 použijeme na ich vytváranie. Presnejšie, budeme sa musieť rozhodnúť, koľko cifier 4, 6, 8 a 9 chceme mať vo výslednom čísle.

Zabudnúť nemôžeme ani na druhú podmienku zadania -- ciferný súčet, ktorý sa tiež musí rovnať $n$. Ciferný súčet je však väčšinou oveľa menší ako súčin, číslo preto vieme doplniť potrebným počtom cifier 1, ktoré ciferný súčin nemenia.

## Ako vybrať sadu použitých cifier?

Koľko možností máme na výber počtu jednotlivých cifier? Vieme napríklad, že nemôžeme použiť žiadnu cifru 0, pretože celý ciferný súčin by bol tiež 0. A keďže poznáme prvočíselný rozklad $n$, vieme, že naše číslo musí obsahovať rovnaký počet 5 a 7 ako je v tomto rozklade. Otázne sú iba cifry 4, 6, 8 a 9, keby sme vedeli, koľko ich bude vo výsledku, počet 2 a 3 si vieme dopočítať z celkového počtu týchto čísel v rozklade.

Skúsime teda všetky možnosti, lebo vieme, že maximálny počet jednej cifry môže byť najviac $\\log n$, keďže ich súčin nesmie presiahnuť hodnotu $n$. Určením týchto cifier sú už všetky ostatné jednoznačne dané, počet 1 dopočítame tak, aby sedel ciferný súčet (ak by nám tento počet vyšiel záporný, tak počty ostatných cifier nevyhovujú žiadnemu číslu).

## Koľko možných čisiel máme pre danú sadu cifier?

Keď už vieme koľko jednotlivých cifier chceme použiť v našom čísle, potrebujeme zvoliť ich poradie. To totiž nemení ciferný súčet ani súčin, chceme preto zarátať všetky možné preusporiadania. Toto je už však pomerne ľahká kombinatorická úloha, ak si počet cifry $i$ označíme ako $P_i$ a počet všetkých cifier dokopy ako $x$, počet preusporiadaní je:

$$\\binom{x}{P_1} \\binom{x-P_1}{P_2} ... \\binom{x-P_1- ... - P_8}{P_9} = \\frac{x!}{P_1! P_2! ... P_9!}$$.

Na daný vzorec sa môžete pozerať cez kombinačné čísla (ľavá strana), keď si postupne volíme na ktoré pozície dáme ktoré cifry a počet voľný pozícií sa zmenšuje, alebo ako na permutácie s opakovaním (pravá strana), kde najskôr započítame všetky možné preusporiadania a potom odstraňujeme (delíme) tie, kde sme iba zmenili poradie rovnakých cifier.

Celkový počet cifier bude kvôli cifernému súčtu určite najviac $n$ a preto si vieme predpočítať všetky faktoriály až po hodnotu $x$ dopredu a to dokonca modulo $10^9+7$. Tu však nastáva problém, pretože v okamihu, keď začneme čísla modulovať, normálne delenie prestane správne fungovať. Našťastie, na vyriešenie tohto problému poznáme pomerne klasickú techniku **inverzných prvkov**. Pre každý faktoriál si vypočítame aj jeho inverzný prvok a keď týmto faktoriálom potrebujeme deliť, namiesto toho delené číslo vynásobíme inverzným prvkom delenca. Keďže hodnota $p=10^9+7$, ktorú používame na modulovanie je prvočíslo platí, že inverzný prvok čísla $a$ je rovný $a^{p-2}$.

V prípade, že sa chcete o inverzných prvkoch dozvedieť niečo viac, prečo ich potrebujeme a počítame práve daným spôsobom, navštívte našu kuchárku a prečítajte si článok o [Počítaní modulo prvočíslo](https://www.ksp.sk/kucharka/modularna_aritmetika/).

## Časová a pamäťová zložitosť

Najprv si potrebujeme predpočítať všetky faktoriály a ich inverzy, čo nám zaberie $O(n \\log p)$ času ($p = 10^9+7$), keďže na vypočítanie inverzu čísla ho musíme umocniť na $p-2$, čo vieme spraviť v logaritmickom čase. Následne musíme vygenerovať všetky možné počty cifier 4, 6, 8 a 9, každej z nich môže byť najviac $O(\\log n)$, čo dáva dokopy zložitosť $O(\\log^4 n)$. Počty týchto cifier jednoznačne určujú počty zvyšných cifier, ostáva teda výpočet všetkých preusporiadaní vybranej sady cifier. To vieme spraviť v konštantnom čase, keďže faktoriály a ich inverzy už máme predpočítané. Celková časová zložitosť našeho riešenia je $O(n \\log p)$.

V pamäti musíme mať predrátané všetky faktoriály, teda pamäťová zložitosť bude $O(n)$
",9
f7ad198b8bd9383d,ksp,"# Zákerní súrodenci

Alžbetka má malú sestru. Jedného dňa sa Alžbetka rozhodla vyrobiť náhrdelník z korálok. Jej malá sestra pri tom samozrejme nemohla chýbať a musela jej pomôcť. Na začiatku Alžbetka navliekla na šnúrku nejaké korálky. Podľa jej sestry to však spravila úplne zle a teda musí vymeniť túto korálku za novú, a tamtú tiež...^[Áno, správne ste uhádli. Alžbetka musí vždy vyvliecť väčšinu korálok aby sa k tej ""zlej"" korálke vôbec dostala. A potom ich dať zase späť. Ale to v tejto úlohe vôbec nie je podstatné.] Veď poznáte malé sestry.

Alžbetka by bola rada, keby ten náhrdelník vyzeral aspoň trochu dobre. Napríklad aby bol symetrický. Pri všetkom tom vymieňaní korálok by teda chcela vedieť, kedy sa tak stane.

## Úloha

Jednotlivé druhy korálok budeme reprezentovať malými písmenami anglickej abecedy `a-z`. Na začiatku dostanete popis náhrdelníka -- nejaký reťazec znakov, ktorý popisuje jednotlivé korálky v náhrdelníku. Postupne v ňom budeme vymieňať korálky za iné. Po každej takejto výmene povedzte, či je daný reťazec symetrický -- tj. či sa odzadu číta rovnako ako spredu.

## Formát vstupu

V prvom riadku vstupu je reťazec dĺžky $n$ ($1 \\leq n \\leq 100,000$) -- popis pôvodného náhrdelníka. V druhom riadku je číslo $q$ ($1 \\leq q \\leq 100,000$) -- počet zmien, ktoré nastanú. Ďalších $q$ riadkov bude obsahovať medzerou oddelené číslo a znak -- pozícia korálky, ktorú treba vymeniť (číslujeme od $0$) a druh (písmeno), na ktorý sa má korálka zmeniť.

## Formát výstupu

Na výstup vypíšte $q$ riadkov, pričom každý bude obsahovať buď `""ano""` alebo `""nie""` (bez úvodzoviek) podľa toho, či je reťazec po danej zmene symetrický, alebo nie.

Pozor na veľkosť vstupu a výstupu. S pomalým načítavaním/vypisovaním môžete dostať hlášku `""TLE - Prekročený časový limit""` aj s inak rýchlym riešením.

## Príklady

```vstup
abcabc
3
0 c
2 a
3 c
```

```vystup
nie
ano
nie
```

\_Po prvej zmene bude reťazec vyzerať takto: cbcabc, čo nie je symetrické. Po druhej zmene bude vyzerať takto: cbaabc, čo symetrické je. Treťou zmenou nám to sestra pokazí a reťazec opäť nebude symetrický. \_

```vstup
ppppp
2
2 a
3 p
```

```vystup
ano
ano
```

\_Prvou zmenou sme zmenili znak v strede; reťazec ostane symetrický. Druhou zmenou zmeníme p na p; reťazec ostane rovnaký. \_
","# Zákerní súrodenci

Prvé a najľahšie riešenie, ktoré nám napadne, je vykonávať operácie a po každej zmene skontrolovať, či je reťazec palindróm^[Palindróm je reťazec, čo sa číta odzadu rovnako ako spredu.] alebo nie. Pri kontrole možného palindrómu nás vždy^[Okrem prípadu, keď je reťazec nepárnej dĺžky.] zaujímajú dvojice znakov - prvý a posledný, druhý a predposledný, atď. Aby bol reťazec palindrómom, musia byť všetky tieto dvojice zhodné.

Keď sa pokúsime pri každej zmene prechádzať celý reťazec, zistíme, že je to príliš pomalé. Každé skontrolovanie, či je reťazec momentálne palindróm, si totiž v najhoršiom prípade (ak palindróm je) vyžaduje $O(n)$ porovnaní znakov. Celé to teda nášmu programu môže trvať až $O(n \\times q)$, čo nestíhame.

Čo robíme navyše? Keďže sa nám vždy mení len jeden znak, nie je vôbec potrebné kontrolovať zvyšok reťazca; ten bude presne taký ako pred danou zmenou.

Pozrime sa radšej na ten znak, ktorý meníme a na jeho náprotivok. Zaujíma nás, ako sa zmenil stav dvojice: z rovnakej na rozdielnu, z rovnakej na rovnakú, z rozdielnej na rovnakú alebo z rozdielnej na rozdielnu.

Chceme teraz zistiť, kedy nastane situácia, že každá dvojica je zhodná. Na začiatku si prejdeme celý reťazec a budeme si pamätať, koľko párov sa navzájom nezhoduje. Pri každej zmene znaku toto číslo príslušne upravíme: ak sme si nejakú dvojicu pokazili, tak počet zlých párov stúpne a ak sme si dvojicu opravili, počet zlých dvojíc klesne. Treba si dať pozor, aby sme hodnotu nemenili, ak sa zmení rozdielny na rozdielny alebo rovnaký na rovnaký! Keď máme počet nezhôd $0$, vieme, že náš reťazec je palindróm.

Načítanie a prvotné spočítanie nezhodných dvojíc nám zaberie $O(n)$ krokov, a každú z $q$ otázok vyriešime a odpovieme v $O(1)$ -- časová zložitosť je teda $O(n+q)$.

V oboch riešeniach sme si museli pamätať celý reťazec, ale otázky stačilo riešit postupne, teda sme si mohli pamätať len jednu otázku naraz. To nám udáva pamäťovú zložitosť $O(n)$.
",2
598bdc613bb16cac,ksp,"# Úžasná lyžovačka

Kristína a Aďo sa vybrali na lyžovačku do Tatier. Bohužiaľ, kvôli pandemickým opatreniam sú všetky vleky a lanovky vypnuté. Sú ale odhodlaní lyžovať sa aj za cenu toho, že si budú musieť kopec zakaždým vyšliapať po svojich. Aby sa ale nestratili, budú kráčať po iba po svahoch medzi stanicami lanoviek.

Po prvom výstupe ale zistili, že šliapať do kopca v lyžiarkach je nesmierne náročné, a že čím strmší kopec je, tým viac sú potom vyčerpaní. Aby si ušetrili čo najviac energie na zjazdy, rozhodli sa, že hore radšej pôjdu po čo najmenej strmých kopcoch aj za cenu toho, že ich cesta bude dlhšia.

Samozrejme, ak sa niekde počas ich cesty na vrch objaví úsek na ktorom pôjdu dole kopcom, neváhajú a spustia sa na lyžiach. Je tu ale jeden drobný problém -- Aďo je začiatočník a preto nerád jazdí po strmých kopcoch. Chcel by teda, aby aj dole išli po čo najmenej strmých kopcoch.

Zapozerali sa teda do mapy strediska a začali hľadať čo najmenej strmú cestu na kopec, ktorý si vybrali. Stredisko je ale príliš veľké, a tak to po chvíľke vzdali. Keby si tak zobrali so sebou počítač, určite by niečo vymysleli. Ten ale nemajú a preto potrebujú vašu pomoc.

## Úloha

Stredisko pozostáva z $v$ staníc lanoviek, pričom poznáme nadmorské výšky každej z nich. Na jednej z nich, označenej číslom $s$, stoja Kristína a Aďo, ktorí sa chcú dostať na kopec so stanicou s číslom $f$.

V stredisku je $e$ svahov, z ktorých každý spája dve stanice lanoviek, pričom poznáme vzdušnú vzdialenosť staníc ktoré spája. Uvažujeme, že svah je na celom svojom úseku rovnako strmý a jeho strmosť je určená podielom rozdielu prevýšení staníc a jeho vzdušnou vzdialenosťou.

Vašou úlohou je nájsť takú cestu z $s$ do $f$, aby maximálna strmosť svahov na tejto ceste bola čo **najmenšia**.

## Formát vstupu

Na prvom riadku dostanete štyri čísla $v, e, s, f$, kde $v$ je počet staníc lanoviek, $e$ je počet svahov v stredisku, $0 \\leq s < v$ je číslo stanice lanovky na ktorej Kristína a Aďo začínajú a $0 \\leq f < v$ je číslo stanice, na ktorú sa chcú dostať. (Stanice lanoviek sú číslované od $0$.)

Nasleduje $v$ riadkov, kde každý riadok obsahuje celé číslo $h_i$ -- nadmorskú výšku $i$-tej stanice lanovky.

Ďalších $e$ riadkov obsahuje tri celé čísla $a_j, b_j, d_j$, kde $a_j$ a $b_j$ sú čísla staníc prepojených $j$-tým svahom a $d_j$ je vzdušná vzdialenosť staníc $a_j$ a $b_j$.

## Formát výstupu

Vypíšte jediné číslo -- strmosť najstrmšieho svahu na ceste z $s$ do $f$, s presnosťou na práve dve desatinné miesta.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |-----------------|-----:|------:|---------:|----------:| | $1 \\leq v \\leq$ | $20$ | $100$ | $2,500$ | $9,000$ | | $1 \\leq e \\leq$ | $50$ | $500$ | $5,000$ | $20,000$ |

## Príklad

```vstup
4 6 0 3
10
40
50
220
0 1 100
0 2 100
1 2 50
1 3 150
2 3 250
0 3 100
```

```vystup
0.68
```

*Vhodné cesty sú $[0, 1, 2, 3]$ a $[0, 2, 3]$. Obe cesty sú ale rovnako dobré, keďže majú rovnakú najstrmšiu časť -- svah medzi stanicami $2$ a $3$.*
","# Úžasná lyžovačka

Už na prvý pohľad je asi vcelku zrejmé, že lyžiarske stredisko si vieme predstaviť ako neorientovaný ohodnotený graf, v ktorom stanice lanoviek budú vrcholmi a svahy hranami grafu. Ceny hrán budú strmosti svahov, ktoré si vypočítame už pri načítavaní vstupu.

## Priamočiare riešenie

Môžeme si všimnúť, že na nájdenú cestu nemáme žiadne ďalšie nároky, okrem toho že existuje. Najjednoduchšie riešenie teda spočíva v tom, že z grafu odstránime všetky hrany a budeme ich postupne pridávať v poradí od najmenej strmej. Po každom pridaní hrany skontrolujeme, či neexistuje cesta medzi $s$ a $f$. V momente, ako takúto cestu nájdeme, môžeme skončiť, keďže všetky ďalšie hrany, ktoré by sme pridali by mali vyššiu strmosť. Naopak, lepšie riešenie tiež nemôže existovať, keďže by sme ho už našli skôr. Zároveň už poznáme aj najstrmšiu hranu v nájdenej ceste -- je ňou posledná pridaná hrana.

V našej implementácii nám bude teda stačiť, keď si po načítaní uriedime hrany podľa strmosti, v cykle ich budeme pridávať do grafu (ideálne reprezentovaného ako zoznam susedov) a existenciu cesty overíme napríklad pomocou BFS (prehľadávania do šírky). Časová zložitosť takéhoto riešenia je $O(e \\cdot (v + e))$. V najhoršom prípade totiž postupne pridáme do grafu všetky hrany, čo znamená, že BFS budeme musieť spustiť až $e$-krát. Pamäťová zložitosť je $O(v + e)$.

Za implementáciu s maticou susedov ste mohli dostať až 4 body, za šikovnú implementáciu so zoznamom susedov dokonca až 6 bodov.

## Ako to zrýchlime?

Z predchádzajúceho riešenia už asi tušíme, že hlavný problém je v počte spustení BFS. Naozaj musíme pridávať hrany po jednej a zakaždým skúšať, či existuje riešenie? Samozrejme, že nie!

To, čo sme robili v predchádzajúcom riešení si môžme predstaviť aj trochu inak: V podstate sme hľadali posledný prvok najmenšieho prefixu **utriedeného** poľa hrán $[e_0, e_1, \\ldots, e\_{max}]$ takého, že s pomocou týchto hrán je možné vytvoriť cestu z $s$ do $f$. No, a keďže je pole už utriedené, namiesto skúšania všetkých hrán si tú správnu hranu môžeme nájsť binárnym vyhľadávaním.

Samotné binárne vyhľadávanie bude prebiehať takmer rovnako ako na obyčajnom poli: Prehľadávanú oblasť rozdelíme v polovici a vyberieme prostrednú hranu $e\_{mid}$. Vyskúšame, či podgraf s hranami $e_0$ až $e\_{mid}$ obsahuje cestu z $s$ do $f$. Ak áno, budeme znovu binárne prehľadávať ľavú polovicu (keďže chceme nájsť najmenej strmú hranu, ktorú potrebujeme).

Vďaka binárnemu vyhľadávaniu potrebujeme spustiť BFS už len $\\log{e}$-krát, čiže výsledná časová zložitosť bude $O((v + e) \\cdot \\log{e})$. Pamäťová zložitosť sa oproti predchádzajúcemu riešeniu nezmenila.

## Riešenie s kostrami

Táto úloha sa dala riešiť aj trochu inak: Ak si na začiatku nájdeme minimálnu kostru grafu reprezentujúceho lyžiarske stredisko, dostaneme vlastne graf, v ktorom už nie sú žiadne nadbytočné drahšie hrany. Medzi každou dvojicou vrcholov teda bude existovať už len jedna cesta, ktorej maximálna strmosť bude najmenšia možná. Na to, aby sme túto cestu našli nám opäť bude stačiť BFS alebo podobný algoritmus.

Navyše, ak si mierne upravíme Kruskalov algoritmus, nebudeme dokonca potrebovať ani BFS. Rovnako ako v Kruskalovom algoritme budeme postupne pridávať najlacnejšie hrany, pričom každá nová hrana nám spojí dva komponenty grafu. Ak sa nám teda niekedy vyskytnú vrcholy $s$ a $f$ v rovnakom komponente, vieme, že existuje medzi nimi cesta. Stačí nám teda po každej pridanej hrane skontrolovať v akých komponentoch sú $s$ a $f$. A keďže nehľadáme minimálnu kostru, cykly v grafe nám nevadia a nemusíme dokonca ani vynechávať hrany.

Takéto riešenie má časovú zložitosť iba $O(e \\log e)$. Toto riešenie by sa dalo ešte zrýchliť efektívnejšou implementáciou Union-Find až na $O(e \\log^\* e)$^[$\\log^\*$ je iterovaný logaritmus]. Pamäťová zložitosť zostáva stále rovnaká, čiže $O(v + e)$.
",6
b9c2d252825e4ac4,ksp,"# Keď už je to po ceste...

V Manhattane kedysi stáli dvojičky. Kolumbus objavil Ameriku, one thing led to another a dvojičky dnes už v Manhattane nestoja. Finančníci, ktorí v dvojičkách pracovali, sa rozpŕchli po celom Manhattane.

Nieje nad vzťah založený na peniazoch, a tak ešte dodnes neustále medzi sebou kadečo vybavujú -- odcestujú na nové pracovisko ich známeho, prehrabnú sa v kufríku plnom papierov, podpíšu niečo čo nikto nikdy nečítal, a vrátia sa naspäť do práce. A keď sa vydarí, po ceste sa ešte zastavia u kamaráta, vypijú kávu, zaspomínajú na strašidelné časy kedy si aj úplne obyčajní ľudia vedeli dovoliť nový, priestorný byt, a pokračujú v pracovnej ceste. Svojim nadriadeným toto drobné zdržanie vysvetlia ako zápchu v poludňajšej New Yorkskej^[Kedy ste naposledy videli v slove 'rksk'?] premávke, a veselo si celú cestu pripíšu do firemného času.

Ale takéto výhovorky nefungujú vždy -- ak by kvôli priateľskej návšteve finančník robil dajaké obkľuky, určite by mu na to nadriadení prišli^[pomocou GPS trackingu firemných vozidiel]. Takúto zastávku sa teda odhodlajú urobiť len vtedy, keď nezvýšia prejdenú vzdialenosť k ich ozajstnej destinácií.

FKS^[Finačný Korupčný Sektor] sa rozhodol vyčísliť, koľko takýchto návštev môže denne prebiehať. Vrámci znižovania nákladov však programátorské práce outsourceli na Slovenské stredné školy...

## Úloha

Všetky budovy Manhattanu perfektne zapadajú do štvorčekovej mriežky.

Zadané sú súradnice budov v Manhattane, v ktorých pracujú finančníci.

Keďže sú v Manhattane, vzdialenosť medzi budovami je samozrejme Manhattanovská -- budova so súradnicami $(x_1 , y_1)$ je od budovy so súradnicami $(x_2 , y_2)$ vzdialená $|x_1 - x_2| + |y_1 - y_2|$.

Finančník cestujúc z budovy A do budovy B sa môže po ceste zastaviť pri budove C práve vtedy, keď vzďialenosť budov A a B je rovná vzdialenosti budov A a C plus vzdialenosti budov C a B.

Vyhodnotťe, koľko rôznych pocestných návštev sa môže v Manhattane odohrať. Dve návštevy považujeme za rôzne ak sa líšia v štartovnej, cieľovej, alebo navštívenej budove.

## Formát vstupu

V prvom riadku je číslo $n$ -- počet finančníkov v Manhattane. Každý z nasledujúch $n$ riadkov obsahuje dve celé čísla $x_i\\ y_i$ -- súradnice budovy, v ktorej pracuje $i$-ty finančník. Súradnice budov sú navzájom rôzne.

Pre testovacie sady pritom platí nasledovné:

| Sada | 1 | 2 | 3 | 4 | |:------------------ | ----: | --------: | ----------: | -------------:| | $1\\leq n\\leq$ | $200$ | $2,000$ | $200,000$ | $200,000$ | | $0\\leq x_i, y_i\\leq$ | $1,000$ | $1,000$ | $1,000$ | $1,000,000$ |

## Formát výstupu

Vypíšte jediné číslo -- počet rôznych návštev, ktoré medzi sebou dokážu finančníci urobiť.

## Príklady

```vstup
3
2 2
3 2
4 2
```

```vystup
2
```

*Návštevu v druhej budove si môžu dovoliť finančníci cestujúci z prvej do tretej budovy, a naopak.*

```vstup
4
2 2
3 2
4 2
1 1
```

```vystup
8
```

*Teraz môžu navyše prvú budovu navštíviť finančníci zo štvrtej budovy na ceste do druhej alebo tretej (a naopak), a druhú budovu na ceste do tretej (a naopak).*
","# Keď už je to po ceste...

## Ako vždy, hrubá sila

Chceme vediet počet usporiadaných trojíc bodov (A,B,C) pre ktoré platí, že súčet Manhattanovských vzdialeností medzi A,B a B,C je rovný Manhattanovskej vzdialenosti medzi A a C.

Tak ich poďme všetky vyskúšať - v troch vnorených cykloch prejdeme všetky body, overíme či rovnosť sedí, a ak áno, pripočítame odpoveď.

Počet rôznych trojíc bodov, ktoré vyskúšame, je $O(n^3)$. Nemusíme si pritom pamätať nič okrem samotných bodov a zopár pomocných premenných, máme teda pamäť $O(n)$.

Toto by nám malo stačiť na prvú sadu, kde $n \\leq 200$.

### Poznámka o súradniciach

Doleuvedené riešenia budú záležať od veľkosti súradníc. Pre zjednodušenie zložitostí si teda môžeme uvedomiť, že ozajstné súradnice nás až tak nezaujímajú, iba ich relatívne poradie. Môžeme si teda x-ové aj y-ové súradnice na vstupe osobitne prečíslovať od $0$ po $n-1$ v $O(nlogn)$, a ďaľšia práca záležiaca na súradniciach bodov už bude $O(n)$. Keď sú súradnice menšie ako $n$, ponecháme ich tak a použijeme notáciu $O(s)$.

## Postavíme Manhattan

Kedy platí požadovaná rovnosť pre body (A,B,C)? Kedy je cesta od A do B a B do C rovnako dlhá, ako priama cesta z A do C? Optimálna cesta z A do B, kde BÚNV. A je naľavo hore od C, je nejaká postupnosť krokov dĺžky jedna dole a vpravo, pričom nikdy neprekročíme súradnice bodu C. Keďže táto postupnosť krokov je ľubovoľná (nezáleží v akom poradí tieto kroky spravíme, len aby bol správny počet krokov dole a správny počet vpravo), môžeme pritom navštíviť ľubovoľný bod B ktorý je v obdĺžniku s bodmi A a C ako rohmi.

Pre každú dvojicu bodov by sme teda chceli vedieť odpovedať na otázku: Koľko bodov leží v obdĺžniku určenom týmito dvoma bodmi?

Toto je presne tá otázka, na ktorú vie efektívne odpovedať 2D prefixový súčet, o ktorom si [môžete prečítať v kuchárke](https://www.ksp.sk/kucharka/2d_prefixove_sumy/).

Spravíme si teda mriežku núl, na súradnice bodov pripočítame jedna, a spravíme na nej 2D prefixový súčet.

Teraz jednoducho prejdeme všetky dvojice bodov, a pre každú k odpovedi pripočítame počet bodov v obdĺžniku medzi nimi, mínus dva (keďže v obdĺžniku sa nachádzajú aj naše rohové body). Keďže každý platný bod B s rohmi A a C patrí do trojice (A,B,C) aj (C,B,A), nakoniec náš výsledok ešte prenásobíme dvomi.

Naša mriežka musí mať riadok/stĺpec pre každú možnú súradnicu. Naša mriežka teda má veľkosť $O(n^2)$,

Keďže vytvárame mriežku veľkosti $n^2$, a prechádzame všetky dvojice bodov (pre ktoré spravíme $O(1)$ operáciu v 2D prefixej mriežke), naša časová zložitosť je $O(n^2).

Pamäťová je priamočiaro $O(n^2)$.

## Opačná otázka

Limitujúci faktor v našom riešení je, že musíme vyskúšať všetky dvojice bodov (a spočítať koľko bodov je v obdĺžniku medzi nimi).

Vieme túto otázku otočiť naopak, a zistiť pre každý bod, koľko dvojíc bodov tvorí obdĺžnik, v ktorom leží?

Samozrejme že to bola básnická otázka, inak by nebola vo vzoráku, všakže?^[aj to je básnická otázka]

Poďme sa nad ňou teda zamyslieť. Obdĺžnik ktorý obsahuje nejaký bod B musí mať jeden roh nad ním (alebo zarovno), a druhý roh pod ním (alebo zarovno). Nápodobne, musí mať jeden roh naľavo od neho (alebo zarovno), a druhý roh napravo (alebo zarovno).

Ak skúsime tieto štyri podmienky zlúčiť do dvoch bodov, získame len dve možnosti: buď je jeden roh naľavo hore a druhý napravo dole, alebo je jeden roh napravo hore a druhý naľavo dole. Všetky takéto dvojice bodov sú rohmi obdĺžnika, ktorý náš bod obsahuje.

Prejdime teda všetky body, a pre každý vynásobme počet bodov naľavo hore s bodmi napravo dole, a počet bodov napravo hore s bodmi naľavo dole, a tieto dve čísla sčítajme. Úspešne sme započítali všetky obdĺžniky, ktoré obsahujú náš bod! Nanešťastie, niektoré sme započítali viackrát. Sú to práve tie, v ktorých oba body majú jednu zo súradníc rovnakú ako náš bod. Napríklad bod ktorý je priamo nad našim zvoleným, sme započítali v obdĺžnikoch s druhým rohom naľavo dole aj napravo dole, pričom v oboch prípadoch sme pripočítali body ktoré sú priamo pod ním. Musíme ich teraz raz odpočítať. Od našeho výsledku teda ešte odpočítame počet bodov priamo nad našim bodom krát počet bodov priamo pod ním, a nápodobne s bodmi priamo naľavo a napravo.

Všetky tieto otázky sú na počty bodov v obdĺžnikoch, čiže ich hravo zodpovieme 2D prefixovými súčtami v konštantnom čase.

Stále vytvárame mriežku so všetkými súradnicami, čiže $O(s^2)$.

Každý bod teraz spracujeme len raz, pričom sa popýtame na konštantne veľa obdĺžnikov v našich 2D prefixoch, a teda aj časová zložitosť je rovnaká.

## Vzorák

Keď však súradnice narastú, máme už problém aj s $O(s^2)$ aj s $O(n^2)$ mriežkou. 2D prefixy nám už nestačia.

Zamyslime sa teda trochu nad informáciou ktorú potrebujeme, aby sme pripočítali k odpovedi cesty prechádzajúce cez daný bod. Potrebujeme vedieť počet bodov presne nad ním a pod ním, počet bodov presne naľavo a napravo od neho, a počet bodov vľavo/vpravo a hore/dole od neho. Ak si teda túto informáciu nevieme získať pre všetky body naraz (postavením 2D prefixov), možno si ju vieme postupne prepočítavať od jedného bodu k druhému? Tento prístup nás v tomto prípade dovedie k riešeniu.

Poďme skúsiť prechádzať bodmi zhora-dole, zľava-doprava, a udržovať si všetku potrebnú informáciu pre bod, ktorý práve spracúvame. Na začiatku, pred spracovaním prvého bodu, sú akoby všetky bod pod nami. Vytvorme si teda pole `dole`, ktoré na súradnici $x$ bude udržovať počet bodov pod bodom, ktorý práve spracúvame, a s x-ovou súradnicou $x$. Pred tým ako začneme spracovávať si doň zapíšeme všetky body. Nápodobne si vytvorme pole `hore`, ktoré bude udržiavať počet bodov nad bodom ktorý práve spracúvame, ktoré je najprv plné núl.

Postupne ako budeme prechádzať bodmi zhora-dole, si ich budeme odpočítavať z poľa `dole` a pripočítavať do poľa `hore`. Toto nám dá skoro všetku informáciu čo potrebujeme - vieme spočítať počet bodov napr. naľavo dole od práve spracúvaného bodu $(x,y)$ ako súčet poľa `dole` od súradnice $0$ po $x$, a napr. napravo hore ako súčet poľa `hore` od $x$ po maximum zo vstupu. Počet bodov priamo nad/pod našim bodom je priamo `hore[x]`, resp. `dole[x]`.

Jediné čo nám ostáva je vyriešiť správanie bodov s rovnakou $y$ súradnicou. Jedna možnosť je napríklad spracovávať všetky body s rovnakou výškou naraz - pridať ich `hore`, spočítať požadované obdĺžniky, odpočítať počet bodov priamo vľavo a vpravo (keďže spracovávame všetky v jednom prechode, udržujeme si túto informáciu), a nakoniec ich všetky jednotne odpočítať z `dole`.

Aby sme si polepšili s časovou zložitosťou, naše polia `dole` a `hore` budú musieť vedieť sčítavať čísla v intervale, a meniť hodnoty na jednotlivých súradniciach, v lepšom čase ako $O(n)$ resp. $O(s)$. Použijeme teda nejakú vhodnú dátovú štruktúru, ako [Intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/) alebo [Fínsky strom](https://en.wikipedia.org/wiki/Fenwick_tree).

Budeme si pamätať naše body a polia zhruba také veľké, akú máme najväčšiu súradnicu -- ak použijeme kompresiu, je to $n$, čiže pamäťová zložitosť je $O(n)$.

Body musíme usporiadať, prípadne spraviť kompresiu súradníc, čo nám zaberie $O(n \\log n)$. Následne všetky body prejdeme, a každý konštantne veľa krát pridáme/odpočítame z intervalového stromu, a zakaždým spravíme konštantne veľa súčtov na tomto strome. Všetky tieto operácie zaberú $O(\\log n)$, čiže dokopy taktiež $O(n \\log n)$.
",9
5f814f86963ffae8,ksp,"# Zajtra dávam výpoveď!

Myslíte si, že programovanie v skutočnej softvérovej firme bude jednoduché? Syseľ si to myslel tiež. Postupne si však uvedomuje, ako veľmi sa mýlil.

Syseľ je zamestnaný vo firme *Kontra Systémové Programy* a na vlastnej koži zažíva, čo je to život programátora z povolania. Každé ráno sa mu vo dverách objaví šéf a hromovým hlasom zvolá všetky nové požiadavky, ktoré by mal Syseľ splniť.

Jedno ráno príde a zahuláka: ""Nech sú tie tlačidlá oblejšie! Nech to načítavanie trvá trochu dlhšie, veď to vyzerá, ako keby ten program nič nerobil! Prečo to vôbec nepadá?"". A zvyšok dňa Syseľ tvrdo maká, aby vyhovel šéfovým požiadavkám. Na druhý deň šéf rozcapí dvere a zručí: ""Prečo sú tie tlačidlá také oblé? To načítavanie aj niekedy skončí? V tom programe sa nedá robiť! Každú chvíľu padá!"". A zvyšok dňa Syseľ znova tvrdo maká, aby vyhovel novým šéfovým požiadavkám. Najhoršie je, že Syseľ nemôže prepisovať kód, ktorý už je napísaný. To by potom budilo dojem, že šéfove požiadavky neboli konzistentné. Môže len na koniec dopisovať ďalšie a ďalšie riadky. Celý kód potom vyzerá ako [veľká guľa bahna](https://en.wikipedia.org/wiki/Big_ball_of_mud), má tisíce riadkov, ale šéf je spokojný!

Sysľov kolega Roman na tom nie je o nič lepšie. Roman určuje, akým číslom bude označená nová verzia Sysľovej aplikácie. Podobne ako sa predlžuje Sysľov program, toto číslo sa musí každý deň predĺžiť o jednu cifru, pričom jeho začiatok sa už nesmie meniť. Naviac, každé ráno si šéf zmyslí, čím má byť toto číslo deliteľné.

V minulosti šéf postupne vyberal čísla 1, 2, 3, 4, ... avšak pri verzii 3608528850368400786036725 sa nedalo pokračovať ďalej^[ Toto číslo je skvelé preto, že každé číslo pozostávajúce z jeho prvých $k$-cifier je deliteľné $k$. Napríklad 3608528850368 je deliteľné číslom 13, celé číslo je deliteľné 25. Dlhšie číslo s touto vlastnosťou neexistuje.] a šéf musel zastaviť vývoj aplikácie.

Pri novej aplikácii si šéf dáva väčší pozor a vyberá len čísla z rozsahu 1 až 10 a čísla nevyberá postupne zaradom, ale náhodne. No a Roman musí celé dni počítať správnu verziu programu. Vedeli by ste mu s tým pomôcť?

## Úloha

Dostanete postupnosť $n$ celých čísel v rozsahu $1$ až $10$ -- zoznam šéfových požiadaviek pre jednotlivé dni. Vypočítajte číslo, o ktorom pre všetky $i$ od $1$ po $n$ platí, že číslo, ktoré vznikne spojením prvých $i$ cifier tohto čísla je deliteľné $i$-tou šéfovou požiadavkou.

Ak je možností viacero, nájdite najmenšie z vyhovujúcich čísel.

## Formát vstupu

Na prvom riadku sa nachádza číslo $2 \\leq n \\leq 200,000$ -- počet šéfových požiadaviek. Na druhom riadku sa nachádza $n$ medzerami oddelených čísel $p_i$ -- šéfove požiadavky. Platí, že $1 \\leq p_i \\leq 10$. Čiastočné body samozrejme dostanete, aj keď vyriešite úlohu pre malé $n\\leq 9$, $n\\leq 18$, $n\\leq 100$, $n\\leq 10,000$ alebo $n\\leq 100,000$.

## Formát výstupu

Vypíšte jeden riadok, a na ňom jediné číslo -- najmenšie $n$-ciferné číslo $c$ také, že ak zoberieme prvých $i$ cifier z čísla $c$, tak takéto číslo bude deliteľné požiadavkou $p_i$.

Mimochodom, $n$-ciferné číslo pre $n \\geq 2$ nemôže mať prvú cifru nulu.

## Príklad

```vstup
10
1 2 3 4 5 6 7 8 9 10
```

```vystup
1020005640
```

*Odpoveď, bohužiaľ, nemôže byť prvých 10 cifier Romanovho skvelého čísla (3608528850), pretože to nie je **najmenšie** možné číslo vyhovujúce požiadavkám.*

```vstup
7
3 9 7 5 6 7 4
```

```vystup
3640212
```

```vstup
13
9 4 7 8 2 3 7 4 9 7 2 3 4
```

```vystup
9240000035012
```
","# Zajtra dávam výpoveď

Táto úloha sa dala riešiť viacerými spôsobmi. Ukážeme si výhody a nevýhody riešení, ktoré ste submitovali. Prvé z nich je nedostatočné, druhé vtipné ale správne, a tretie je správne a elegantné.

Hlavná myšlienka za všetkými riešeniami je nasledovná: postupne vypočítať výsledok po jednotlivých cifrách. To znamená, že najprv si vygenerujeme jednociferné číslo, ktoré spĺňa prvú požiadavku, potom k nemu pridáme ďalšiu cifru tak, aby spĺňalo druhú požiadavku, a tak ďalej. Týmto spôsobom postupne splníme všetky požiadavky, a keďže tie požadujú len deliteľnosť číslom od $1$ po $10$, tak sa nikdy nestane, že by nebolo možné požiadavku splniť. Toto tvrdenie si neskôr dokážeme.

Teraz sa postupne pozrieme na všetky spomínané riešenia.

## Skúšanie cifry

Toto je najjednoduchšie riešenie. Výsledok máme uložený v číselnej premennej a vždy, keď dostaneme novú požiadavku, pridáme k nemu novú cifru tak, aby sme požiadavku splnili.

Urobíme to tak, že budeme postupne skúšať všetky cifry od $0$ po $9$. Cifru pridáme k výsledku tak, že ho vynásobíme desiatimi a pripočítame cifru. Pridáme prvú (najmenšiu) cifru, ktorá spraví výsledok deliteľný číslom z požiadavky.

Jedna nevýhoda tohoto riešenia je zjavná: požiadaviek na vstupe môže byť až $200,000$. Keďže počet cifier výsledného čísla sa rovná počtu požiadaviek, tak je jasné, že ukladať si výsledok v číselnej premennej nie je veľmi dobrý nápad. Ani do 64-bitovej premennej (napríklad `long long int` v C++) sa nezmestí viac ako 20-ciferné číslo.

Samozrejme, máme tu Python, a v ňom sú predsa číselné premenné neobmedzené, nie? Áno, ale zistiť zvyšok po delení sedmičkou $200,000$ cifernému číslu dá zabrať aj Pythonu a program nestihne vypočítať výsledok v časovom limite.

Takéto riešenie mohlo dostať najviac $4$ body.

#### Zložitosť

V tomto riešení $n$-krát počítame zvyšky po pridaní každej možnej cifry. Počítanie zvyšku po delení má časovú zložitosť $O(n)$^[To, že operácie s číslami trvajú konštantne dlho môžeme tvrdiť vtedy, ak sú tieto čísla ohraničené konštantou, teda nezávisia od veľkosti vstupu.], kde $n$ je počet cifier čísla, z ktorého robíme zvyšok. Ostatné operácie, ktoré v programe robíme nemajú časovú zložitosť horšiu ako $O(n)$.

Preto je časová zložitosť tohoto programu $O(n \\cdot 10 \\cdot n)$, čo sa rovná $O(n^2)$.

Keďže si uchovávame celé výsledné číslo a toto číslo má na konci $n$ cifier, na jeho uloženie potrebujeme $O(n)$ pamäte.

## ""Orlojové"" riešenie

Z predchádzajúceho riešenia je jasné, že potrebujeme vymyslieť niečo lepšie. Slabina spomínaného riešenia je v tom, že zakaždým potrebujeme vypočítať zvyšok po delení celého výsledku, čo, okrem iného, spôsobuje zlú časovú zložitosť.

Jednoduchým vylepšením bude, že si o našom výsledku budeme pamätať nejaké informácie, aby sme rýchlo vedeli vypočítať zvyšok po delení. V riešení, ktoré viete vymyslieť na základe toho, čo ste sa učili na hodinách matematiky, si môžeme pamätať takéto informácie:

- paritu, pre deliteľnosť $2$
- ciferný súčet, pre deliteľnosť $3$, $9$
- posledné trojčíslie, pre deliteľnosť $4$, $5$, $8$, $10$
- deliteľnosť $6$ sa dá odvodiť z deliteľnosti $2$ a $3$
- zvyšok po delení $7$, pre deliteľnosť $7$

Keď si pamätáme tieto informácie, výsledok vieme generovať po cifrách tak, že postupne vyskúšame všetky cifry od $0$ po $9$ a na základe týchto informácii zistíme, či bude výsledok po pridaní danej cifry deliteľný číslom z požiadavky. Ak bude, tak cifru vypíšeme a aktualizujeme všetky tieto informácie.

#### Zložitosť

Keďže premenné, v ktorých si udržujeme vyššie popísané informácie dosahujú maximálne hodnoty nezávislé od veľkosti vstupu, tak práca s nimi je v konštantnom čase. Keďže musíme spracovať všetkých $n$ požiadaviek, tak časová zložitosť je $O(n)$.

Cifry výsledku môžeme vypisovať postupne, jednu po druhej, bez toho, aby sme si ich ukladali, teda pamäťová zložitosť môže byť až konštantná, $O(1)$^[V Pythone je ale rýchlejšie vypísať celý riadok naraz, než vypisovať po znakoch, a teda je lepším rozhodnutím pamätať si celé číslo a na konci ho vypísať].

## Zvyšky -- pôjde to aj jednoduchšie

Predošlé riešenie som nazval ""orlojové"", lebo je zbytočne zložité. Pamätáme si 4 odlišné informácie a implementácia tohto riešenia obsahuje množstvo `if - else` alebo `case` príkazov -- špeciálne prípady, v ktorých sa dá ľahko pomýliť.

Skúsme teda zjednodušiť myšlienku a tým aj implementáciu. Pre deliteľnosť sedmičkou sme si pamätali zvyšok po delení sedmičkou... A nedá sa to tak spraviť pre všetky cifry? Áno, dá! V tomto jednoduchšom riešení si budeme pamätať zvyšky po delení všetkými číslami od $1$ po $10$. Pre novú požiadavku skúsime postupne pridávať novú cifru, a vyberieme najmenšiu vyhovujúcu. V predošlom riešení tak stačí nahradiť `if - else` príkazy jedným `for`-cyklom a namiesto počítania 4 špecifických premenných spočítame v jednom `for`-cykle nové zvyšky po delení číslami $1$ až $10$, uložené v poli.

#### Zložitosť

S časovou zložitosťou je to v tomto riešení rovnaké ako v prechádzajúcom, ""orlojovom"". Máme pole s konštantnou veľkosťou, ktorého prvky môžu nadobúdať len ohraničené hodnoty, nezávislé od $n$. Práca s nimi je teda v konštantnom čase, a keďže spracúvame všetky požiadavky, tak celková časová zložitosť je $O(n)$.

Pamäťová zložitosť je na tom rovnako, ako v prechádzajúcom riešení, ak by sme cifry vypisovali jednu po druhej, bola by konštantná, $O(1)$, ale keďže to kvôli výkonu nerobíme, tak je lineárna, $O(n)$.

## Počítanie namiesto skúšania možností

Na záver si môžeme uvedomiť, že keď poznáme zvyšky po delení všetkými potrebnými číslami, už nepotrebujeme skúšať všetky cifry. Potrebnú cifru vieme vypočítať!

Výpočtom ďalšej cifry tiež dokážeme, že pre ľubovoľné číslo a ľubovoľnú požiadavku existuje cifra, ktorú vieme pridať. Toto tvrdenie sme využívali vo všetkých predošlých úvahách, no neboli sme presvedčení o tom, že skutočne platí.

Čo musí spĺňať cifra, ktorú chceme pridať? Výsledok po pridaní tejto cifry musí byť deliteľný číslom z požiadavky. Musí teda platiť, že nový zvyšok po delení číslom požiadavky sa rovná nule. Ak $Z_i$ je zvyšok doteraz napísaného čísla po delení $i$, $p$ je požiadavka a $c$ je cifra, ktorú pridávame, tak musí platiť toto:

$$ (Z_p \\cdot 10 + c) \\bmod p = 0 $$

Z tohto vzorca si jednoducho odvodíme, ako vypočítať želanú cifru:

$$ c = (- Z_p \\cdot 10) \\bmod p $$

Ak by ste mali vy alebo váš programovací jazyk problém počítať zvyšky záporných čísel, môžeme si uvedomiť, že $(- Z_p \\cdot 10) \\bmod p = (p \\cdot 10 - Z_p \\cdot 10) \\bmod p$.

Iný spôsob, ako sa dopracovať k $c$ je pouvažovať: Doteraz napísané číslo má zvyšok $Z_p$. Po pridaní cifry 0 bude mať zvyšok $(Z_p \\cdot 10) \\bmod p$. O koľko potrebujeme zväčšiť pridanú cifru, aby sme zvyšok $(Z_p \\cdot 10) \\bmod p + c$ dostali na nulu? Jednoducho o $p - (Z_p \\cdot 10) \\bmod p$. Ak však $(Z_p \\cdot 10) \\bmod p = 0$, nechceme pridať cifru $p$, ale cifru $0$ a to dosiahneme takto ďalším zmodulovaním $p$:

$$ c = (p - (Z_p \\cdot 10) \\bmod p) \\bmod p $$

Počítanie novej cifry nám prinesie len zrýchlenie o konštantu, no dôležitá je myšlienka, že nová cifra sa vždy dá pridať. Ak by napríklad mohla byť požiadavka $11$, mohli by sme sa dostať do situácie, že doteraz napísané číslo má $(Z\_{11} \\cdot 10) \\bmod 11 = 1$. V takomto prípade by žiadna cifra výsledný zvyšok nedotiahla na nulu.

## Optimalizované zvyšky

Riešenie so zvyškami je úplne dobré. Avšak, ak sme veľkí fajnšmekri, môžeme riešenie ešte raz konštantne zrýchliť. Nemusíme si zvyšky pamätať jednotlivo v zozname, stačí, ak si budeme pamätať zvyšok po najmenšom spoločnom násobku čísel $1$ až $10$ a z toho si vždy vieme vypočítať každý potrebný zvyšok. Takéto riešenie dáva v Pythone dvakrát až trikrát lepšie časy než riešenie s poľom zvyškov.
",5
c5e1c69bdd0674f0,ksp,"# Okultistický fundraising

Trojsten je chudobné občianske združenie. Preto niet divu, že sa našlo zopár vedúcich, ktorí sa rozhodli s tým niečo spraviť a založili fundraisingovú skupinu. Získavanie peňazí sa im však až tak nedarilo. Preto sa Vlejd rozhodol, že sa k nim pridá a ukáže im, ako sa to robí.

Poriadny fundraising sa samozrejme nedá robiť bez štipky okultizmu. Poprípade viac ako štipky. A to bolo to, čo priniesol do skupiny Vlejd. Neprešiel ani týždeň a všetci z nich počúvali Pentagramček a spievali si ho v sprche. Takisto už vedeli, že keď chcú ísť na nejaké dôležité stretnutie, musia zabiť dve panenské sliepky a vykúpať sa v ich krvi.

Najväčšou zmenou však boli posedenia u veštice. Ak totiž chcete vedieť, či od firmy získate peniaze, ktoré od nej žiadate, musíte ísť za špeciálnou okultistickou vešticou. Tá vám pomôže vyveštiť, či bude vyjednávanie úspešné alebo nie. Na to používa špeciálny balíček fundraising-tarotových kariet.

Funraising-tarotové karty sa od tých normálnych trochu líšia. Na oboch stranách majú napísané jedno číslo. Na začiatku veštenia vytiahne z balíčka $n$ kariet a podá vám ich. Vy sa potom pre každú kartu rozhodnete, ktorá strana sa vám páči viac. Ak je súčet čísiel, ktoré si takto zvolíte rovný množstvu peňazí, ktoré od firmy žiadate, budete úspešný. V opačnom prípade vás však pošlú preč s prázdnymi rukami.

Vlejd chce u veštice trošku podvádzať. Keď mu podá karty, chce si vybrať strany nie podľa osobnej preferencie, ale tak, aby ich súčet bol rovný číslu $s$ -- sume peňazí, ktorú bude žiadať. Tak nakloní osud na svoju stranu a Trojsten bude zachránený. Táto úloha však vôbec nie je taká jednoduchá. Vybrať správnu stranu karty je ťažké a možno sa dokonca ani nedá získať súčet $s$. Pokúste sa mu pomôcť a naprogramovať program, ktorý mu pre každú kartu povie, ktorú stranu si má vybrať.

## Úloha

Na vstupe dostanete $n$ dvojíc kladných čísiel. Z každej dvojice vyberte \\textbf{práve} jedno číslo tak, že súčet vybratých čísiel je rovný číslu $s$. Ak sa to nedá, vypíšte príslušnú hlášku.

## Formát vstupu

Na prvom riadku je číslo $n$ ($1 \\leq n \\leq 1,000$) -- počet dvojíc čísiel.

Na druhom riadku je číslo $s$ ($0 \\leq s \\leq 50,000$) -- súčet, ktorý sa snažíme dosiahnuť.

Nasleduje $n$ riadkov, každý obsahujúci dve čísla $x_i$ a $y_i$ ($0 \\leq x_i,y_i \\leq 50,000$) popisujúce jednotlivé dvojice čísiel, ktoré boli na kartách.

Pre hodnoty premennej $n$ naviac platia nasledovné obmedzenia:

- Vo vstupoch za $3$ body je $n \\leq 20$.

- Vo vstupoch za $5$ bodov je $n \\leq 50$

## Formát výstupu

Na výstup vypíšte v jednom riadku $n$ znakov, každý z nich je \\texttt{1} alebo \\texttt{2}. Na pozícii $i$ tohto reťazca je \\texttt{1} ak má Vlejd vybrať prvé číslo z dvojice a \\texttt{2}, ak má vybrať druhé. V prípade viacerých možností, ako sa dá dosiahnuť výsledný súčet $s$ vypíšte ľubovoľnú z nich.

Ak nie je možné dosiahnuť súčet $s$ vypíšte \\texttt{""A je to v ...""} (bez úvodzoviek).

## Príklady

```vstup
3
12
3 5
4 2
4 7
```

```vystup
122
```

```vstup
3
15
3 5
4 2
4 7
```

```vystup
A je to v ...
```
","# Okultistický fundraising

Táto úloha bola na pomery O-čka pomerne ľahká. Hlavná časť jej riešenia používa metódu dynamického programovania a ak sa vám túto úlohu nepodarilo vyriešiť, určite by ste si mali prečítať toto vzorové riešenie, pretože táto metóda je často používaná.

## Prezeranie všetkých riešení

Skôr ako sa pustíme do vzorového riešenia, povedzme si čo-to o menej optimálnych prístupoch. Úloha po nás chce, aby sme sa o každej z $n$ kariet rozhodli, ktorou stranou ju otočíme (ktoré číslo sa objaví na vrchu) a chceme, aby súčet týchto čísel dal dokopy hodnotu $s$.

Ako prvé riešenie teda môžeme vyskúšať všetky možné otočenia kariet. Pre každé otočenie vyskúšame, aký súčet dostaneme a ak sa nejaký súčet rovná $s$, prehlásime toto otočenie za výsledok. Ak ani jedno otočenie nebude vyhovovať, riešenie zjavne neexistuje. Otázka je, koľko je možných otočení $n$ kariet. A asi je jasné, že týchto možností je $2^n$. Ak naviac každú možnosť spracujeme v čase $O(n)$ dostávame riešenie so zložitosťou $O(n2^n)$. Nič úžasné, ale dosť na to, aby sme získali sľubované $3$ body.

Otázkou teraz zostáva, ako takéto riešenie naprogramovať a ako ho naprogramovať čo najbezbolestnejšie. Celý trik leží v tom, ako si reprezentujeme dané otočenie. Ak sa pozrieme na výstup, vidíme, že máme vypísať postupnosť čísel $1$ a $2$, kde $i$-te číslo reprezentuje otočenie $i$-tej karty. Čísla $1$ a $2$ nie sú pre počítač až také pekné -- čo ak by sme ich zmenili na čísla $1$ a $0$? Potom by predsa každé otočenie bol bitový reťazec, čo je vlastne **číslo v binárnom zápise**.

Reprezentovať si otočenie pomocou čísla môže byť pomerne pohodlné, hlavne ak vezmeme do úvahy, že každé číslo od $0$ po $2^n-1$ je nejaké platné otočenie, a navyše každé dve rôzne čísla reprezentujú dve rôzne otočenia. Otázkou však zostáva, či sa vieme nejakým jednoduchým spôsobom dostať k $i$-temu bitu čísla $x$, teda zistiť, či je tento bit $0$ alebo $1$. Odpoveď je, že to vieme dokonca v konštantnom čase, použitím dvoch binárnych operácií -- *shift left* (zapisovaný ako $\<<$) a *and* (zapisovaný ako $&$). Operácia $x&(1\<<i)$ potom vráti na výstup $i$-ty bit čísla $x$.^\[Prezradím, že číslo $1\<<i$ vráti hodnotu $2^i$ a $&$ je bitový *and* dvoch čísel pracujúci bit po bite. Zvyšok si domyslite (dogooglite) sami.\]

##Meet in the middle

Keď už máme tri body, mohli by sme poškuľovať po tých piatich. Obmedzenie, ktoré máme zadané, nám vraví, že $n$ je menšie ako $50$, čo je zhruba dvojnásobok predchádzajúceho obmedzenia. Mohli by sme teda stále zostať v exponencionálnej časovej zložitosti, akurát ju trošku zlepšiť. V tomto prípade, ak by sa nám podarilo vytvoriť algoritmus so zložitosťou približne $O(2^{n/2})$, ešte stále by to mohlo fungovať. Vyzerá to teda, ako by sme mohli naraz pracovať len s polovicou vstupu. A presne na tom sa zakladá riešenie metódou meet in the middle.

Zoberme si prvú polovicu vstupu a pustime naň predchádzajúci algoritmus. Vyskúšame teda všetky možné otočenia prvej polovice kariet. Ak je súčet nejakého otočenia väčší ako $s$, toto otočenie môžeme rovno zahodiť, lebo je nepoužiteľné. V opačnom prípade si ho ale zapamätáme aj s príslušným súčtom.

Keď sme spracovali prvú polovicu, pustime sa do druhej. Zoberieme si nejaké otočenie druhej polky kariet a zistíme, že jeho súčet je $x$. To ale znamená, že ak sa nám podarí otočiť prvú polovicu kariet tak, aby dávala súčet $s-x$, máme vhodné otočenie. Dokopy totiž obe časti dajú súčet $s$. Stačí sa teda pozrieť do riešení prvej polovice -- a aby to bolo dosť efektívne, tieto riešenia chceme mať uložené v *map*e alebo utriedené podľa súčtov a v nich binárne vyhľadávať.

Spracovanie prvej polovice nám trvá $O(n2^{n/2})$ (najväčší prínos má triedenie, ktorého zložitosť je $2^{n/2} \\log(2^{n/2})$, to je však po odstránení logaritmu $n2^{n/2}$) a tento čas nám trvá aj spracovanie druhej polovice. Keďže sme ich však od seba oddelili a spracovávame ich samostatne, výsledný časová zložitosť bude tiež $O(n2^{n/2})$, a to by nám malo stačiť na $5$ bodov. Riešenie vyzerá podobne ako predchádzajúce, minimálne sa v ňom využívajú rovnaké časti programu^[Opäť odporúčam dogoogliť všetky pojmy, ktorým ste neporozumeli úplne. Napríklad set v C++ alebo aj samotný meet in the middle postup.].

##Vzorové riešenie

Podľa obmedzení, ktoré máme zadané, je jasné, že žiadne exponenciálne riešenie nebude vyhovovať, preto to potrebujeme nejakým spôsobom zlepšiť. Začnime teda malým trikom.

Hlavný problém je, že sa musíme rozhodovať, ktorú stranu zoberieme, a ktoré číslo prirátame k výsledku. Zoberme si teraz kartu, na ktorej sú čísla $8$ a $3$. Je jasné, že nech otočíme kartu ľubovoľnou stranou, k výsledku pripočítame **aspoň** hodnotu $3$. Čo ak by sme teda nahradili túto kartu kartou, ktorá má na sebe čísla $5$ a $0$, a odčítali číslo $3$ od $s$? Dostali by sme novú sadu kariet a ich otočením by sme chceli dosiahnuť hodnotu $s-3$. Vidíme, že naša úloha sa vlastne vôbec nezmenila, a ak nájdeme otočenie, ktoré rieši túto úlohu, toto otočenie bude dobré aj pre nezmenené karty.

Takýmto spôsobom môžeme upraviť všetky karty. Zistíme minimum z ich strán a toto minimum odčítame jednak od oboch strán karty, jednak od hodnoty $s$. Na prvý pohľad sa zdá, že sa nič nezmenilo, stále hľadáme otočenie $n$ kariet, akurát hľadáme inú hodnotu $s^\\prime$. Na jednej zo strán karty je však zakaždým hodnota $0$. To znamená, že náš problém sa dá preformulovať: Ktoré karty máme vybrať, aby ich súčet bol $s^\\prime$?

Znamená to, že máme množinu $n$ čísel a chceme zistiť, či niektorá z množín týchto čísel má súčet $s^\\prime$. Možno, že to tak nevyzerá, úloha sa nám však trochu zjednodušila a skúsenejší z vás v nej možno spoznali klasický problém o napĺňaní batoha (aspoň jednu z mnohých verzií tohoto problému).

Ako však riešiť túto úlohu? Ešte stále sa nám ponúka vyššie ukazované exponenciálne riešenie, pomocou ktorého vieme prechádzať všetky podmnožiny. Samozrejme toto riešenie je príliš pomalé. Treba sa preto pozrieť na to, prečo je tak pomalé. Spýtajme sa teda veľmi dôležitú otázku, ktorú by ste sa mali pýtať zakaždým: **Nerobíme niečo viac krát?** Ak totiž rátame nejakú informáciu viacej krát, dá sa toto opakovanie odstrániť a tým zrýchliť naše riešenie.

Zoberme si množinu čísel ${1,3,2,5}$. Ak spracujeme prvé tri prvky, zistíme, že pomocou prvého a tretieho prvku vieme dosiahnuť hodnotu $3$, ale túto hodnotu vieme dosiahnuť aj pomocou druhého prvku. Máme teda dva rôzne spôsoby ako dosiahnuť tú istú hodnotu a k obom týmto možnostiam následne skúsime pridať hodnotu $5$. Nám však stačí, ak zistíme, že hodnotu $3$ vieme vyskladať pomocou prvých troch prvkov a potom k tejto hodnote pridať $5$ len raz. Samozrejme, dá sa argumentovať, že toto nám nemusí pomôcť, lebo každá podmnožina čísel môže dávať rôzny súčet. Možných súčtov by teda bolo $2^n$, pre nás zaujímavé sú však len tie súčty, ktoré sú menšie ako $s^\\prime$. V okamihu ako nájdeme väčší súčet, môžeme ho rovno zahodiť, lebo nám nemôže pomôcť, keďže pracujeme len s kladnými číslami. A hodnota $s^\\prime$ je podľa zadania najviac $50,000$, čo je často menej než $2^n$.

Zostáva už len správne využiť spomenuté pozorovanie. Spravíme si pole $V$ dĺžky $s^\\prime$ a na políčko $x$ si budeme značiť, či vieme dosiahnuť súčet $x$ pomocou nejakej podmnožiny prvých $i$ čísel. Na začiatku, keď nepoužívame žiadne čísla, jediný súčet, ktorý vieme dosiahnuť, je $0$. Preto si nastavíme hodnotu $V[0]=1$ a zvyšné hodnoty na $0$.

Nech už máme pridaných prvých $i-1$ čísel a chceme pridať $i$-te číslo, ktoré má hodnotu $a_i$. Prezerajme postupne pole $V$, prvok po prvku. Ak je na $x$-tej pozícii hodnota $0$, nepotrebujeme urobiť nič -- hodnotu $x$ nevieme vyskladať z prvých $i-1$ kariet a teda nemôžeme pridať túto kartu. Ak je však $V[x]$ rovné $1$, tak to znamená, že existuje podmnožina prvých $i-1$ kariet, ktorá dáva súčet $x$. Ak k tejto (ľubovoľnej z nich) podmnožine pridáme kartu $a_i$, dostaneme množinu so súčtom $x+a_i$ a zaznačíme si do $V$, že $V[x+a_i]=1$. Ak náhodou $x+a_i>s^\\prime$ tak túto hodnotu zahodíme.

Ak po spracovaní všetkých kariet sa $V[s^\\prime]$ rovná $1$, tak naša úloha má riešenie, v opačnom prípade nevieme nájsť podmnožinu s požadovaným súčtom. Zostávajú nám posledné dve veci, ktoré musíme vyriešiť. Prvou z nich je, ako spätne zistiť, ktoré čísla použijeme vo výslednej množine, ktorá dáva súčet $s^\\prime$, aby sme vedeli späť zistiť, ktoré karty otočiť na ktorú stranu. Druhá vec je trochu nejasnejšia, ale pomôže nám v tom, aby nám celý algoritmus fungoval korektne.

Začnime tou druhou. Problém našeho algoritmu môže vzniknúť pri prechádzaní poľa $V$ a pridávaní ďalšej karty. Ak budeme prechádzať pole od hodnoty $0$ po $s^\\prime$, tak sa stane nasledovná vec. Nájdeme jednotku vo $V[0]$ a nastavíme na jedna $V[a_1]$. Potom ale nájdeme aj túto novo pridanú jednotku a nastavíme $V[2a_1]$ na jednotku. To však nie je platná množina, lebo pomocou jednej karty s hodnotou $a_1$ ju nevieme dosiahnuť. Preto si treba dať pozor, aby sme pole prechádzali **od väčších hodnôt k menším**. Tým zaručíme, že upravujeme už spracované indexy a náš algoritmus bude fungovať správne.

Posledný problém, ako spätne zistiť, ktoré čísla tvoria výslednú množinu, vieme vyriešiť pomocou jedného poľa navyše. V tomto poli $S$ si na pozícii $x$ zaznačíme, ktoré číslo sme pridali ako posledné do množiny so súčtom $x$. Ak teda nastavíme hodnotu $V[x+a_i]$ na jednotku, do políčka $S[x+a_i]$ nastavíme hodnotu $i$. Pomocou tohoto poľa a hodnôt $a_i$ vieme spätne zrekonštuovať riešenie.

##Rekapitulácia

Zopakujme si teda celé naše riešenie. Začneme tým, že upravíme všetky naše karty tak, aby na jednej strane bola $0$ a na druhej kladná hodnota, a príslušne upravíme hodnotu $s$. S novovytvorenými číslami potom spustíme algoritmus, ktorý bude zisťovať, ktoré všetky súčty vieme vytvoriť z prvých $i$ čísel. Na konci zistíme, či vieme vytvoriť súčet $s^\\prime$ a pomocou pomocného poľa $S$, do ktorého si ukladám posledné použité číslo, zistíme, ktoré čísla patria do riešenia. Následne otočíme každú kartu, ktorej patrí číslo z tejto množiny, na stranu, kde má maximum a zvyšné karty na stranu, kde majú minimum.

Aká bude časová a pamäťová zložitosť tohoto riešenia? Na zisťovanie dosiahnuteľnosti súčtov a pamätanie si kroku späť potrebujeme pole dĺžky $s$ a na zapamätanie kariet pole veľkosti $n$. Máme teda pamäťovú zložitosť $O(n+s)$. Čo sa týka času, tak na pridanie jednej karty k našim vytvoreným množinám potrebujeme prejsť celým poľom dĺžky $s$ a toto opakujeme $n$ krát. Dosiahneme teda zložitosť $O(ns)$, ktorá nám bude stačiť na získanie plného počtu bodov.

Na záver poznamenám, že riešenie využíva to, že hodnota $s$ je dostatočne malá a teda treba vždy zvážiť, kedy takéto riešenie použiť. Naviac je dobré si uvedomiť, že riešenie nemá polynomiálnu časovú zložitosť, lebo je závislé od hodnoty $s$, ktorá nezodpovedá veľkosti vstupu. Vstup je veľký $O(n)$ a $s$ môže byť ľubovoľne veľké bez toho aby sa zväčšila veľkosť vstupu. Takéto riešenie nazývame pseudopolynomiálne.
",8
ac30eafb35a36718,ksp,"# Záchrana princeznej

Jimi si nedávno kúpil nový herný počítač a jeho štúdium tým značne utrpelo. Je veľmi ťažké učiť sa, keď máte na výber z toľkých dobrých hier. Preto si vytvoril rozvrh, v ktorom má každú hodinu označenú ako pracovnú alebo hernú. Po čase hrania ale Jimiho prestalo baviť zabíjanie príšer a rozhodol sa splniť veľkú úlohu -- zachráni princeznú ukrytú na hmlistom ostrove.

Hra však nepodporuje ukladanie počas plnenia misie a preto Jimi nemôže pracovať, kým nezachráni princeznú. Nechce si ale veľmi meniť rozvrh, preto len vyškrtne niektoré pracovné hodiny z rozvrhu tak, aby si vytvoril dostatočne dlhý súvislý úsek herného času na záchranu princeznej. Jeho štúdium je však už teraz riadne zanedbané, a preto chce obetovať čo najmenej zo svojho pracovného času.

## Úloha

Jimiho rozvrh vyzerá ako jedna dlhá postupnosť znakov `P` a `H`, ktoré označujú **p**racovné a **h**erné hodiny.

Jimi si vypočítal, že na záchranu princeznej bude potrebovať $c$ hodín hry.

Vašou úlohou je zistiť, koľko najmenej hodín práce vie vyškrtnúť z rozvrhu tak, aby mal **aspoň $\\mathbf{c}$ hodín hry** v jednom kuse.

Môžete predpokladať, že herných hodín je v rozvrhu vždy aspoň $c$.

## Formát vstupu

V prvom riadku je číslo $c$ -- počet hodín potrebných na záchranu princeznej. V druhom riadku je rozvrh -- reťazec znakov `P` a `H` dĺžky $n$.

Pre vstupy platí $1 \\leq c \\leq n \\leq 1,000,000$.

## Formát výstupu

Vypíšte jedno číslo -- najmenší počet hodín práce, ktoré treba vyškrtnúť z rozvrhu. Výstup ukončite znakom nového riadku.

## Príklad

```vstup
3
PPHHPPPHPHPHPPP
```

```vystup
2
```

_Upravený rozvrh vyzerá takto: PPHHPPPHHHPPP._

```vstup
4
HHPPPHHPPHHHPH
```

```vystup
1
```

```vstup
2
HHPPHPP
```

```vystup
0
```
","# Záchrana princeznej

Predstavíme si dve riešenia: riešenie hrubou silou a optimálne riešenie.

## Hrubá sila $O(n^2)$

Príklad vieme vyriešiť veľmi jednoducho vyskúšaním všetkých možných začiatkov záchrany: Spočítame, koľko hodín práce by musel Jimi preskočiť, keby začal so záchranou práve v $i$-tu hodinu. Zo všetkých $i$ vyberieme také, kedy je počet preskočených hodín práce minimálny.

Počet preskočených hodín spočítame tak, že v cykle prejdeme vstupné pole od $i$-tej hodiny, pričom si budeme počítať počet prejdených `P` a `H`. Ak dosiahneme počet `H` rovný $c$, dosiahli sme potrebný počet hracích hodín a počet `P` je počet obetovaných pracovných hodín. Stačí teda počet `P` porovnať s doterajším minimom a ak je menší, našli sme nové minimum.

Keď od hodiny $i$ po koniec rozvrhu ostáva menej ako $c$ hodín, vypíšeme najmenší počet vynechaných `P`.

Keďže pre každý začiatok môžeme prejsť až na koniec poľa, časová zložitosť je $O(n^2)$.

## Optimálne riešenie $O(n)$

Môžeme si všimnúť, že v predošlom riešení robíme množstvo práce viackrát. Ak totiž poznáme počet `P`-čok (označme ho $p_i$) v úseku začínajúcom na $i$, tak vieme, že počet `P`-čok v úseku začínajúcom na $i+1$ nemusí byť veľmi odlišný. Mohli by sme teda zvýšiť $i$ na $i+1$ a nezačať počítať `P` a `H` od $i+1$ ale rovno od $i + c + p_i$ (teda odtiaľ, kde sme skončili prechod poľa pre predošlé $i$), kým nedosiahneme potrebný počet `H`-čok.

My budeme postupovať podobne, akurát teraz nebudeme skúšať všetky začiatky, ale prejdeme cez všetky konce.

Budeme sa teda vždy pozerať na časť poľa, ktorá je určená začiatkom a koncom^[Prístup, ktorým vyriešime túto úlohu sa nazýva ""dvaja bežci"" -- jeden ukazuje na začiatok, druhý na koniec a postupne nimi prejdeme pole.]. Tiež si udržiavame počet `P` a počet `H` v tejto časti poľa.

Začneme so začiatkom aj koncom na prvom políčku poľa. V každom kroku cyklu posunieme koniec úseku o jedno políčko ďalej. Kým je počet `H` v našom úseku väčší alebo rovný $c$, posúvame začiatok úseku doprava. Tým dosiahneme najkratší úsek s týmto koncom, ktorý má aspoň $c$ `H`-čok. Keďže je najkratší, má aj minimálny počet `P`-čok. Počet `P`-čok porovnáme s medzivýsledkom a zapamätáme si menší.

Po prechode poľom vypíšeme minimum.

Každé políčko poľa sme navštívili raz koncom a najviac raz začiatkom, teda celková časová zložitosť je $O(n)$.
",4
5da1c2903ea335e3,ksp,"# Akýsi časopis

September prišiel a farmár Jožo sa chystá na zber zeleniny zo svojho políčka. Na ňom má pekne v rade zasadených $n$ zelenín rôznych (alebo aj rovnakých) druhov. Jožo si chce zvoliť jeden súvislý úsek poľa, z ktorého si zeleninu odloží doma; zvyškom prispeje do pohostenia pri najbližšom stretnutí dedinskej futbalovej ligy.

Okrem toho ale Jožo cez leto začal odoberať akýsi časopis o vyrovnanej strave. V ňom sa dočítal, že mu urobí dobre, ak nebude existovať jeden druh zeleniny, z ktorého by mal doma viac kusov ako z každého iného. (Tu sa ukazuje prečo sa Jožo nerozhodol proste zožrať všetko sám -- mal by pocit že žije nezdravo.) Inak povedané, musia existovať aspoň dva druhy, z ktorých na jeho vybranom súvislom úseku poľa bude rovnako veľa kusov a zároveň zo žiadneho iného druhu na tom úseku nebude viac kusov.

Samozrejme, aj tak by si chcel Jožo nechať čo najviac zeleniny pre seba. Konkrétne chce, aby z každého z tých najčastejších druhov zeleniny mal doma aspoň $k$ kusov. Povedzte mu, koľko najviac zeleniny si môže uskladniť doma, alebo aspoň že si nevie podľa svojich požiadaviek vybrať žiadny úsek poľa (a dofrasa aj s časopisom, všetky plány mu prekazil!).

## Formát vstupu

Na prvom riadku sú čísla $n$ a $k$ -- počet kusov zeleniny na poli a minimálny vyžadovaný počet kusov najčastejšieho druhu.

Na druhom riadku je $n$ čísel $a_1$ až $a_n$ -- typy jednotlivých kusov zeleniny v poradí, v ktorom rastú na poli. Platí $1 \\le a_i \\le n$.

## Formát výstupu

Vypíšte jeden riadok a na ňom jedno číslo -- dĺžku najdlhšieho úseku poľa, ktorý je možné vybrať, alebo $-1$ ak nie je možné vybrať žiadny úsek.

## Hodnotenie

Je 6 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1 | 2 | 3, 4 | 5 | 6 | |:----------------- | -----: | ---------: | ---------: | --------: | ---------: | | $1 \\leq n \\leq$ | $60$ | $5,000$ | $10,000$ | $50,000$ | $100,000$ | | $1 \\leq n/k \\leq$ | $60$ | $5,000$ | $20$ | $100$ | $200$ |

## Príklad

```vstup
5 1
2 2 3 1 2
```

```vystup
3
```

Pole obsahuje napr. zemiak, zemiak, mrkvu, kareláb, zemiak. Optimálne je zobrať mrkvu, kareláb a jeden zo zemiakov ktoré s nimi susedia. Futbalový guľáš získal zvyšné dva zemiaky.
","# Akýsi časopis {bodypopis=12 bodyprogram=8}

Chceme nájsť najdlhšiu súvislú podpostupnosť $a_l, \\ldots, a_r$ (v skrátenom značení $[l,r]$), ktorej modus nie je unikátny -- musia existovať aspoň dve čísla, ktoré sa v $[l,r]$ vyskytujú práve $f \\ge k$ krát, a žiadne číslo sa v nej nesmie vyskytovať viac ako $f$-krát.

Najprv sa zamyslime nad tým, čo nám dáva veľké $k$. Existuje najviac $\\lfloor n/k \\rfloor$ rôznych čísel, ktoré sa môžu vyskytnúť $\\ge k$ krát, lebo ak by ich bolo viac, postupnosť $a$ by musela mať $\\ge (\\lfloor n/k \\rfloor + 1) k > n$ prvkov. Volajme ich *časté*. To nám pri hľadaní efektívneho algoritmu pomôže. Rovno si označme $c\_{v,p}$ počet výskytov častého čísla $v$ medzi $a_1, \\ldots, a_p$ (teda $c\_{v,0} = 0$); tieto prefixové sumy môžeme predpočítať v čase aj pamäti $O(n^2/k)$.

Napr. $O(n^2)$ riešenie je zjavné -- zoberieme si pevné $l$, začneme s $r = n$, postupne ho zmenšujeme a pamätáme si v poli, koľko čísel sa v $[l,r]$ vyskytuje práve $1,2,\\ldots,n$ krát; vždy, keď zmenšíme $r$, sa zmenší počet výskytov jedného čísla, teda vieme ľahko aktualizovať tieto hodnoty a aktuálnu hodnotu $f$ (ktorá nemôže rásť), a nájdeme dokonca všetky podpostupnosti $[l,r]$ ktoré spĺňajú našu podmienku.

Pridajme teraz do tohto algoritmu podmienku, že sa zastavíme (a pokračujeme s ďalším $l$) hneď, keď nájdeme $r$ pre ktoré je modus neunikátny. Vtedy stačí skontrolovať, či sa modus vyskytuje aspoň $k$-krát a aktualizovať odpoveď na úlohu. Tu prichádza kľúčové pozorovanie:

- Označme $u$ najčastejšie číslo v $[l,n]$ (ak nie je jedinečné, potom niet čo riešiť).
- Pre každé $i \\neq u$ nájdime maximálne $r$ také, že $c\_{i,r}-c\_{i,l-1} = c\_{u,r}-c\_{u,l-1}$, a označme ho $r_i$.
- Maximum všetkých $r_i$ je práve hľadané najväčšie $r$, pre ktoré má $[l,r]$ neunikátny modus.

Pointa je, že ak zoberieme maximálne $r_m$ a príslušné číslo $m$, potom čísla iné ako $u, m$ môžeme odignorovať, lebo žiadne z nich sa nevyskytuje v $[l,r_m]$ častejšie ako $u$. Dokážeme to sporom. Ak existuje $j \\neq u,m$ také, že $(c\_{u,r_m}-c\_{u,l-1}) - (c\_{j,r_m}-c\_{j,l-1}) < 0$, ale $(c\_{u,N}-c\_{u,l-1}) - (c\_{j,N}-c\_{j,l-1}) > 0$, potom musí existovať nejaké $r > r_m$ také, že $c\_{u,r}-c\_{u,l-1} = c\_{j,r}-c\_{j,l-1}$. Ak totiž posúvame $r$ od $n$ po $r_m$ a sledujeme hodnotu výrazu $(c\_{u,r}-c\_{u,l-1}) - (c\_{j,r}-c\_{j,l-1})$, pri každom posunutí $r$ o $1$ sa výraz zmení maximálne o $1$, teda musíme medzi záporným a kladným číslom natrafiť na nulu. Potom by ale bolo $r_j \\ge r$, teda väčšie ako $r_m$, čo je spor s maximálnosťou $r_m$.

Na prvý pohľad toto pozorovanie nevyzerá až tak užitočne, ale hovorí nám, že $u$ bude modus aj pre podpostupnosť $[l,r_m]$ a že hodnoty vo vstupnom poli sú dosť nezávislé -- pre dané $l$ (a teda $u$) sa stačí pozrieť na všetky dvojice $(m,r)$, vybrať tie pre ktoré platí $c\_{m,r}-c\_{m,l-1} = c\_{u,r}-c\_{u,l-1}$, a z nich vybrať maximálne $r$. Prepíšme si túto rovnicu na $$c\_{u,r}-c\_{m,r} = c\_{u,l-1}-c\_{m,l-1} ,.$$

Pre každú dvojicu $(u,m)$ teda môžeme spraviť toto: zoskupíme všetky indexy $i$ podľa hodnoty $c\_{u,i}-c\_{m,i}$ v čase $O(n)$, pre každú hodnotu sa pozrieme na všetky jej indexy $i=l-1$, pre ktoré je $u$ modusom $[l,n]$, a vieme pre ne maximálny index $i=r$, ktorý dá rovnakú hodnotu. Takto pre každé $l$ spočítame maximálne $r$, pre ktoré má $[l,r]$ neunikátny modus, alebo zistíme, že žiadne také $r$ neexistuje. Nakoniec pre každý z týchto $O(n)$ kandidátov $[l,r]$ skontrolujeme, či sa modus $[l,n]$ (ktorý je aj modus $[l,r]$) vyskytuje v $[l,r]$ aspoň $k$ krát a spočítame odpoveď. To funguje v čase $O(n^3/k^2)$.

Ešte to môžeme zrýchliť. Samozrejme, možných trojíc $(u,m,i=l-1)$ je len $O(n^2/k)$, lebo $l$ jednoznačne určuje $u$. Pre $(u,m,i=r)$ zasa využime nápad s posúvaním $r$. Na začiatku ($r=n$) je $u$ unikátny modus a bude to tak až kým nenarazíme na $r=r_m$. Keďže posunutím $r$ o $1$ sa môže zmeniť len počet výskytov jedného čísla, pri posunutí z $r=r_m+1$ na $r=r_m$ musí to číslo byť $u$, teda chceme $a\_{r+1} = u$. Vidíme, že celkovo stačí uvažovať len $O(n^2/k)$ trojíc $(u,m,i)$, a rovnaká je aj časová náročnosť. Pamäťová náročnosť je stále $O(n^2/k)$.

(Pre zaujímavosť: rozšíriť riešenie úlohy na ľubovoľné $k$ je pomerne ľahké. Pre pevné $f < \\sqrt{n}$ sa posúvame po poli, pamätáme si pre každú hodnotu jej nasledujúcich $f+1$ výskytov a na základe najbližších z $f$-tých a $f+1$-vých výskytov určíme najväčšiu súvislú podpostupnosť s neunikátnym modusom. Pri posunutí o jeden prvok sa veľa nemení, takže z odpovede pre $k+1$ vieme vypočítať odpoveď pre $k$ v čase $O(n)$.)
",10
55b863b33f7d7688,ksp,"# Pochúťka

Paulinka^[s krátkym i] mala jedného dňa robiť úlohu z databáz. Ako písala riešenie, uvedomila si, že jedáleň práve zatvorila. Bola nedeľa, takže aj všetky obchody boli zatvorené. Žiaľ, musela pokračovať v písaní o hlade a tak miesto databáz Paulinka premýšľala o koláčoch. A tak to aj skončilo. Jej domáca úloha obsahovala databázy všelijakých koláčov.

Keď prišla z ďalekého západu na prázdniny domov, rozhodla sa, že taká databáza koláčov je výborný nápad. Išla ho teda zrealizovať. Po chvíli plánovania prišla na to, že databáza predsalen nie je najlepší spôsob pre uloženie koláčov a namiesto databázy upečie maticu koláčov.

Matica mala $r$ riadkov a $s$ stĺpcov a Paulinka upiekla $n + m$ koláčov. Najskôr prvých $n$ položila tak, že $i$-ty bol v $(i \\mod r)$-tom riadku a $(i \\mod s)$-tom stĺpci.

Následne ešte na niektoré políčka matice položila zvyšných $m$ koláčov tak, ako sa jej to páčilo. Paulinka mohla položiť aj viacero koláčov do jedného políčka.

Ako finalizovala svoju maticu, rozhodla sa, že niektoré koláče ozdobí maslovým krémom. Samozrejme, nie len tak ledabolo! Každý riadok a každý stĺpec musí obsahovať nepárny počet ozdobených koláčov. Samozrejme, žiadne rearanžovanie koláčov!

Paulinka s krémom stojí nad maticou a premýšľa, ako to urobiť. Ide to vôbec? Koľkými spôsobmi?

## Úloha

Koľkými spôsobmi ide ozdobiť koláče v horeuvedenom rozložení tak, aby v každom riadku a stĺpci matice bol nepárny počet ozdobených koláčov?

Dva spôsoby sú rôzne, ak je nejaký koláč ozdobený v jednom a neozdobený v druhom. V jednom políčku môže byť aj viac koláčov.

## Formát vstupu

Na prvom riadku dostanete rozmery mriežky $r, s \\leq 10^{9}$ a čísla $r + s \\leq n \\leq 10^{9}$ a $m \\leq 10^{5}$ oddelené medzerou.

Na ďalšom riadku je $m$ čísel, $r_0$ až $r\_{r-1}$, kde $r_i$ je riadok $n + i$-teho koláča.

Na treťom riadku je $m$ čísel, $s_0$ až $s\_{s-1}$, kde $s_i$ je stĺpec $n + i$-teho koláča.

Riadky a stĺpce číslujeme od nuly.

V jednotlivých sadách vstupov platia pre $r$, $s$, $n$ a $m$ nasledovné obmedzenia:

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | | ---------------:| ----------------:| -----------------:| ----------------:|------------------:|----------------------:|-----------------:|-----------------:| | $r, s \\leq 10$ | $r \\leq 10$ | $r, s \\leq 10^6$ | $r, s \\leq 10^6$ | $r, s \\leq 10^6$ | $\\gcd(r, s)\\leq 10^6$ | $r, s \\leq 10^9$ | $r, s \\leq 10^9$ | | $n + m \\leq 20$ | $s < 10^3$ | $n \\leq 5(r + s)$ | $n = r\\cdot s$ | $n \\leq 5(r + s)$ | $n \\leq 10^9$ | $n \\leq 10^9$ | $n \\leq 10^9$ | | | $n \\leq 2^{16}$ | $m \\leq 10^5$ | $m = 0$ | $m \\leq 10^5$ | $m \\leq 10^5$ | $m \\leq 10^5$ | $m \\leq 10^5$ | | | $m \\leq 10^5$ | | | | | | |

Navyše, v tretej a siedmej sade stačí vypísať, či existuje aspoň jedno riešenie. Presnejšie, ak je odpoveď nula, tak program má vypísať nulu, a inak môže vypísať akékoľvek kladné číslo.

## Formát výstupu

Vypíšte jedno číslo -- počet rôznych spôsobov ozdobení koláčov. Keďže toto číslo môže byť veľmi veľké, vypíšte ho modulo $1,000,000,009$.

## Príklad

```vstup
2 4 6 2
1 1
3 0
```

```vystup
8
```

*Jeden možný spôsob ozdobenia koláčov:*

```vstup
6 4 50 5
0 1 2 3 4
3 3 3 3 3
```

```vystup
743544352
```

*Tu je možností veľa.*

```vstup
2 4 6 2
1 0
3 2
```

```vystup
0
```
","# Pochúťka

Prvé pozorovanie, ktoré môže skúseným riešiteľom napadnúť je, že pri riešení úloh, ktoré sa odohrávajú v tabuľke si vieme situáciu zakresliť ako bipartitný graf. V jednej časti (partícii) vrcholy reprezentujú riadky a v druhej časti vrcholy reprezentujú jednotlivé stĺpce. Hrany medzi nimi reprezentujú políčka tabuľky. Týmto spôsobom si môžeme úlohu pretransformovať na nasledovnú: Máme bipartitný graf v ktorom môže byť medzi niektorými dvojicami vrcholov viac hrán (počet hrán reprezentuje počet koláčov v danom políčku). Koľkými spôsobom vieme vybrať hrany (ozdobiť koláče/vyfarbiť hrany) tak aby podgraf tvorený všetkými vrcholmi a vybranými (vyfarbenými) hranami spĺňal podmienku, že každý vrchol má nepárny stupeň?

Ďalšie pozorovanie je, že v rôznych komponentoch môžeme hrany vyfarbovať nezávisle od seba. To znamená, že celkový počet možností akým vyfarbíme hrany je súčinom počtu možností ako vyfarbiť hrany v jednotlivých komponentoch.

Poďme si na chvíľu predstaviť, že nejaký z komponentov je strom. To znamená že neobsahuje cykly. Kedy ho vieme vyfarbiť a ako? Ak je vrchol list tak potrebuje aby z neho išiel nepárny počet vyfarbených hrán. Keďže list má iba jednu hranu tak táto hrana musí byť určite vyfarbená. A toto nám teda jednoznačne určuje, že všetky hrany k listom budú vyfarbené. Čo teda ostatné hrany? Uvažujme nasledovný rekurzívny algoritmus na vyfarbenie hrán v strome: Zoberme si vrchol rekurzívne ofarbime všetky hrany v jeho podstorme. Ak sme vyfarbili párny počet hrán vedúcich z vrcholu musíme vyfarbiť ešte aj hranu k otcovi, aby sme pre tento vrchol dostali nepárny počet zafarbených hrán. Keď sa lepšie pozriete na tento algoritmus zistíte že vďaka invariantom v rekurzií vždy je jednoznačne určené, ktoré hrany v strome budú zafarbené. Môže sa však stať, že zistíme, že koreň má zafarbený iba párny počet hrán a s tým nevieme nič spraviť. (Nevedie totiž od neho hrana k otcovi.) Vďaka tomuto algoritmu však vieme, že v každom strome vieme zafarbiť hrany najviac jedným povoleným spôsobom a aj to, že môžu existovať stromy v ktorých sa to nedá.

Prichádza čas na otázku, kedy sa strom nedá zafarbiť. Každý vrchol v storme má nejakú hĺbku. Zoberme si vrcholy v párnych hĺbkach. (koreň je BUNV v hĺbke 0). Z týchto vrcholov všetky hrany idú do vrcholov v nepárnych hĺbkach. Počet zafarbených hrán z vrcholov v párnych hĺbkach sa preto musí rovnať počtu zafarbených hrán z vrcholov v nepárnych hĺbkach. To znamená že musia mať aj rovnakú paritu. Keďže z každého vrchola vedie nepárny počet zafarbených hrán, tak parita počtu vrcholov v párnej hĺbke musí byť rovná parite počtu vrcholov v nepárnej hĺbke na to aby strom išiel zafarbiť. Ak sú rôzne tak práve vtedy sa stane ten prípad že po jednoznačnom zafarbení hrán v strome zistíme že z koreňu vychádza párny počet zafarbených hrán. Ak sú však parity rovnaké práve tento prípad nastať nemôže.

Tento princíp vieme využiť aj na nestromové bipartitné grafy. Teda ak máme ľubovolný komponent tak sa bude dať zafarbiť práve vtedy keď má počet vrcholov na jednej jeho strane a na druhej strane rovnakú paritu. Toto sa dá ľahko dokázať. Ak má počet vrcholov na jednotlivých stranách rôznu paritu a z každého vrcholu vychádza nepárny počet zafarbených hrán potom nám nesedí celkový počet zafarbených hrán z týchto strán(partícii) grafu. Zároveň ak má počet vrcholov rovnakú paritu tak si môžeme z komponentu zobrať jeho kostru. Poďla predchádzajúceho odseku vieme, že táto kostra (strom) sa dá zafarbiť jednoznačným spôsobom a preto existuje aspoň jedno zafarbenie tohoto bipartitného grafu, tak aby boli splnené podmienky zo zadania.

Myšlienka s kostrou je kľúčom k najdôležitejšiemu pozorovaniu úlohy. Uvažujme komponent pre ktorý existuje zafarbenie. Vyberme si z neho ľubovolnú kostru. Všetky ostatné hrany môžeme zafarbiť úplne ľubovolne a stále bude existovať zafarbenie kostry, také aby nám sedela parita v každom vrchole. Ako toto dokážeme? Konštrukciou. Nech všetko v komponente okrem kostry je zafarbené ľubovolne. Teraz poďme zafarbiť hrany v kostre. Opätovne postupujme rekurzívnym prehľadávaním do hĺbky. Keď sa dostaneme k nejakému vrcholu tak najprv zistíme, ako majú byť zafarbené hrany v jeho podstrome. Potom zafarbíme poslednú hranu, ktorá sa ho týka (tú ktorá vedie k jeho otcovi) a to iba v prípade, že pred jej zafarbením by mal vrchol párny počet zafarbených hrán. Takto vieme zafarbiť celý strom okrem koreňu jednoznačným spôsobom. To, že bude mať správnu paritu počtu zafarbených hrán ukážeme nasledovne: Vieme, že počet vrcholov v komponente na jednotlivých stranách (partíciach) má rovnakú paritu. Preto je ich súčet párny. Predstavme si, že by zo všetkých vrcholov vychádzal nepárny počet hrán okrem koreňu z ktorého vychádza párny počet hrán. Potom z vrcholov okrem koreňu celkovo vychádza nepárny počet hrán a z koreňa párny. Celkový súčet počtu vychádzajúcich hrán z vrcholov je nepárny. To je ale v spore s tým že každá hrana vychádza dva krát - raz z každého vrcholu. Preto aj z koreňu musí vychádzať nepárny počet zafarbených hrán.

Ako zistíme počet zafarbení nejakého komponentu? Je to 0, keď je počet vrcholov v komponente nepárny. (Ak je párny tak počet vrcholov na jednotlivých stranách má rovnakú paritu). A je to $2^k$ keď je počet vrcholov v komponente párny, kde $k$ je počet hrán ktoré nie sú v kostre. Každú z nich totiž vieme zafarbiť jedným z dvoch spôsobov. Aký je teda celkový počet možných zafarbení? Je to súčin počtu zafarbení jednotlivých komponentov. Ak je teda nejaký komponent nezafarbiteľný tak je výsledok nula. Inak je to súčin mocnín dvojky, teda súčet exponentov. Takže by sme mohli povedať, že je to $2^{n+m-l}$, kde $n+m$ je počet hrán a $l$ je počet hrán v kostrách jednotlivých komponentov. Všimnime si, že tento počet hrán môžeme zase vypočítať nasledovne. Nech $u$ je počet komponentov. Ak si spojíme kostry, pričom použijeme $u-1$ hrán, tak dostaneme jednu megakostru ktorá bude mať o jednu hranu menej ako je počet vrcholov. ^[Toto vieme z vlastností stromov] Preto je teda celkový počet zafarbení $2^{n+m-((r+s-1)-(u - 1))} = 2^{n+m+u-r-s}$. Vypočítať zvyšok tohoto čísla po delení iným (malým číslom) vieme jednoducho cez známy algoritmus v logaritmickom čase od veľkosti tohoto čísla.

Zostala posledná časť úlohy: Zistiť počet komponentov. O čo by to bolo jednoduchšie keby nám v zadaní nenadiktovali dodatočné hrany...

Zoberme si teda ľubovoľný takýto graf. Bez ujmy na všeobecnosti nech $r>s$. Potom doňho pridáme aspoň $n>=r+s$ hrán. Pozrime sa na tieto hrany podrobnejšie. Prvých $r$ hrán nám spojí každý riadok so stĺpcom, ktorý ma číslo rovnaké, ako číslo riadku modulo počet stĺpcov. Týmto nám v grafe zostane už iba $s$ komponentov. Teraz pridáme ešte $s$ hrán. Každá spoji riadok s číslom $i$ (ktorý je už spojený so stĺpcom číslo i) s riadkom s číslom $i+r \\pmod r$. Nech sú všetky komponenty definované číslom stĺpca ktorý sa v nich nachádza po prvých $r$ hranách. Potom týchto $s$ ďaľších hrán nám spojí pre všetky $i$ stĺpec $i$ so stĺpcom $i+r \\pmod s$. Poďme sa pozrieť na situáciu po pridaní $r+s$ hrán.

Máme $s$ stĺpcov (riadky už môžeme ignorovať lebo ku každému máme už jednoznačne priradený stĺpec, ktorý ho zastupuje. (Riadok $i$ zastupuje stlpec $(i \\pmod s)$. Vieme nasledovné: Stĺpec $i$ je spojený so stĺpcom $i+r \\pmod s$, žiadne ďalšie dodatočné hrany momentálne nemáme. Teda predstavme si to ako situáciu, kde mame nasledovný graf: Každý stĺpec predstavuje jeden vrchol. Stĺpec $i$ je spojený so stĺpcom $i+r \\pmod s$ a so stĺpcom $i-r \\mod s$.

Tvrdím nasledovné: Stĺpec $a$ je v jednom komponente so stĺpcom $b$ práve vtedy, keď $\\gcd(r,s)$ ^\[*Greatest Common Divisor*, po Slovensky najväčší spoločný deliteľ\] delí $a-b$.

Dôkaz: Ak existuje cesta z $a$ do $b$ tak prechádza nejakými vrcholmi. Všimnime si, že dvojice susediacich vrcholov majú rovnaký zvyšok po delení $\\gcd(r,s)$. Preto počas celej cesty prechádzame vrcholmi s rovnakým zvyškom po delení $\\gcd(r,s)$. Ak teda existuje cesta z $a$ do $b$ tak vtedy musia mať $a$ aj $b$ rovnaký zvyšok po delení $\\gcd(r,s)$.

Podobne môžeme dokázať, ze ak $a-b$ delí $\\gcd(r,s)$ tak existuje cesta z $a$ do $b$: Z $a$ sa vieme dostať na najviac $\\frac{s}{\\gcd(r,s)}$ vrcholov vrátane $a$. To je preto, že toľko vrcholov má rovnaký zvyšok po delení $\\gcd(r,s)$ ako $a$. Vieme sa odtiaľ dostať napríklad na vrcholy $(a \\mod s)$, $(a + r \\mod s)$, $(a+2r \\mod s)$, $(a+3r \\mod s)$... Všimnite si, ze napriek tomu že táto postupnosť je nekonečne dlhá, môže obsahovať len konečne veľa čísel. Preto sa niekedy stane že bude obsahovať dva krát to isté číslo a teda sa nutne niekde zacyklí. Zoberme si teda jej najkratší cyklus a zistime aký je dlhý. Pre nejaké $k$ a $j$ nutne platí že $a+kr \\equiv a+jr \\pmod s$. Potom ale $(k-j) r \\equiv 0 \\pmod s$. Počet riadkov $r$ si vieme rozpísať ako súčin $r=x \\cdot \\gcd(r,s)$, kde $x$ je nesúdeliteľné s $s$. Potom dostaneme $(k-j)r \\equiv (k-j) \\cdot x \\gcd(r,s) \\equiv 0 \\pmod s$. Keďže x je nesúdeliteľné nijako nám neovplyvňuje deliteľnosť $s$. Preto $(k-j) \\gcd(r,s) \\equiv 0 \\pmod s$, no nato aby bolo nejaké číslo deliteľné $s$ tak musí byť buď 0 alebo aspoň s. Preto $(k-j)\\gcd(r,s) \\ge s$, teda $k-j >= s/\\gcd(r,s)$ a tým pádom má najkratší cyklus dĺžku aspoň $s/\\gcd(r,s)$. No lenže všimnite si, že už vieme, že v komponente s $a$ bude najviac $s/\\gcd(r,s)$ vrcholov. Preto v komponente s $a$ musia byť práve tie vrcholy ktoré majú rovnaký zvyšok po delení $s/\\gcd(r,s)$.

Pozrime sa ešte na to, čo sa stane ak je $n>r+s$. Všimnite si, že sa vzniknú hrany medzi $(i \\pmod r \\pmod s)$ a $i \\pmod s$. Tieto čísla však zaručene majú rovnaký zvyšok po delení $\\gcd(r,s)$. Preto sa tým už žiadne ďalšie komponenty nespoja.

Tým pádom po pridaní $n$ hrán, budú dva stĺpce v jednom komponente práve vtedy keď $\\gcd(r,s)$ delí ich vzdialenosť.

Všimnite si že takto dostaneme $gcd(r,s)$ komponentov a každý z nich je rovnako veľký, takže si ľahko spočítame ich veľkosť a z toho paritu.

Teraz už zostáva len posledná otázka -- ako si zistiť koľko komponentov vlastne máme, keď ich dodatočne pospájame $m$ hranami. Na tento účel vieme použiť Union-Find, no nebude úplne jednoduché keďže si možno nebudeme vedieť zapamätať všetky vrcholy. Preto spravíme pár drobných zmien. V prvom rade si budeme hlavné vrcholy každého komponentu pamätať v mape namiesto poľa. (Tým pádom si nemusíme pamätať všetky vrcholy, stačia iba tie kde nastala zmena.) Taktiež si budeme pamätať celkový počet komponentov a počet komponentov s nepárnym počtom vrcholov. Okrem toho si zapamätáme o každom komponente či ma párny alebo nepárny počet hrán. Pomocou Union Findu budeme vždy vedieť ľahko zistiť, či hrana spája dva komponenty, ktoré ešte spojené neboli a ak áno, tak budeme vedieť, určiť ktoré to sú. Tým pádom budeme vedieť aktualizovať paritu počtu ich vrcholov a tiež počet komponentov s nepárnym počtov vrcholov. Tým pádom nakoniec budeme vedieť či je komponent s nepárnym počtom vrcholov a koľko komponentov je celkovo v grafe, z čoho budeme vedieť vyrátať odpoveď.

Union find bude potrebovať $O(m log (r+s))$ krokov vzhľadom k tomu že bude uložený v mape. Umocňovanie spravíme na rádovo $\\log (n+m)$ krokov. Najväčší spoločný deliteľ vieme pomocou Euklidovho algoritmu zrátať radovo v čase $O(\\log (r+s))$. Celková časová zložitosť je teda $O(m log ^2 (r+s) + log(n+m))$.
",10
cf4a07300e5c164a,ksp,"# Liečivá alpa

V Anurovej lekárničke pribudla mocná zbraň -- všeliek všetkých otvorených zranení, všemocná alpa^[Ako každý vie, všeliek všetkých zatvorených je konská masť.]. Tak sa mu osvedčila a zapáčila, že ampuliek alpy nosí so sebou vždy nekonečne veľa.

V sobotu sa, tak ako asi všetci, zabával na gladiátorských hrách. Tak veľmi sa mu tam páčilo, až sa rozhodol, že ani porazení gladiátori si nezaslúžia zomrieť. Preto hneď, ako dotlieskal, zoskočil z tribúny a vytiahol alpu, odhodlaný vyliečiť čo najviac bojovníkov.

Každý bojovník má niekoľko zranení, ktoré treba vyliečiť. Ak ostane bojovníkovi čo i len jedno zranenie nevyliečené, dostane infekciu a zomrie tak či tak. Na vyliečenie hocijakého zranenia stačí jedna kvapka alpy. Keďže alpa je balená v znovu neuzatvárateľných obaloch, Anura má teraz veľkú dilemu:

Chce vyliečiť čo najviac bojovníkov. Zároveň si však alpu veľmi váži^[Príprava alpy je veľmi náročná, ako súčasť procedúry musí alpa prejsť tráviacim traktom Púnskeho slona.] a teda ak nejakú jej ampulku otvorí, chce ju celú do poslednej kvapky minúť (zužitkovať, nie premrhať vyhodením, alebo kvapnutím na už zahojenú ranu). Anura nemá to srdce prejsť počas liečenia okolo bojovníka a nevyliečiť ho. Teda ak niekde začne liečiť, bude postupne za radom liečiť všetkých bojovníkov, až k nejakému, od ktorého potom nenápadne odíde, snažiac sa nemyslieť na ostatných nevyliečených.

## Úloha

V rade vedľa seba stojí $n$ bojovníkov čakajúcich na vyliečenie. O každom bojovníkovi vieme jeho počet zranení $z_i$, a teda aj počet kvapiek alpy potrebných na jeho zachránenie.

V každej ampulke je $a$ kvapiek alpy. Zistite, aký najdlhší súvislý úsek bojovníkov môže Anura vyliečiť bez toho, aby čo i len kvapka alpy vyšla nazmar. **Počet použitých ampuliek nás nezaujíma.**

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú medzerou oddelené prirodzené čísla $n$ a $a$ ($1 \\leq n, a \\leq 100,000$) -- počet zranených bojovníkov a počet kvapiek v jednej ampulke alpy. Nasleduje $n$ riadkov, v $i$-tom z nich sa nachádza prirodzené číslo $z_i$ ($1 \\leq z_i \\leq 10^9$) -- počet zranení $i$-teho bojovníka zľava.

## Formát výstupu

Na jediný riadok výstupu vypíšte maximálny počet bojovníkov, ktorých sa dá za daných podmienok vyliečiť.

## Príklady

```vstup
5 9
1
2
3
4
5
```

```vystup
3
```

_Troch vyliečime, ak začneme liečiť druhého bojovníka a skončíme predposledným._

```vstup
6 2
3
4
1
2
4
3
```

```vystup
5
```

_Napríklad vyliečime prvých piatich._

```vstup
5 22
9
1
6
2
3
```

```vystup
0
```

_Je nám to ľúto, ale nie sme ochotní premrhať čo i len kvapku._
","# Liečivá alpa

Čo vám napadne ako prvé po prečítaní úlohy? Pravdepodobne priamočiaro vyskúšať všetky možnosti. V tomto príklade to znamená vyskúšať liečiť všetky možné podúseky bojovníkov a pre každý overiť, či po ich vyliečení nezostanú v nejakej ampulke ešte nejaké kvapky. Pre každý možný začiatok a koniec úseku spočítame, koľko kvapiek alpy na tomto úseku minieme. Ak je tento počet deliteľný veľkosťou jednej alpulky $a$, potom sa daný úsek dá vyliečiť bez plytvania alpou. Zapamätáme si a vypíšeme dĺžku najdlhšieho vyliečiteľného úseku. Easy!

Asi tušíte, že toto nebude vzorové riešenie. Hlavne kvôli svojej časovej zložitosti $O(n^3)$ - máme totiž $O(n^2)$ možných podúsekov a pre každý z nich potrebujeme sčítať všetky čísla v ňom (ktorých je $O(n)$).

Šikovnou implementáciou (alebo aj bezduchým použitím prefixových súm) sa dá časová zložitosť tohto algoritmu zlepšiť na $O(n^2)$. To je však stále pomalé. Pre počet bojovníkov $100, 000$ už počítač jednoducho nebude stíhať.

## Prefixové súčty

Predstavme si, že by sme si nad zraneniami bojovníkov spočítali [prefixové súčty](https://www.ksp.sk/kucharka/prefixove_sumy/). Súčet čísel medzi $i$-tym a $j$-tym bojovníkom (vrátane) potom vieme vypočítať ako rozdiel $j$-teho a $i-1$-vého prefixového súčtu.

Ak je počet zranení na nejakom úseku deliteľný veľkosťou ampulky $a$, potom musia mať príslušné dva prefixové súčty rovnaký zvyšok po delení $a$ (lebo ich rozdiel je deliteľný $a$). Toto platí aj obrátene: ak majú dva prefixové súčty rovnaký zvyšok po delení $a$, potom sa úsek bojovníkov medzi nimi dá vyliečiť bez plytvania alpou.

Aby sme teda našli najdlhší vyliečiteľný úsek bojovníkov, stačí nám nájsť dva najvzdialenejšie prefixové súčty, ktoré dávajú rovnaký zvyšok po delení $a$.

## Už to len nakódiť

Ak si všetky prefixové súčty vymodulujeme^\[operácia _modulo_ znamená zvyšok po delení\] číslom $a$, bude nám stačiť nájsť dve rovnaké čísla, ktoré sú čo najďalej od seba.

Toto sa dá implementovať napríklad tak, že budeme prechádzať pole s vymodulovanými prefixovými súčtami zľava doprava a v ďalšom poli o veľkosti $a$ (pretože všetky čísla budú po upravení z tohto rozsahu!), si budeme pamätať prvý výskyt každého čísla. Akonáhle narazíme na číslo, ktoré už poznamenané máme, vieme, že sme objavili podúsek dlhý od prvého výskytu až po aktuálny index. Takto vieme vypočítať správny výsledok v jednom prechode a teda v časovej zložitosti $O(n)$. Pamäťová zložitosť je $O(a)$, teda závislá od veľkosti alpy.

## Poznámka na záver - mega veľké alpy

Dalo by sa to riešiť aj keby $a$ bolo veľké?^[Na Orave som naozaj videl v potravinách predávať litrovú alpu ;).] Áno ide to, jediná zmena by bola v pamätaní prvých výskytov. Nepoužili by sme pole, ale napr. hashmapu. Vďaka nej by čas stále ostal $O(n)$ a pamäť by bola závislá už iba od počtu bojovníkov, tiež $O(n)$.
",4
75a05fdbfb0aae80,ksp,"# Oprášený startup

V dávnych časoch, na ktoré sa v KSP pamätá už len Mišof, sa snažil Dávidko^[Bývalý KSP vedúci, ktorý aktuálne pracuje v New Yorku a má manželku Halucinku (ďalšia bývalá KSP vedúca).] rozbehnúť start-up so špeciálnymi 'Dávidkovými procesormi'. V tom čase predstavovali so svojou 32 bitovou výpočtovou jednotkou a takmer 77 MB pamäťou vrchol technického pokroku. Bohužiaľ, kvôli slabej mediálnej kampani neboli tieto procesory úspešné a celý Dávidkov projekt zapadol prachom.

Nedávno, prehrabávajúc sa zákutiami T2, objavil tento projekt Syseľ a povedal si, že teraz by už mohol dopadnúť lepšie. Ísť však na trh s procesorom by nebolo príliš rozumné. Ak by však daný procesor upravil tak, aby vedel komprimovať text, tak by 'Sysľov komprimátor' mohol zožať nečakaný úspech. Akurát tá úprava nie je taká jednoduchá, keďže 'Dávidkov procesor' beží na veľmi starom a primitívnom systéme. Vy si s tým však určite nejak poradíte.

## Dávidkov procesor

Dávidkov procesor obsahuje jeden zásobník (stack), s ktorým pracujú dané inštrukcie. Na zásobník sa ukladajú 32-bitové čísla so znamienkom, teda čísla z rozsahu $-2^{31}$ až $2^{31}-1$. Na začiatku behu programu je zásobník prázdny.

Zásobník zapisujeme horizontálne, pričom napravo sa nachádza vrch zásobníka. Reťazec `""...""` reprezentuje pôvodný stav zásobníka. Reťazec `""...|a|b""` značí, že na vrchu zásobníka sa nachádza číslo $b$ a pod ním číslo $a$. Hodnota `""S[n]""` je $n$-tá hodnota zásobníka. Ak je $n\\geq 0$ táto hodnota sa počíta od spodku, ak $n\<0$, tak od vrchu.

Dávidkov procesor pozná nasledovné príkazy:

| Príkaz | Popis príkazu | Zásobník pred | Zásobník po | | ------------- | :-------------------------------------------------------------- | :-------------- | :------------ | | PUSH$~~const$ | Na vrch zásobníka pridá číselnú konštantu $const$ | ... | ...|const | | OUT | Odstráni vrchné číslo zásobníka a vypíše ho na výstup ako ASCII | ...|a | ... | | | znak. Chyba nastane, ak je odstránené číslo menšie ako 0 alebo | | | | | väčšie ako 127. | | | | READ | Odstráni zo zásobníka vrchné číslo (označme ho $a$) a následne | ...|a | ...|S[a] | | | nakopíruje na vrch zásobníka hodnotu $S[a]$ | | | | JGZ | Odstráni zo zásobníka dve vrchné hodnoty $b$ a $a$. Následne sa | ...|a|b | ... | | | posunie o $b$ inštrukcií (dopredu pre kladné $b$, inak dozadu) | | | | | v prípade, že je $a>0$ | | | | ADD | Odstráni dve čísla na vrchu zásobníka a pridá na vrch ich súčet | ...|a|b | ...|a+b | | MUL | Odstráni dve čísla na vrchu zásobníka a pridá na vrch ich súčin | ...|a|b | ...|a\*b | | DIV | Odstráni dve čísla na vrchu zásobníka a na vrch pridá ich podiel| ...|a|b | ...|q|r | | | a zvyšok po delení ($q=a/b$ (celočíselné delenie), $r=a%b$) | | |

Ak by pri vykonávaní niektorého príkazu nebolo v zásobníku dostatočné množstvo čísel (napríklad aspoň 2 pre JGZ, aspoň 1 pre OUT), program skončí chybou. Program tiež skončí chybou, ak je na zásobníku v niektorom momente viac ako $20,000,000$ čísel, alebo sa vykoná viac ako $300,000,000$ príkazov.

Technické detaily aritmetických operácií (pretečenie, modulo zo záporného čísla atď.) fungujú rovnako ako v C++.

Program si po spustení udržiava hodnotu $prikaz$, ktorá ukazuje na príkaz, ktorý sa aktuálne vykonáva. Táto hodnota je na začiatku 0 (začína sa prvým príkazom). Hodnota $prikaz$ sa zvýši o 1 po dokončení aktuálneho príkazu. Ak nastal skok príkazom `""JGZ""`, táto premenná sa ešte predtým zmení o danú veľkosť skoku $b$, následne sa však opäť posunie o 1 dopredu. Ak teda $b=-1$, tak $prikaz$ bude ukazovať opäť na ten istý príkaz. V okamihu ako premenná $prikaz$ ukazuje mimo existujúce príkazy, program je považovaný za korektne zastavený.

## Úloha

Dávidkov procesor podporuje iba uvedenú malú sadu príkazov. Vašou úlohou je pomocou týchto príkazov napísať čo najkratší program, ktorý vypíše zadaný text.

## Formát vstupu

Dostanete 9 rôznych súborov s textami, všetky používajú štandardnú 7-bitovú ASCII reprezentáciu znakov. Niektoré z textov sú zmysluplné anglické alebo slovenské texty, iné sú vytvorené umelo. Súbory so vstupmi majú názvy `1.in`, `2.in`, ... , `9.in`.

## Formát výstupu

Odovzdajte jeden ZIP archív, ktorý bude obsahovať súbory s názvami `1.out`, `2.out`, ... , `9.out`. Pre každý vstupný text teda odovzdávate samostatný súbor s programom pre Dávidkov procesor.

Každý súbor sa musí skladať z príkazov popísaných vyššie a vypísať daný text. Odovzdaný program je zoznam inštrukcií, každá na samostatnom riadku. Inštrukcie píšte veľkými písmenami presne ako sú udané v tabuľke.

Uvedomte si, že vašou úlohou je vypísať presne taký istý text, vrátane znakov ako medzery alebo konce riadkov. Prvé 4 vstupy neobsahujú znak konca riadka.

## Hodnotenie

Každý z deviatich textov bude hodnotený samostatne. Za vyriešenie každého z nich sa dá získať nejaká časť bodov a výsledný bodový zisk je súčet bodov za každý text.

| Text | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | | --------------------- | - | - | - | - | - | - | - | - | - | | Maximálny počet bodov | 1 | 2 | 2 | 3 | 3 | 3 | 4 | 3 | 4 |

V tejto úlohe budete súťažiť proti sebe. Bodovanie v rámci jedného textu je škálované podľa najlepšieho odovzdaného riešenia.

Skóre odovzdaného programu sa vypočíta ako počet inštrukcií použitých v programe (teda počet príkazov v zdrojovom kóde, nie počet príkazov, ktoré sa naozaj vykonajú počas behu programu), pričom príkaz `""PUSH""` sa počíta za 2. Nech $O$ je skóre programu, ktorý ste odovzdali, $M$ je najmenšie dosiaľ získané skóre nejakého programu (vrátane toho so skóre $O$) a $B$ je počet bodov, ktoré sa dajú získať za vyriešenie daného textu. Výsledného skóre tohto programu je $B\\cdot \\frac{M}{O}$.

Počas behu kola budeme hodnoty $M$ (najmenšie dosiahnuté skóre pre každý text) aktualizovať približne raz za týždeň a po skončení kola ich aktualizujeme znova a vypočítame finálne body.

Keďže neodovzdávate programy a nás zaujíma, ako úlohu riešite, môžete do ZIPka priložiť aj zdrojové kódy programov, ktoré ste pri riešení použili, prípadne stručný popis, ak by ste sa chceli pochváliť.

## Súbory na stiahnutie

Na tomto odkaze: [http://media.ksp.sk/ulohy/34rocnik/1kolo/prikl8-na-stiahnutie.zip](http://media.ksp.sk/ulohy/34rocnik/1kolo/prikl8-na-stiahnutie.zip) si viete stiahnuť niekoľko užitočných súborov. Je tam spomínaných deväť textov, pre ktoré máte vytvoriť programy a takisto C++ program, ktorý simuluje tento zásobníkový procesor. Vďaka nemu si viete otestovať, či vami vytvorený program naozaj vypíše žiadaný text. Rovnakým spôsobom budeme tiež simulovať vaše riešenia na testovači, takže si môžete overiť implementáciu dôležitých častí zásobníkového procesora.

## Príklad

```vstup
Hello
```

```vystup
PUSH 72
OUT
PUSH 203
PUSH 2
DIV
PUSH 2
JGZ
PUSH 80
OUT
OUT
PUSH 108
PUSH 111
PUSH 0
PUSH 0
READ
OUT
READ
OUT
OUT
```

_Všimnite si, že príkazy na riadkoch 7 a 8 (číslujeme od 0) boli preskočené vďaka `""JGZ""` a nikdy sa nevykonali. Program skončil korektne a na zásobníku ostalo číslo 108. Skóre takéhoto programu je 28._
","# Oprášený startup

Dúfam, že so mnou budete súhlasiť v tom, že táto optimalizačná úloha bola naozaj zaujímavá. Nestáva sa predsa každý deň, že píšete program, ktorého výstupom je iný program. Otázkou však je, ako napísať k takejto úlohe vzorák.

Nakoniec som sa rozhodol, že vám v tomto vzoráku ukážem hlavné myšlienky, ktorými sa dalo riadiť pri postupnom získavaní bodov. Najprv si ukážeme niekoľko jednoduchších prístupov, potom si predstavíme pomerne zaujímavý algoritmus slúžiaci na kódovanie znakov a nakoniec to všetko skombinujeme do výsledného riešenia. To samozrejme nebude najlepšie možné, ale kvôli prehľadnosti vzorového riešenia nebudeme uplatňovať príliš veľa optimalizácií.

## S niečím začať treba

Prečo teda nespraviť prvú a najľahšiu vec, čo nám napadne! Nemáme čo stratiť a naprogramovanie ľahkého riešenia nám zaberie veľmi málo času. Otestujeme si ním, či správne rozumieme príkazom, ktoré Dávidkov procesor používa, a keď budeme neskôr robiť niečo zložitejšie, budeme si vedieť porovnať naše riešenia a zistiť, ako veľmi sme sa zlepšili.

Ak sa pozrieme na príkazy, ktoré používa Dávidkov procesor, vidíme, že vypisovať budeme príkazom `OUT`. Ten podľa zadania zoberie vrchné číslo na zásobníku a vypíše toľký znak z ASCII tabuľky. Ak teda chceme napríklad vypísať znak `""a""`, ktorý je v ASCII tabuľke 97-my, tak najskôr musíme dostať na zásobník číslo 97, čo spravíme príkazom `PUSH 97`. Takto vieme dostať jednoduchý program, ktorý vypíše znak `""a""` a nič iné.

A toto predsa vieme spraviť s ľubovoľným znakom v texte. Pozrieme sa na to, koľký v poradí je tento znak v ASCII tabuľke, vložíme také číslo do zásobníka a potom ho z neho rovno vypíšeme. Môžeme preto napísať jednoduchý program v `C++`, ktorý načíta text a vytvorí z neho program pre Dávidkov procesor, ktorý daný text vypíše.

Všimnite si, ako v tomto programe šikovne využívame fakt, že `C++` vie s premennou typu `char` pracovať ako s číslom z ASCII tabuľky. Ak preto necháme vypísať `char` ako `int`, vypíše sa žiadaná hodnota.

## Programovanie v Dávidkovom procesore

Ukázali sme si, ako vieme spraviť prvé, veľmi jednoduché riešenie, ktoré pre každý znak na vstupe použije dva príkazy Dávidkovho procesora. Ďalej potrebujeme prísť s niečím, čo tento počet príkazov výrazne zmenší. To, že musíme pridať na zásobník konkrétnu hodnotu pre každý znak asi neovplyvníme (zatiaľ). Mohli by sme však radšej použiť ostatné príkazy Dávidkovho procesora na to, aby sme zmenšili počet príkazov potrebných na vypisovanie.

Čo spravíme v `C++`, ak chceme vypísať obsah nejakého poľa (zásobníka)? Použijeme `for`-cyklus. Hľadáme preto spôsob, akým naprogramovať `for`-cyklus v Dávidkovom procesore. A keďže `for`-cyklus nie je nič iné ako vracanie sa na tie isté riadky, budeme chcieť použiť príkaz `JGZ`.

Rozmyslime si najskôr slovne, čo chceme spraviť: ""Vypíš znak zodpovedajúci vrchnému číslu na zásobníku a toto číslo odstráň. Ak zásobník nie je prázdny, vráť sa na príkaz výpisu (začiatok).""

Hneď si však všimneme, že nevieme zistiť, či je zásobník prázdny alebo nie. Vieme iba zisťovať, či je na vrchu zásobníka číslo väčšie ako 0. A keďže 0 sa medzi číslami na zásobníku nachádzať nebude (lebo to nie je znak, ktorý by sa nám objavil v texte), môže 0 slúžiť ako vhodná zarážka na koniec zásobníka. Potrebujeme preto overiť, či je na vrchu zásobníka 0 a ak nie je, tak pokračovať vo vypisovaní.

Posledný problém, ktorý musíme vyriešiť, je, že príkaz `JGZ` odstráni dve vrchné čísla zo zásobníka. Musíme si preto vytvoriť kópiu vrchného čísla, ktorú môžeme bez problémov odstrániť. Takúto kópiu vytvoríme pomocou príkazu `READ`.

To, čo sme spravili, je vlastne programovanie pomocou príkazov Dávidkovho procesora. Poriadne si pozrite vyššie uvedený program. Niečo podobné ešte párkrát uvidíte a v podstate nič zložitejšie potrebovať nebudeme.

Náš program teda do zásobníka postupne pridá jedno číslo za každý znak textu a potom vykoná vyššie uvedený kúsok programu, ktorý znaky vypíše. Netreba ešte zabudnúť na to, že čísla znakov musíme na zásobník pridávať v obrátenom poradí, teda prvý znak textu musí byť pridaný ako posledný.

## Štyri v jednom

Koľko príkazov použil náš posledný program? Potreboval jeden príkaz za každé písmeno na vstupe a potom ešte päť príkazov na vypísanie. Asi je jasné, že ak chceme vymyslieť ešte lepšie riešenie, musíme zmenšiť počet čísel, ktoré na začiatku vložíme do zásobníka.

To znamená, že jedno číslo musí zastupovať (kódovať) viacero znakov. Uvedomme si, že čísla, ktoré môžeme vkladať do zásobníka môžu mať veľkosť až $2^{31}-1$. Naše riešenia však zatiaľ používali iba čísla, ktoré nemohli byť väčšie ako $2^7$ (počet znakov v ASCII tabuľke). Pokúsime sa preto nájsť spôsob, akým zakódovať viacero znakov do jedného čísla a samozrejme aj spôsob, ako tento postup obrátiť (ako z čísla zistiť znaky, ktoré kóduje).

Predstavme si, že chceme zakódovať dva znaky -- znak `""a""` s ASCII číslom 97 a znak `""b""` s ASCII číslom 98, pričom `""a""` má byť vypísané skôr ako `""b""`. Použime na to číslo $12,641 = 128\\cdot 98

- 97$. Dôvod, prečo je takéto kódovanie dobré je ten, že z čísla $12,641$ vieme ľahko zistiť, ktorý znak má byť vypísaný prvý. Bude to predsa zvyšok čísla $12,641$ po delení $128$. Druhé číslo na vypísanie bude celočíselný podiel týchto dvoch čísel a na počítanie podielu a zvyšku po delení máme pre Dávidkov procesor príkaz `DIV`.

Nemusíme sa však obmedziť tým, že do jedného čísla zakódujeme len dva znaky. Takéto čísla budú totiž nanajvýš veľkosti $2^{14}$. Pridajme preto rovnakým spôsobom ďalšie dve čísla. Zo štyroch znakov $a$, $b$, $c$ a $d$ (toto sú premenné a nie konkrétne znaky) potom vieme spraviť jedno číslo menšie ako $2^{28}$ nasledovne:

$$a + 128\\cdot b + 128^2 \\cdot c + 128^3 \\cdot d$$

Sami si rozmyslite, že postupným delením tohto čísla číslom 128 budeme ako zvyšky dostávať čísla zodpovedajúce znakom $a$, $b$, $c$ a $d$.

Program, ktorý kóduje náš text takýmto spôsobom je o niečo komplikovanejší. Musíme si dať pozor, aby sme zakódovali čísla v správnom poradí a musíme vymyslieť program používajúci príkazy Dávidkovho procesora, ktorý bude zadané čísla deliť 128 a vypisovať ich na výstup. Nie je to však až také ťažké a nižšie si môžete pozrieť jedno možné riešenie.

## Tok bitov

Pokúsime sa ešte viac vylepšiť naše riešenie. Dobrý nápad je pozrieť sa na jednotlivé texty, ktoré máme zadané. Možno nás napadne nejaké lepšie riešenie, našité priamo na ne.

A naozaj, ak sa pozrieme na text `1.in`, zistíme, že obsahuje iba písmená `""c""` (dokonca neobsahuje ani koniec riadku). Je zjavne zbytočné do zásobníka vkladať veľa hodnôt, ktoré nám aj tak povedia to, čo už dopredu vieme -- vypíš písmeno `""c""`. Namiesto toho by nám v zásobníku mohla stačiť iba jedna hodnota, ktorá hovorí, koľko písmen `""c""` ešte máme vypísať. Túto hodnotu budeme postupne znižovať až kým neklesne na 0. Vtedy program ukončíme pomocou príkazu `JGZ`.

Dostaneme jednoduchý 9-príkazový program:

Pozrime sa teraz na text `2.in`. V ňom sa nachádzajú iba dva druhy písmen -- `""f""` a `""y""`. Naším cieľom bude teda zakódovať túto postupnosť dvoch druhov písmen čo najúspornejšie. Predchádzajúce všeobecné riešenie používalo na kódovanie čísla 102 a 121. To je však strašne zbytočné. Na zakódovanie písmena `""f""` môžeme predsa použiť hodnotu 0 a ako kód `""y""` použijeme 1. Záleží len na nás, či bude náš program rozoznávať `""f""` ako 102 alebo 0.

Náš text sme si teda zmenili na postupnosť bitov (základná jednotka informácie, ktorá nadobúda iba hodnotu 0 alebo 1) -- a v počítači je aj každé číslo reprezentované ako postupnosť bitov (v našom prípade 32 bitov). Namiesto 4 písmen vieme teraz do jedného čísla preto zakódovať až 32 písmen, čo je 8-násobné zlepšenie.

Napriek tomu, to nebude také jednoduché. Po prvé, potrebujeme do čísla zakódovať nejakým spôsobom túto postupnosť bitov. To síce vyzerá priamočiaro -- nasekám si bity na 32-tice a jednoducho ich zmením na číslo -- avšak objaví sa niekoľko problémov, ktoré budeme musieť vyriešiť. Po prvé, je nebezpečné používať všetkých 32 bitov, lebo hoci Dávidkov procesor dokáže pracovať s $2^{32}$ číslami, polovica z nich je záporná (rozsah čísel v zásobníku je $-2^{31}$ až $2^{31}-1$). Tu by už naša matematika -- delíme 2 a pozeráme sa na zvyšok -- nefungovala tak akoby sme chceli, a preto sa obmedzíme len na prvých 31 bitov, ktoré nám zaručia, že čísla budú kladné.

Navyše však dostaneme nasledovný problém. Náš program bude postupne deliť naše číslo hodnotou 2. Kedy má však zastať? Ak sa číslo zmenší na 0, znamená to, že už som spracoval všetky bity, alebo ešte nasleduje niekoľko 0-vých bitov? Riešení tohto problému môže byť viac. Pri jednom možnom spôsobe zopakujeme Dávidkovým programom 31 delení. Mohli by sme 31-krát nakopírovať kus programu ktorý vykoná delenie alebo na to použiť ďalší (vnorený) cyklus. Buď sa nám teda zväčší počet príkazov, alebo to bude neprehľadnejšie a takisto budeme musieť ešte vyriešiť prípad, kedy niektoré číslo nekóduje 31, ale menej bitov.

Riešenie, ktoré si ale ukážeme my, bude založené na tom, že si do každého čísla spravíme značku. V podstate si vyhradíme najvyšší používaný bit (väčšinou 31-vý) ako zarážku. Zakaždým bude mať hodnotu 1. Tým pádom, pri delení dvojkou sa nám raz stane, že nám v celom čísle ostane už len tento jednotkový bit, a číslo, ktoré budeme spracovávať bude teda rovné 1. Ak nastane takýto prípad, budeme vedieť, že už sme spracovali všetky bity, ktoré kódovalo toto číslo a môžeme sa presunúť na to ďalšie.

Pozrite si nižšie uvedenú implementáciu takéhoto riešenia. Všimnite si hlavne časť, v ktorej je zadrôtovaný Dávidkov program, ktorý vydelí číslo hodnotou 2 a podľa zvyšku skočí buď do časti, ktorá vypisuje písmeno `""f""` alebo do časti pre písmeno `""y""`.

Uvedomme si ešte, že takéto riešenie sa dá istým spôsobom zovšeobecniť. Na vstupe máme postupnosť (tok) bitov. Našou úlohou je spracovávať ich jeden po druhom a robiť rozhodnutia podľa toho, či je aktuálny bit 0 alebo 1. To, čo sme si ukázali v tejto časti, boli často len technické pomôcky, ako niečo takéto robiť pomocou príkazov Dávidkovho procesora.

## Nerovnomerný výskyt a prefixový kód

Pozrime sa teraz na text `4.in`^\[Text `3.in` preskakujem úmyselne. Vieme naň síce vymyslieť vcelku jednoduché a pomerne dobré riešenie, nijak však nesúvisí so vzorovým riešením, a preto ho tu nespomeniem.\]. V ňom sa objavujú len tri znaky -- `""p""`, `""q""` a `""A""`.

Prirodzene, prvá vec, ktorá nám napadne, je použiť na kódovanie znakov čísla 0, 1 a 2 (v jednom čísle by sme si pamätali znaky nie ako zvyšky po opakovanom delením dvomi, ale po delení tromi). Na tom by nebolo nič zlé, ale predsa len, zaberá to trochu veľa miesta -- na každé číslo musíme využiť takmer 2 bity.

Zostaňme ale pri našej predstave toku bitov s hodnotami 0 alebo 1. Mohli by sme napríklad každému znaku priradiť nejaké dva bity (napr.: `""p""` by sme zakódovali ako `""00""`, `""q""` ako `""01""` a `""A""` ako `""10""`). Potom by sme opäť dostali tok bitov, akurát by sa trochu nepríjemnejšie spracovával. Ale to nám tiež neušetrí počet bitov, ktoré použijeme. Skúsme to ešte inak. Použime na kódovanie tri, nerovnako dlhé, reťazce `""1""`, `""00""` a `""01""`.

Keď každému písmenu priradíme jeden takýto reťazec, opäť vieme celý text zmeniť na postupnosť bitov. Naviac, táto postupnosť bitov sa dá jednoducho dekódovať. Postupne prechádzame bity zľava -- ak je prvý bit 1, vieme, že sme narazili na prvé písmeno a môžeme ho vypísať. Ak je prvý bit 0, tak zase vieme, že sa musíme pozrieť ešte na druhý bit a až ten nám rozhodne, čo máme vypísať. V každom momente sa preto vieme jednoznačne rozhodnúť, čo treba spraviť. Naviac, na zakódovanie jedného zo znakov použijeme iba jeden bit.

To, čo môžeme v takomto riešení ovplyvniť je, ktorým písmenám priradíme ktorý reťazec. Už pri letmom pohľade do textu `4.in` by sme si mali všimnúť, že znak `""A""` sa tam nachádza častejšie. Je preto logické, že práve jemu chceme priradiť reťazec `""1""`, lebo ušetrenie jedného bitu (oproti reťazcom `""01""` a `""00""`) bude častejšie. Na priradení zvyšných dvoch reťazcov nezáleží, lebo majú rovnakú dĺžku.

Následne ešte musíme trochu upraviť Dávidkov program, ktorý bude tento tok bitov spracovávať. Aj on sa totiž musí vedieť rozhodovať podľa toho, či vidí 0 alebo 1 a ak vidí 0 tak sa presunúť na ďalší bit, aby vedel, čo má vypísať. Riešenie je však veľmi podobné tomu, čo sme už videli predtým. Všimnite si, že Dávidkov program aj pre prehľadnosť rozdeľujem do častí, medzi ktorými náš program skáče a každá časť má presne určenú úlohu.

Na tomto riešení si môžeme všimnúť dve veľmi dôležité veci. Prvou je, že reťazce, ktoré priraďujeme ako kódy znakov nemusia byť rovnako dlhé. Prirodzene sa nám potom oplatí použiť kratšie reťazce pre častejšie sa vyskytujúce znaky, keďže vďaka tomu viac ušetríme. Takýto postup využíva napríklad aj Morseovka. Ak si pozriete tabuľku jej kódovania, zistíte, že dva najkratšie reťazce, bodka a čiarka, sú priradené písmenám `""E""` a `""T""`, ktoré sú (nie zhodou náhod) dve najčastejšie sa vyskytujúce písmená anglickej abecedy. Najdlhšie reťazce sú naopak priradené znakom, ktoré sa vyskytujú veľmi zriedkavo.

To však nebola jediná vec, na ktorú sme si museli dať pozor. Je potrebné tiež zaručiť, že dekódovanie je jednoznačné -- teda vždy máme na základe aktuálneho bitu iba jedinú možnosť na to, čo spraviť. V Morseovke takéto niečo neplatí, ak sa pri dekódovaní objaví ako prvá bodka, nemôžeme si byť istí, či máme vypísať `""E""` (bodka), alebo prečítať ďalší znak, ktorý môže byť čiarka, čo by zodpovedalo písmenu `""A""` (bodka, čiarka). V Morseovke sa preto používa aj tretí symbol -- oddeľovač.

My však oddeľovač k dispozícii nemáme (máme iba znaky 0 a 1), preto budeme používať **prefixové** kódy. To znamená, že žiaden kód nie je prefixom (začiatkom) iného kódu. Keď je splnená táto podmienka, kód sa bude dať vždy jednoznačne dekódovať.

## Huffmanov kód

Zoberme si teraz ľubovoľný text, napríklad jeden z posledných štyroch -- anglické a slovenské texty. Naším cieľom je vytvoriť prefixový kód, ktorý naviac zakóduje náš text na čo najmenej bitov. Uvedomte si, že takýto kód chceme našiť priamo na daný text, lebo výskyty písmen ovplyvňujú dĺžku kódových slov. V slovenčine totiž asi ťažko budeme hľadať písmená `""q""` alebo `""w""` a ak sa aj vyskytnú, môžeme im priradiť naozaj dlhý kód. V angličtine sú však tieto dve písmená oveľa častejšie a naše riešenie by to malo zobrať do úvahy. Hľadáme preto všeobecný algoritmus, ktorý dokáže pre daný text vytvoriť prefixový kód s optimálnou dĺžkou.(**Kód** je jedno konkrétne priradenie **kódových slov** (v našom prípade binárnych reťazcov) znakom textu.)

Zoberme si konkrétny text a spočítajme si písmená, ktoré obsahuje. Nech obsahuje $m$ písmen, pričom $i$-te písmeno sa v tomto texte vyskytuje $p_i$-krát. Naviac, nech platí $p_0 \\geq p_1 \\geq \\dots \\geq p_m$. Predstavme si tiež, že už máme nájdený optimálny prefixový kód, ktorý týmto znakom priradí binárne kódy $w_1, w_2 \\dots w_m$. Naviac, dĺžky týchto kódových slov si označme $l_1, l_2 \\dots l_m$.

Z tohto vyplýva, že na zakódovanie tohto textu potrebujeme presne $\\sum\_{i=1}^m p_i\\cdot l_i$ bitov. Poďme si povedať, čo musí platiť o týchto slovách, ak majú tvoriť optimálny kód. Po prvé, musí platiť, že $l_1 \\leq l_2 \\leq \\dots \\leq l_m$. Toto zodpovedá nášmu pozorovaniu, že dlhšie kódové slová chceme priraďovať menej častým znakom. Teraz si to však vieme aj dokázať. Ak by to totiž pre nejaké $i$ a $j$ neplatilo, vieme vymeniť im zodpovedajúce kódové slová, čím zmenšíme hodnotu sumy $\\sum\_{i=1}^m p_i\\cdot l_i$. To je však v spore s tým, že priradenie kódovaní bolo optimálne, teda malo túto sumu minimálnu.

Veľmi užitočné bude tiež vedieť, ako si tieto kódové slová reprezentovať. Vhodnou štruktúrou bude písmenkový strom. Uvedomme si, že z každého vrcholu vychádzajú dve hrany -- jedna reprezentujúca 0 a jedna reprezentujúca 1. V listoch tohto stromu sú potom jednotlivé znaky, ktoré kódujeme. Takýto strom je užitočný na dve veci. Po prvé nám hovorí, aký kód má príslušný znak -- stačí prejsť od koreňa k danému listu a zapisovať si, po akých hranách prechádzam.

Naviac nám tento strom dáva postup, ktorým rozkódovať postupnosť zadaných bitov. Začneme v koreni a vždy sa pohneme po tej hrane, ktorú nám určuje aktuálny bit postupnosti. Ak narazíme na list, tak vypíšeme príslušný znak, ktorý sme práve rozkódovali, a pokračujeme opäť od koreňa.

Na záver si ešte uvedomme nasledovné. Každý vnútorný vrchol (teda nelist) tohto stromu má práve dve hrany, ktoré z neho vychádzajú -- 0 a 1. Ak by totiž mal iba jedného syna, môžeme tento vrchol odstrániť a nahradiť ho tým jediným vrcholom pod ním. Tým však skrátime kódové slová, čo je v spore s optimálnosťou.

Z toho vyplýva, že slovo $w_m$ (s dĺžkou $l_m$), ktoré je najdlhšie, má suseda, ktorého kód má rovnakú dĺžku a líši sa iba v poslednom bite. Bez ujmy na všeobecnosti, nech je tento sused slovo $w\_{m-1}$ (ak by nebolo, tak ho vymeníme na túto pozíciu a nič tým nepokazíme).

Teraz si už vieme popísať algoritmus, ktorý vytvorí písmenkový strom kódujúci všetky naše znaky a toto kódovanie bude navyše optimálne. Myšlienka je naozaj jednoduchá -- zakaždým si zoberieme dva najmenej často sa vyskytujúce znaky. Tie majú mať, podľa našich úvah, najdlhšie kódové slová a navyše majú byť v našom strome susedné. Vytvoríme preto vrchol, z ktorého vychádzajú hrany do dvoch listov, jeden patriaci znaku $m-1$ a druhý patriaci znaku $m$. Nemôžeme však na tieto znaky len tak zabudnúť. To čo sa však stalo je, že sme ich zlúčili do jedného spoločného znaku, ktorý je teraz reprezentovaný novovytvoreným vrcholom. A počet výskytov tohto spoločného znaku je predsa $p\_{m-1} + p_m$. Úspešne sme preto zredukovali počet znakov, ktoré potrebujeme ešte spracovať, o jedna. A na to čo nám zostalo môžeme použiť úplne rovnakú myšlienku.

Predstaviť si to môžeme tak, že náš algoritmus má v každom kroku množinu aktívnych vrcholov, ktoré ešte nemajú priradeného žiadneho otca. Každý vrchol má naviac priradenú váhu zodpovedajúcu tomu, ako dôležitý je tento vrchol (ako často sa znaky v listoch pod týmto vrcholom vyskytujú v texte). Na začiatku náš algoritmus začína s $m$ vrcholmi (listami), každý reprezentuje jeden znak a váha príslušného vrchola je určená podľa počtu výskytov daného znaku v texte.

Následne v každom kroku zoberie dva vrcholy s najmenšou váhou a vytvorí nový vrchol, ktorý bude slúžiť ako otec týchto dvoch vrcholov. Jeho váha bude daná súčtom váh jeho synov. Následne pôvodné dva vrcholy prestane náš algoritmus uvažovať, lebo im už priradil otca. Musí však začať uvažovať novovytvorený vrchol, ktorý otca ešte nemá. V každom kroku sa však zmenší počet vrcholov, ktoré ešte potrebuje spracovať o 1 a preto po $m-1$ krokoch mu ostane iba jediný vrchol -- koreň celého stromu.

Takéto kódovanie sa nazýva Huffmanovo a skutočne je najlepšie možné, ktoré vieme dostať pri daných predpokladoch. Dôkaz optimálnosti som sa rozhodol sem neuviesť, keďže je pomerne formálny (aj keď vôbec nie ťažký). Ak by vás zaujímal, tak si ho môžete pozrieť tu: [Úvod do teórie kódovania (3.3.3)](http://new.dcs.fmph.uniba.sk/files/texty/codebook.pdf).

Jeho implementácia je takisto pomerne jednoduchá. Uvedomme si, že nám stačí použiť jednu haldu, v ktorej si udržiavame váhu jednotlivých vrcholov, ktoré ešte potrebujeme spracovať. Z haldy vieme jednoducho vybrať dva vrcholy s najmenšou váhou a spojiť ich. Časová zložitosť takéhoto riešenia bude preto $O(n \\log n)$.

## Výsledné riešenie

Vo vzoráku sme si postupne ukázali, ako sa dá programovať v Dávidkovom procesore, ukázali sme si, že pomerne dobré riešenie je zakódovať všetky znaky ako postupnosť bitov, a tú potom postupne dekódovať. Na to sme potrebovali priradiť každému znaku určité kódové slovo a chceli sme aby takéto priradenie vytvorilo čo najkratší kód.

Ukázali sme si, že hľadáme takzvaný prefixový kód (kód ktorý vieme jednoznačne dekódovať) taký, že uprednostňuje častejšie sa vyskytujúce znaky tým, že im priradzuje kratšie kódové slová. Nakoniec sme si ukázali aj konkrétny takýto algoritmus priraďovania -- Huffmanov kód.

Ostáva nám už len spojiť všetky tieto veci dokopy a napísať program, ktorý pre daný text vytvorí Huffmanov kód, a následne vypíše program v jazyku Dávidkovho procesora, ktorý bude simulovať rozkódovanie Huffmanovho kódu.

Prekvapivo to však nie je až taký problém. Je nutné si dať pozor na veľa technickejších detailov, mnohé z nich sme však vyriešili v priebehu tohto textu. Najdôležitejšie je dať si pozor, aby ste postupnosť bitov zakódovali do čísel v správnom poradí, a aby ste mali vhodné zarážky -- na spodku zásobníka alebo na konci čísla. Navyše, v tomto všeobecnom riešení musí náš program vedieť aj vypočítať, o koľko má skákať dopredu alebo dozadu na príkaze `JGZ`. Keď si to však trochu premyslíte, mali by ste vedieť tento problém vyriešiť.

A keďže raz vidieť je lepšie ako stokrát počuť, tak vám rovno ukážeme už hotový algoritmus, ktorý úlohu rieši. Odporúčame sa aspoň zbežne pozrieť na časť s Huffmanovým kódovaním.
",10
6ac570d0f3071b74,ksp,"# Éra vyhýbania

Jožo nemá rád svojich spolužiakov. Neustále im robí zle a najradšej by ich vôbec nevidel. Keď je s nejakým spolužiakom na prednáške, radšej zaspí. Rozhodol sa preto, že svoj nový rozvrh zostaví tak, aby bol s každým spolužiakom čo nejmenej.

Nažhavil teda larsa^[Jožov počítač] a začal hackovať univerzitné účty svojich nenávidených spolužiakov. Netrvalo dlho, aby zistil rozvrhy všetkých ľudí, s ktorými sa nechce stretávať.

Počas hackovania sa Jožovi vybil počítač a nabíjačku má niekde hlboko v batohu. Nepripadá teda do úvahy, aby si tento optimalizačný problém vyriešil sám. Zostavíte Jožovi jeho nový rozvrh?

## Úloha

Jožo vám dodal rozvrhy svojich $n$ spolužiakov. Existuje $k$ predmetov. Očíslujme si ich od $1$ po $k$.

Každý spolužiak na každý predmet buď chodí, alebo nechodí. Reprezentujme si teda predmety každého spolužiaka binárnym reťazcom dĺžky $k$. Ak daný spolužiak chodí na predmet číslo $i$, tak v binárnom reťazci bude na $i$-tej pozícii $1$, ináč bude na $i$-tej pozícii $0$.

Vzdialenosť od spolužiaka Jožo definuje ako počet predmetov, na ktoré spolužiak chodí a Jožo nechodí, alebo spolužiak nechodí a Jožo chodí. Ináč povedané, keď si napíšeme spolužiakov a Jožov rozvrh pod seba, tak vzdialenosť od spolužiaka bude počet pozícií, na ktorých sa tieto rozvrhy líšia.

Vašou úlohou bude zostaviť Jožov rozvrh tak, aby bola minimálna vzdialenosť od spolužiaka (spomedzi všetkých spolužiakov) čo najväčšia.

## Formát vstupu

Na prvom riadku dostanete čísla $n$ -- počet spolužiakov a $k$ -- počet predmetov. Platí, že $1 \\leq n \\leq 100,000$ a $1 \\leq k \\leq 20$

Nasleduje $n$ riadkov. Na každom z nich je binárny reťazec dĺžky $k$. Na $i$-tom z týchto $n$ riadkov je popis rozvrhu $i$-teho spolužiaka vo vyššie popísanom formáte.

## Formát výstupu

Na jediný riadok výstupu vypíšte nový Jožov rozvrh. Ak takých rozvrhov existuje viac, vypíšte z nich **lexikograficky najmenší**.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:-------------- | ----: | --------: | ----------: | ----------:| | $1\\leq n\\leq$ | $10$ | $1,000$ | $10,000$ | $100,000$ | | $1\\leq k\\leq$ | $20$ | $10$ | $20$ | $20$ |

## Príklady

```vstup
3 5
01101
10101
00011
```

```vystup
11000
```

```vstup
1 6
011011
```

```vystup
100100
```
","# Éra vyhýbania

V tejto úlohe sme dostali $n$ binárnych reťazcov dĺžky $k$ a mali sme nájsť taký binárny reťazec dĺžky $k$, ktorý bude mať čo najväčšiu minimálnu vzdialenosť od každého z $n$ reťazcov. Vzdialenosť 2 reťazcov sme definovali ako počet pozícií, na ktorých sa tieto dva reťazce líšia.

## Pozorovania

Vždy predtým, ako začneme riešiť nejakú úlohu je dobrý nápad pozrieť sa na obmedzenia vstupov. V tejto úlohe bolo $n \\leq 100,000$, no $k$ bolo iba do $20$. Keď vidíme toto obmedzenie pre $k$, hneď by nám malo napadnúť, že si môžeme dovoliť riešenie, ktoré má vo svojej zložitosti aj člen $2^k$, alebo podobný.

Keďže si to môžeme dovoliť, tak pravdepodobne budeme chcieť vygenerovať všetky možné rozvrhy, ktorých je $2^k$, pretože na každej z $k$ pozícií môžu byť 2 rôzne hodnoty.

Keď už vieme, že asi budeme chcieť generovať všetky rozvrhy, tak ľahko vyriešime aj to, aby sme našli lexikograficky najmenší. Stačí, aby sme ich generovali v lexikografickom poradí a zobrali prvý vyhovujúci, ktorý nájdeme. O takomto generovaní rozvrhov sa dočítate v nasledujúcej sekcii.

## Implementačné rady

Ak viete dobre používať bitové operácie, túto sekciu kľudne preskočte, nič nové sa v nej asi nedozviete.

Máme najviac 20-bitové rozvrhy. Môžeme sa na ne pozerať ako na binárne zápisy čísiel. Každý rozvrh si teda vieme pamätať ako jedno číslo. Nemusíme si rozvrhy pamätať ako stringy.

Teraz niečo ku generovaniu rozvrhov v lexikografickom poradí. Stačí si uvedomiť, ako funguje dvojková (a aj každá iná) sústava. Totiž, väčšie čísla sú lexikograficky väčšie, ako menšie čísla. Ak teda budeme prechádzať, čísla od $0$ po $2^k - 1$, tak vlastne prejdeme rozvrhy v lexikografickom poradí. Stačí sa vždy pozrieť na bitovú reprezentáciu aktuálneho čísla.

Ďalej sa pozrime na to, ako zistiť vzdialenosť 2 rozvrhov. Keď ich už máme ako 2 čísla, tak stačí spraviť $xor$ týchto 2 čísiel a zrátať počet jednokových bitov vo výsledku. Rozmyslite si, prečo to funguje, je to veľmi jednoduché.

Niekde počas riešenia, či vypisovania výstupu sa nám asi bude hodiť vedieť zistiť, aký je $i$-ty bit nejakého čísla. Na to sa vo väčšine jazykov dajú pohodlne využiť bitové operácie. Aby sme zistili, aký

je $i$-ty bit čísla $x$, môžeme spraviť `(x & (1 << i)) > 0`. Taktiež budeme možno chcieť vedieť zapnúť $i$-ty bit čísla $x$. To spravíme ako `x |= (1 << i)` Ak neviete, prečo to funguje, nájdite si niečo o bitových operáciách a skúste si to rozmyslieť, nemal by to byť problém pochopiť.

## Riešenie hrubou silou

Toto bude celkom priamočiare. Vygenerujeme si každý možný rozvrh. Pre každý z nich prejdeme cez všetkých $n$ rozvrhov zo vstupu a zrátame ich vzdialenosť. Z týchto vzdialeností pre aktuálny rozvrh si zapamätáme minimum, pretože to je tá minimálna vzdialenosť od $n$ rozvrhov zo vstupu. Každý vygenerovaný rozvrh nám dá nejaké takéto minimum. Z týchto miním chceme zobrať maximum. Rozvrh s touto maximálnou vzdialenosťou je náš hľadaný rozvrh.

Pre každý zgenerovaný rozvrh prejdeme všetkých $n$ rozvrhov, takže časová zložitosť bude $O(n2^k)$. Pamätáme si iba vstup, takže pamäť bude $O(n)$.

## Vzorové riešenie

V riešení hrubou silou sme pre každý vygenerovaný rozvrh odznova prechádzali všetkých $n$ rozvrhov zo vstupu. To by sme chceli zrýchliť. Skúsme sa na vzdialenosť 2 rozvrhov pozerať skutočne ako na vzdialenosť. Pozerajme sa na ňu tak, že je to počet operácií zmeny bitu, ktoré musíme na jednom rozvrhu vykonať, aby sme sa dostali do druhého rozvrhu. Na vzdialenosť 1 od rozvrhu 01101 teda budú tie rozvrhy, ktoré z neho vieme dostať 1 zmenou, čo sú 11101, 00101, 01001, 01111 a 01100.

Všetky rozvrhy si teraz vieme predstaviť ako graf. Každý vrchol má stupeň (počet susedov) $k$, pretože na ňom vieme spraviť $k$ rôznych zmien. Z každého rozvrhu pôjdu hrany do rozvrhov, ktoré vieme z aktuálneho dostať na 1 zmenu. Takýto graf sa niekedy zvykne nazývať binárna kocka.

Koľko hrán má takýto graf? Z každého vrchola ide $k$ hrán a vrcholov je $2^k$, takže celkový počet hrán bude $O(k2^k)$. To je pre naše obmedzenie na $k$ stále tak málo, že si môžeme dovoliť tento graf prehľadať.

Čo v tomto grafe hľadáme? Zaujímajú nás vrcholy, ktoré sú čo najďalej od všetkých $n$ vrcholov zo vstupu. Ak teda pustíme [BFS](https://www.ksp.sk/kucharka/bfs/) zo všetkých vrcholov zo vstupu naraz a zrátame si tak najkratšie vzdialenosti do každého vrchola, stačí nám potom pozrieť sa na vzdialenosť každého vrchola (opäť v lexikografickom poradí) a zobrať ten s najväčšou vzdialenosťou.

## Časová a pamäťová zložitosť

Časová zložitosť takéhoto BFS bude $O(k2^k)$. Graf si nemusíme explicitne pamätať, pretože vždy vieme povedať, aké hrany idú z aktuálneho vrchola. Pamäť preto bude $O(2^k)$.
",6
8f0fa91b4fd9355e,ksp,"# Zahrabaná Kika

Kika sedí v T2-ke[^1] a rozmýšľa, čo bude dnes robiť. Na Ufe už bola, zvieratá v ZOO už tiež videla a aj všetky obchody už pobehala. Pri rozmýšľaní o svojom ďalšom programe si uvedomila, že vedúci majú v T2-ke ich vlastný program -- idú ju prerobiť a popresúvať nábytok.

Jooj, no pri tom sa Kike fakt nechce byť. Tak si povie, že odíde skôr, ako ostatní prídu. Tento plán ale preruší jej potreba idenia na záchod. A čo je horšie, na chodbe už počuje hlasy vedúcich, čiže, ak by na záchod aj šla, tak ich stretne a oni ju pošlú naspäť, aby im pomohla.

Jej posledná šanca, ako sa vyhnúť upratovaniu je skryť sa. V poslednej chvíli, keď už počula otvorenie dverí, sa konečne niekam rýchlo zahrabala a dúfala, že s týmto kúskom T2-ky sa už hýbať nebude.

Plány ostatných vedúcich sa ale nečakane zmenili, lebo namiesto presúvania nábytku si sadli a rozprávali sa. Avšak Kika o sebe nemôže dať vedieť, lebo keby sa dozvedeli, prečo sa skrývala, mohlo by to mať nejaké prerábkové následky. Tak si povedala, že si zatiaľ skúsi premyslieť, kde inde sa ešte mohla skryť tak, aby ju žiadny vedúci nemohol nájsť ani keď sa bude obzerať okolo seba.

## Úloha

Na vstupe dostanete plán T2-ky v podobe mriežky rozmerov $m\\times n$, kde je vyznačená poloha každého vedúceho a všetkých stien, skríň a iných rôznych prekážok, ktoré obmedzujú výhľad ostatných vedúcich. Vašou úlohou je zrátať všetky miesta v T2-ke, na ktoré nevidí ani jeden z vedúcich (pri ľubovoľnom otočení hlavy -- dozadu, dopredu, doľava, doprava, ale nie diagonálne) a Kika sa tam vie potenciálne skryť.

## Formát vstupu

V prvom riadku vstupu dostanete dve čísla $n$ a $m$ -- výšku a šírku plánu T2ky. Nasleduje $n$ riadkov, na každom je $m$ znakov kde `.` reprezentuje priechodné miesto, `#` prekážku a `V` vedúceho.

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet políčok, ktoré nie sú videné v ľubovoľnom momente ani jedným z vedúcich.

## Príklady

```vstup
4 6
V#....
.V..#.
..#V..
......
```

```vystup
7
```

```vstup
3 3
.#.
#V#
.#.
```

```vystup
4
```

\[^1\]: T2-ka je miestosť KSPákov na Matfyze. Pre bližšie predstavenie si tejto miestnosti -- sú v nej skrine, gauče, stoly a veľká kopa eráru.
","# Zahrabaná Kika {mail=""emma.badurova@trojsten.sk"" bodypopis=12 bodyprogram=8}

Riešenie tejto úlohy nie je vôbec zložité. Jediné, čo nám stačí spraviť, je prejsť celú miestnosť a zistiť pre každého vedúceho, kam vidí. Ukážeme si dva spôsoby ako to spraviť.

## Prechádzanie vedúcich

Budeme sa postupne posúvať po políčkach a pozerať sa na to, či na danom políčku stojí vedúci. V prípade, že stojí, označíme si všetky políčka na ktoré vidí nad a pod ním, vľavo a vpravo od neho ako ""ohrozené"". Teda všetky, ktoré nie sú už za nejakou prekážkou alebo iným vedúcim.

Keď toto spravíme pre všetkých vedúcich, tak nám na plániku ostanú neoznačené len miesta, na ktoré nevidí ani jeden vedúci. Stačí ich už len zrátať a dostaneme počet miest, na ktoré sa môže Kika bezpečne skryť.

### Časová a pamäťová zložitosť

Keďže rozmery nášho plániku zo vstupu, ktorý si musíme zapamätať, sú $m\\times n$ a prechádzame iba tento plánik, tak aj časová zložitosť bude $O(m\\cdot n)$. Teraz sa možno zdá, že to nevychádza, lebo vždy, keď prídeme na vedúceho, musíme označiť *všetky* políčka v stĺpci a riadku, na ktoré vidí a tých môže byť až $n+m-1$. Treba si však uvedomiť, že ak takto označíme napríklad veľkú časť jedného riadu, tak to znamená že na tom úseku nebol žiadny vedúci a teda ho následne prejdeme rýchlo. Dá sa teda povedať, že na každé políčko sa ""pozeráme"" najviac $5$ krát. Raz keď kontrolujeme či je tam vedúci a potom najviac raz z každého smeru, podla toho či na to políčko z daného smeru vidí vedúci. Z toho vychádza časová zložitosť $O(5\\cdot m\\cdot n)$, ale keďže $5$ je len konštanta, tak $O(m\\cdot n)$.

Pamäťová zložitosť je $O(m\\cdot n)$, lebo si pamätáme iba plánik, ktorý v priebehu prepisujeme.

## Druhý spôsob - zametanie

Zametanie je prístup, ktorý spočíva v tom, že cez nejakú plochu (pole) prechádzame v jednom smere a ťaháme so sebou nejakú informáciu -- ako keď metla ťahá špinu. My budeme zametať postupne vo všetkých $4$ smeroch: zhora, zdola, zľava a sprava, aby sme si v plániku zaznačili, ktoré políčka sú videné nejakým vedúcim. Bližšie si popíšeme jeden z nich.

Ideme zametať zľava doprava. Môžeme si teda predstaviť že každý vedúci sa pozerá iba doprava a chceme označiť videné políčka. Po takomto zjednodušení môžeme prechádzať riadok po riadku a pamätať si len či sa niekto pozerá, alebo nie.

Nakoniec opäť prejdeme plánik a zistíme, ktoré políčka sú ""neohrozené"".

### Časová a pamäťová zložitosť

Na tomto riešení ešte jasnejšie vidieť, že $4$ krát prejdeme celé pole a nerobíme pri tom nič časovo náročnejšie, ako že sa pozrieme na celý plánik, teda časová aj pamäťová zložitosť je opäť $O(m\\cdot n)$.
",4
5e760a94d82643b3,ksp,"# Ye ti zima?

Yeti Ignác nedávno dostal skvelý nápad: oholí si nohy, aby bol krajší. No len čo tak spravil, pochopil, že ten nápad nebol až taký skvelý. Keď sa teraz brodí snehom, je mu zima. Rozhodol sa preto, že si pustí na počítači vaše programy a tým sa zahreje.

Vytrestajte Ignáca za jeho hlúpe nápady, nech si dobre zapamätá, že yeti si nemá holiť nohy. Vyriešte teda čo najefektívnejšie nasledujúcu úlohu, nech sa yeti príliš nezahreje.

## Úloha

*KSP-krása* reťazca je počet spôsobov, ktorými v ňom vieme vyznačiť podpostupnosť `ksp` -- teda niekde vyznačiť písmeno `k`, niekde napravo od neho písmeno `s` a napravo od toho zase písmeno `p`. Napríklad KSP-krása reťazca `kokosplesk` je 2: buď zoberieme znaky na indexoch 0, 4, 5 alebo znaky na indexoch 2, 4, 5.

Na vstupe dostanete jeden reťazec $S$ a potom postupne $q$ otázok o ňom. Každá otázka bude nasledujúceho tvaru: ""Aká je KSP-krása podreťazca tvoreného znakmi na indexoch $a_i$ až $b_i$?""

## Formát vstupu

V prvom riadku je číslo $n$: dĺžka reťazca. V druhom riadku je reťazec $S$ tvorený $n$ malými písmenami anglickej abecedy. V treťom riadku je číslo $q$: počet otázok.

Zvyšok vstupu tvorí $q$ riadkov. Tieto riadky a aj im zodpovedajúce otázky si očíslujeme od 0 po $q-1$. Správnu odpoveď na otázku $i$ označíme $c_i$ a navyše dodefinujeme, že $c\_{(-1)} = 0$.

Riadok popisujúci otázku číslo $i$ obsahuje dve celé čísla $x_i$ a $y_i$, pre ktoré platí $0\\leq x_i, y_i < n$. Hodnoty $a_i$ a $b_i$ pre túto otázku sú určené nasledovne: Nech $p_i = (x_i + c\_{i-1}) \\bmod n$ a $q_i = (y_i + c\_{i-1}) \\bmod n$. Potom $a_i = \\min(p_i,q_i)$ a $b_i = \\max(p_i,q_i)$.

V jednotlivých sadách testov platia pre $n$ a $q$ nasledovné obmedzenia zhora:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | -----:| ----------:| -----------:| -----------:| | $n,q$ | 50 | $20,000$ | $100,000$ | $500,000$ |

## Formát výstupu

Vypíšte $q$ riadkov a v nich postupne čísla $c_0$ až $c\_{q-1}$.

## Upozornenie

Pri hodnotení popisov budeme o čosi viac ako inde prihliadať na asymptotickú časovú zložitosť vašich riešení. Špeciálne upozorňujeme na to, že algoritmy asymptoticky horšie od vzorového riešenia nedostanú plný počet bodov za popis (hoci môžu úspešne vyriešiť všetky testy).

## Príklad

```vstup
16
kkssppkokosplesk
4
6 15
4 14
3 3
15 0
```

```vystup
2
8
0
16
```

- Otázka 0 sa pýta na podreťazec `kokosplesk`, ktorého KSP-krása je $c_0 = 2$.
- Keď vieme, že $c_0=2$, vypočítame si, že otázka 1 má $a_1=0$ a $b_1=6$, pýta sa teda na reťazec `kkssppk`. Toto KSP-krása je $c_1 = 8$.
- Otázka 2 sa pýta na nejaký jednoznakový reťazec, toho KSP-krása je určite $c_2 = 0$.
- No a na záver, otázka 3 sa teda pýta na celý reťazec $S$.
","# Ye ti zima?

Táto úloha mala až prekvapivo jednoduché riešenie. Netreba žiadne logaritmické dátové štruktúry, vystačíme si s obyčajnými prefixovými súčtami a každú otázku zodpovieme v konštantnom čase.

Skôr, než sa do riešenia pustíme, dohodneme sa, že všetky intervaly, ktoré budeme používať, budú polootvorené: ľavý koniec do nich patrí, pravý už nie. Napr. $\[0,3)$ je interval obsahujúci čísla 0, 1 a 2, zatiaľ čo $\[4,5)$ obsahuje len číslo 4.

\\bigskip

Základná myšlienka riešenia bude nasledovná: keď máme zistiť počet spôsobov, ako vybrať reťazec 'ksp' zo znakov, ktorých indexy ležia v intervale $\[a,b)$, zoberieme počet spôsobov, ako vybrať 'ksp' zo znakov s indexmi v intervale $\[0,b)$ a od nich potom odpočítame tie zlé. Zlé spôsoby sú troch typov: buď leží v intervale $\[0,a)$ len znak 'k', alebo znaky 'ks', alebo tam leží celé 'ksp'. Nižšie si detailne popíšeme, ako všetky tieto počty v konštantnom čase vypočítať z obyčajných prefixových súčtov.

\\bigskip

Počet spôsobov, ako vybrať reťazec $r$ spomedzi prvých $i$ písmen reťazca $S$ si označíme $P_r[i]$.

Pre jednopísmenové reťazce je tento počet veľmi ľahké spočítať: je to jednoducho počet výskytov dotyčného znaku v dotyčnom úseku reťazca $S$. Napríklad teda platí $P_k[0] = 0$ a $\\forall i: P_k[i+1] = P_k[i] + (1 \\text{~ak~$S[i]$='k'})$. Analogicky spočítame hodnoty $P_s$ a $P_p$.

Pozrime sa teraz na hodnoty $P\_{ks}$. Zjavne aj tu platí $P\_{ks}[0] = 0$, lebo keď nemáme žiadne znaky, nevyberieme žiadne $ks$. Predstavme si teraz, že postupne zväčšujeme dĺžku prefixu $S$, z ktorého môžeme vyberať. Keď pribudne nové písmeno, sú dve možnosti. Ak to nie je 's', tak sa počet spôsobov výberu 'ks' nijak nezmení -- toto nové písmeno nemáme ako použiť. A ak pribudne 's', zväčší sa počet 'ks' o toľko, koľko rôznych 'k' sme už videli. Dokopy teda dostávame toto: $\\forall i: P\_{ks}[i+1] = P\_{ks}[i] + (P_k[i] \\text{~ak~$S[i]$='s'})$.

Rovnakým spôsobom vieme spočítať aj hodnoty $P\_{sp}$. No a úplne na záver celej prípravy si spočítame hodnoty $P\_{ksp}$, pričom znova opakujeme tú istú úvahu: ak pre nejaké $i$ vidíme, že $S[i]$='p', pribudlo nám do $P\_{ksp}[i+1]$ oproti $P\_{ksp}[i]$ práve toľko nových možností výberu reťazca 'ksp', koľko máme možností na výber 'ks' zo znakov s indexmi menšími ako $i$.

\\bigskip

Ako teraz zodpovieme na otázku, koľkými spôsobmi vieme 'ksp' vybrať z daného úseku $\[a,b)$ reťazca $S$? Hľadanú odpoveď môžeme zapísať v tvare $\\alpha - \\beta - \\gamma - \\delta$, kde:

- $\\alpha$ je počet výskytov 'ksp' v intervale $\[0,b)$.
- $\\beta$ je počet výskytov 'ksp' v intervale $\[0,a)$.
- $\\gamma$ je počet výskytov 'ksp' takých, že 'k' leží v intervale $\[0,a)$ a 'sp' v intervale $\[a,b)$.
- $\\delta$ je počet výskytov 'ksp' takých, že 'ks' leží v intervale $\[0,a)$ a 'p' v intervale $\[a,b)$.

Skoro všetky tieto hodnoty už vieme:

- $\\alpha = P\_{ksp}[b]$
- $\\beta = P\_{ksp}[a]$
- $\\delta = P\_{ks}[a] \\cdot (P_p[b] - P_p[a])$. Rozmyslite si, prečo je $P_p[b] - P_p[a]$ rovné počtu výskytov 'p' v $\[a,b)$.

Jediné, s čím ešte bude trocha práce, je $\\gamma$. Ale tej práce bude skutočne len trocha, keďže hodnotu $\\gamma$ môžeme tiež určiť podobnou úvahou. Máme $P_k[a]$ možností, ako vybrať 'k' ležiace v intervale $\[0,a)$, ostáva nám už len určiť počet spôsobov, ako vybrať 'sp' z intervalu $\[a,b)$. No a toto vieme zistiť ako $\\zeta - \\eta - \\theta$, kde:

- $\\zeta$ je počet výskytov 'sp' v intervale $\[0,b)$, teda $\\zeta = P\_{sp}[b]$
- $\\eta$ je počet výskytov 'sp' v intervale $\[0,a)$, teda $\\eta = P\_{sp}[a]$.
- $\\theta$ je počet výskytov 'sp' takých, že 's' leží v $\[0,a)$ a 'p' leží v $\[a,b)$, čiže $\\theta = P_s[a]\\cdot(P_p[b]-P_p[a])$.

A to už je všetko. V lineárnom čase od dĺžky $S$ sme si predpočítali hodnoty $P$ a následne v konštantnom čase vieme odpovedať na ľubovoľnú otázku. Celková časová zložitosť je teda $O(n+q)$.
",9
c27dd478a998b3b0,ksp,"# Zlovestný svet

Po týždni strávenom lozením po horách sa Katka vrátila naspäť do civilizovaného sveta a do svojho biologického labáku. Dušu jej ale ťažilo trápenie.

Jej obľúbený plyšový hroch bol teraz vážne chorý a hrozilo to najhoršie. Hory a chlad mu proste nespravili dobre. Dlhé noci sa oňho musela starať a uplatňovať všetky svoje poznatky z imunológie, mikrobiológie, analýzy, fyziológie a iných okultných náuk.

Nakoniec ale všetko dobre dopadlo. Hroch to prežil. Kaťa si ale povedala, že niečo takéto už nikdy nechce zažiť znova a teda, že hrocha už so sebou nebude na takéto túry nosiť. To by tam ale musela chodiť sama a to sa jej nechce. Rozhodla sa teda, že si ako správna biologička vyšľachtí niekoľko silných, alergiám, malátnosti, a kazom odolných vtákopyskov.

To ale nie je sranda. Také šľachtenie je mimoriadne komplikovaná vec a ani Kaťa jej úplne nerozumie. Jediné, čo teda môže robiť, je zobrať niekoľko génov, zlepiť ich za seba a dúfať, že jej vznikne vtákopysk so chcenými vlastnosťami. Aby otestovala jeho odolnosť, pošle ho na bakalársky seminár. Čím dlhšie tam vydrží, tým je odolnejší. Takto si Katka mieša a testuje už niekoľko mesiacov. Pomôžte jej tento proces trochu zautomatizovať.

## Úloha

Vašou úlohou je napísať program, ktorý bude schopný vytvoriť čo najodolnejšieho vtákopyska. Na výrobu vtákopyska potrebujeme $50$ génov (tak málo to je, lebo je plyšový). Gény sú písmená `A`, `C`, `G` a `T`.

Dokopy máte $n=100,000$ pokusov na ukuchtenie toho najodolnejšieho stvorenia aké kedy tento seminár videl (a to teda naozaj nie je ľahká úloha). Po každom pokuse sa dozviete, ako veľmi bolo vaše stvorenie odolné. Kto vytvorí najodolnejšieho vtákopyska vyhrá. Samozrejme je tu aj istý časový limit.

## Bodovanie

Zo všetkých (najviac $100,000$) vašich pokusov jedného odovzdaného programu sa vyberie najodolnejší vtákopysk. Čím bude tento vtákopysk odolnejší, tým viac bodov za program dostanete. ^[Jednotlivé programy sa však naďalej hodnotia nezávisle a ráta sa len posledný odovzdaný program. Upozorňujeme vás, aby ste v tejto úlohe neodovzdávali príliš veľa programov, napríklad takých 200 už je veľa ale 10 až 30 je úplne v poriadku. Pokiaľ budete odovzdávať priveľa programov, môžeme sa rozhodnúť ohodnotiť iný ako posledný program.]

Skoro určite sa vám nepodarí vytvoriť vtákopyska, ktorý na bakalárskom seminári vydrží viac ako 85 dní (pochybujeme, že taký vôbec môže existovať). Pokiaľ váš vtákopysk vydrží $80$ alebo viac dní, dostanete plný počet bodov. Za $67$ a viac dní dostanete aspoň $10$ bodov, za $53$ a viac dní aspoň $5$ bodov. Ak váš vtákopysk nevydrží ani $10$ dní nedostanete žiadne body, iba by ste Kaťu zbytočne rozosmútili. Dostať môžete ľubovoľný celočíselný počet bodov od $0$ po $15$, veď odovzdajte nejaké riešenie a uvidíte.

## Poznámka

Možno ste si všimli, že nikde nie je napísané, čo tá odolnosť vlastne znamená. No, svet je tajomné a komplikované miesto a naozaj nikto netuší, čo treba mať na zvládnutie bakalárskeho semináru. Odporúčame vám si pri testovaní vymyslieť si nejakú vlastnú funkciu a zistiť, ako na nej vaša metóda kuchtenia funguje.

Dobré je robiť veľa testov na vlasntnom počítači, nie všetko čo naprogramujete hneď odovzdávať.

## Formát vstup a výstupu

V tejto úlohe budete komunikovať s naším programom (krutý svet príkorí). Jednoducho na (štandardný) výstup vypíšte reťazec $50$ znakov z ACGT končiaci znakom nového riadku a na vstup dostanete jedno celé číslo predstavujúce odolnosť vášho výtvoru. Toto môžete opakovať až $100,000$ krát, ak sa pokúsite spýtať viac otázok, váš pokus bude považovaný za neplatný.

Ak nechcete využiť všetky pokusy, musíte namiesto reťazca znakov vypísať znak K (ako koniec).

Ak chcete dostať odpoveď, **je nutné** po každom vypísaní génov výstup presunúť z pamäte na štandardný výstup pomocou príkazu `fflush(stdout);` v C++, alebo `flush(output);` v Pascale.

## Príklad

Komunikácia medzi vašim a našim programom by mohla vyzerať napríklad nasledovne:

| Váš program vypisuje: | Testovač vypisuje: | |:--- | ---:| | `AAAAAA..ďalších 40 znakov..AAAA` | `30` | | `ACGTAC..ďalších 40 znakov..ACGT` | `58` |\
| `CCCCCC..ďalších 40 znakov..CCCC` | `42` |\
| `K` | |

Najlepší vtákopysk prežil 58 dní. Riešenie by dostalo 6 bodov.
","# Zlovestný svet

## Na začiatok

Toto vzorové riešenie nebude také, na aké ste možno zvyknutí. Dôvod je, že táto úloha vzorové riešenie ako také _nemá_ a nemôže mať. Samozrejme, určite existuje zvieratko, ktoré má najväčšiu odolnosť, ale všeobecný, zaručený a rýchly spôsob jeho hľadania neexistuje. Prečo? Lebo inak by sme vedeli jednoducho riešiť ľubovoľný informatický problém.

Celá táto úloha bol taký experiment s vami. Úloha skúmala, ako sa dokážete vysporiadať s neznámym problémom. Možných prístupov je mnoho a do vzorového riešenia sa všetky nezmestia. Ukážeme si teda niekoľko techník a niekoľko prístupov k úlohe.

## Lacný bod

Napíšeme program, ktorý skúsi zvieratká, ktoré ponúka ukážkový vstup. Pár riadkov kódu a máme dva body ani nevieme ako. Ale aspoň sme sa presvedčili, že rozumieme ako má fungovať vypisovanie výstupu.

## Náhodné tipovanie

Čo tak predchádzajúci prístup zlepšiť, a pýtať sa aj na ďalšie možné zvieratká. Budeme veselo generovať náhodné stringy a posielať ich do sveta. A máme tri body, s trochou šťastia štyri.

## Lozenie hore kopcom

Ako rozprávka napovedá, ideme si zaloziť po kopcoch a použijeme metódu zvanú hill-climbing. Predstavme si, že sme v neznámom teréne uprostred tmy a chceme vyliezť na kopec. Môžeme spraviť jeden krok náhodným smerom a overiť, či sme takto išli hore kopcom. Ak sa nám nepodarilo ísť hore kopcom, tak sa vrátime a skúsime ísť iným smerom. Opakovaním tohto postupu sa dostaneme na vrchol nejakého kopca, odkiaľ už nebudeme môcť ísť vyššie.

Problém tohto postupu je, že keby sme to skúšali v Tatrách, tak pravdepodobne ostaneme zaseknutí na nejakom veľkom kameni v údolí a na Gerlachovský štít sa zrejme nedostaneme. Tento postup totiž nájde len takzvané lokálne maximum (bod, ktorý je vyšší od všetkých okolitých) a nie globálne maximum (najvyšší bod celkovo). Môžeme však skúsiť šťastie a začať naše putovanie z 200 náhodných miest a z každého spraviť 500 krokov smerom hore.

V reči DNA začneme vždy z nejakého náhodného DNA reťazca a budeme opakovane meniť jedno náhodné písmeno na iné. Zistíme, či vtákopysk so zmeneným jedným písmenom vydržal dlhšie a ak áno, necháme si ho. Inak zmenu zahodíme a skúsime spraviť inú náhodnú zmenu. Môžme tiež skúsiť aj iné typy zmien, napríklad vymieňať dve písmenka, meniť písmenko na náhodnej pozícií, kopírovať náhodné kusy zvieratka na iné miesto, čo nás len napadne. Vo všeobecnosti sa ale odporúča skúsiť naraz viac podobných zmien a potom vybrať tú najlepšiu. Ak sa napríklad rozhodneme, že budeme meniť druhý gén, tak skúsime všetky možnosti a tú najlepšiu si necháme.

V závislosti od konkrétnej implementácie získame pravdepodobne 5 až 8 bodov.

## Takmer simulované žíhanie

Toto je postup podobný lozeniu do kopca. Líši sa v tom, že dovolíme robiť aj zmeny k horšiemu. Navyše v žíhaní vystupuje aj parameter _teplota_, ktorý ovplyvňuje správanie algoritmu.

V každom kroku zoberieme aktuálny reťazec a spravíme v ňom nejaké drobné zmeny (počet zmien zvykne závisieť od teploty). Následne zistíme, či nový reťazec má lepšie skóre (t.j. odolnosť zodpovedajúceho vtákopyska) ako predošlý a ak áno, necháme si nový reťazec. Ak nie, tak sa náhodne rozhodneme, či si necháme nový alebo starý reťazec. Pravdepodobnosť toho, že si aj pri neúspechu necháme nový reťazec, závisí od teploty.

Potom existuje viacero prístupov ako meniť teplotu, môžeme začať s vysokou a vždy, keď sa nám podarí spraviť dobrú zmenu, tak ju trocha znížime (prenásobíme konštantou trochu menšou ako 1). Alebo môžeme dokola striedať 4 hodnoty teploty. Fantázii sa medze nekladú.

Týmto spôsobom by ste pravdepodobne dostali 10 až 11 bodov, a ak správne odladíte konštanty, tak aj 12.

## Labák

Ak chceme ísť ďalej, môžeme sa inšpirovať prírodou a skúsiť takzvané genetické algoritmy. Idea je nasledovná. Budeme sa tváriť, že naše zvieratká sú naozajstné živočíchy, že si skutočne spolu nažívajú v skupine zvanej populácia a že ich DNA reťazce sú naše stringy. Na začiatku si vyrobíme náhodne niekoľko zvieratiek a zistíme si ich odolnosť (pošleme ich do sveta). Tieto zvieratká nám budú tvoriť prvú generáciu našej populácie.

Tak ako bežne v prírode, zvieratká sa budú medzi sebou krížiť a ich DNA bude podliehať náhodným mutáciam (zmenám). Aby sme celý proces urýchlili (a tým zlepšili) budú mutácie oveľa pravdepodobnejšie ako naozaj v prírode. Tiež tak ako bežne v prírode, prežijú len najsilnejší. Každé zvieratko má nejakú pravdepodobnosť, že sa dožije ďalšej generácie a tá pravdepodobnosť by mala byť tým vyššia, čím odolnejšie je zvieratko.

Novú generáciu z predošlej vyrobíme nasledovne: Zahodíme náhodne vybraté zvieratká s nízkou odolnosťou (asi tretinu). Nakopírujeme najodolnejších pár zvieratiek. Náhodným zvieratkám spravíme náhodné mutácie. Nové náhodné zvieratká vytvoríme kombináciou predošlých. Spravíme ďalšie veci čo nám napadnú, napríklad môžeme pridať niekoľko nových úplne náhodných zvieratiek.

V celom postupe sa skrýva veľké množstvo magických konštánt, od veľkosti populácie po jednotlivé pravdepodobnosti. Tiež sa treba rozhodnúť, aké mutácie budeme robiť (tu sa dajú robiť rovnaké ako v hill-climbingu, náhodná zmena písmen, vymieňanie písmen atď.), a ako sa budú zvieratá krížiť. Často kríženie prebieha tak, že zoberieme dve (kľudne ale aj viac) zvieratiek a nejako ich spojíme dokopy. Napríklad začiatok reťazca zoberieme z prvého zvieratka a koniec z druhého. Tiež môžeme občas nechať nejaké zvieratko vyvinúť, napríklad tak, že ho dáme ako počiatočné pre hill-climbing a do ďalšej generácie pošleme už vyoptimalizované zvieratko.

Je tu obrovský priestor na experimentovanie a veľmi veľa možností, čo robiť. S hala-bala neporiadnym nastavením konštánt sa dalo získať 10 bodov.

Vedúcovské riešenie bolo tiež genetické programovanie s trocha lepšie nastavenými konštantami (aj keď určite sa dali ešte zlepšiť). Väčšinou dostalo 12 až 14 bodov.

## Drobné optimalizácie na zváženie

Pokiaľ sme použili v algoritme nejakú náhodu, alebo aj keď nie, mohlo sa stať, že sme do sveta posielali to isté zvieratko dva krát. To je ale plytvanie drahocennými pokusmi. Čo môžeme spraviť je, že si každé zvieratko, na ktoré sme sa už spýtali, uložíme do mapy aj s jeho odolnosťou (a.k.a. memoizácia). Potom vždy, keď budeme chcieť otestovať nejaké zvieratko, tak sa najprv pozrieme, či už nie je v mape.

Pokiaľ by sme mali pamäťové problémy (zvieratiek je predsa len celkom dosť), môžeme si zvieratká trochu úspornejšie zakódovať, a to nie do stringov, ale do dvojíc longov (64 bitový integer). Stačí si uvedomiť, že na zakódovanie jedného génu nám stačia dva bajty. Potom vieme jedno zvieratko uložiť ako 100 bitov, čo sú dva longy. Toto prináša isté implementačné problémy a námahu, ale v pamäťovo rozšafnejších jazykoch na to treba myslieť.

Vedúcovský program takéto optimalizácie nerobil.

Tiež sme rátali s tým, že svoje riešenie odovzdáte viac krát a necháte tam to najlepšie. (Napríklad počty bodov za submity toho istého programu mohli vyzerať 13,12,14,11,12,13,14,12,14. V zadaní sme však písali aby ste to nepreháňali a odovzdať viac ako 100 programov nie je úplne fér.)

## Krutý svet príkorí

Určite ste všetci zvedaví, ako vlastne fungoval svet -- ako sa hodnotila odolnosť vtákopyskov.

Najprv sa z DNA reťazca dlhého 50 znakov vyrobil binárny reťazec dlhý 100 znakov a to tak, že každé písmeno si zmeníme na dva bity ($A=00$, $C=01$, $G=11$, $T=10$) a prvých 50 bitov binárneho reťazca bude tvorených prvými bitmi písmen z DNA a druhých 50 bitov sú druhé bity z písnen z DNA. ^[Teda ešte pred tým sa celý vstup zrotoval nejakou náhodnou cyklickou rotáciou, ktorá bola fixná počas celého behu programu. Toto tam bolo na to, aby sa funkcia trocha líšila pri rôznych behoch a aby sa nedali jednoducho využívať informácie z predošlých submitov.]

Keď máme binárny reťazec, tak vypočítame takzvaný počet rôznych štvorcov v ňom. Teda spočítame koľko existuje reťazcov $w$ takých, že $ww$ sa nachádza v binárnom reťazci. Napríklad $101011001100$ má 6 rôznych štvorcov a vyhovujúce $w$ sú $0,1,10,01,0110,1100$. Počítanie štvorcov sa robí pomocou hashovania, aby bolo rýchlejšie, a teda je tam nejaká, veľmi malá šanca, že sa pomýlime. (Napr. vtákopysk mal šťastný život a prežil o deň dlhšie ako by mal.)

Napokon, ešte penalizujeme reťazce, ktoré obsahujú dlhé úseky rovnakých bitov, lebo tie sú príliš nudné. Mohli ste mať však 20 rovnakých bitov za sebou beztrestne.

Áno, hodnotiaca funkcia bola pomerne komplikovaná, ale našťastie ste sa ňou nemuseli trápiť :). Keď ju poznáme, vieme spraviť o trocha lepšie riešenie, napríklad vedúcim sa podarilo nájsť zvieratko, ktoré prežilo 83 dní. Avšak nevieme, či je to najlepšie riešenie, či neexistuje nejaký lepší vtákopysk. Totiž túto úlohu, pre dané $n$ nájsť binárny reťazec dĺžky $n$ s najväčším počtom štvorcov nevieme efektívne riešiť. Na riešenie úloh, ktoré nevieme efektívne riešiť, často používame také heuristické algoritmy^[Teda nemáme žiadnu záruku, že dajú správnu odpoveď] ako sme si spomínali vyššie. Ak spravíme dobrý heuristický algoritmus, tak na malých vstupoch dáva optimálny výsledok oveľa rýchlejšie ako exaktný algoritmus a na veľkých vstupoch, kde by exaktný algoritmus bežal milióny rokov, dáva celkom dobré výsledky pomerne rýchlo.

Algoritmus, ktorý bodoval vaše riešenia vyzeral takto:

## Záver

Genetické programovanie, simulované žíhanie a hill-climbing sú príklady heuristických algoritmov, ktoré sa pomerne ľahko programujú a dávajú celkom dobré výsledky.

Konkrétne v tejto úlohe má podľa nás najväčšiu nádej na úspech práve genetické programovanie, ktoré (ak ste tomu venovali dosť času) vám umožnilo získať 14 bodov. Ak by ste boli veľkí šťastlivci alebo by ste sa s úlohou naozaj dlho hrali, bola nádej získať 15 bodov. Nikomu sa to však nepodarilo.
",6
45ed9b9ab953dde8,ksp,"# Obávaný skok syslí, horizontálno-zvislý

Počuli ste už o paraglidingu? Je to rekreačno-adrenalínový šport v štýle 'riadeného voľného pádu' -- inak povedané, po skoku z vyvýšeného miesta sa s pomocou vyčačkaného padáka vznášate nad okolitou krajinou, pričom vás gravitácia pomaly, ale neúprosne priťahuje k zemi.

Paragliding, ako každý správny šport, má svoj klub nadšencov s neoriginálnym názvom -- Klub Slovenských Paraglidistov (KSP). A ako každý správny zväz organizuje KSP klubové akcie -- spoločné výlety do prestížnych paraglidingových centier, kde sa členovia klubu do sýtosti vylietavajú v tých najlukratívnejších pohoriach. Samozrejme, každá akcia musí byť úžasnejšia ako tá predošlá, a preto je výber správnej destinácie kľúčový. Tento rok sa dokonca na akciu prihlásila legenda Tatranského paraglidingu Syseľ Samovrah. Ten je svojou vytrvalosťou a zápalom pre tento šport známy na svetovej paraglidingovej scéne.

V jeho bestseller autobiografii sa členovia KSP dočítali, že Syseľ si najviac užíva veľké zoskoky -- také, kde prevýšenie, ktoré preletí, je väčšie ako $m$. V rámci exkluzívneho rozhovoru tiež spomenul, že na paraglidingu mu najviac prekáža nutnosť po každom skoku vyšliapať naspäť na kopec. Preto väčšinou skočí z vrchola jedného kopca a pristane na vrchole nejakého nižšieho, z ktorého môže opäť skočiť ďalej. Ak toto urobí $s-1$ krát, už mu v porovnaní s počtom skokov výstup na prvý kopec až tak neprekáža. No a z odpočutého telefónneho rozhovoru vysvitlo, že Syseľ rád lietava po dobrom obede, ale zásadne smerom na východ, keďže pri lete na západ by mu svietilo slnko do očí.

KSP nechce Sysľa na svojej akcii sklamať, a preto hľadá také pohorie, ktoré obsahuje najviac trás vyhovujúcich Sysľovi. Napíšte program, ktorý im v tom pomôže.

## Úloha

Každé pohorie s $n$ horami sa dá opísať ako postupnosť $n$ čísel, reprezentujúcich výšky hôr v ňom, v smere od západu na východ. Trasa je ľubovolná postupnosť niekoľkých, nie nutne susediacich hôr, pričom Sysľovi vyhovuje práve vtedy, ak obsahuje presne $s$ hôr takých, že medzi každou za sebou idúcou dvojicou hôr je prevýšenie väčšie ako $m$ -- teda ak výška západnejšej hory je $x$ a výška východnejšej hory je $y$, tak musí platiť, že $x-y > m$. Pre dané pohorie tvorené $n$ horami a hodnoty $m$ a $s$ nájdite počet trás, ktoré vyhovujú Sysľovym požiadavkam.

## Formát vstupu

Na prvom riadku sú tri čísla $n$, $m$ a $s$ ($1 \\leq n \\leq 10^5$, $0 \\leq m \\leq 10^{18}$, $2 \\leq s \\leq 20$) -- počet hôr v pohorí, najmenšie prevýšenie ktoré Sysľa uspokojí, a počet hôr v trase, ktorá mu vyhovuje.

V druhom riadku je $n$ čísiel $h\_{i}$ ( $1 \\leq h\_{i} \\leq 10^{18}$) -- výšky hôr v pohorí, od západu na východ.

Navyše pre jednotlivé vstupné sady platí

| Číslo sady | 1 | 2,3 | 4,5,6 | 7,8 | |--------------------------------| -------------|------------------|-------------| ---| | Maximálne $n$ | $20$ | $10^3$ | $10^5$ | $10^5$ | | Maximálne $m$ a $h_i$ | $10^6$ | $10^6$ | $10^6$ | $10^{18}$ |

## Formát výstupu

Vypíšte jedno číslo -- počet rôznych trás, ktoré obsahujú presne $s$ hôr a každá hora na trase je o viac ako $m$ vyššia od tej nasledujúcej. Dve trasy považujeme za rôzne, ak existuje aspoň jedna hora, ktorá patrí do jednej z nich, ale nie do druhej.

Keďže toto číslo môže byť príliš veľké, pre KSP stačí vedieť tento počet modulo $1,000,000,007$ ($10^9+7$).

## Príklad

```vstup
4 0 2
5 4 3 1
```

```vystup
6
```

_Sysľovi vyhovuje ľubovoľná dvojica hôr._

```vstup
4 1 2
5 4 3 1
```

```vystup
4
```

_Sysľovi už nevyhovujú dvojice $(5,4)$ a $(4,3)$_

```vstup
8 3 3
11 15 15 10 10 7 1 1
```

```vystup
14
```
","# Obávaný skok syslí, horizontálno-zvislý

## Hrubá sila

Štedrí vedúci Klubu Slovenských Paraglidistov vám darujú jeden bod za riešenie, ktoré implementuje definíciu zo zadania. Stačí vyskúšať všetky trasy s $s$ horami a zistiť, ktoré z nich vyhovujú podmienke v zadaní. Tak prečo to nevyužiť? Overíme si, či sme správne pochopili úlohu, a navyše budeme mať správne riešenie na otestovanie svojich riešení pre ďalšie sady.

Potrebujeme už len vymyslieť čo najpríjemnejší spôsob, ktorým trasy dĺžky $s$ vyskúšame. Zamyslime sa, ako by si mohol za letu trasu zvoliť Syseľ? Vyberie si ľubovolnú horu, na ktorú sa na začiatku postaví a povie si, že chce skočiť ešte $(s-1)$-krát. Skočí s padákom, pričom letí nad všetkými horami napravo od tejto začiatočnej hory. Keď uvidí horu ktorá je aspoň o $m+1$ metrov nižšia ako tá z ktorej práve skočil, môže sa rozhodnúť že pristane práve na nej, alebo pokračuje v lete a rozhoduje sa nad ďalšou. Keď na nejakej hore pristane, opakuje sa tento proces znova -- ale tentokrát už Syseľ túži skočiť len ďalších $(s-2)$-krát. Keď napokon pristane na niektorej z hôr a netúži už viac skákať, resp. túži skočiť ešte 0-krát, práve dokončil jednu trasu, ktorá mu vyhovuje.

Táto úvaha sa už celkom príjemne programuje pomocou rekurzie -- skúsime 'skočiť' z každej hory, pamätajúc, že sme už dokončili trasu dlhú 1. Následne prejdeme všetky hory napravo, a pre každú horu nižšiu o viac ako $m$ od vybranej hory zavoláme tú istú funkciu (akoby sme stáli na tejto hore) s tým, že sme už preleteli trasu dĺžky 2. Keď na nejakej hore pristaneme a zistíme, že sme už preleteli trasu s $s$ horami, pripočítame k odpovedi 1.

Na záver malý detail -- trás dĺžky $s$ v pohorí s $n$ horami môže byť najviac ${n \\choose s}$. Toto číslo je v prvej sade najviac ${20 \\choose 10} = 184,756$, a teda nepresiahne hodnotu $10^9 + 7$. Výsledok teda nemusíme modulovať (počítať zvyšok po delení $10^9 + 7$).

Aká je naša pamäťová zložitosť? Stačí nám pamätať si výšky všetkých $n$ hôr a zopár pomocných premenných. Naša rekurzívna funkcia sa v sebe zavolá najviac $s$-krát, a teda počet premenných, ktoré máme vytvorené v ľubovoľnom čase v jej všetkých volaniach bude úmerný $s$. Celková pamäťová zložitosť je teda $O(n+s)$.

Ako je to s časovou zložitosťou? Skúšame všetky platné trasy dĺžky $s$ spomedzi $n$ hôr. V najhoršom prípade všetky trasy dĺžky $s$ vyhovujú Sysľovi, a bude ich teda ${n \\choose s}$. Pre jednoduchší odhad zložitosti využijeme fakt, že všetkých podmnožín $n$ prvkov je $2^n$. Naše riešenie síce zaujímajú len $s$-prvkové množiny hôr v našom pohorí, ich počet však rastie asymptoticky rovnako rýchlo. Časová zložitosť je teda exponenciálna od $n$, s horným rádovým ohraničením $O(2^n)$.

## Postupne predlžujeme známe trasy

Označme výšku $i$--tej hory v smere na východ $h_i$. Pozrime sa bližšie na otázku, ktorú sme sa pri rekurzii pýtali: koľko platných trás dĺžky $s$ začína v hore $i$? Ak by sme odpoveď chceli popísať slovne, je ich práve toľko, koľko platných trás dĺžky $s-1$ začína v horách $i+1,i+2,...,n-1$, ktoré sú vysoké najviac $h_i-m-1$. Keby sme pre každú horu $k$, pre ktorú platí $i < k$, vedeli povedať, koľko platných trás dĺžky $s-1$ v nej začína, ľahko by sme odpoveď spočítali. No a koľko takých trás existuje pre nejakú horu $k$? No predsa presne toľko, koľko platných trás dĺžky $s-2$ začína v takých horách $k+1,k+2,...,n-1$, ktoré sú vysoké najviac $h_k-m-1$.

Ale to je tá istá otázka ako predtým! Keby sme vedeli počet platných trás dĺžky $d$ začínajúc v každej hore v pohorí, pre každú horu $i$ by sme vedeli sčítať počty platných trás tých hôr, ktoré sú napravo od nás a dostatočne nízke, a tým našli počet platných trás dĺžky $d+1$ začínajúc v hore $i$. Túto hodnotu spočítame pre každé $0 \\leq i \\leq n-1$. Odteraz budeme označovať **počet platných trás dĺžky $d$ začínajúc v hore $i$ ako $v(d, i)$**.

Ak teda poznáme $v(d, i)$ pre nejaké $d$, vieme teraz spočítať počet platných trás dĺžky $d+1$ pre každú horu v pohorí! A kde začať? Poznáme pre nejaké $d$ počet platných trás začínajúc v každej hore? Samozrejme - každá hora je sama o sebe platná trasa dĺžky 1. Vieme teda našou úvahou spočítať pre každú horu $i$ počet platných trás dĺžky 2 ktoré v nej začínajú -- $v(2,i)$. Jednoducho sčítame $v(1, j)$ všetkých dostatočne nízkych hôr napravo. Hodnoty $v(2,i)$ sú všetko, čo potrebujeme na vypočítanie trás dĺžky tri -- $v(3,i)$, a tak ďalej. Tento výpočet zopakujeme teda $(s-1)$-krát a dostaneme pre každú horu počet platných trás dĺžky $s$, ktoré v nej začínajú. Tieto čísla sčítame, a máme hľadaný výsledok. Keďže nás zaujíma len jeho zvyšok po delení číslom $10^9+7$, všetky výpočty ním budeme modulovať.

Na záver tohto riešenia ešte vieme spraviť jedno pozorovanie: akonáhle sme pre každú horu zistili počet platných trás dĺžky $d+1$ ktoré v nej začínajú ($v(d+1,i)$,) predtým vypočítaná hodnota $v(d,i)$ nás už nebude nikdy zaujímať. Na celý výpočet nám teda budú stačiť dve polia, pričom budeme striedať ich význam. Pri prvom výpočte máme v prvom poli hodnoty $v(d,i)$, a do druhého počítame $v(d+1,i)$. Následne prvé pole vynulujeme, a spočítame doňho pre každú horu $v(d+2,i)$, využívajúc výsledky pre $d+1$ ktoré máme teraz uložené v druhom poli.

Dokopy si teda budeme pamätať výšky všetkých $n$ hôr, a zároveň dve polia dĺžky $n$, v ktorých budeme striedavo vypočítavať pre každú horu počet v nej začínajúcich platných trás postupne väčšej dĺžky. Pamäť teda lineárne závisí od $n$ a ničoho iného -- $O(n)$.

Tú istú úvahu opakujeme $(s-1)$-krát -- máme pre každú horu $i$ vypočítanú hodnotu $v(d,i)$ pre nejaké $d$ (na začiatku $v(1,i) = 1$), a pre každú horu budeme počítať $v(d+1,i)$. Ako vyzerá tento výpočet pre jednu horu? Prejdeme všetky hory východnejšie od nej, a pre každú dostatočne nízku horu $k$ pripočítame k našej hore jej hodnotu $v(d,k)$. Toto robíme pre každú horu, ktorých je $n$, a počet kontrolovaných hôr napravo od nich takisto závisí lineárne od $n$. Vypočítanie hodnôt pre $v(d+1,i)$ z hodnôt $v(d,i)$ nám teda zaberá kvadratický čas od $n$, a tento výpočet opakujeme $(s-1)$-krát, teda lineárne od $s$. Celková časová zložitosť bude teda $O(s\\cdot n^2)$.

## Spočítavame rýchlejšie

Potrebujeme si zrýchliť naše riešenie. Zjavne potrebujeme z našej časovej zložitosti odstrániť faktor $n^2$, keďže pre $n = 100,000$ je táto zložitosť neúnosná. Čo nám trvá $n$ krokov? $n$-krát spracúvame nejakú horu $i$ a počítame počet trás dĺžky $d+1$ (postupne $2,3,...,s-1,s$), ktoré v nej začínajú -- $v(d+1,i)$. Ako vyzerá spracovanie jednej hory? Prejdeme všetky hory východnejšie od nej (teda hory $k$ kde $i < k$. Tých je lineárne veľa od $n$), a pre tie hory, ktorých výška $h_k$ je najviac $h_i - m - 1$ pripočítame k našemu číslu $v(d+1,i)$ počet trás dĺžky $d$ začínajúc v hore $k$ -- $v(d,k)$.

Pozrime sa na hory, ktorých trasy vlastne chceme spočítať. Zoberme si všetky východnejšie hory od hory $i$, a usporiadajme si ich podľa výšky. Ktoré z nich nás zaujímajú? Tie dostatočne nízke! Presnejšie, tie hory, ktorých hodnoty $v(d,k)$ chceme spočítať, budú po usporiadaní tvoriť súvislý úsek hôr začínajúci najnižšou z nich, a končiaci najvyššou horou, ktorej výška $h_k$ je stále menšia ako $h_i - m$ (toto môžu teda byť aj všetky východnejšie hory od hory $i$, prípadne ani jedna). Toto pozorovanie nám samo o sebe nepomôže -- usporiadať východnejšie hory, ktorých je lineárne veľa od $n$, vieme najlepšie v čase $n \\log n$. Pomôžeme si však, keď si uvedomíme že nás pri počítaní $v(d+1,i)$ vlastne nezaujíma, ktorá východnejšia hora prispieva koľkými trasami dĺžky $d$, ani to, kde tieto hory vlastne sú -- stačí vedieť že su dostatočne nízke a východnejšie od nás.

Skúsme na to isť teda trošku inak. Namiesto toho, aby sme zisťovali pre každú horu jej hodnotu $v(d,i)$, bude nám stačiť pre každú výšku $h$ súčet $v(d,i)$ tých hôr $i$, ktoré majú výšku $h$. Ak toto vieme, pri počítaní $v(d+1,i)$ by nám stačilo spočítať tieto hodnoty pre výšky $1,2,...,h_i-m-1$. Tieto hodnoty si pre hory dostatočne malej výšky môžeme rovno pamätať v pomocnom poli $P$ na indexoch $1,2,...,10^6$. Keď si teda náš algoritmus takto pozmeníme, stačilo by nám vedieť sčítavať čísla na intervale v poli $P$ v lepšom ako lineárnom čase od veľkosti intervalov. Vieme to urobiť?

Odpoveď je: áno. Budeme však musieť použiť dátovú štruktúru, ktorá dokáže spracovávať (v našom prípade sčítavať) hodnoty na zvolenom intervale: intervalový strom. Ak ste o intervalovom strome nepočuli, prečítajte si nasledovný článok [v kuchárke KSP](https://www.ksp.sk/kucharka/intervalovy_strom/).

Nám bude teraz stačiť skutočnosť, že s intervalovým stromom vieme zostrojiť funkciu $spocitaj(P,l,r)$, ktorá nám vráti súčet políčok v $P$ od $l$ po $r$, v logaritmickom čase od veľkosti stromu. Zároveň vieme zostrojiť aj funkciu $pridaj(P,i,y)$, ktorá na políčko $P_i$ pripočíta hodnotu $y$ taktiež v logaritmickom čase. Po zvýšení políčka $i$ už bude funkcia spocitaj($P,l,r$) vracať nový, zvýšený výsledok ak $l \\leq i \\leq r$,

Postupovať budeme teda rovnako ako pri pomalšom riešení s niekoľkými rozdielmi. Namiesto polí veľkosti $n$ budeme mať intervalové stromy s o trochu viac ako $10^6$ políčkami, pričom v intervale $[l,r]$ stromu $S_d$ budeme mať hodnoty $v(d,i)$ začínajúc horami s výškami $l$ až $r$. Počet platných trás dĺžky $d+1$ začínajúcich v hore $i$ vypočítame pomocou $spocitaj(S_d, 0, h_i - m - 1)$ (nazvime výsledok $y$), a pridáme ho do stromu $S\_{d+1}$ pomocou $pridaj(S\_{d+1}, i, y)$.

Ostáva jedna otázka -- ako zaručiť, že práve spracovaná hora $i$ neovplyvní počet spočítaných trás, keď budeme v ďalšom kroku spracovávať východnejšiu horu $i+1$? Stačí, ak po vypočítaní hodnoty $v(d+1,i)$ v $S\_{d+1}$ z nášho momentálne používaného stromu $S_d$ zmažeme z políčka $h_i$ počet trás, ktoré začínali v našej hore $v(d,i)$. Túto hodnotu si môžeme zapamätať v poliach veľkosti $n$ (v riešení nazvané `zacina`). Keď spočítame počet trás dĺžky $d+1$, zapíšeme si do prislúchajúceho poľa túto hodnotu, a tú použijeme pri výpočte $S\_{d+2}$.

Na záver prichádza rovnaké pozorovanie ako pri riešení dynamickým programovaním. Pri výpočte trás s dĺžkou $d+1$ do intervalového stromu $S\_{d+1}$ a $zacina\_{d+1}$ využívame len výšky hôr a hodnoty v $S_d$ a $zacina_d$. Takisto ako minule si teda vystačíme len s dvoma pármi štruktúr, ktoré budeme pri výpočtoch striedať.

Pamätáme si výšky všetkých hôr a počet trás končiacich v každej z nich v (dvoch) poliach `zacina` , ktoré majú počet prvkov lineárny od $n$. K tomu nám pribudli dva rovnako veľké intervalové stromy, ktorých veľkosť je lineárna od najvyššej hory na vstupe. Ak by sme toto číslo mali uvedené na vstupe ako $max$ (a teda rozlišovali sadu 4 od sád 1,2,3), naša pamäťová zložitosť by bola $O(n+max)$.

Namiesto spočítania trás začínajúc v menších horách napravo v čase lineárnom od $n$ používame konštantne veľa volaní funkcii pridaj a spocitaj, ktorých časová zložitosť je $O(\\log max)$. Výpočet robíme stále pre všetkých $n$ hôr a opakujeme $s$-krát, postupne pre väčšie dĺžky trás. Vynulovanie polí `zacina` a intervalového stromu pri prestupovaní z dĺžky $d$ na $d+1$ robíme taktiež v lineárnom čase od ich veľkosti. Časová zložitosť je teda $O(s\\cdot n\\cdot \\log max + max)$.

## Ako na vysoké hory

S doterajším prístupom si na horách veľkosti nad $10^6$ náš program vyláme zuby. Skúsme si tento problém s vysokými horami posunúť niekam inam -- vytvorí nám to asi iný problém, a ten potom skúsime vyriešiť.

Zoraďme si teda hory podľa výšky. Prvej hore povieme, že je najnižšia, akoby s výškou 1. Nájdeme si druhú najnižšiu (ale nie s rovnakou výškou!). Tej povieme, že má výšku 2. Takto postupujeme, až každej hore priradíme novú výšku z rozsahu $[1,n]$. Tieto výšky sa nám už zmestia do intervalového stromu rovnako ako v minulom riešení. Hurá, hotovo!

Teda, skoro. V minulom riešení sme sa opierali o to, že z hory s výškou $h_i$ vieme skočiť na všetky hory z výškou najviac $h_i-m-1$, teda súčtom v intervalovom strome cez $spocitaj(S_d,1,h_i-m-1)$. Toto však už zďaleka nie je pravda. O ozajstných výškových rozdieloch hôr po prečíslovaní už nič nevieme. Hora s novou výškou 2 mohla byť len o jeden meter vyššia ako hora s novou výškou 1, ale rovnako pravdepodobne mohla byť vyššia o miliardu metrov. Po vyriešení veľkosti nášho intervalového stromu teda musíme vyriešiť iný problém -- pri spracúvaní hory $i$ potrebujeme efektívne povedať, ktorá je najvyššia hora ktorá má s $h_i$ prevýšenie aspoň $m$. Označme si (novo pridelenú) výšku tejto hory $inv_i$.

Zoberme si naše hory, ktoré máme momentálne zoradené podľa (starej) výšky. Pozrime sa na tú, ktorá je v strede tohto poľa (nazvime ho $C$) -- $C\_{n/2}$. Ak je táto hora privysoká -- $h_i-m \\leq C\_{n/2}$ -- určite sú aj hory napravo od nej ( $C\_{n/2 + 1},...,C\_{n-1}$ ) príliš vysoké. Ak je však dostatočne nízka -- $h_i-m>C\_{n/2}$ určite sú aj všetky hory naľavo od nej ( $C_0 ,...,C\_{n/2-1}$ ) dostatočne nízke. Určite už tušíte riešenie -- v poli $C$ v čase $O(\\log n)$ binárne vyhľadáme najvyššiu horu, ktorá je dostatočne nízka, a zapíšeme si k príslušnej hore $i$ hodnotu $inv_i$ -- novopriradenú výšku tejto hory (pripomíname, že tá je z rozsahu $[1,n]$). Toto zopakujeme pre každú horu, pridávajúc nami akceptovanú zložitosť $O(n\\cdot \\log n)$.

Už nám zafunguje naše riešenie rovnako ako v minulých sadách -- pri počítaní $v(d+1,i)$ zavoláme spocitaj($S\_{d+1},0,inv_i$) a nakoniec odčítame z $S_d$ na pozící novej výšky hory $i$ hodnotu $zacina_i$. Prečíslované výšky hôr si môžeme pamätať napríklad v hešovacej tabulke (`map` v C++) -- jej zložitosť na vkladanie alebo pozeranie sa do nej je $O(\\log k)$, kde $k$ je počet prvkov v nej -- prečíslovanie $n$ hôr teda bude trvať najviac O($n \\log n$) -- a pozrieme sa do nej konštantne veľa krát pri spracovaní každej hory počas vypočítavania odpovede.

V pamäti máme teraz $n$ výšok hôr, dve polia `zacina` a dva intervalové stromy (ktorých veľkosť po prečíslovaní výšok klesne na $O(n)$), a napokon pre každú horu záznam v hešovacej tabuľke a priradenú hodnotu $inv_i$. Celková pamäťová zložitosť nášho programu je teda $O(n)$.

Rovnako ako v predchádzajúcom riešení, práca s poliami `zacinaj`, intervalovými stromami a tentokrát aj s prvkami $inv_i$ prebieha v lineárnom čase od ich veľkosti, ktorá je lineárna od $n$. Volania funkcii $spocitaj$ a $pridaj$, ktoré obe používame $O(s\\cdot n)$-krát, je $O(\\log n)$ a teda s celkovou zložitosťou $O(s\\cdot n\\cdot \\log n)$. Usporiadania poľa $C$ a prečíslovanie výšok hôr pomocou hešovacej tabulky vieme v vykonať v $O(n \\log n)$, zatiaľ čo $O(s \\cdot n)$ nazretí do nej pri spracovávaní trás intervalovými stromami nám trvá $O(s\\cdot n \\cdot \\log n)$. Horný odhad časovej zložitosti je teda $O(s\\cdot n\\cdot \\log n)$.
",9
9baa0ae1dfb21c33,ksp,"# Oblepené mesto

Bratislava, hlavné mesto Slovenska, je celkom slušne oblepená. To určite viete, ak ste v nej aspoň raz v živote boli. Billboard sem, billboard tam, plagáty a plagáty. Ale ani jeden nepatrí spoločnosti Kaderníkov Spod Papuče. Jej manažér, Mário, si to tiež všimol a tak sa rozhodol, že jeden plagát svojej spoločnosti predsa len vybaví.

Pochodil celú Bratislavu a nakoniec našiel ideálnu stenu. Bolo na nej už síce zopár plagátov, ale to nevadí. ""Veď nejaké môžeme aj prelepiť,"" povedal si Mário. V Bratislave je však zakázané prelepiť nejaký plagát čiastočne, a tak je to aj správne, veď je to potom hrozne neestetické. Ak sa má nejaký plagát prelepiť, tak celý!

Teraz Mário nevie, ako má nalepiť plagát Kaderníkov Spod Papuče. Pomôžete mu?

## Úloha

Na stene je už umiestnených niekoľko plagátov, ktoré majú tvar obdĺžnikov, ktorých strany sú rovnobežné s osami súradnicovej sústavy. Mário si zaumienil, že plagát svojej spoločnosti musí pokrývať aspoň obdĺžnik $(x, y, w, h)$ ($x, y$ určujú pozíciu ľavého horného rohu, $w, h$ určujú šírku a výšku).

Teraz potrebuje nájsť takú obdĺžnikovú plochu na nalepenie plagátu, aby pokrývala aspoň obdĺžnik $(x, y, w, h)$ a zároveň, aby každý iný plagát prekrývala buď celý alebo vôbec.

Keďže spoločnosť Kaderníkov Spod Papuče má len obmedzené financie, Mário chce nájsť najmenší takýto obdĺžnik.

## Formát vstupu

Na prvom riadku sa nachádza jedno celé číslo $n$ ($0 \\leq n \\leq 100,000$) -- počet plagátov na stene.

Na ďalších $n$ riadkoch sa nachádzajú popisy jednotlivých plagátov. Na $i$-tom z týchto riadkov sú štyri celé čísla oddelené jednou medzerou: $x_i, y_i, w_i, h_i$. Čísla $x_i, y_i$ určujú súradnice ľavého horného rohu $i$-teho plagátu a čísla $w_i, h_i$ určujú jeho šírku a výšku. Tieto plagáty sa môžu čiastočne aj úplne prekrývať.

Pozor, v tejto úlohe používame súradnicovú sústavu, kde sa $y$-ová súradnica zväčšuje smerom dole. Preto určujeme pozíciu ľavého _horného_ rohu.

Pre všetky $i$ platí $0 \\leq x_i, y_i, w_i, h_i \\leq 10^9$.

Na poslednom riadku sa nachádzajú čísla $x, y, w, h$ oddelené medzerou. Tieto popisujú plochu, ktorá musí byť pokrytá Máriovým plagátom.

Rovnako platí, že $0 \\leq x, y, w, h \\leq 10^9$.

## Formát výstupu

Vypíšte jeden riadok a na ňom štyri celé čísla oddelené jednou medzerou: $x_p, y_p, w_p, h_p$, kde $x_p, y_p$ sú súradnice ľavého horného rohu a $w_p, h_p$ sú šírka a výška plochy kam nakoniec Mário nalepí plagát svojej spoločnosti.

## Príklady

```vstup
2
0 7 5 5
7 0 5 5
0 0 5 5
```

```vystup
0 0 5 5
```

_Máriova vysnívaná plocha sa neprekrýva so žiadnym existujúcim plagátom._

```vstup
2
0 5 5 5
5 0 5 5
0 0 5 5
```

```vystup
0 0 5 5
```

_Dokonca ani teraz sa neprekrýva so žiadnym existujúcim plagátom._

```vstup
2
2 2 9 9
6 0 7 2
1 1 4 4
```

```vystup
1 0 12 11
```

_Cieľová plocha sa prekrýva s prvým plagátom. Ak ho však chceme zahrnúť, nevieme sa vyhnúť prekrytiu s druhým, a tak musíme zakryť aj ten._
","# Oblepené mesto

V tomto popise vzorového riešenia budeme používať nasledovné názvoslovie:

- *Nutný obdĺžnik* = obdĺžnik, ktorý musíme celý prekryť -- určený číslami $x, y, w, h$ zo vstupu.

- *Postačujúci obdĺžnik* = najmenší obdĺžnik, ktorý pokrýva nutný obdĺžnik a zároveň spĺňa podmienky zadania -- správna odpoveď a teda určený číslami $x_p, y_p, w_p, h_p$.

- *Pumpovací obdĺžnik* = riešenie bude vždy spočívať v tom, že začneme s nutným obdĺžnikom a budeme ho rozťahovať až kým nedostaneme postačujúci obdĺžnik. Obdĺžnik v procese rozťahovania budeme volať pumpovací obdĺžnik.

## Pozorovanie

Najdôležitejšie pozorovanie v celej tejto úlohe je toto: k správnemu riešeniu sa vždy dostaneme nasledovným spôsobom. Za pumpovací obdĺžnik si najprv zoberieme nutný obdĺžnik. Kým sa pumpovací obdĺžnik čiastočne prekrýva s nejakým plagátom, tak pumpovací obdĺžnik roztiahneme tak, aby ten plagát akurát celý prekrýval. Lepšie je to objasnené na nasledujúcom obrázku:

Po roztiahnutí sa môže stať, že sa pumpovací obdĺžnik začne prekrývať s nejakým ďalším plagátom. Tento postup teda opakujeme až kým sa pumpovací obdĺžnik neprekrýva čiastočne so žiadnym plagátom. Vtedy sa pumpovací obdĺžnik rovná postačujúcemu obdĺžniku.

## Pomalé riešenie

Toto riešenie bude spočívať v naivnej implementácii spomenutého pozorovania. Najprv si pumpovací obdĺžnik nastavíme na nutný. Potom prejdeme cez všetky plagáty a zistíme, či sa nejaký z nich čiastočne neprekrýva s pumpovacím obdĺžnikom. Ak áno, tak pumpovací obdĺžnik roztiahneme tak, aby akurát pokrýval daný plagát. Tento postup opakujeme, kým dochádza k nejakým zmenám. Keď prestane dochádzať k zmenám, našli sme správne riešenie.

Objasnime si, čo znamená ""roztiahnuť obdĺžnik tak, aby akurát pokrýval daný plagát"". Znamená to vytvoriť taký obdĺžnik, ktorý súčasne pokrýva pôvodný obdĺžnik aj plagát a je zároveň čo najmenší. Vieme ho vypočítať takouto funkciou:

Funkcia berie ako argumenty dva obdĺžniky. Prvý je zadaný číslami $x_1, y_1, w_1, h_1$ a druhý číslami $x_2, y_2, w_2, h_2$. Výsledkom je obdĺžnik, ktorého ľavý okraj je tam, kde je ľavý okraj ""ľavejšieho"" z obdĺžnikov, pravý tam kde je okraj ""pravejšieho"" a podobne pre zvyšné prípady.

Pozrime sa na časovú a pamäťovú zložitosť tohto riešenia. Existujú vstupy, v ktorých sa na začiatku nutný obdĺžnik čiastočne prekrýva len s jedným plagátom. Hneď ako ho pokryje, prekryje sa s jedným ďalším a tak ďalej, až kým postupne pokryje všetky plagáty. V tomto riešení potrebujeme s každým novým pokrytím preiterovať cez všetky plagáty, aby sme zistili, s ktorým sa pumpovací obdĺžnik prekrýva. Keďže postupne pokryjeme všetkých $n$ plagátov a pri každom potrebujeme preiterovať cez všetkých $n$ plagátov, časová zložitosť je $O(n^2)$. Pamäťová zložitosť je $O(n)$, keďže si potrebujeme pamätať len pozície a rozmery všetkých obdĺžnikov.

## Rýchle riešenie

Počet plagátov v tejto úlohe môže byť až $100,000$ a tak je predchádzajúce riešenie príliš pomalé. Pokúsime sa ho teda zrýchliť.

Najprv si uvedomme, že na každý plagát narazíme buď sprava, zľava, zvrchu, alebo zospodu (teda: najprv sa pumpovací obdĺžnik s daným plagátom neprekrýva, potom sa pumpovací obdĺžnik roztiahne doľava, čo spôsobí, že sa prekryje s nejakým iným plagátom; v tomto prípade naň narazil sprava).

Ďalej je dôležité si uvedomiť, v akom poradí budeme na jednotlivé plagáty narážať. Majme nejaké dva plagáty. Pravý okraj prvého nech je ďalej od nutného obdĺžnika, ako pravý okraj druhého. Ak na oba tieto obdĺžniky narazíme zľava, tak zaručene musíme najprv naraziť na druhý, až potom na prvý, lebo je ďalej.

Z tohto je zrejmé, v akom poradí budeme na jednotlivé plagáty narážať. Najprv narazíme na tie, ktorých okraje sú bližšie, až potom na tie, ktorých okraje sú ďalej.

Plagáty si teda usporiadame osobitne podľa ľavých, pravých, horných a spodných okrajov. Následne si v každom z týchto usporiadaných polí budeme udržiavať ukazovateľ (index), ktorý určuje, kde sa nachádza daný okraj pumpovacieho obdĺžnika.

Na začiatku budú tieto indexy ukazovať na okraje nutného obdĺžnika.

Ďalej si budeme v každom smere udržiavať ďalší ukazovateľ, ktorý nazvime ""naťahovací"". Tieto ukazovatele budeme posúvať vždy, keď sa pumpovací obdĺžnik v niektorom smere čiastočne prekrýva s nejakým plagátom.

Ukazovatele pumpovacieho obdĺžnika budú ""dobiehať"" naťahovacie ukazovatele. Pri každom posunutí ukazovateľov pumpovacieho obdĺžnika narazíme na okraje nejakého nového plagátu. Skontrolujeme teda, či sa s ním pumpovací obdĺžnik čiastočne neprekrýva a ak áno, tak zase posunieme naťahovacie indexy.

Takýmto spôsobom postupne napumpujeme pumpovací obdĺžnik z nutného na postačujúci a tak nájdeme správne riešenie.

Pozrime sa ešte na časovú a pamäťovú zložitosť tohto riešenia. Na začiatku si musíme zoradiť okraje plagátov, čo nám dáva časovú zložitosť najmenej $O(n \\log n)$. V nasledujúcej fáze postupne posúvame ukazovatele. Každý okraj nejakého plagátu však každým ukazovateľom navštívime najviac raz, a tak je časová zložitosť tejto fázy $O(n)$. Celková časová zložitosť je teda $O(n \\log n)$. Pamäťová zložitosť je $O(n)$, pretože aj v tomto riešení si musíme len pamätať pozície a rozmery jednotlivých plagátov a nič navyše.
",6
3146ab52c9969422,ksp,"# Idiomatická rekonštrukcia

Vzrušujúce noviny! V auguste sa bude konať veľkolepá lingvistická konferencia v Memphis v Tennessee. A pozvaní sú všetci! Budú aj prednášky. Prednášku bude mať napríklad Viktor. O čom? Isto ste počuli o významných objavoch nekrolingvistky Kristíny. [Minulé kolo](https://www.ksp.sk/ulohy/zadania/2476/) sa jej podarilo ukázať, že isté prastaré atlantídske zvitky sú z neznámych socio-kultúrnych dôvodov napísané tak, aby obsahovali palindrómy[^1]... Ale čo to môže znamenať? Odkiaľ pramení táto atlantídska fascinácia palindrómami? Viktor si myslí, že zistil odpoveď. Na jednom zvitku totiž našiel niečo takéto:

Pokiaľ sa Viktor nemýli, jedná sa o historicky vôbec prvé vyobrazenie obrovskej kozmickej ploštice (pohľad zvrchu). Určite sa pýtate ""?"". Všetko pochopíte, až budete starší, približne presne o pár sekúnd. Predstavte si, že ste atlantíďan. Keď za vami takáto kozmická ploštica príde, naskytne sa vám približne nasledovný pohľad (kozmická ploštica spredu - be not afraid):

Ale čo! Vidíte to aj vy? Táto kozmická ploštica vyzerá úplne ako palindróm (os súmernosti je vyznačená)!!! Viktor verí, že prví atlantíďania nadizajnovali svoje písmo podľa ploštičej tváre, a aj potom, čo kozmické ploštice vymreli[^2], sa moderný skript snaží túto spomienku zachovať už spomínaným spôsobom písania[^3].

Ale čo s týmto zistením? Samozrejme, treba zrekonštruovať, ako mohli kozmické ploštice naozaj vyzerať! Vpred-smerujúca kozmická ploštica na obrázku vyššie je totiž iba estimácia. Naviac, každá kozmická ploštica je unikátna.

Vieme, že prvé atlantídske vety vznikli z ploštičej tváre, ktorú atlantíďania rozdelili na jednotlivé slovíčka. Teda rekonštrukcia je jednoduchá: vezmeme slovíčka, ktoré poznáme, a vyskladáme z nich našu predstavu ploštičej tváre...

\[^1\]: palindróm je taký reťazec, že odzadu sa číta rovnako ako odpredu, teda napríklad ""aktivitka"". Vedúci KSP palindrómy zbožňujú a majú ich každé raňajky. \[^2\]: momentálne asi vedeckou komunitou najuznávanejšia teória je, že kozmické ploštice nezmizli, len sa vplyvom gravitácie z plochého tvaru zaguľatili a do dnešného dňa prežívajú v podobe basketbalových lôpt. \[^3\]: azda atlantíďania verili, že kozmické ploštice sa ku nim vrátia, pokiaľ sa text bude opäť na ich podobizeň podobať?

## Úloha

Na vstupe dostanete niekoľko reťazcov pozostávajúcich z malých písmen anglickej abecedy. Vašou úlohou je na výstup vypísať ľubovoľný palindróm, ktorý vie vzniknúť tak, že niektoré zo vstupných reťazcov v nejakom poradí zapíšeme priamo za seba (môžu sa aj opakovať, a nemusíte použiť všetky), prípadne zistiť, že sa to nedá.

## Formát vstupu

V prvom riadku vstupu je číslo $n$ udávajúce počet slov, ktoré poznáme.

Na každom z $n$ nasledovných riadkov je jedno slovo -- reťazec dĺžky $d_i$ ($1 \\leq d_i \\leq 10$) pozostávajúci z malých písmen anglickej abecedy. Navyše platí, že žiadne slovo nie je prefixom ani suffixom iného, teda zo žiadneho slova nevieme dostať žiadne iné iba tak, že na jeho začiatok alebo koniec pridáme nejaké znaky.

Počty slov sú v jednotlivých sadách nasledovné:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|----------:|----------:|----------:| | $1 \\leq n \\leq$ | $10$ | $1,000$ | $30,000$ | $40,000$ |

## Formát výstupu

Na jedinom riadku výstupu vypíšte palindróm pozostávajúci z malých písmen anglickej abecedy, ktorý sa dá zo vstupných slov vyskladať. Ak ich existuje viac, vypíšte ľubovoľný z nich. Ak neexistuje žiaden, vypíšte `-1`.

## Príklady

```vstup
5
jelenovi
ani
sobovi
nelej
pivo
```

```vystup
jelenovipivonelej
```

```vstup
3
takyto
palindrom
neexistuje
```

```vystup
-1
```

```vstup
2
aktivi
tka
```

```vystup
aktivitka
```
","# Idiomatická rekonštrukcia

## Základná myšlienka riešenia

Najprv si predstavme, že jednoducho skladáme reťazec zo zadaných podreťazcov (nazvime ich ""kúsky""). Ako to môžeme robiť? Aké máme kedy možnosti, ako v ktorom momente pokračovať? Na začiatku si vieme zvoliť ľubovoľný znak, ktorým nejaký kúsok začína. Potom ľubovoľný znak, ktorým niektorý z takto začínajúcich kúskov pokračuje. Až dosiahneme bod, keď sme napísali nejaký celý kúsok, vieme určite, že ďalšie znaky do toho istého kúsku patriť nemôžu, keďže by sme vyskladali nejaký kúsok, ktorého prefixom je ten kúsok, ktorý sme teraz dokončili...

Ukážka: skladajme od začiatku reťazec z kúskov ""ahoj"" ""aha"" a ""hanoj"". Najprv môžeme začať znakom ""a"" alebo ""h"". Zvoľme si ""a"". Pokračujeme určite znakom ""h"", teda teraz máme zatiaľ reťazec ""ah"". Tretím písmenom môže byť ""o"" alebo ""a"". Ak si zvolíme ""a"", vyskladáme hotový reťazec ""aha"". Vieme, že toto je koniec tohto kúsku, pretože žiaden iný kúsok nemôže začínať prefixom ""aha"". Teda pokračujeme od začiatku: znova si môžeme vybrať ""a"" alebo ""h"". A tak ďalej...

## Reprezentácia slovníka

Štruktúra, ktorá nám môže pomôcť pamätať si aké písmenká sme zatiaľ v budovanom kúsku použili, je napríklad trie: strom, ktorého koreň označuje prázdny kúsok (buď keď sme na začiatku skladania alebo keď sme práve dokončili kúsok pred tým). Každý ďalší vrchol v trie označuje reťazec v jeho rodičovi, ku ktorému je na koniec pridaný jeden znak. V trie sú všetky reťazce, ktoré sú prefixom nejakého povoleného kúsku. Teda, keď chceme budovať nejaký reťazec z kúskov, vieme sa jednoducho pohybovať po trie vždy do dieťaťa aktuálneho vrcholu a z listov (dokončených kúskov) sa vrátiť do koreňa.

## Skladanie palindrómu

Dobre, čo teraz? Chceme, aby náš reťazec bol nielen vyskladaný z kúskov, ale aj aby bol palindrómom. Prípadne zistiť, že neexistuje. Skladajme reťazec nielen od začiatku, ale aj od konca zároveň. Spravíme dve trie - jedno pre všetky povolené kúsky odpredu a jedno pre povolené kúsky odzadu.

Ako vyzerá skladanie palindrómu? V oboch trie začneme od koreňa - na začiatku ani na konci ešte žiaden znak nie je. Následne vieme pridať na začiatok aj koniec ten istý znak. Teda musí to byť nejaký taký, ktorý vieme v oboch trie pridať - teda oba momentálne vrcholy v nich majú dieťa, kde je pridaný ten istý znak. Keď v nejakom trie narazíme na koniec, vrátime sa hneď do koreňa.

## Kedy skončiť

Kedy sme palindróm doskladali? Ako spoznáme, že môžeme začiatok aj koniec palindrómu, ktorý skladáme, spojiť do celku, ktorý bude tiež pozostávať z povolených kúskov? Spravíme trik: budeme hľadať iba palindrómy párnej dĺžky, v ktorých žiadne kúsky neprechádzajú stredom. Teda prvá aj druhá polovica sú samé osebe vyskladané z kúskov. Určite, ak existuje akékoľvek riešenie, existuje aj takéto - jednoducho, akékoľvek riešenie napíšeme dvakrát za seba. Stále bude palindrómom a prvá aj druhá polovica budú vyskladané z kúskov samé osebe. Takéto riešenia sa budú hľadať omnoho jednoduchšie - ak sa vrátime do situácie, že v oboch trie sme v koreni, našli sme ho. Totiž náš budovaný prefix aj suffix sú v tomto momente uzatvorené, a teda ich vieme proste nalepiť za seba a dostať riešenie.

## Vyhodnotenie

Už nám teda ostáva len premyslieť si, ako zistiť, či sa takto dá vyskladať riešenie alebo nie. Teda máme niekoľko stavov, každý je popísaný dvojicou vrcholov v oboch trie a chceme zistiť, či sa zo stavu koreň-koreň dá do seba vrátiť. V podstate nám stačí DFS algoritmus zbehnutý na dvojiciach týchto vrcholov. V dvojrozmernom poli si zapamätáme pre každú dvojicu, či sme ju už navštívili. Ak nájdeme spôsob, ako sa tam vrátiť, teda riešenie existuje, tak konkrétne riešenie nájdeme, ak si pre každú dvojicu zapamätáme, z ktorej sme sa na ňu dostali a takto odzadu celú cestu zrekonštruujeme.

## Zložitosť

Aké sú zložitosti našeho programu? Jeho časová zložitosť je $O(n^2)$, pretože na začiatku spravíme obe trie - na to musíme prejsť $n$ slov konštantnej dĺžky a každé z nich vložiť do trie odpredu a odzadu. To trvá len $O(n)$. Potom zbehneme DFS na dvojiciach vrcholov týchto trie. Každé trie má najviac $O(n)$ vrcholov, teda dvojíc je $O(n^2)$ a to je aj zložitosť tohoto DFS. Jeho pamäťová zložitosť je $O(n^2)$, pretože si pamätáme okrem dvoch trie veľkosti $O(n)$ ešte dvojrozmerné pole veľkosti $O(n^2)$.
",8
949c53cb2b7fc751,ksp,"# Inovatívny dážď

Hady sužované neustálymi dažďami dali jedného dňa hlavy dohromady a vynašli Hadí Automat Aktualizujúci Rozbité Počasie. Problém je, že je to iba jednoduchý prototyp, ktorý dokáže jednu vec: vyjasní počasie na nejakom obdĺžnikovom kuse zeme. Následne sa hady znovu zamysleli a dokázali upraviť Hadí Automat Aktualizujúci Rozbité Počasie, aby slnil vo viac *neprekrývajúcich sa* obdĺžnikoch naraz.

Hady by chceli použiť Automat na oslňovanie parku. Park si vieme predstaviť ako štvorcovú plochu s $n$ lavičkami a $n-1$ cestičkami spájajúcimi lavičky. Navyše, cestičky sú postavené tak, že z každej lavičky sa vieme po cestičkách dostať ku ktorejkoľvek inej lavičke (teda cestičky tvoria strom).

Hady väčšinou využívajú park tak, že sa rozležia po nejakej ceste: položia hlavu na jednu lavičku, chvost na druhú lavičku (alebo to môže byť had veľmi krátky a ležiaci len na jednej lavičke) a zvyšok teda na lavičky cestou medzi týmito dvoma lavičkami. Predtým nastavia Automat, aby oslnil niekoľko obdĺžnikov tak, aby oslnil práve tie lavičky kde had leží, ale nie tie prázdne.

Ako sa had ukladá na slnenie, s hrôzou si uvedomí, že si nepamätá, či nastavil Automat správne a bude slniť práve tie lavičky kde had leží. Pomôžte mu!

## Úloha

Existuje $n$ lavičiek pospájaných $n-1$ cestičkami. Lavičky ležia na štvorcovej ploche rozmerov $n\\times n$.

Postupne prichádza $q$ hadov. Pre každého hada poznáme lavičku, na ktorej má hlavu, lavičku, na ktorej má chvost a konfiguráciu Automatu. Konfigurácia Automatu pozostáva z niekoľko neprekrývajúcich sa obdĺžnikov, ktoré majú byť slnené. Pre každého hada zistite, či Automat nakonfiguroval správne, teda či obdĺžniky obsahujú práve tie lavičky, na ktorých leží had.

Hady využívajú park v dostatočných odstupoch po sebe, takže sa nemusíte trápiť, či sa hady neprekrývajú alebo neslnia iného hada. Žiadne predchádzajúce nastavenia Automatu neovplyvňujú nadchádzajúce slnenia.

## Formát vstupu a výstupu

Na prvom riadku vstupu je číslo $n$ -- počet lavičiek, $1 \\leq n \\leq 40,000$.

Na ďalších $n$ riadkoch sú súradnice lavičiek. Na $i$-tom z nich sú medzerami oddelené celé čísla $x_i$ a $y_i$ -- súradnice lavičky, $1 \\leq x_i, y_i \\leq n$.

Na ďalších $n-1$ riadkoch je popis cestičiek: pre každú cestičku na samostatnom riadku sú dve čísla oddelené medzerou, $a$ a $b$, $1 \\leq a, b \\leq n$, $a \\neq b$.

Ďalší riadok obsahuje číslo $q$ -- počet slniacich sa hadov, $1 \\leq q \\leq 100,000$.

Pre každého slniaceho sa hada dostanete najskôr tri čísla oddelené medzerou $a$, $b$ a $k$. $1 \\leq a, b \\leq n$ -- postupne čísla lavičky kde má had hlavu a lavičky, kde má chvost, a $1 \\leq k \\leq 3$ -- počet slnených obdĺžnikov. Nasledujúcich $k$ riadkov obsahuje popis obdĺžnikov: štyri medzerou oddelené čísla $x_1$, $y_1$, $x_2$ a $y_2$ -- súradnice najskôr ľavého dolného a potom pravého horného bodu obdĺžnika. $x_1\\leq x_2$ a $y_1 \\leq y_2$. Platí že bod $(x, y)$ je v tomto obdĺžniku práve ak $x_1 \\leq x \\leq x_2$ a $y_1 \\leq y \\leq y_2$. Je garantované, že obdĺžniky sa neprekrývajú. To znamená, že neexistuje žiadny bod $(x, y)$, ktorý je v dvoch rôznych obdĺžnikoch.

Pre každého hada vypíšte jeden riadok obsahujúci `OK`, ak je Automat správne nakonfigurovaný, a `NIE` ak niečo je zle.

## Hodnotenie

Je 8 sád vstupov.

- V prvých troch sadách platí $1 \\leq n, q \\leq 1000$
- V prvej, štvrtej a piatej sade navyše platí, že cestičky vždy spájajú lavičky s číslami $i$ a $i + 1$
- V piatej a šiestej sade navyše platí, že $k = 1$ pre každého hada
- V siedmej a ôsmej sade neplatia žiadne ďalšie obmedzenia

Neodporúčame pokúšať sa úlohu riešiť v pomalších jazykoch, ako napríklad Python.

## Príklad

```vstup
9
1 1		// Pozicie laviciek
1 5
3 4
4 1
4 2
5 1
1 6
2 6
1 7
1 2		// Cesticky
1 3
1 4
2 7
4 5
4 6
7 8
7 9
5
1 9 1
1 1 2 7
1 9 1
1 1 1 7
8 3 2
1 3 4 6
1 1 2 2
5 8 3
1 1 4 2
1 3 2 6
5 5 8 9
3 5 1
3 1 4 4
```

```vystup
NIE
OK
OK
OK
NIE
```

_V prvom prípade jediný obdĺžnik slní lavičku číslo 8, čo nechceme. V druhom_ _prípade je rovnaký had, ale zmenšený slnený obdĺžnik. Všimnite si v treťom_ _príklade, že obdĺžnik nemusí pokrývať súvislú časť hada (táto otázka by sa_ _nemohla objaviť v sade 7). V štvrtej otázke máme tretí obdĺžnik úplne zbytočne_, _-- neslní žiadne lavičky. Piaty had zabudol oslniť lavičku 1._

_Znaky `//` označujú komentáre, ktoré sa v skutočnom vstupe neobjavia. Slúžia len na objasnenie vstupu._
","# Inovatívny dážď

Možno ste si všimli, že táto úloha je nápadne podobná sedmičke z minulého kola. To veru nie je náhoda, vznikla pri písaní checkeru na tú sedmičku :) Tak sa pusťme do toho, veď napísať checker nemôže byť ťažšie ako originálne riešenie, či?^[a veru môže]

## Riešenie za tri body

Získať tri body nie je tak ťažké -- každý obdĺžnik overíme v lineárnom čase: najskôr si nájdeme cestu v strome medzi vrcholmi, ktoré nás zaujímajú (na to postačí napríklad obyčajné DFSko), a potom pre každý vrchol skontrolujeme, či leží, alebo neleží v nejakom obdĺžniku. Ak vrchol leží na ceste, ale neleží v žiadnom obdĺžniku, vypíšeme `NIE`, a rovnako vypíšeme `NIE`, ak niektorý vrchol neležiaci na ceste zas leží v nejakom obdĺžniku.

Takéto riešenie má čas $O(n)$ na query, takže celková časová zložitosť je $O(nq)$ a pamäťová $O(n)$.

## Koľko všetkých vrcholov leží v obdĺžniku?

Predstavme si najskôr zjednodušenú úlohu: daný je obdĺžnik, koľko vrcholov stromu v ňom leží? Keby sme mali miesto obldĺžnika iba 1D interval? Potom je úloha ľahko riešiteľná intervaláčom! A keď sa nad tým zamyslíme, tie obdĺžniky nie sú od intervalov až tak odlišné, takže tiež použijeme intervaláč, avšak 2D intervaláč!

### 2D intervalový strom

2D intervalový strom je intervalový strom, ktorý má v každom vrchole intervalový strom. Zdá sa to kus abstraktné?

Pozrime sa na obrázok:

\\obrazok{../prikl8/2d-intervalac.png}

Majme vrchol vo ""veľkom"" intervaláči, pokrývajúci interval $\[a, b)$. Povedzme, že tieto intervaláče pokrývajú x-ovú súradnicu. V tomto vrchole je druhý intervaláč rovnakej veľkosti. Ten si v intervale $\[c, d)$ pamätá hodnotu z políčok $\[a, b)\\times\[c, d)$.

My chceme súčtový intervaláč, z ktorého dostaneme počet vrcholov v obdĺžniku, takže si tento ""malý"" intervaláč pamätá počet vrcholov v obdĺžniku s rohmi $(a, c)$ a $(b, d)$.

Update jedného políčka v intervaláči nám zaberie $O(\\log^2 n)$ času, keďže najskôr potrebujeme updatnúť $O(\\log n)$ ""malých"" intervaláčov po ceste. Podobne, query zaberie $O(\\log^2 n)$ času.

Zdá sa však, že tento veľký 2D intervaláč zaberie veľa miesta: má $2n$ vrcholov, a ak je v každom jeden intervaláč zaberajúci $O(n)$ pamäte, potrebujeme až $O(n^2)$ pamäte! Už to začína znieť nerealizovateľne, avšak povšimnime si kontrast medzi pamäťovou a časovou zložitosťou: ak potrebujeme updatnúť $n$ vrcholov, použijeme $O(n\\log^2 n)$ času, ale až $O(n^2)$ pamäte! Teda veľa inicializovanej pamäte je vstutku zbytočnej. Čo s tým?

Môžeme použiť múdru, lenivú implementáciu intervaláča: každý vrchol (aj v ""malom"" intervaláči) má pointre (smerníky) na svoje dve deti (alebo NULL ak deti ešte neboli upravované). Ak príde query do vrchola a chcela by ísť do niektorého neexistujúceho dieťaťa, vrátime za daného potomka odpoveď nula. Ak príde update, ktorý by potreboval updatovať aj nejakého neexistujúceho potomka, potomka vytvoríme a pustíme update rekurzívne ďalej.

Takže vieme zaručiť, že nedostaneme asymptoticky horšiu pamäťovú zložitosť ako časovú zložitosť na update queries, teda $O(n\\log^2 n)$.

Už sa blížime k riešeniu otázky: *koľko všetkých vrcholov leží v obdĺžniku?*

Najskôr si predpripravíme takýto 2D intervalový strom a updatneme $+1$ na políčka, kde ležia vrcholy.

Následne, pre každý obdĺžnik, povedzme s rohmi v $(x_1, y_1)$ a $(x_2, y_2)$, zavoláme query: ako v bežnom intervaláčovom hľadaní ideme po ""veľkom"" intervaláči, kým nie je rozsah x-súradníc vrcholu (povedzme že $\[a, b)$) podmnožina intervalu x-súradníc nášho obdĺžnika (teda $\[x_1, x_2)$). V takomto vrchole pokračujeme naše hľadanie do ""menšieho"" intervaláča, kde následne nájdeme počet vrcholov so súradnicami $a \\leq x < b$ a $y_1 < y_2$.

Takto vieme rovnako ako v normálnom 1D intervaláči vyskladať celý obdĺžnik, a teda získame počet vrcholov ležiacich v obdĺžniku.

Avšak, nejako stále ignorujeme otázku, ako zistiť, či vrcholy na nejakej ceste ležia v obdĺžniku?

## Leží cesta v obdĺžniku?

Ďalší krok v ceste za riešením je zistenie, koľko vrcholov z nejakej cesty leží v obdĺžniku.

Nápad je nasledovný: Použijeme *perzistentný intervaláč*, a to konkrétne tak, že keď sa pozrieme na intervaláč v konkrétnom čase, bude to súčtový intervaláč vrcholov na nejakej ceste od koreňa do vrchola. Poďme sa na to pozrieť bližšie:

### Perzistentný 2D intervaláč

Cieľom je mať intervalový strom, v ktorom sa vieme pýtať query nielen do priestoru, ale aj v čase -- teda otázky typu: aký je súčet na tomto obdĺžniku pred $u$ updatmi?

Ako sa to dá robiť? Používame 2D intervaláč naprogramovaný pomocou pointerov. Vždy, keď sa vrchol má updatnuť, neuložíme zmenu priamo -- miesto toho vytvoríme nový, updatnutý vrchol.

Pre lepšiu ilustráciu použime obrázok:

\\obrazok{../prikl8/persistent-segment-tree.png}

Pri updatnutí tretieho listu (pozície 3) vytvoríme nový list (zelenou). Následne updatujeme jeho rodiča (keďže sa vytvorilo nové, updatnuté dieťa). Na staré dieťa nazabúdame, starý rodičovský vrchol ostáva ako je, ale vytvárame nový zelený vrchol, ktorému ako deti dáme aktuálne verzie synov (teda ľavý zelený list a pravý čierny list). Následne ideme zas hore, a vytvoríme nový koreň, ktorého pointer do pravého syna ukazuje práve na náš nový zelený vrchol.

Keďže my máme intervaláče v intervaláčoch, musíme ešte domyslieť technické detaily, čo ako, keď robíme tieto updaty. Napríklad ""malé"" intervaláče máme uložené vo vrcholoch väčšieho intervaláča ako pointre, a pri každom update dostaneme nový pointer, na nový koreň ""malého"" intervaláča, ktorý potom uložíme v novom vrchole.

A nie je toto nejaké pomalé? Veď predsa vytvárame veľa nových vecí!

Ale keď sa nad tým zamyslíme, nie je ich v skutočnosti až tak veľa. Pre každý update updatneme $O(\\log n)$ vrcholov vo veľkom intervaláči a pre každý tento vrchol updatneme ešte $O(\\log n)$ vrcholov v malom intervaláči. Takže dokopy dostaneme zložitosť $O(log^2n)$ času aj pamäte na jednu update query, čo je pomerne akceptovateľné.

### Použitie perzistentného intervaláča

Ako tento perzistentný intervaláč použiť?

Začneme s prázdnym 2D perzistentným intervaláčom. Zakoreňme si strom a prehľadávajme ho DFSkom. Kedykoľvek prídeme do nového vrcholu, pridajme $+1$ na jeho súradnicu v intervaláči. Kedykoľvek z vrcholu nadobro odídeme, pridajme $-1$ na jeho súradnicu v intervaláči.

Takto, keď sme v akomkoľvek vrchole, aktuálny stav intervaláča (ten po poslednom update) je, že sú $+1$ na všetkých predkoch vrchola (do tých sa už DFS dostalo, ale ešte ich neopustilo nadobro), ale zároveň, ak sme nejaký vrchol už navštívili, ale nie je predok, museli sme ho aj opustiť, takže na jeho súradnici je $+1-1 = 0$. Ak sme nejaký vrchol ešte nenavštívili, intervaláč si preň pamätá $0$ (resp. si nepamätá nič, keďže sme sa k updatovaniu súradnice ešte nedostali, ale pre to, ako intervaláč funguje, to je rovnaké, ako keby tam bola nula).

Takže keď chceme dostať stav, že jediné $+1$ sú na súradniciach vrcholov na ceste z koreňa do nejakého vrchola $v$, stačí si zobrať koreň intervaláča z updatu hneď po navštívení $v$.

Už sa blížime ku koncu, ostávajú technické detaily.

### A čo pre akúkoľvek cestu?

Akúkoľvek cestu v strome vieme rozdeliť na dve slížovité cesty od najbližšieho spoločného predka dole (pozri napríklad [kuchárku](https://www.ksp.sk/kucharka/lca/)).

Najbližšieho spoločného predka vieme nájsť napríklad v čase $O(1)$ s predpočítaním $O(n\\log n)$.

Keď máme takto rozdelené cesty, pre každú cestu získame počet vrcholov v obdĺžniku zvlásť, a keďže LCA leží na oboch, odrátame $1$, ak leží v obdĺžniku.

Ako to teda nájsť pre peknú slížovitú cestu z predka $p$ do potomka $v$? Vieme nájsť koľko vrcholov je v obdĺžniku pre cestu z koreňa do $v$. Chceli by sme odrátať tie vrcholy, ktoré ležia na ceste medzi koreňom a $p$. Ale to vieme, zistíme koľko je vrcholov v obdĺžniku na ceste medzi koreňom a rodičom $p$ (aby sme neodrátali $p$), a to odčítame od počtu vrcholov v obdĺžniku na ceste medzi koreňom a $v$. A hurá, dostali sme, čo sme chceli.

## A ako teda odpovedať na queries?

Poďme si to zrekapitulovať.

Dostaneme query vo forme dvoch vrcholov, $a$ a $b$, a zopár ($k$) obdĺžnikov. Obdĺžniky sa zaručene neprekrývajú, takže máme o jeden kameň na srdci menej.

Zistime najskôr, koľko je všetkých vrcholov v strome ležiacich v obdĺžnikoch (to vieme, obyčajným 2D intervaláčom) v $O(k\\log^2 n)$ čase.

Zistime, koľko vrcholov na ceste medzi $a$ a $b$ leží v obdĺžnikoch. Tiež to vieme zistiť v čase $O(k\\log^2 n)$.

Pochopiteľne, tieto dva údaje sa musia rovnať, inak kričíme `NIE` (inak by nejaký vrchol mimo cesty ležal v obdĺžniku).

Ak sa rovnajú, to stále nie je automatické áno: môže sa stať, že v obdĺžnikoch leží menej vrcholov z cesty, ako má. Ako toto overiť? Jednoducho, stačí nám navyše zistiť počet vrcholov na ceste a porovnať ho s počtom vrcholov z cesty ležiacich v obdĺžnikoch.

Počet vrcholov na ceste sa dá zistiť jednoducho: zapamätáme si výšku každého vrchola, a potom dĺžka cesty je:

$$v_a + v_b - 2v\_\\text{lca}$$

Kde $v_a$ je výška $a$, $v_b$ je výška $b$ a $v\_\\text{lca}$ je výška najbližšieho spoločného predka. Tak, a toto nám dáva online odpoveď na query v $O(k\\log^2 n)$ čase. Na predpočítanie sme použili čas $O(n\\log^2 n)$ (na vybudovanie intervaláča a predpočítanie LCA, a teda celková časová zložitosť je $O((n + q k\_\\text{max}) \\log^2 n)$ a pamäťová $O(n\\log^2 n)$.
",10
8ee8577bf5f77d14,ksp,"# Rolka výterov

""Ojojoooj, kedy už Dano pripraví tú úlohu? Dalo by sa? Bolo by možné? Mohlo by byť umožnené?!"", hovoril si Adam počas vykonávania potreby na svojej záhradnej latríne, ktorú postavil ešte jeho starý otec. Ako si to tak hovoril, a rozčuľoval sa, podvedome si pripravoval toaletný papier. Rôzne ho skladal a podsúval, až mu ostal iba jeden $n$-vrstvový obdĺžniček. Začal teda rozmýšľať, akými rôznymi spôsobmi sa dá $n$-kúskový toaletný papier poprekladať. Adam má svojich favoritov, no nevie, či sa vôbec dajú vytvoriť. Zmyslel si teda, že Danovi napíše a povie mu, aby ako úlohu do KSP pripravil toto.

## Úloha

Adam vám povie niekoľko permutácií obdĺžničkov toaletného papiera. O každej z nich by chcel vedieť, či sa skutočne dá získať nejakým poprekladaním. Adamov papier je taký tenký, že jeho hrúbku môžeme zanedbávať.

Prekladanie a podsúvanie funguje nasledovne. Adam rozvinie celý papier na zem a jeho obdĺžničky si očísluje od 1 do $n$. Prekladať môže iba po perforáciách. Následne vždy môže priložiť ľubovoľný obdĺžniček na iný obdĺžniček zhora alebo zdola, ak mu nebránia iné obdĺžničky. Môže teda ľubovoľne prekladať. Ak si stále nie ste istí, či môže prekladať nejakým konkrétnym spôsobom, pravdepodobne ním prekladať môže.

## Formát vstupu

Na prvom riadku vstupu je číslo $t$ -- počet permutácií, na ktoré sa vás Adam opýta. Platí $1 \\leq t \\leq 100$. Nasleduje $t$ dvojíc riadkov. Na prvom riadku z $i$-tej dvojice je číslo $n_i$ -- počet obdĺžničkov celého toaletného papiera. Na druhom riadku z $i$-tej dvojice je $n_i$ medzerou oddelených čísiel predstavujúcich permutáciu, na ktorú sa Adam pýta. Prvé číslo v permutácii je číslo obdĺžnička navrchu, posledné predstavuje číslo spodného obdĺžnička. Platí $1 \\leq n_i \\leq 10,000$.

## Formát výstupu

Pre $i$-tu permutáciu vypíšte na samostatnom riadku `Vyter mozny`, ak je možné poprekladať toaletný papier do danej permutácie. V opačnom prípade na tomto riadku vypíšte `Vyter nemozny`.

## Príklad

```vstup
2
5
1 4 5 3 2
5
1 5 3 2 4
```

```vystup
Vyter mozny
Vyter nemozny
```
","# Rolka výterov

Na prvý pohľad môže úloha vyzerať zložito. V tejto situácii zvykne pomôcť urobiť čo najviac pozorovaní a z nich potom prísť na riešenie. Nuž, poďme teda skúsiť spraviť nejaké pozorovania.

Prvým zjavným faktom je, že dielik $i$ má vedľa seba dieliky $i-1$ a $i + 1$. Ďalším pozorovaním je, že keď toaleťák nejak skladáme, tak dieliky na párnych pozíciách pôjdu zľava doprava a dieliky na nepárnych pozíciách pôjcu sprava doľava, alebo naopak.

## Pomalé riešenie

Našim cieľom je zistiť, či toaleťák niekde neprechádza sám sebou. Toaleťák sa pretína sám so sebou práve vtedy, keď medzi dielikom $i$ a $i+1$ leží nejaké $j$ také, že dielik $j-1$ alebo $j+1$ nie je v permutácii medzi $i$ a $i+1$. Samozrejme, zároveň musí platiť, že $i$ a $j$ majú rovnakú paritu.

Ak majú $i$ a $j$ rovnakú paritu, znamená to, že zhyb medzi $i$ a $i+1$ je na rovnakej strane ako zhyb medzi $j$ a $j+1$. Preto ak by boli dieliky v permutácii v poradí $i$, $j$, $i+1$, $j+1$, zjavne by to znamenalo, že zhyb medzi $i$ a $i+1$ pretína zhyb medzi $j$ a $j+1$.

Stačí nám teda overiť, či naša podmienka pretínania neplatí pre žiadne $i$, $j$ rovnakej parity. Toto riešenie bude mať v závislosti od implementácie časovú zložitosť $O(n^2)$ až $O(n^3)$ na permutáciu a pamäťovú zložitosť $O(n)$.

## Vzorové riešenie

Permutáciu budeme konštruovať zhora nadol. Nech je najvrchnejší dielik $i$. Z tohto dieliku nám doľava visí dielik $i-1$ a doprava dielik $i+1$. Ak je ďalším dielikom v permutácii $i-1$, tak môžeme jednoducho podložiť visiaci dielik $i-1$ pod $i$. Dieliky, ktoré visia pod $i-1$ teraz už budú visieť na pravej strane (kde už budú 2 visiace vrstvy). Analogicky by sme vedeli vyriešiť aj prípad, kde by bol ďalším očakávaným dielikom $i+1$.

Čo ale máme spraviť, ak je ďalším očakávaným dielikom niečo iné, napríklad $j$? Nuž, na niektorej strane nám tento dielik visí (nie navrchu, ale niekde nižšie). Podložíme ho teda pod posledný pridaný dielik. Ak je $j$ párne (resp. nepárne, podľa toho ako sme začali), tak po podložení na ľavej strane začne visieť $j-1$ a na pravej $j+1$.

Vždy teda máme na ľavej aj na pravej strane niekoľko visiacich vrstiev. V každom kroku sa môžeme zbaviť iba jednej z vnútorných vrstiev. Tu už možno vidno, že na reprezentáciu toho, čo visí naľavo a napravo vieme použiť dva stacky.

Algoritmus následne bude vyzerať tak, že prejdeme celú permutáciu a každý jej dielik samostatne spracujeme. Vždy, keď spracovávame dielik, pozrieme sa, či zrovna nie je na vrchu niektorého stacku. Ak je, môžeme ho zo stacku odstrániť. Ak na vrchu stacku nie je, tak na jednotlivé stacky pridáme jeho susedov (podľa parity).

Časová aj pamäťová zložitosť tohto riešenia je $O(n)$ na permutáciu.
",5
830b3212b89b0952,ksp,"# Ostrovný maják

Neďaleko kalifornského pobrežia je ostrov. Má svoje meno, ale miestni mu hovoria Ostrov. Na ostrove je maják. V majáku žije jeho správca. Má svoje meno, ale miestni mu hovoria Maják.

Maják z majáku dovidí ľubovoľným smerom do tej istej vzdialenosti. Môže teda pozorovať, čo sa deje vo vnútri konkrétneho kruhu, ktorého stredom je samotný maják. Všade v tomto kruhu okrem samotného majáku je voda.

Kruhom sa raz za čas preplaví nejaká loď. Všetky lode sa plavia po priamke (z ktorej Maják vidí len úsečku). Maják si do databázy poctivo zapisoval, kedy, odkiaľ a kam sa ktorá loď plavila.

Občas sa stane, že sa okolo majáku plavia dve lode naraz. A v tých najvzrušujúcejších chvíľach to dokonca chvíľu vyzerá na kolíziu. Vtedy jedna z lodí musí spomaliť alebo zrýchliť. A Maják je celý preč od radosti, že sa konečne niečo zaujímavé deje.

Po poslednej oslave Majákovych narodenín však s kamarátmi blbli, menili heslá a z databázy zmazali stĺpec s časmi. Na nové heslá si ešte Maják ráno horko-ťažko spomenul, časy do databázy mu už ale nik nevráti.

## Úloha

Na obvode kruhu, ktorý vidí Maják z majáku, rovnomerne rozmiestnime $r$ bodov (kde $r$ je nepárne). Idúc po obvode kruhu body očíslujeme od 0 po $r-1$. Lodí sa doteraz okolo plavilo $n$, tie očíslujeme od 0 po $n-1$. O poradí lodí nič nevieme -- napr. loď 3 mohla prejsť okolo skôr ako loď 47, neskôr ako loď 47, alebo zhruba v tom istom čase. Pre každé $i$ platí, že loď $i$ Maják prvýkrát uvidel v bode $z_i$ a naposledy v bode $k_i$.

Váš program dostane na vstupe vyššie popísané údaje. Z nich by mal vypočítať počet dvojíc lodí $i\<j$ takých, že je možné, že sa lode $i$ a $j$ museli jedna druhej prispôsobiť aby zabránili kolízii.^\[Povšimnite si, že každú dvojicu treba posudzovať zvlášť. *Nepýtame* sa teda na to, koľko najviac takých dvojíc mohlo *postupne* nastať. Rozmyslite si sami, či a prečo je v tom rozdiel.\] Pochopiteľne, lode považujte pri riešení úlohy za body.

## Formát vstupu

V prvom riadku je číslo $n$ udávajúce počet lodí. V druhom riadku je číslo $r$ udávajúce počet bodov na obvode kruhu (pričom $r$ je nepárne číslo^[To aby Majákovi nechodili lode cez maják.] väčšie ako $2n$).

Nasleduje $n$ riadkov, každý z nich popisuje jednu loď: obsahuje jej čísla $z_i$ a $k_i$. Platí $0\\leq z_i\<r$ a $0\\leq k_i\<r$. Navyše platí, že všetky hodnoty $z_i$ a $k_i$ sú navzájom rôzne. (Vstup teda obsahuje $2n$ rôznych súradníc.)

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno celé číslo: počet dvojíc lodí, ktoré sa mohli vo vnútri kruhu stretnúť.

## Hodnotenie

Je päť sád vstupov.

Maximálne počty lodí v týchto sadách sú 20, $75,000$, $200,000$, $75,000$ a $200,000$.

Maximálne hodnoty $r$ v týchto sadách sú 1000, $10^6$, $10^{18}$, $10^{18}$ a $10^{18}$.

Navyše v tretej sade platí, že všetky vstupy sú generované rovnomerne náhodne (každé z čísel $z_i$ a $k_i$ je zvolené náhodne spomedzi všetkých ešte nepoužitých).

## Príklady

```vstup
3
101
10 20
15 25
70 60
```

```vystup
1
```

_Lode 0 a 1 sa mohli stretnúť, ak sa plavili okolo majáku s Majákom zhruba v tom istom čase._

```vstup
3
101
97 3
6 94
91 10
```

```vystup
0
```

```vstup
4
101
0 50
25 75
20 80
82 22
```

```vystup
4
```
","# Ostrovný maják

Zadanie úlohy bolo jednoduché: máme kruh a ním prechádzajúce priamky, spočítajte dvojice priamiek, ktoré sa vo vnútri kruhu križujú. Celé je to ešte zjednodušené tým, že priesečníky priamiek s kruhom sú všetky navzájom rôzne.

Za túto úlohu je hanba mať nulu, pretože riešenie hrubou silou -- presnejšie, v čase $\\Theta(n^2)$ -- je veľmi jednoduché. Pre každú dvojicu priamiek vieme v konštantnom čase spočítať, či sa križujú alebo nie: Ak máme priamku spájajúcu body $a$ a $b$, pričom $a\<b$, a druhú priamku spájajúcu body $c$ a $d$, tak sa križujú vo vnútri kruhu vtedy a len vtedy, ak práve jedno z čísel $c$ a $d$ leží v intervale $(a,b)$. Rozmyslite si to pri pohľade na nasledujúci obrázok:

Veselšie to samozrejme bude akonáhle sa pokúsime o riešenie s lepšou časovou zložitosťou.

Základná myšlienka nášho riešenia pritom nebude vôbec zložitá. Mnohé problémy na kruhu sa dajú previesť na problémy na priamke, a tie sa väčšinou dajú riešiť jednoduchšie. Presne o to sa pokúsime aj v našom vzorovom riešení.

Predstavme si, že sme zobrali nožnice a prestrihli kruh medzi ľubovoľnými dvomi z bodov zadaných na vstupe -- napríklad medzi bodmi s číslom $0$ a $r$. (Na našom obrázku teda medzi bodmi 0 a 100.) Kruh teraz chytíme za oba konce a vystrieme ho na úsečku. Pre kruh z príkladu vyššie by sme takto dostali nasledovnú úsečku:

Každá z pôvodných priamok (presnejšie, tetív našej kružnice) sa teraz zmenila na nejaký interval na našej úsečke. Dôležité je uvedomiť si, že tieto intervaly naďalej nesú všetku informáciu potrebnú na vyriešenie úlohy. (Totiž nijak sme nezmenili čísla zo vstupu, len sa na ne inak pozeráme.) A navyše túto informáciu z nich vieme ľahko získať:

- Dvojica tetív zodpovedajúca disjunktným intervalom sa nepretína.
- Dvojica tetív zodpovedajúca intervalom z ktorých je jeden celý vnútri druhého sa nepretína.
- Všetky ostatné dvojice tetív sa pretínajú.

Inými slovami, stačí nám zistiť počet dvojíc intervalov, ktoré sa len čiastočne prekrývajú: teda idúc zľava doprava najskôr začne prvý interval, potom začne druhý, potom skončí prvý a až po ňom skončí druhý interval.

Tento počet dvojíc vieme ľahko určiť zametaním. Začneme tým, že si všetky začiatky a konce našich intervalov uložíme do jedného poľa a toto pole usporiadame. V tomto poradí ich teraz budeme spracúvať.

A čo sa bude diať počas tohto spracúvania? Budeme si (v nejakej šikovnej podobe, ktorú upresníme neskôr) pamätať, ktoré intervaly sú momentálne otvorené -- teda množinu intervalov, ktorých začiatok sme už spracovali ale koniec ešte nie. Vždy, keď spracujeme ďalší začiatok intervalu, pribudne nám nejaký interval do tejto množiny, a vždy, keď spracujeme koniec, tak nám z nej jeden interval ubudne.

Navyše vždy, keď spracúvame koniec nejakého intervalu, započítame nejaké dvojice čiastočne sa prekrývajúcich intervalov -- tie, v ktorých je interval, ktorý práve skončil, ""prvý"". Koľko je takých dvojíc? ""Druhým"" intervalom v každej takejto dvojici je určite niektorý z intervalov, ktoré sú práve otvorené. Treba si ale uvedomiť, že my nechceme úplne všetky takéto intervaly -- len tie z nich, ktoré začali neskôr ako náš interval, ktorého koniec práve spracúvame.

Potrebujeme teda vedieť efektívne odpovedať na otázky nasledujúceho typu: ""Koľko spomedzi intervalov ktoré sú práve otvorené, má začiatok medzi $x$ a $y$?"" Toto vieme spraviť veľa rôznymi spôsobmi. Napríklad môžeme použiť vyvažovaný binárny vyhľadávací strom, v ktorého vrcholoch si pamätáme začiatky aktuálne otvorených intervalov, a navyše informáciu o tom, koľko vrcholov stromu sa pod ním nachádza. Pomocou takejto dátovej štruktúry vieme ľubovoľnú otázku vyššie uvedeného typu zodpovedať v logaritmickom čase.

Existujú však aj stručnejšie možnosti implementácie. K tým nám môže pomôcť napríklad to, že si uvedomíme, že na konkrétnych súradniciach začiatkov a koncov našich intervalov vôbec nezáleží. Keď už ich raz usporiadame, riešenie sa vôbec nezmení, ak ich následne prečíslujeme na $1$ až $2n$. No a udržiavať si podmnožinu množiny ${1,\\dots,2n}$ je už výrazne ľahšie ako robiť to vo všeobecnosti. Môžeme na to použiť napríklad intervalový strom (ľudovo nazývaný intervaláč) alebo Fenwickov strom (u nás ľudovo nazývaný fínsky strom, pozri \\url{http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=binaryIndexedTrees}). Ten druhý používame aj v našej nižšie uvedenej implementácii.

Všetky vyššie popísané riešenia majú zjavne časovú zložitosť $\\Theta(n\\log n)$ a pamäťovú $\\Theta(n)$.

## Bonus na záver

Štandardný `set` v C++ veci potrebné na riešenie tejto úlohy robiť nevie. Konkrétne, nevie nám odpovedať na otázku, koľko spomedzi v ňom uložených prvkov leží v danom intervale. Netreba však hneď implementovať vlastný strom. V novších verziách g++ kompilátora nájdeme aj takzvané ""policy-based data structures"" a medzi nimi aj stromy, ktoré potrebnú fičúriu majú. A s nimi je už riešenie našej úlohy hračkou.

(Tento strom podporuje aj operáciu inverznú k `order_of_key`: metóda `find_by_order(x)` vráti iterátor na $x$-tý najmenší prvok, číslujúc od nuly. Obe operácie bežia v čase logaritmickom od počtu uložených prvkov.)

## Bonus za záverom

Ak by niekedy došlo na najhoršie a bolo naozaj treba od základov implementovať vlastný vyvažovaný strom, dôležité je dodržať dve zásady:

- nepodľahnúť panike
- vedieť, aký strom implementovať

Hrdinom dnešných dní je treap (\\url{http://en.wikipedia.org/wiki/Treap}): strom, ktorý na to, aby bol *s veľkou pravdepodobnosťou* vyvážený, používa náhodné čísla. Keď porozumiete tomu, ako treap funguje, je jeho implementácia (spravená správnym spôsobom) až prekvapivo stručná a takmer bez špeciálnych prípadov. Trik na dobrú implementáciu je nasledovný:

- jediným rekurzívnym prechodom zhora dole vieme treap rozbiť na dva menšie (`split`)
- taktiež jediným prechodom zhora dole vieme tie dva menšie spojiť späť (`merge`)
- vkladanie prvku aj výber prvku vieme triviálne realizovať pomocou `split` a `merge`
- čokoľvek ďalšie dorobíme rovnako ako by sme to robili v nevyvažovanom strome

Tu je v celej jej kráse implementácia, ktorá sa dá priamo použiť v predchádzajúcom riešení namiesto `ordered_tree`.
",10
c637052ef6770e2e,ksp,"# Dlhodobý Krtkov plán

Neviem, či si to viete predstaviť, ale život takéto Krtka vôbec nie je jednoduchý. Krtko má viacero úloh, ktoré musí spraviť. Napr. vykopať tunel, rozryť nejakú záhradu, natočiť nové diely Krtka, pripraviť niekoľko sústredení a v neposlednom rade napísať bakalárku. Nie je to také jednoduché, ale keďže Krtko sa snaží pristupovať ku všetkým úlohám férovo, priradil každej úlohe nejakú prioritu. Navyše chce, aby pre každé dve úlohy platilo, že dôležitej z nich venuje viac času. Krtka teraz zaujíma koľkými spôsobmi vie rozdeliť svoj čas medzi jeho úlohy. Keďže táto úloha nie je medzi Krtkovými, musíte ju vyriešiť vy.

## Úloha

Krtko má $n$ úloh a $m$ času. Tento čas chce (celý) rozdeliť medzi tieto úlohy tak, aby dôležitejšia úloha dostala viac času. Žiadne dve úlohy nie sú rovnako dôležité. Vašou úlohou je vypočítať, koľkými spôsobmi sa to dá urobiť. Keďže Krtkovi sa z veľkých čísel točí hlava, vypíšte toto číslo modulo $10^9+7$ ($1,000,000,007$).

## Formát vstupu

Na jedinom riadku vstupu sú čísla $n$ a $m$ - počet úloh, ktoré má Krtko, a čas, ktorý chce celý Krtko úlohám venovať.

## Formát výstupu

Vypíšte jedno číslo - počet spôsobov, koľkými krtko dokáže rozdeliť svoj čas medzi zadané úlohy. Keďže toto číslo môže byť veľmi veľké, vypíšte ho modulo $10^9+7$.

## Hodnotenie

V každej sade platí, že $0 \\leq n \\leq 100$, $1 \\leq m < 50,000$

## Príklady

```vstup
2 4
```

```vystup
2
```

*Buď rozdelí čas medzi úlohy ako 0 a 4, alebo ako 1 a 3. Menej dôležitej úlohe nemôže venovať 2 alebo viac času, lebo potom by dôležitejšej úlohe nemohol venovať viac času ako menej dôležitej (teda viac ako 2).*
","# Dlhodobý Krtkov plán {bodypopis=12 bodyprogram=8}

Prvá vec, ktorú si môžeme uvedomiť, je koľko najmenej času potrebujeme na $n$ úloh. Najmenej času, ktorý vieme venovať najmenej dôležitej úlohe je $0$. Potom najmenej času ktorý vieme venovať druhej najmenej dôležitej úlohe je 1. Vo všeobecnosti vieme povedať, že ak máme $i$-tu najmenej dôležitú úlohu, musíme jej venovať aspoň $i-1$ času. Každej z i-1 menej dôležitých úloh musíme totiž venovať iný čas. $n$ úlohám teda musíme venovať aspoň $0 + 1 + 2 + ... + (n-1) = \\frac{(n-1)\\cdot n}{2}$

Keď už vieme koľko času najmenej musíme venovať ktorej úlohe, môžeme problém zo zadania mierne upraviť. Zvyšný čas, teda $m - \\frac{(n-1)\\cdot n}{2}$ chceme rozdeliť medzi $n$ úloh tak, aby dôležitejšia dostala viac **alebo rovnako** ako menej dôležitá. To môže pôsobiť ako zbytočné, no povedie to ku kúsok jednoduchšej implementácií.

## Riešenie

Túto úlohu budeme riešiť pomocou dynamického programovania. Cheme zistiť, ako sa dá rozdeliť čas medzi nejaké úlohy. Prvým riešením by mohlo byť, že vyskúšame všetky možnosti koľko času môžeme venovať najmenej dôležitej úlohe, a zvyšok je podobná otázka - o jednu úlohu menej a o nejaký čas menej. Možeme si všimnúť, že ak sa rozhodneme venovať najmenej dôležitej úlohe $k$ času, musíme aj každej ďaľšej úlohe venovať aspoň $k$ času. Počet možností teda môžeme spočítať ako $f(u, c) = \\sum f(u-1,\\ c-u\\cdot k)$, kde $f(u, c)$ je počet možností ako vieme rozdeliť medzi $u$ úloh $c$ času. Samozrejme využijeme memoizáciu, aby sme jednu hodnotu nepočítali viackrát.

Takéto riešenie prejde všetky možnosti ako vieme rozdeliť čas medzi úlohy. Pozrime sa na zložitosti. Máme $n \\cdot m$ stavov, každý vieme spočítať v $O(m)$. Výsledná zložitosť teda bude $O(nm^2)$.

## Vzorové riešenie

V predošlom riešení sme sa vždy rozhodli koľko presne času budeme venovať jednej úlohe, čo viedlo k tomu, že jeden stav sme museli počítať až v zložitosti $O(m)$. V tomto riešení to vylepšíme. Vždy sa rozhodneme, či najmenej dôležitej úlohe ešte budeme pridávať čas, alebo už nie. Presnejšie sa rozhodneme či pridáme ešte $1$ čas. Opakovaným pridávaním $1$ času vieme pridať ľubovoľne veľa. Ak čas pridáme, musíme ho pridať aj všetkým ostatným úlohám, podobne ako v minulom riešení. Bude teda platiť, že $f(u, c) = f(u,\\ c-u) + f(u-1, c)$. Počet rôznych stavov, ktoré potrebujeme spočítať sa nezmenil, ale každý už vieme vypočítať v $O(1)$. Preto celková časová zložitosť našeho algoritmu bude $O(nm)$ a pamäťová $O(nm)$.

Táto pamäťová zložitosť sa dá ešte zlepšiť. Predstavme si, že máme iteratívne naprogramovaný náš algoritmus. Teda máme dvojrozmerné pole, a postupne ho vypĺňame hodnotami $f(u, c)$. Všimnime si, že keď dopĺňame riadok pre nejaké $u$, nepotrebujeme si pamätať celú tabuľku, ale stačí nám posledný a aktuálny riadok - teda tie, pre $u$ a $u-1$. Takto vieme zmenšiť pamäťovú zložitosť na $O(m)$.
",8
2ef468b17e3a77b6,ksp,"﻿# Láska kvitne v júni

Záhradník rád záhradníčil, pestoval ovocie a zeleninu a užíval si pokojný život. Táto idylka však skončila, keď jedného dňa na Záhradníkovu hlavu vyskočil Krtko a začal Záhradníka ovládať. Záhradník sa už viac nestaral o baklažány, kaleráby, jablká, ananásy či petržleny a namiesto toho kopal krtince a organizoval sústredenia. A hoci už nemal viac v živote pokoja, aspoň robil radosť mnohým deťom, ktoré sa na sústredenia veľmi tešili.

Ani táto radosť však netrvala dlho, lebo Záhradníkove schopnosti sa rozhodla využiť aj hlavná kubrická ploštica. Tej bolo smutno, že ploštice kvôli svojej zlej reputácii medzi ľuďmi klesajú na počtoch a rozhodla sa proti tomuto trendu bojovať a pre ostatné ploštice zorganizovať speed dating. Vyskočila na hlavu Krtkovi, ktorý sedel na hlave Záhradníkovi a začala ho ovládať, aby jej speed dating pripravil.

Speed dating ploštíc prebieha následovne. Máme $n$ ploštíc a každá dvojica z nich pôjde na rande na večeru. Večerať budú účastníkov sústredenia a každá ploštica si na svojho účastníka počká v jednej z dvoch postelí na izbe. No každá ploštica má rada iný typ posteľných obliečok a chce byť iba v posteli s tými obliečkami. Tie bude Záhradník ovládaný Krtkom ovladaný kubrickou plošticou medzi jednotlivými rande v prípade potreby prezliekať. Toto sťažuje fakt, že postele v izbe sú rôzne veľké, čo plošticiam síce neprekáža, no znamená to, že treba kúpiť iný rozmer obliečky na jednu posteľ, a iný na druhú.

Kubrická ploštica potrebuje nakázať Krtkovi, nech nakáže Záhradníkovi koľko kusov obliečok treba nakúpiť, nech každá dvojica z jej $n$ ploštíc môže spolu ísť na rande.

## Úloha

Pre daný počet ploštíc a ich preferencie zistite minimálny počet obliečok, ktoré treba nakúpiť na sústredenie, aby každá dvojica ploštíc mohla ísť spolu na rande, každá do inej postele s jej obľúbeným typom obliečok. Ak na speed dating príde iba jedna ploštica, pôjde sa navečerať osamote (a spoznať sa sama so sebou).

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $k$ ($1 \\leq n,k \\leq 2 \\cdot 10^5$) udávajúce počet ploštíc a počet rôznych typov obliečok.

V druhom riadku následuje $n$ čísel, $p_1, p_2, \\cdots, p_n$ kde $p_i$ je preferovaný typ obliečok $i$-tej ploštice.

Sú dve sady. Pre prvú sadu platí, že $p_i$ sa rovná $i$.

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo - počet kusov obliečok, ktoré treba nakúpiť.

## Príklady

```vstup
5 5
1 2 3 4 5
```

```vystup
8
```

*Aj keď každú obliečku chce iba jedna ploštica, aj tak musíme z niektorých typov kúpiť dva kusy. Keby sme napríklad kúpili obliečku typu 4 a 5 len v rozmeroch prvej postele, keď pôjdu ploštice 4 a 5 na rande, nebudeme vedieť obliecť druhú posteľ tak, aby ju niektorá z nich chcela. Rozmyslite si, ktoré obliečky stačí kúpiť pre obe postele, aby nám ich stačilo dokopy 8 kusov.*

```vstup
6 4
1 2 3 2 3 2
```

```vystup
5
```

*Záhradník potrebuje kúpiť obliečky typu 2 a 3 pre obe postele, a obliečku typu 1 len pre jeden rozmer. Bez ohľadu na to, ktoré dve ploštice pôjdu na rande, budeme každej vedieť obliecť posteľ do jej obľúbenej obliečky.*
","# Láska kvitne v júni

Zádrhel tejto úlohy spočíva v tom, že dve postele na izbe potrebujú obliečky rôznych veľkostí. To znamená, že v niektorých prípadoch budeme musieť kúpiť dva kusy obliečok rovnakého typu (ale rôzných veľkostí). Keď sa rozhodujeme, z ktorých typov obliečok potrebujeme dva kusy, potrebujeme zvážiť niekoľko prípadov.

## Každá ploštica preferuje iný typ obliečok

Tento prípad zodpovedá prvej sade, kde platí, že preferencia ploštice $p_i$ sa rovná $i$.

V tomto prípade, keď $n$ sa rovná 1, vieme, že ploštica pôjde na rande sama a je jedno, akú veľkosť obliečok kúpime, stačiť bude jeden kus.

Ak $n$ sa rovná 2, tak vieme, že každá z ploštíc pôjde na rande presne raz, a to naraz s druhou plošticou z páru. Tým pádom pre každú plošticu potrebujeme presne jedny obliečky (rôznej veľkosti) a výsledok, ktorý hľadáme je 2.

Komplikovanejšie to začína byť v prípade, že máme viac, ako dve ploštice. Bez ujmy na všeobecnosti si môžeme povedať, že prvá z $n$ ploštíc sa bude vždy nachádzať na posteli číslo 1, a tak pre ňu zaobstaráme iba jednu veľkosť obliečok. Pri druhej ploštici si podobne môžeme povedať, že sa vždy bude nachádzať na posteli číslo 2, a tak pre ňu stačí tiež zaobstarať iba jednu veľkosť obliečok. Zatiaľ nám v tom nič nebráni, keďže tieto ploštice vedia spokojne ísť spolu na rande. No akonáhle by sme chceli povedať, že tretia ploštica bude vždy na posteli číslo 1, zistíme, že nebude vedieť ísť na rande s prvou plošticou. Takisto, ak povieme, že bude vždy na posteli číslo 2, nebude môcť ísť na rande s druhou plošticou.

Vieme teda povedať, že pre tretiu plošticu musíme kúpiť obe veľkosti obliečok, aby mohla ísť na rande s prvou aj s druhou plošticou. Toto platí aj pre všetky zvyšné ploštice. Tým pádom máme 2 ploštice (prvú a druhú), pre ktoré kúpime jeden kus obliečok a $n-2$ ploštíc, pre ktoré kupime dve obliečky. Celkový počet obliečok, ktorý kúpime je teda $2 * (n - 2) + 2$, po úprave $2n - 2$.

## Ploštice môžu preferovať rovnaký typ obliečok

V druhej sade sa stretneme so situáciou, kde rôzne ploštice môžu preferovať rovnaký typ obliečok. Tu je dôležité si uvedomiť, že ak existujú aspoň dve ploštice, ktoré majú rady rovnaký typ, potrebujeme presne dva kusy tohoto typu, aby dve ploštice s touto preferenciou mohli ísť spolu na rande. Taktiež nepotrebujeme viac ako 2 kusy, každý na jednu posteľ, keďže jeden kus obliečok môže byť použitý viackrát.

Poďme sa pozrieť len na tie typy obliečok, ktoré sú preferované len jednou plošticou. Zmenila sa nám situácia tým, že sme niektoré obliečky rovno kúpili dva krát? Nie, keďže bezohľadu na to, ako pokúpime tie obliečky, ktoré preferuje len jedna ploštica, budú vedieť ísť randiť s plošticami, ktorým sme práve kúpili obliečky na obe postele.

Obliečky, ktoré preferuje práve jedna ploštica, teda môžeme ponakupovať úplne nezávisle a spravíme to tak, ako sme si vysvetlili v predošlej sekcií. Čiže z týchto obliečok môžeme zobrať maximálne dva rôzne typy, z ktorých nám stačí kúpiť jeden kus a pre zvyšné typy platí, že musíme kúpiť dva kusy.

Dokázali sme si, že opäť môžeme mať maximálne dva typy obliečok, z ktorých kúpime jeden kus. A podmienkou je, že tieto typy musia byť preferované len jendou plošticou. Otázkou je, ako zistíme, či takéto typy existujú a koľko ich je.

Potrebujeme použiť dátovú štruktúru, ktorá nám pre každý typ obliečok povie, koľko ploštíc danú obliečku preferuje.

Jednou takouto dátovou štruktúrou je vector (v pythone list) veľkosti $k$, v ktorom každá pozícia prezentuje typ obliečky a hodnota na danej pozícii reprezentuje počet ploštíc, ktoré danú obliečku preferujú. Pri načítavaní sa pozrieme na preferenciu konkrétnej ploštice a navýšime zodpovedajúcu hodnotu vo vectore o 1. Na konci celý vector prejdeme a v osobitnej premennej $raz$ si zapamätáme, koľko hodnôt vo vectore sa rovnalo 1 a v premennej $viac$ koľko ich bolo aspoň 2.

Každú z $viac$ typov obliečky budeme musieť kúpiť dva krát a obliečok z $raz$ typov kúpime podľa predošlého vzorca: $raz$ kusov, ak sú najviac 2, inak $2raz - 2$.

Časová zložitosť načítania vstupu a prejdenia listu je $O(n + ǩ)$ a pamäťová je $O(k)$, keďže si vytvárame pole veľkosti $k$.

## Použitie mapy

Riešenie, ktoré sme si predstavili, môže byť ešte efektívnejšie, ak použijeme dátovú štruktúru map (dictionary v pythone). Táto štruktúra nám dovoľuje držať v pamäti a prechádzať hodnoty zodpovedajúce len tým typom obliečok, čo sú preferované aspoň jednou plošticou. Ak napríklad máme veľké $k$ ($10^9$), ale všetky ploštice preferujú ten istý typ obliečok, v mape si budeme pamätať údaje práve o tomto jednom type.

Časová a pamäťová zložitosť sa nám teda zhodí na $O(n)$. Nebolo nám to však pri daných obmedzeniach treba.
",2
c5aa11a40d4850da,ksp,"# Obmenené zátvorky

Malý Marcelko je introvert, a tak si v škôlke spestruje dni tým, že len veľmi z diaľky pozoruje svojich spolužiakov, keď si kreslia voskovkami. Keďže sa zatiaľ naučil počítať iba do $4$, pozoruje, čo sa deje počas kreslenia s týmito $4$ druhmi voskoviek -- guľatou, kučeravou, špicatou a hranatou (voskovky si môžeme predstaviť ako príslušné zátvorky). Jeho novou zábavkou je písať si na papier záznamy o tom, čo sa deje s ktorou voskovkou. Na papier napíše otváraciu -- ľavú zátvorku (príslušného typu), keď si nejaký spolužiak danú voskovku vezme zo stolíka. Naopak, keď ju položí na stolík, zapíše si zatváraciu -- pravú zátvorku (príslušného typu). Na začiatku a na konci dňa sa všetky voskovky nachádzajú na stole. Občas sa ale Marcel zadíva na Sabinku a zabudne zapisovať niektoré zobratia alebo položenia voskoviek, alebo zapíše nejaké zobratia a položenia zle. Potom mu vznikajú všelijaké čudné zápisy a je smutný, lebo si nie je istý, či niečo nezmeškal. Pomôžte mu overiť, či jeho zápis mohol vzniknúť zapisovaním pohybov voskoviek, alebo nie.

## Úloha

Na vstupe dostanete počet jednotlivých druhov voskoviek a postupnosť zátvoriek. Vašou úlohou je zistiť, či pri danom počte druhov voskoviek mohol na konci dňa, keď všetky deti vrátili svoje voskovky, tento zápis nastať alebo nie.

## Formát vstupu

Na prvom riadku vstupu dostanete 4 čísla: $g$, $k$, $s$, $h$, kde $g$ je počet guľatých, $k$ je počet kučeravých, $s$ je počet špicatých a $h$ je počet hranatých voskoviek, ktoré majú v škôlke. Platí, že $0 \\leq g,k,s,h \\leq 5000$.

Nasleduje $1$ riadok obsahujúci neprázdnu postupnosť zátvoriek. Dĺžka tejto postupnosti je najviac $200,000$.

## Formát výstupu

Vypíšte jediný riadok obsahujúci buď reťazec `ANO` ak je záznam korektný, alebo reťazec `NIE` ak záznam nie je korektný a teda Marcel musel pri obzeraní Sabinky zmeškať nejaké položenie, zobratie voskovky, alebo nejaké zapísal zle. Nezabudnite na koniec vypísať znak konca riadku.

## Príklad

```vstup
1 1 1 1
([{<)]}>
```

```vystup
ANO
```

*V škôlke majú z každého druhu voskoviek jeden kus a takýto zápis mohol nastať tak, že zo stola postupne zobrali guľatú, hranatú, kučeravú a špicatú voskovku a následne ich v rovnakom poradí vrátili.*

```vstup
1 0 0 0
[()]
```

```vystup
NIE
```

*V škôlke majú iba guľatú voskovku a tu hneď na začiatku podľa zápisu niekto zobral hranatú, ktorú ale v škôlke nemajú.*

```vstup
1 0 0 0
(())
```

```vystup
NIE
```

*V škôlke majú iba jednu guľatú voskovku, ale podľa tohto zápisu sa zo stola najprv zobrali dve guľaté bez toho, aby sa medzi nimi nejaká položila.*

```vstup
2 0 0 0
(()
```

```vystup
NIE
```

*V škôlke majú dve guľaté voskovky ale v tomto zápise nám chýba položenie jednej voskovky.*
","# Obmenené zátvorky {bodypopis=12 bodyprogram=8}

Skúsme si najprv povedať, v akých situáciách budeme vedieť zo zápisu zátvoriek povedať, že táto postupnosť nemohla nastať. Sú to tieto situácie:

- v zápise je, že by sme mali zo stola zobrať nejakú voskovku, ktorá už nie je na stole, alebo ani nikdy na stole nebola

- v zápise je, že by sme mali vrátiť na stôl nejakú voskovku, ktorú sme si nikdy nezobrali

Ako takéto veci kontrolovať? Jednoducho postupne prechádzame postupnosť zátvoriek a pamätáme si počet voskoviek jednotlivých druhov, ktoré aktuálne sú na stole. Vždy, keď nájdeme nejakú zátvorku, tak si správnym spôsobom zmeníme aktuálny počet voskoviek na stole. Ak sa hocikedy v priebehu stane, že by počet nejakých voskoviek klesol pod $0$ alebo stúpol nad počet, koľko voskoviek toho druhu máme v škôlke, tak vypíšeme `NIE`. Netreba zabudnúť skontrolovať, že na konci dňa (na konci vstupu) musia byť na stole všetky voskovky. V prípade ak nie sú, tak tiež vypíšeme `NIE`. V ostatných prípadoch vypíšeme `ANO`.

Časová aj pamäťová zložitosť je lineárna, priamo úmerná dĺžke postupnosti zátvoriek.
",2
3cb8a16b8a7ad95c,ksp,"# Malé preusporiadanie

Spartakus sa smutne pozerá na svoju armádu zdecimovanú poslednou bitkou. Vojaci stoja vo štvorcovej formácii -- falange. Na mnohých miestach, kde by mal stáť vojak, je však iba prázdny priestor pripomínajúci hrdinského bojovníka padnuvšieho v boji.

S deravými šíkmi sa však bojovať nedá. Vojakov preto treba preusporiadať do kompaktnejšieho útvaru. Spartakus nemá čas každému vojakovi osobitne určovať nové miesto vo formácii. Preto sa rozhodol iba vymeniť niektoré stĺpce falangy. Jeho cieľom je, aby v žiadnom rade formácie neboli diery -- teda aby všetci vojaci v danom rade stáli tesne pri sebe (a mohli zo svojich štítov vytvoriť stenu). Ale dá sa to vôbec?

## Úloha

Formáciu vojakov si môžeme predstaviť ako štvorec rozdelený na $n \\times n$ políčok. Každé políčko je buď prázdne, alebo na ňom stojí vojak. Vašou úlohou bude preusporiadať stĺpce tohto štvorca tak, aby v každom riadku platilo, že všetci vojaci stojaci v tomto riadku tvoria jeden súvislý úsek (alebo nula súvislých úsekov, ak v danom riadku žiadni vojaci nie sú). Ak nie je možné formáciu preusporiadať takýmto spôsobom, podajte o tom správu.

## Formát vstupu

Prvý riadok vstupu obsahuje jedno celé číslo $n$ ($1 \\leq n \\leq 500$) -- rozmer formácie. Nasleduje $n$ riadkov po $n$ znakov popisujúcich formáciu. Políčka s vojakmi sú značené znakom `""*""`, prázdne políčka sú značené znakom `"".""`. Znaky v týchto riadkoch **nie sú** oddelené medzerami.

## Formát výstupu

V prípade, že stĺpce formácie sa dajú preusporiadať tak, aby v žiadnom riadku neboli diery, vypíšte na prvý riadok výstupu slovo `""ANO""` (bez úvodzoviek). Následne vypíšte $n$ riadkov po $n$ znakov -- popis formácie po preusporiadaní, v rovnakom formáte, ako na vstupe. Ak existuje viacero riešení, vypíšte ľubovoľné z nich.

Ak sa stĺpce formácie nedajú preusporiadať vhodným spôsobom, vypíšte iba jeden riadok obsahujúci slovo `""NIE""`.

## Príklady

```vstup
6
*...*.
**.**.
......
.*..*.
...*..
.**..*
```

```vystup
ANO
.**...
****..
......
..**..
*.....
...***
```

_Stĺpec, ktorý bol pôvodne prvý, sme presunuli na druhé miesto, druhý stĺpec na štvrté, tretí na piate, štvrtý na prvé, piaty na tretie a šiesty sme nechali na mieste._

```vstup
3
**.
*.*
.**
```

```vystup
NIE
```
","# Malé preusporiadanie

## Hrubá sila

Najjednoduchšie (ale zďaleka nie najefektívnejšie) vyriešime úlohu, ako inak, vyskúšaním všetkých možností. Môžeme vyskúšať všetkých $n!$ možných preusporiadaní stĺpcov, pre každé preusporiadanie skonštruovať výslednú formáciu a skontrolovať, či táto formácia spĺňa podmienky zo zadania. Časová zložitosť takéhoto riešenia je (pri dobrej implementácii) $O(n! n^2)$ a v praktickom testovaní by malo zvládnuť prvú sadu vstupov.

## Ako vyzerá výsledok?

Ak sa Spartakova armáda dá preusporiadať do formácie spĺňajúcej podmienku zo zadania, aké vlastnosti bude mať výsledná formácia?

Zo zadania vieme, že v každom rade musia vojaci tvoriť jeden súvislý úsek (okrem prázdnych radov, tie ale nie sú zaujímavé, preto sa nimi veľmi zaoberať nebudeme).

Keďže vymieňame iba stĺpce, každý vojak ostane v tom rade, v ktorom začínal. Pre každý rad teda vieme ľahko zistiť, koľko vojakov v ňom je. Inak povedané, vieme, aký dlhý úsek vojakov musí byť v tomto rade.

Ak teda správne určíme, kde sa nacházajú (v ktorom stĺpci začínajú) úseky vojakov v jednotlivých riadkoch, jednoznačne tým určíme celú formáciu.

Pre ľubovoľné dva rady $A, B$ vieme zistiť, ako veľmi sa budú ich úseky vojakov prekrývať: stačí nám spočítať, koľko je takých stĺpcov, že aj v rade $A$ aj v rade $B$ majú vojaka.

Ak sa úseky vojakov v dvoch radoch čiastočne prekrývajú (teda majú aspoň jeden spoločný stĺpec, ale každý z nich má aj stĺpec, ktorý ten druhý nemá), určuje to takmer jednoznačne ich vzájomnú polohu. Ak napríklad máme rad $A$ so $7$ vojakmi a rad $B$ s $10$ vojakmi, ktorých úseky majú $4$ spoločné stĺpce, bude ich vzájomná poloha buď takáto:

```
A: *******......
B: ...**********
```

alebo takáto:

```
A: ......*******
B: **********...
```

Ak teda poznáme absolútnu polohu jedného úseku (teda vieme, v ktorom stĺpci formácie začína), sú iba dve možnosti, kde môže začínať druhý úsek.

Ak poznáme absolútnu polohu dvoch čiastočne sa prekrývajúcich úsekov $A, B$ a niekto nám dá tretí úsek $C$, ktorý sa čiastočne prekrýva s úsekom $A$, dokážeme už presne určiť polohu úseku $C$:

- Z toho, že $C$ sa čiastočne kryje s $A$, máme iba dve možnosti, kde môže začínať $C$.
- Podľa toho, koľko spoločných stĺpcov majú úseky $B$ a $C$ vieme zistiť, ktorá z týchto dvoch možností je správna.

Ak by napríklad úseky $A$ a $B$ z vyššie uvedeného príkladu boli umiestnené takto:

```
A: ....*******.........
B: .......**********...
```

a vo formácii by bol aj úsek $C$ dĺžky $6$, ktorý sa s $A$ prekrýva v piatich stĺpcoch a s $B$ v dvoch stĺpcoch, $C$ musí byť umiestnený takto:

```
A: ....*******.........
B: .......**********...
C: ...******...........
```

Nakoniec si ešte všimnime dve veci:

- Ak je nejaká formácia riešením našej úlohy (dá sa vytvoriť preusporiadaním stĺpcov pôvodnej formácie a každý jej neprázdny riadok obsahuje súvislý úsek vojakov), potom aj jej zrkadlový obraz je riešenie.
- Ak formácia vyhovuje podmienkam zo zadania a obsahuje prázdne stĺpce, potom môžeme všetky tieto stĺpce presunúť úplne doprava a znovu dostaneme formáciu, ktorá je riešením.

## Zárodok algoritmu

Na základe týchto pozorovaní už môžeme postaviť efektívny algoritmus, ktorý dokáže riešiť niektoré vstupy:

1. **Pre každý riadok si spočítame, aký dlhý bude jeho úsek vojakov.** _Pri prázdnych riadkoch nie je čo riešiť -- musia ostať prázdne. Ďalej sa už budeme zaoberať iba neprázdnymi riadkami._
1. **Vezmeme si nejaký riadok $\\boldsymbol{A}$ a začiatok jeho úseku vojakov umiestnime predbežne do stĺpca $\\boldsymbol{0}$.** _Toto ešte nie je jeho finálne umiestnenie vo formácii. Ak v nasledujúcich krokoch umiestnime začiatok nejakécho úseku do stĺpca $x$, myslíme tým, že vo finálnej formácii bude tento úsek začínať $x$ stĺpcov napravo od začiatku úseku $A$. Preto má zmysel hovoriť aj o stĺpcoch so zápornými číslami._
1. **Nájdeme iný riadok $\\boldsymbol{B}$, ktorý sa čiastočne prekrýva s $\\boldsymbol{A}$ a na základe ich prekryvu umiestnime úsek $\\boldsymbol{B}$ jedným z dvoch možných spôsobov (je jedno ktorým).** _Od tohto momentu ďalej si budeme pre každý umiestnený riadok pamätať odkaz na jeho _kotvu_ -- iný umiestnený riadok, s ktorým sa čiastočne prekrýva._ **Kotvou riadku $\\boldsymbol{A}$ bude $\\boldsymbol{B}$ a kotvou $\\boldsymbol{B}$ bude $\\boldsymbol{A}$.**
1. _Kým sa dá, opakujeme nasledujúce kroky:_
   1. **Nájdeme riadok nejaký $\\boldsymbol{R}$, ktorý sme ešte nikam neumiestnili, ale čiastočne sa prekrýva s nejakým už umiestneným riadkom $\\boldsymbol{S}$.**
   1. **Na základe prekryvu $\\boldsymbol{R}$ s $\\boldsymbol{S}$ a s kotvou riadku $\\boldsymbol{S}$ jednoznačne umiestnime úsek v riadku $\\boldsymbol{R}$.** _Môže sa stať, že neexistuje ani jeden vhodný spôsob umiestnenia $R$ -- vtedy hneď vieme, že Spartakova armáda sa nedá dobre preusporiadať._
   1. **Za kotvu riadka $\\boldsymbol{R}$ vezmeme riadok $\\boldsymbol{S}$.**
1. _Ak sme mali šťastie a vstup bol dobrého tvaru, v kroku 4 sa nám podarilo umiestniť úseky vojakov vo všetkých riadkoch._ **Všetky úseky posunieme o rovnaký kus doprava tak, aby najľavejší z nich začínal v stĺpci $\\boldsymbol{0}$.** _Tým dostaneme ich finálne umiestnenie vo formácii._

Ak pre daný vstup existovala aspoň jedna vyhovujúca formácia, my sme určite zostrojili niektorú z nich: pri umiestňovaní väčšiny riadkov sme si vybrali jedinú možnosť, ktorá mala šancu byť správna.

Vynímkou bol riadok $B$, kde sme si vyberali z dvoch symetrických možností. Ak však existovala vyhovujúca formácia, kde bol riadok $B$ umiestnený jedným zo spôsobov, potom symetrická formácia bola tiež vyhovujúca a $B$ je v nej umiestnený druhým spôsobom. Preto bolo naozaj jedno, čo sme si vybrali.

Druhým miestom v našom algoritme, kde nevyberáme jedinú možnú správnu možnosť je krok 5. Ak však existuje nejaká vyhovujúca formácia, potom určite existuje aj taká, kde najľavejší úsek začína v nultom stĺpci (napríklad môžeme zobrať formáciu, kde sú všetky prázdne stĺpce úplne napravo).

Mohlo sa však stať, že daný vstup sa nedá vhodne preusporiadať a my sme napriek tomu niečo vytvorili. Preto ešte **musíme overiť, že naša formácia mohla vzniknúť z pôvodnej**:

1. **Najprv overíme, že každý úsek vojakov končí najneskôr v stĺpci $\\boldsymbol{n-1}$.** _Ak nie, potom sa naša formácia nezmestí do štvorca $n \\times n$ a teda je určite nesprávna._
1. _Ešte potrebujeme overiť, že naša formácia sa skladá z rovnakých stĺpcov ako pôvodná. To zistíme tak, že_ **utriedime jej stĺpce a utriedime aj stĺpce pôvodnej formácie.** _Ak sa formácie skladali z rovnakých stĺpcov, po utriedení už budú úplne identické (a to vieme overiť ľahko)._

Jediným problémom tohto algoritmu je, že funguje, iba ak sa mu v kroku 4 podarí umiestniť všetky úseky vojakov (alebo ak sa mu v tomto kroku podarí zistiť, že sa to nedá).

## Vzorové riešenie

V predošlom algoritme sa nám nemusí podariť umiestniť všekty úseky. V takom prípade nám neumiestnené ostanú iba úseky, ktoré sa s umiestnenými úsekmi prekrývajú buď úplne, alebo vôbec. Neumiestnený úsek $X$ môže vyzerať tromi rôznymi spôsobmi:

1. Úsek $X$ sa vôbec neprekrýva so žiadnym umiestneným úsekom (nemajú spoločné stĺpce).
1. Úsek $X$ úplne prekrýva nejaký umiestnený úsek (všetky stĺpce daného úseku sú zároveň stĺpcami $X$, ale $X$ má aj nejaké ďalšie stĺpce). V takom prípade už musí $X$ prekrývať úplne všetky umiestnené úseky (inak by sa s niektorým z nich čiastočne prekrýval -- rozmyslite si!).
1. Úsek $X$ je úplne obsiahnutý v niektorých (aspoň jednom) umiestnených úsekoch, s ostatnými (tých môže byť aj nula) sa vôbec neprekrýva.

Vzniku úsekov druhého typu vieme predísť tým, že si v prvom kroku algoritmu za úsek $A$ zvolíme najdlhší úsek vo formácii.

Zvyšné dva druhy (prvý a tretí) sa dajú šikovne vyriešiť rekurziou.

Neumiestnené úseky prvého typu sa neprekrývajú s umiestnenými úsekmi, ani s úsekmi tretieho typu. Od týchto sú teda úplne nezávislé. Medzi sebou sa však prekrývať môžu. Poumiestňujeme ich tak, že celý algoritmus rekurzívne zavoláme iba na úseky prvého typu a následne ich posunieme tesne napravo od predtým umiestnených úsekov.

Ostáva nám ešte vyriešiť neumiestnené úseky tretieho typu. Všetky tieto úseky sa budú celé nachádzať niekde medzi začiatkom najľavejšieho umiestneného úseku a koncom najpravejšie umiestneného úseku. Ak máme $k$ umiestnených úsekov, pozície ich začiatkov a koncov nám tento interval rozdeľujú na nanajvýš $2 k - 1$ chlievikov. Každý neumiestnený úsek tretieho typu bude celý vnútri niektorého z týchto chlievikov (inak by sa s nejakým umiestneným úsekom čiastočne prekrýval). Na základe toho, s ktorými umiestnenými úsekmi sa neumiestnené úseky prekrývajú, ich vieme rozdeliť do jednotlivých chlievikov. Ešte potrebujeme umiestniť úseky v rámci ich chlievikov. Na to môžeme pre každý chlievik opäť rekurzívne zavolať náš algoritmus na úseky, ktoré v tomto chlieviku majú byť. Výsledok tohto rekurzívneho volania potom posunieme tak, aby začínal na začiatku chlievika.

## Implementácia a zložitosť

Pri implementácii nášho algoritmu si môžeme na začiatku pre každé dva riadky predrátať, v koľkých stĺpcoch majú oba riadky vojaka. To môžeme urobiť priamočiaro v čase $O(n^3)$. Následne už vieme v konštantnom čase pre ľubovoľné dva riadky zistiť, akým spôsobom sa prekrývajú (čiastočne, vôbec, jeden prekrýva druhý, ...).

Na to, ako v kroku 4 hľadáme úseky, ktoré sa čiastočne prekrývajú s už umiesnenými úsekmi, sa dá pozerať ako na prehľadávanie grafu: vrcholmi sú riadky formácie, hrana je medzi dvoma vrcholmi práve vtedy, keď sa ich úseky čiastočne prekrývajú. Tak ho aj môžeme implementovať, takže hľadanie čiastočne sa prekrývajúcich úsekov nám zaberie $O(n^2)$ času (lebo náš graf je hustý -- môže mať až rádovo $n^2$ hrán).

Ostatné kroky algoritmu by už mali byť pomerne jasné.

Poďme sa teraz pozrieť na zložitosť. Predrátanie prekryvov riadkov robíme len raz za život a trvá $O(n^3)$ času. Okrem toho máme nejaký rekurzívny algoritmus, ktorý keď zavoláme na $k$ riadkov, urobí $O(k^2)$ roboty^[hľadanie riadkov čiastočne sa kryjúcich s už umiestnenými riadkami trvá najdlhšie, ostatné časti algoritmu sú rýchlejšie], čím umiestni niektoré riadky (aspoň jeden) a na zvyšné sa nejakým spôsobom rekurzívne zavolá. Keďže v každom rekurzívnom zavolaní umiestnime aspoň jeden riadok, volaní bude dokopy nanajvýš $n$. Keďže v každom z nich urobíme nanajvýš $O(n^2)$ roboty, dokopy to bude $O(n^3)$^[poctivejším odhadovaním sa dá ukázať, že táto časť je v skutočnosti dokonca $O(n^2)$, pre nás je to však jedno, lebo aj tak už robíme $\\Theta(n^3)$ roboty pri predrátaní]. Na konci ešte overujeme, či sme naozaj zostrojili riešenie nášho problému. Pri tejto kontrole najdlhšie trvá triedenie stĺpcov formácie, ktoré zaberie $O(n^2 \\log n)$ času (na utriedenie $n$ prvkov potrebujeme $O(n \\log n)$ porovnaní a jedno porovnanie môže trvať pri najhoršom $O(n)$). Celý náš algoritmus teda beží v čase $O(n^3)$.

Čo sa týka pamäte, pomerne ľahko sa dá vidieť, že nám bude stačiť $O(n^2)$ pamäte.

## Lepšie riešenia

Táto úlohá má aj riešenie v $O(n^2)$, je však nad rámec tohoto textu a na plný počet bodov ho nebolo treba. Môžete sa však zamyslieť nad nasledovnou otázkou: ako by sa dalo predrátanie prekryvov riadkov (ktoré vo vzoráku robíme v čase $O(n^3)$) robiť v čase $O(n^3 / \\log n)$?
",10
eb131ebfea45acb5,ksp,"# Obedové menu: ryža

V Číne majú veľa malých chlapcov a dievčat. Chlapcov trochu viac. A ešte viac ryže.

V poslednom čase je ale v ich škôlkach stále viac a viac plačúcich a nešťastných detí. Začali sa totiž učiť matematiku. Konkrétne, zatiaľ sa naučili počítať do veľkých čísel a tiež násobiť a deliť dvomi.

Mohli by ste si myslieť, že majú množstvo domácich úloh, alebo že ich matematika nebaví. Opak je však pravdou. Akonáhle získali túto novú superschopnosť, využívajú ju každý deň. Hlavne pri obede. Skôr než sa pustia do jedenia, každý si spočíta svoje zrnká ryže.^[Vďaka tejto zábavke tiež obedujú niekoľko hodín, a tak nemusia ísť poobede spať.]

Keď má každý spočítanú svoju ryžu, začne sa druhá fáza obeda. Porovnávanie. Ak niekto zistí, že má dvakrát viac zrniek ako spoluškôlkar, má právo povyšovať sa a vysmievať sa mu. Potom nasleduje plač, alebo si ublížený chlapec či dievča nájde niekoho, kto má ešte dvakrát menej ryže. Deti niekedy bývajú kruté.

Pani vychovávateľky sú bezradné. Toľko plaču a kreatívnych nadávok, koľko počuli za posledné obdobie ešte nikdy nezažili. Proces výučby sa samozrejme rýchlo zastavil, no nedá sa deti odnaučiť od toho, čo už vedia.

Preto by, ako náhradné riešenie, chceli niektorým deťom zobrať ryžu a dať im tofu. Ryžu treba zobrať deťom tak, aby nemali žiadni dvaja škôlkari $x$ a $2x$ zrniek ryže. Pani vychovávateľky si uvedomujú, že tofu nemá nikto rád^[A všetku tú ryžu musí tiež niekto zjesť.], a preto by ho chceli dať **čo najmenej** deťom. Tiež by ich zaujímalo, koľkými spôsobmi sa dá deťom zobrať najmenší počet ryžových tanierov a rozdať tofu.

## Úloha

Na obed je pripravených $n$ porcií ryže. O každej porcii sa dozviete jedno číslo -- počet zrniek ryže. Tieto čísla sú na vstupe usporiadané vzostupne. Niektoré porcie potrebujete odobrať tak, aby nikto nedostal dvakrát viac ryže ako hocikto iný. Inak povedané, aby nezostali žiadne dve porcie, ktoré majú $x$ a $2x$ zrniek. Snažíte sa odobrať čo najmenej porcií.

Zistite tiež, koľkými spôsobmi sa dajú porcie odobrať tak, aby boli splnené predošlé požiadavky. Dva spôsoby sú rôzne ak existuje aspoň jedna porcia, ktorú sme v jednom spôsobe nechali a v druhom nie. Keďže týchto spôsobov môže byť veľmi veľa, vypíšte len zvyšok po delení prvočíslom $1,000,000,009$.

## Formát vstupu

Na prvom riadku vstupu je kladné celé číslo $n$ neprevyšujúce $1,000,000$ udávajúce počet porcií. Na ďalšom riadku nasleduje $n$ čísel $r_i$ oddelených medzerami, pričom pre každé z nich platí $0 < r_i < 10^{18}$. Čísla $r_i$ sú zoradené od najmenšieho po najväčšie.

## Formát výstupu

Vypíšte dve celé čísla oddelené medzerou: najväčší možný počet porcií, ktoré zostanú po odobratí potrebných tanierov a počet spôsobov ich výberov premodulovaný $1,000,000,009$. Výstup ukončite znakom nového riadku.

## Príklad

```vstup
8
1 2 2 3 4 5 5 6
```

```vystup
5 4
```

_Žiadne povyšovanie a čo najmenej tofu dosiahneme ak necháme deťom tieto porcie: 1 3 4 5 5, 1 4 5 5 6, 2 2 3 5 5, 2 2 5 5 6_
","# Obedové menu: ryža

Najprv si povieme, prečo je výhodné rozdeliť čísla zo vstupu na reťaze. Ďalej sa dozviete, ako spočítať celkový výsledok z čiastkových výsledkov pre reťaze a potom ukážeme rôzne spôsoby ako rozdeliť vstup na reťaze a ako vypočítať najlepší výber prvkov a počet týchto výberov pre jednu reťaz.

## Stačí sa pozerať na $60$ čísel z $1,000,000$

Podľa zadania je potrebné z $n$ čísel odstrániť čo najmenej tak, aby nezostali žiadne $2$ čísla $x, 2x$. Prvé pozorovanie, ktoré urobíme je, že každé číslo $x$ sa vylučuje s najviac dvoma inými číslami: $\\frac{x}{2}, 2x$. Ďalej sa $2x$ vylučuje s $x$ a $4x$, $4x$ s $2x$ a $8x$ atď.

$x,2x,4x,...,2^{k}x$ sa navzájom ovplyvňujú. Ostatné čísla, ku ktorým sa nevieme dostať z $x$ násobením a delením dvomi, môžeme pri riešení $2^{k}$-násobkov $x$ úplne ignorovať.

- Každé prirodzené číslo vieme jednoznačne zapísať ako $x = 2^{u} \\cdot z$, kde $z$ je nepárne číslo, ktoré z čísla $x$ získame tak, že ho delíme $2$ kým sa dá, teda $u$-krát. Pokiaľ majú dve čísla rôzne $z$, určite sa nebudú ovplyvňovať.

- Ak máme vo vstupe čísla $x, 2x, 8x$ ale nie $4x$, zjavne ani $8x$ nebude nijak závisieť od toho, či $x, 2x$ odstránime alebo necháme.

Vstup sa nám teda oplatí porozdeľovať na **reťaze** čísel, ktoré spolu súvisia. Podľa predošlých dvoch argumentov budú dve čísla v jednej reťazi, ak vieme **jedno z nich prerobiť na druhé opakovaným násobením $2$ a každý medzivýsledok je vo vstupnej postupnosti**.

Keďže čísla na vstupe sú najviac $10^{18} \\approx 2^{60}$, reťaze budú mať dĺžku najviac 60 a budú navzájom nezávislé. Ak teda zistíme najlepší výber čísel a počet týchto výberov pre každú reťaz zvlášť, budeme vedieť vypočítať aj celkové výsledky.

## Ako spočítať celkové výsledky z čiastkových

Vstup sme si porozdeľovali na reťaze a predpokladajme, že vieme pre každú reťaz zistiť, aký najväčší **počet čísel** v nej môže zostať^[Ako to spočítať si ukážeme neskôr.] -- označíme $C(retaz)$. **Počet rôznych možností** ako poodstraňovať čísla z jednej reťaze si označíme ako $M(retaz)$.

Keďže každé číslo sa nachádza v práve jednej reťazi, najväčší počet čísel, ktoré vieme zachovať spočítame jednoducho ako súčet $C(r)$ pre každú reťaz.

Keďže reťaze sa nijak neovplyvňujú, pre každú z nich môžeme zvoliť ľubovoľný spôsob výberu čísel, a vďaka tomu bude celkový výsledok súčin $M(r)$ pre všetky reťaze.

## Ako porozdeľovať čísla do reťazí

Po rozdelení čísel do reťazí už nebude záležať na hodnote čísel, iba na ich poradí v reťazi a na počtoch rovnakých čísel. Reťaz $3,3,3,6,6,12,24,48,48$ si preto zapamätáme len ako postupnosť počtov čísel s rovnakými mocninami dvojky (podľa hodnoty $u$ v zápise $x = 2^{u} \\cdot z$), t.j. ako $3,2,1,1,2$.

Na vytvorenie reťaze potrebujeme rýchlo zisťovať, **či je vo vstupnej postupnosti číslo $x$, ak áno, koľkokrát**. Pri tvorení reťaze si vyberieme začiatočné číslo a pridáveme dvojnásobky. Ak sú také čísla vo vstupnej postupnosti, pridáme ich do reťaze, ak nie sú, ukončíme reťaz a pokračujeme s ďalšou.

## Rozdeľovanie do reťazí -- Binárne vyhľadávanie

Vstup je utriedená postupnosť a preto v nej vieme binárne vyhľadávať. Ak chceme zisiť koľkokrát sa nachádza $x$ v postupnosti, stačí binárne vyhľadať najmenšiu pozíciu čísla $x$ a pozíciu najmenšieho väčšieho čísla. V C++ presne tieto úlohy plnia funkcie \\texttt{lower_bound, upper_bound}. Pokiaľ sa číslo $x$ nachádza v poli, počet jeho výskytov je jednoducho \\texttt{upper_bound(x) - lower_bound(x)}.^[Tieto funkcie v C++ vracajú iterátory, ktoré sú adresami prvkov, nie indexami do poľa. Pokiaľ chceme zistiť index x, potrebujeme od iterátora odpočítať adresu začiatku poľa.] V najhoršom prípade -- ak sú všetky čísla vstupu rôzne -- musíme každé z nich binárne vyhľadať, teda časová zložitosť takéhoto delenia na reťaze bude $O(n \\log n)$.

## Rozdeľovanie do reťazí -- Fronta / dvaja bežci

Vďaka utriedenému vstupu sa čísla dajú rozdeliť do reťazí aj v lineárnom čase.

Predstavme si, že čísla načítavame postupne tak, ako sú na vstupe a vkladáme ich do fronty -- queue. Načítali sme číslo $x$ a pozrieme sa, čo s ním môžeme urobiť:

- ak je $x$ rovnaké ako predošlé číslo, vložíme ho do rovnakej reťaze
- ak je vo fronte číslo $\\frac{x}{2}$ vložíme $x$ na koniec reťaze, v ktorej je $\\frac{x}{2}$
- ak vo fronte nie je $\\frac{x}{2}$ vytvoríme novú reťaz so začiatkom $x$

Vieme rýchlo odpovedať na otázku, či je vo fronte $\\frac{x}{2}$? Z fronty vieme vyberať prvky iba zo začiatku, teda z nej budeme musieť vyhadzovať všetky prvky menšie ako $\\frac{x}{2}$. Nakoniec buď nájdeme $\\frac{x}{2}$, alebo najmenšie väčšie číslo. Dôležité je uvedomiť si, že týmto spôsobom nikdy nevyhodíme čísla, ktoré budeme v budúcnosti hľadať. Zjavne polovice väčších čísel ako $x$ sú tiež väčšie ako $\\frac{x}{2}$, teda zostanú vo fronte.

Každé číslo zo vstupnej postupnosti najviac raz vložíme do fronty a najviac raz vyberieme, a tak spravíme len $O(n)$ operácií. Ak máme čísla načítané v poli, frontu môžeme simulovať pomocou dvoch ukazovateľov (bežcov), ktorí budú ukazovať na začiatok a koniec fronty.

## Rozdeľovanie do reťazí -- Hashovacia tabuľka

Pole veľkosti $10^{18}$ by zaberalo niekoľko miliónov terabajtov, ale ak by boli čísla na vstupe malé ($\\approx$ menšie ako $10,000,000$), na riešenie by nám stačilo pole malej veľkosti (napr. 10 miliónov prvkov pre čísla menšie ako 10 miliónov). Políčku $pole[x]$ by sme pripočítali $1$ za každý výskyt $x$ vo vstupe a na požadovanú otázku -- koľko $x$-ov je na vstupe by sme vedeli odpovedať v konštantnom čase. Reťaze by sme tak vedeli vytvoriť v čase $O(n)$.

Pre veľké čísla si presne takéto údaje môžeme ukladať a odpovedať na otáky v konštantnom čase pomocou hash mapy, ktorá si ,,premenuje'' prvky -- zahashuje -- aby sa zmestili do poľa, do ktorého potom indexuje. V C++11 ju nájdete pod názvom \\texttt{unordered_map}. Jej réžia si však vyžaduje konštantne viac času a pamäte oproti riešeniu s frontou/2 bežcami.

## Výpočet pre jednu reťaz

V tejto časti popíšeme ako pre jednu reťaz spočítať najväčší možný počet zachovaných prvkov a počet výberov ktorými sa to dá dosiahnuť. Budeme sa sústrediť už len na nasledovnú úlohu:

Máme postupnosť čísel -- počty prvkov v reťazi. Chceme vybrať niekoľko čísel tak, aby sme nevybrali žiadne dve vedľa seba a aby počet vybratých bol čo najväčší. Chceme zistiť aj počet rôznych výberov.

## Výpočet pre jednu reťaz -- Neopakujúce sa čísla

3 body sa dali získať aj za vyriešenie jednoduchšej úlohy -- pre neopakujúce sa čísla na vstupe. V takejto verzii úlohy nám stačí poznať len dĺžky jednotlivých reťazí -- v reprezentácii, ako bola spomenutá na začiatku časti o rozdeľovaní čísel do reťazí, by sme mali reťaze uložené ako postupnosti samých jednotiek.

Výber čísel z reťaze budeme značiť ako postupnosť $0/1$, kde $0$ bude znamenať, že sme číslo odstránili a $1$, že sme ho zachovali.

- Pokiaľ je dĺžka reťaze nepárna existuje len jedna možnosť ako dosiahnuť najvačší počet zachovaných čísel a zachová sa ich $\\lfloor \\frac{l}{2} \\rfloor + 1$, kde $l$ je dĺžka reťaze a $\\lfloor x \\rfloor$ je dolná celá časť x. Výber čísel bude vyzerať nasledovne: $1010\\dots0101$.

- Ak je dĺžka párna, najväčší počet zachovaných je $\\lfloor \\frac{l}{2} \\rfloor$. Koľko je ale rôznych možností výberov? Pre $l=4$ to môže byť $0101$, $1010$, ale aj $1001$. Pre ľubovoľnú párnu dĺžku sú 2 možnosti výberov, kedy sú na krajoch $0/1, 1/0$. Ak sú však na oboch krajoch jednotky, vnútri postupnosti sme museli odstrániť 2 čísla vedľa seba. Takýchto potenciálnych miest je vo vnútri reťaze $\\lfloor \\frac{l}{2} \\rfloor - 1$, teda počet možností výberov je celkovo pre párne dlhú reťaz $\\lfloor \\frac{l}{2} \\rfloor + 1$.

## Výpočet pre jednu reťaz -- Hrubá sila

Ak by boli všetky reťaze krátke, môžeme dovoliť použiť hrubú silu. Skonštruovali by sme všetky výbery, ako niektoré čísla vynechať -- všetky podmnožiny reťaze. V každom takomto výbere by stačilo skontrolovať, či sme v ňom nenechali 2 nasledujúce čísla. Počet rôznych výberov by sme jednoducho zväčšovali o $1$ za každý výber s najlepším výsledkom.

Ako prakticky prezerať všetky možné výbery? Ak si opäť označíme výber prvkov ako reťazec núl a jednotiek, potrebujeme skontrolovať všetky výbery medzi $00\\dots00$ a $11\\dots11$. Tieto binárne reťazce ale môžeme považovať aj za čísla od $0$ po $2^l-1$. Stačí nám teda v cykle prejsť cez tieto čísla a pre každé číslo -- výber, skontrolovať či v ňom nie sú 2 jednotky za sebou a spočítať súčet čísel, čo zostanú v reťazi.

Ak by sme ohraničili dĺžku reťazí číslom $l$, časová zložitosť takéhoto riešenia by sa dala odhadnúť ako $O(n \\cdot 2^l)$. Za takéto riešenie ste mohli získať až 6 bodov z praktickej časti.

## Výpočet pre jednu reťaz -- Dynamické programovanie

Na záver si ukážeme, ako spočítať všetko, čo chceme, optimálne -- teda v lineárnom čase.

Skúsme **výber prvkov z reťaze postupne konštruovať zľava doprava**. Na začiatku nech je výber prázdny a postupne do neho budeme pridávať niektoré čísla z reťaze. Pri každom čísle budeme mať na výber dve možnosti: ,,pridať, či nepridať?''

Začnime prvým prvkom zľava. Ak ho nepridáme, je zjavne len jeden výber s najlepším súčtom -- nulovým. Ak ho pridáme, najlepší možný súčet je prvé číslo z reťaze a počet výberov je $1$.

Poďme pridať ďalšie číslo z reťaze. Ak sme pridali predošlé číslo, druhé číslo pridať nemôžeme. Ak sme predošlé číslo nepridali, môžeme sa rozhodnúť či pridáme alebo nepridáme ďalšie.

Všimnite si, že akonáhle sa rozhodneme jedno číslo nepridať do výberu, zvyšok výberu bude úplne nezávislý od všetkého naľavo. Nemusíme teda výbery konštruovať, stačí nám zapamätať si, aký je doterajší najlepší súčet a koľkými rôznymi spôsobmi sa dá dosiahnuť.

Na základe týchto úvah nájdeme najväčší súčet a počet rôznych výberov postupne pre prvých $1,2,\\dots,i$ prvkov reťaze.

Označme si ako \\texttt{S[i][0]} **najväčší súčet**, ktorý môžeme dosiahnuť výberom z prvých $i$ prvkov, ak prvok $i$ nepridáme. \\texttt{S[i][1]} bude označovať maximálny možný súčet z prvkov $0,1,\\dots,i$ ak $i$-te číslo pridáme.

Podobne označíme **počet rôznych výberov** z prvkov $0,1,\\dots,i$ s najlepším súčtom ako \\texttt{V[i][0]} a \\texttt{V[i][1]} opäť podľa toho, či sme $i$-te číslo pridali.

Celkový výsledok pre reťaz zistíme ako najväčší súčet čísel z výberu všetkých prvkov, teda\
\\texttt{max(S[dĺžka reťaze - 1][0], S[dĺžka reťaze - 1][1])} a počet výberov, pri ktorých dosiahneme tento súčet, sa dozvieme z príslušného \\texttt{V[dĺžka reťaze - 1][0], V[dĺžka reťaze - 1][1]}.

**Najlepšie súčty** pre prvých $i$ prvkov vieme určiť z informácií pre prvých $i-1$ prvkov takto:

- Ak chceme pridať prvok $i$, $(i-1)$-vý sme pridať nemohli. Preto \\texttt{S[i][1] = S[i-1][0] + retaz[i]}.
- Ak prvok $i$ nepridávame, pre výber prvých $i$ prvkov sa môžeme rozhodnúť či v ňom bude $(i-1)$-vé číslo z reťaze alebo nie. Vtedy \\texttt{S[i][0] = max(S[i-1][0], S[i-1][1])}.

**Počet výberov** prvých $i$ prvkov s najlepším súčtom vieme tiež zistiť len z informácií pre prvých $i-1$ prvkov:

- Keď pridávame prvok $i$, počet možností výberu zostane rovnaký ako počet výberov prvých $i-1$ prvkov, keď $(i-1)$-vý v tomto výbere nebude, teda \\texttt{V[i][1] = V[i-1][0]}.
- Ak $i$ do výberu prvých $i$ prvkov nepridáme, môžeme sa rozhodnúť, či je lepší výber prvých $i-1$ prvkov s alebo bez $(i-1)$-vého prvku.
  - Ak je jeden výber lepší, počet možností výberov \\texttt{V[i][0]} bude rovnaký ako \\texttt{V[i-1][ten lepší]}.
  - Ak sú najlepšie výbery s a bez $i-1$ rovnocenné, teda ak vieme dosiahnuť rovnaký najlepší súčet bez aj s $(i-1)$-vým prvkom, môžeme použiť všetky tieto výbery a tak výsledný počet rôznych výberov je súčtom počtov výberov \\texttt{V[i][0] = V[i-1][0] + V[i-1][1]}.

Pre každý prvok reťaze vypočítame štyri čísla \\texttt{S[i][0], S[i][1], V[i][0], V[i][1]}. Každý takýto výpočet je nanajvýš súčtom alebo maximom dvoch čísel, teda sa stíha v konštantnom čase a teda každú reťaz vieme spracovať v čase lineárnom v závislosti od jej dĺžky, teda $O(l)$. Spracovanie všetkých reťazí dokopy nám potrvá $O(n)$, lebo každé políčko tabuľky \\texttt{S, V} zodpovedá aspoň jednému číslu zo vstupu.

Keďže vo výpočte $i$-teho políčka používame len údaje z $(i-1)$-vého, mierne množstvo pamäte sa dá ušetriť tak, že si nepamätáme celé pole ale len tieto posledné údaje o $(i-1)$ prvých prvkoch.

## Záver

Rozdelenie vstupu na reťaze sa dá robiť nezávisle od počítania údajov pre jednu reťaz a tak ste si mohli zvoliť rôzne kombinácie algoritmov. Celkovo sa dala úloha vyriešiť spojením prístupu s frontou s dynamickým programovaním v $O(n)$. Toto je zjavne aj najlepšia asymptotická zložitosť, ktorá sa dá dosiahnuť, keďže už len načítanie vstupu nám potrvá lineárne dlho.
",8
ee0cf906691e2cc4,ksp,"# Znovu začíname

Znova je to tu. Začal nám nový ročník KSP a s tým spojené prvé kolo. Zahrievajú sa servery, vedúci si pripravujú červené perá vo svojich obľúbených softvéroch na editovanie PDF a distribúcia zadaní je v plnom prúde. Začal pracovať aj náš tím odvážnych webových vývojárov. Zhodli sa, že v novom roku treba softvér aj testovať.

Zaručene najdôležitejšou časťou celej série je výsledkovka. Zodpovední vývojári preto chcú pripraviť test, ktorý overí, či daná vygenerovaná [výsledkovka](https://www.ksp.sk/vysledky/) mohla vzniknúť korektným spôsobom. Zvládnete im pomôcť?

## Úloha

Zadanú dostanete _výsledkovku_ -- zoznam mien riešiteľov od najlepšieho po najhoršieho. Z výsledkovky sa pre každého riešiteľa dozvieme aj to, ako sa jeho umiestnenie zmenilo oproti minulej sérii:

- _Zlepšenie sa_ znamená, že poradie účastníka v aktuálnej výsledkovke je lepšie (menšie) ako jeho poradie v predošlej výsledkovke.

- _Zhoršenie sa_ znamená, že poradie účastníka v aktuálnej výsledkovke je horšie (väčšie) ako jeho poradie v predošlej výsledkovke.

- Za predpokladu, že sa poradie nezväčšilo, ani nezmenšilo, hovoríme, že sa jeho poradie _zachovalo_.

Zistite, či zadaná výsledkovka mohla vzniknúť korektným spôsobom z nejakej predošlej výsledkovky a jednu takúto predošlú výsledkovku nájdite. Z dôvodu zachovania jednoduchosti zadania rátame s tým, že účastníci medzi sériami nepribúdajú, nemiznú a nemôžu byť dvaja na tom istom mieste.

## Formát vstupu

Z prvého riadku načítajte $z$ ($1 \\leq z \\leq 100,000$) -- počet riešiteľov.

$z$ nasledujúcich riadkov zobrazuje aktuálne výsledky zoradené od najlepšieho riešiteľa (najmenšie umiestnenie) po najhoršieho. Každý riadok začína znakom, ktorý určuje relatívny posun voči predošlej výsledkovke: `""+""` pre zlepšenie, `""-""` pre zhoršenie, `""0""` pre zachovanie poradia. Za medzerou nasleduje meno riešiteľa pozostávajúce z malých písmen anglickej abecedy (dĺžky najviac 20).

## Formát výstupu

Na prvý riadok vypíšte reťazec `""OK""`, ak daná výsledkovka mohla vzniknúť korektne. Na ďalších $z$ riadkov vypíšte jedno možné predošlé poradie riešiteľov (od najlepšieho po najhoršieho).

Vypíšte reťazec `""FAIL""`, ak je daná výsledkovka určite chybná.

## Príklad

```vstup
3
+ peter
- alica
0 bob
```

```vystup
OK
alica
peter
bob
```

```vstup
1
- peter
```

```vystup
FAIL
```
","# Znovu začíname

V tejto úlohe sme na vstupe dostali popis *terajšej výsledkovky* a bolo našou úlohou zistiť, či mohla táto výsledkovka vzniknúť z nejakých výsledkov predošlého kola a ak áno, mali sme jednu takúto *predošlú výsledkovku* (riešenie úlohy) vypísať.

## Kedy to nejde?

Uvažujme najprv taký vstup, v ktorom nie sú **nuloví riešitelia**. Poďme skúsiť nájsť nejaké kritériá, ktoré musí spĺňať terajšia výsledkovka, ak mala vzniknúť z nejakej predošlej:

- **Prvý riešiteľ musí byť plusový**. Ak by bol mínusový, znamenalo by to, že ho od minulého kola niekto predbehol ... tento riešiteľ by teda musel byť v terajšej výsledkovke vyššie ako prvý, čo sa ale nemôže nikdy stať.

- **Posledný riešiteľ musí byť mínusový**. Podobne, ak by bol posledný riešiteľ plusový, musel sa od predošlého kola zlepšiť a niekoho predbehnúť. Ten niekto by mal byť v terajšej výsledkovke pod ním. Pod posledným riešiteľom ale už nie je nikto, a tak posledný nemôže byť plusový.

Našli sme dve podmienky, ktoré musíme overiť. Ak ľubovoľná z nich neplatí, žiadna predošlá výsledkovka neexistuje. Nevieme však, či stačí overiť **len** tieto podmienky. Možno aj po ich splnení riešenie stále niekedy existovať nebude...

## Ako by to mohlo ísť?

Napriek tejto neistote sa pokúsime nájsť riešenie len za predpokladu, že sú splnené tieto dve podmienky.

Keďže mínusoví riešitelia od minulého kola klesli, je pomerne dobrý nápad dať ich čo najviac navrch predošlej výsledkovky (aby mali odkiaľ klesnúť) a podobne môžeme skúsiť dať plusových riešiteľov čo najviac na spodok. Spravíme to ale tak, aby sme zachovali relatívne poradie plusových riešiteľov navzájom a poradie mínusových navzájom:

1. zoberieme všetkých mínusových a v poradí, v akom sú v terajšej výsledkovke ich zapíšeme na vrch predošlej výsledkovky

1. zoberieme všetkých plusových riešiteľov a v poradí, v akom sú v terajšej výsledkovke ich postupne zapíšeme pod mínusových

Z terajšej výsledkovky teda vytvoríme predošlú takto:

```
 terajsia       predosla
 --------       --------
+ peter      (-) zygro
+ petka      (-) mario
- zygro      (+) peter
+ janko      (+) petka
- mario      (+) janko
```

## Bude to fungovať?

To, že tento postup bude vždy(ak sú splnené 2 predošlé podmienky) fungovať, si musíme **dokázať**. To ale bude jednoduché.

Pozrime sa na umiestnenie ľubovoľného plusového riešiteľa (napr. Peťky) v predošlej (4. miesto) a v terajšej výsledkovke (2. miesto). Miesto, na ktorom je daný riešiteľ závisí len od toho, koľkí riešitelia sú nad ním vo výsledkovke. V predošlej výsledkovke sú teda pred týmto plusovým riešiteľom všetci plusoví, čo sú pred ním aj v terajšej (Peter) a zároveň aj všetci mínusoví (Zygro a Mário). Keďže ale v terajšej výsledkovke nie sú pred plusovým všetci mínusoví (lebo jeden mínusový je posledný) tak je v terajšej výsledkovke aj náš plusový riešiteľ určite vyššie, lebo je nad ním menej riešiteľov ako v predošlej.

Pre mínusových riešiteľov vieme podobne dokázať, že v predošlej výsledkovke boli vyššie, pretože sme pod nich umiestnili všetkých plusových riešiteľov (aj toho plusového, ktorý je v terajšej výsledkovke prvý).

## Čo s nulovými riešiteľmi?

Je jasné, že nuloví riešitelia museli byť v predošlom kole na rovnakom mieste ako sú teraz (lebo sa ani nezhoršili, ani nezlepšili). Môžeme si teda úlohu zjednodušiť a riešiť ju akoby bez nich. Jednoducho ich pomyselne **vyškrtneme z terajšej výsledkovy** a úlohu vyriešime vyššie uvedeným postupom len pre plusových a mínusových riešiteľov -- nazvime toto riešenie *nenulové*.

Riešenie úlohy aj s nulovými riešiteľmi získame tak, že ich najprv umiestnime na ich pôvodné miesta a potom postupne zaplníme zvyšné miesta nenulovými riešiteľmi v takom poradí, v akom boli v nenulovom riešení.

Ak nenulové riešenie neexistuje, nebude existovať ani žiadne riešenie úlohy (predošlá výsledkovka aj s nulovými riešiteľmi). Nutné podmienky vieme totiž prepísať tak, aby platili aj pre riešenie s nulovými riešiteľmi:

- **Prvý nenulový riešiteľ musí byť plusový**. Ak by bol mínusový, musel ho niekto predbehnúť, no pred ním sú len nuloví riešitelia, ktorí tu boli aj predtým.

- **Posledný nenulový riešiteľ musí byť mínusový**. Ak by bol plusový, musel niekoho predbehnúť, no pod ním sú len nuloví riešitelia, ktorí tam boli aj v predošlom kole.

## Ako to naprogramovať?

Hneď na začiatku si vytvoríme tri polia reťazcov. Pole mínusových riešiteľov, plusových riešiteľov a pole, kam budeme zapisovať riešenie -- predošlú výsledkovku.

Ak pri čítaní vstupu narazíme na nulového riešiteľa, zapíšeme si ho do poľa s riešením na jeho pôvodné miesto. Meno plusového alebo mínusového riešiteľa si zapíšeme do plusového alebo mínusového poľa.

Ďalej potrebujeme overiť dve podmienky. Na to si stačí počas čítania vstupu do premenných zapamätať, aké znamienko bolo pri prvom a poslednom nenulovom riešiteľovi. Po dočítaní vstupu podmienky overíme a program buď vypíše `FAIL` a skončí, alebo bude pokračovať.

Na záver bude stačiť vyplniť zvyšné miesta v riešení. Stačí nám teda raz prejsť pole s riešením a ak je nejaké miesto voľné, priradíme sem (alebo rovno vypíšeme) ďalšieho mínusového alebo (keď sa minú mínusoví) plusového riešiteľa.

## Zložitosť

Časová zložitosť algoritmu je $O(n)$ -- lineárna od počtu ľudí vo výsledkovke, keďže stačí len raz prejsť vstup, a prípadne raz prejsť cez všetky pozície výsledkovky.

Pamäťová zložitosť tohto algoritmu je tiež $O(n)$ -- každé z našich troch polí bude obsahovať najviac $n$ reťazcov.
",4
13bc54dcdfd11852,ksp,"# Treba začať kúriť

Prichádza zima a každý chce byť pekne v teplúčku. Lomižaba sa pripravil: dal si na intráku namontovať zbrusu nové kachle. Teraz, spokojný sám so sebou, aké dobré kachle kúpil, si hovie v postielke, no nejako mu je stále bez periny zima.

""Ja ťuťmák!"", vyskočil Lomižaba z postele, ""Zabudol som dreva nakúpiť!"" Rýchlo schytil nejakého [FKS](https://fks.sk/)-áka a dal mu vyrátať, koľko dreva potrebuje na vykúrenie svojej útulnej izbietky. ""Potrebuješ $k$ metrov."" oznámil FKS-ák po vypísaní troch traktorákov.

Kde ale teraz zoženie drevo? Lomižaba prebehol všetky obchody, no dobré drevo už bolo vykúpené! Posledný predajca si ale všimol, že Lomižaba je zo svojej situácie veľmi smutný. ""Počkaj chlapče! Vidím, že junák si mi statný. Mal by som pre teba sáhovicu, no nemám žiadnu pílu."" ponúkol mu predajca. ""Jasné, pílu nepotrebujem ujo, nevolám sa predsa Lomižaba len tak pre nič za nič. Mojim učiteľom Kálania Smrekových Pňov bol sám slávny Lomidrevo."" Pomôžte Lomižabovi nalámať sáhovicu.

## Úloha

Dĺžka sáhovice v metroch je mocnina dvojky. Lomižaba vie ľubovoľný kus dreva zlomiť na polovicu. Lomižaba potrebuje nalámať sáhovicu na niekoľko kusov tak, aby sa spomedzi nich dali vybrať nejaké s celkovou dĺžkou presne $k$.

Vašou úlohou je zistiť najmenší možný počet lámaní, ktoré na to potrebuje.

## Formát vstupu

Na prvom riadku vstupu bude číslo $t ~ (1 \\leq t \\leq 3000)$, ktoré označuje počet otázok, na ktoré máte odpovedať.

Každá otázka je zadaná na jednom riadku vstupu. Tento riadok obsahuje dve celé čísla $n, k ~ (0 \\leq n \\leq 10^{18}$ a $1 \\leq k \\leq 10^{18})$ oddelené medzerou. Sáhovica má $2^n$ metrov a Lomižaba ju chce nalámať na kusy, z ktorých sa dá vyskladať sáhovica dĺžky $k$ metrov. Vždy bude platiť $2^n \\geq k$ (sáhovica je teda dostatočne dlhá).

## Formát výstupu

Pre každú otázku vypíšte na samostatný riadok jedno číslo, a to najmenší možný počet lámaní, ktorým vieme z našej sáhovice spraviť kusy také, že sa z nich dá poskladať sáhovica dĺžky $k$.

Môžete predpokladať, že sa to vždy bude dať.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| ----:| ----:| ----:| | Maximálne $n$ | $3$| $6$| $1000$| $10^{18}$| | Maximálne $k$ | $8$| $16$| $10^6$| $10^{18}$|

Všimnite si, že čísla $n$ a $k$ v $4.$ sade presiahnu $2^{31} - 1$, čo je najväčšie číslo, ktoré sa dá uložiť v $32$-bitovej premennej so znamienkom. Použite preto $64$-bitové premenné typu `long long` v C++ a `Int64` v Pascale.

## Príklad

```vstup
3
3 8
2 3
123456789 109051904
```

```vystup
0
2
123456766
```

_V prvej otázke dostaneme sáhovicu rovno s dĺžkou $8$, preto ju lámať nemusíme._

_V druhej otázke už musíme lámať aspoň $2$-krát. Po prvom rozlomení máme $2$ kusy po $2 \\textrm{m}$. Teraz stačí rozlomiť ešte jeden $2$-metrový kus. Z kusov s veľkosťami $2, 1, 1$ môžeme vybrať $2$-metrový a jeden $1$-metrový, s celkovou dĺžkou $3$ metre._
","# Treba začať kúriť

Úlohou bolo zo sáhovice dĺžky $L = 2^n$ nalámať také kusy, aby sme si vedeli vyskladať kôpku, resp. sáhovicu dĺžky $k$.

Najdôležitejším pozorovaním je fakt, že lámaním sáhovice na polovice vieme postupne dostať sáhovice všetkých dĺžok mocniny dvojky ($1, 2, 4, 8, \\ldots$).

Potrebujeme teda číslo $k$ vyskladať iba z mocnín dvojky. Jeden z takýchto rozkladov dostaneme, ak sa pozrieme na zápis čísla $k$ v [dvojkovej sústave](https://sk.wikipedia.org/wiki/Dvojkov%C3%A1_%C4%8D%C3%ADseln%C3%A1_s%C3%BAstava). Za každú jednotku v tomto zápise vezmeme mocninu dvojky prislúchajúcu danému rádu. Napríklad ak $k = 22$, dostaneme:

$$k = 22 = 10110_2 = 2^4 + 2^2 + 2^1 = 16 + 4 + 2 \\text{.}$$

Takýto rozklad čísla na súčet mocnín dvojky má jednu peknú vlastnosť: každá mocnina dvojky sa v ňom vyskytuje nanajvýš raz. Ak by teda chcel Lomižaba nalámať sáhovicu na takéto kusy, mohol by to robiť nasledujúcim algoritmom:

0. Ak $k = L$, netreba nič lámať, môže skončiť.
1. Kým nemá kus dĺžky $1$, láme vždy najkratší kus dreva, ktorý práve má.
1. Po skončení kroku $1$ má po jednom kuse dreva dĺžok $\\frac{L}{2}, \\frac{L}{4}, \\frac{L}{8}, \\dots, 8, 4, 2$ a dva kusy dĺžky $1$. Keďže z každej mocniny dvojky má aspoň jeden kus, môže spomedzi nich vybrať tie, ktoré potrebuje.

Keďže na začiatku má najkratší (a jediný) kus dreva dĺžku $L = 2^n$ a každým zlomením sa najkratší kus skráti na polovicu, v kroku 1. tohto algoritmu potrebuje Lomižaba $n$ lámaní. Ak však binárny zápis čísla $k$ končí nulami (ich počet označme $x$), nepotrebujeme $x$ najmenších mocnín dvojky. V kroku

1. nášho algoritmu teda môže Lomižaba prestať lámať už v momente, keď má najkratší kus dreva dĺžku $2^x$ (najmenšia mocnina dvojky, ktorú potrebujeme), čím ušetrí posledných $x$ lámaní. Stačí mu teda $n-x$ lámaní.

Nedá sa to však nejakým iným spôsobom na menej? Ukážeme, že nie. Z toho, že binárny zápis čísla $k$ končí $x$ nulami, vyplýva, že číslo $k$ je deliteľné $2^x$. Z toho, že pred týmito $x$ nulami je už jednotka, vyplýva, že $k$ nie je deliteľné $2^{x+1}$. Z mocnín dvojky (ostro) väčších ako $2^x$ sa dajú vyskladať iba násobky čísla $2^{x+1}$, keďže všetky tieto mocininy sú násobkami $2^{x+1}$. Na vyskladanie sáhovice dĺžky $k$ teda nutne potrebujeme aspoň jeden kus dreva dlhý $2^x$, alebo kratší. A na to, aby sme z kusu dĺžky $L = 2^n$ získali kus dĺžky $2^x$ (alebo kratší) potrebujeme aspoň $n-x$ lámaní.

Na vyriešenie našej úlohy nám teda stačí zistiť, koľkými nulami končí binárny zápis čísla $k$ a vypísať $n$ mínus tento počet. Ako tento počet núl zistíme? Keď je na konci čísla v binárnom zápise nula, znemaná to, že je deliteľné $2$. Ak sú tamm dve nuly, tak je deliteľné $4$. Vo všeobecnosti ak je tam $x$ núl, tak dané číslo je deliteľné $2^x$. Stačí nám teda zistiť, koľkokrát sa dá $k$ bezo zvyšku vydeliť dvomi.

Keďže binárny zápis čísla $k$ má $\\lfloor \\log_2(k) \\rfloor + 1$ cifier (bitov), časová zložitosť jednej otázky je $O(\\log(k))$ - pretože v najhoršom prípade musíme skontrolovať $\\log_2(k)$ bitov. Pamäťová zložitosť je $O(1)$.

**Bonus pre fajnšmekrov:** Existuje aj nasledujúce riešenie v $O(1)$:

Toto riešenie by bolo tiež logaritmické, no procesory majú inštrukciu pre funkciu `__lg` (dvojkový logaritmus -- konkrétne pozícia najvyššej jednotky), ktorá umožnuje vypočítať túto hodnotu v $O(1)$. Upozornenie: funkcie s `__` pred menom sú interné funkcie kompilátora, to znamená, že ich implementácia sa môže líšiť od kompilátora ku kompilátoru, a teda nie je ju moc dobré používať v kóde, ktorý bude reálne niekde bežať.
",1
502f9d7723f7ca48,ksp,"# Dežo

Dežo sa chce dostať zo sústredenia v Trnave domov do Nitry, aby mohol ísť na záchod. Rozhodol sa, že pôjde stopom. Teraz ho ale trápi jedna dôležitá otázka: ""[Koľko je ciest?](https://www.youtube.com/watch?v=zjw7BukZkTY)""

## Úloha

Hlavnú cestu medzi Trnavou a Nitrou si predstavte ako úsečku dlhú $s$. Dostanete zoznam áut, ktoré idú po tejto ceste, pre každé z nich miesto kde sa pripojí a kde sa odpojí z hlavnej cesty a tiež čas, kedy sa pripojí. Všetky autá idú rovnakou rýchlosťou $1\\text{km}/\\text{min}$ a rovnakým smerom.

Dežo sa v čase $0$ nachádza v Trnave. Môže nastúpiť na ľubovoľné okoloidúce auto (aj presne v bode kde sa pripája) a kdekoľvek z neho vyskočiť (najneskôr v bode kde sa odpojí). V bode X vie presúpiť z jedného auta na druhé, iba ak to druhé príde do bodu X **ostro neskôr** ako prvé. Zároveň, ak sa Dežo vezie nejakým autom, musí sa viezť nenulový čas.

Zistite koľkými spôsobmi sa môže Dežo dostať do Nitry. Spôsoby sú rôzne, ak použije rôznu množinu áut (všimnite si poradie je jasne dané). Keďže výsledok môže byť veľký, vypíšte iba jeho zvyšok po delení $10^9+7$.

## Formát vstupu

V prvom riadku sú dve čísla $n$, $s$ - počet áuta a vzdialenosť medzi Trnavou a Nitrou. Nasleduje $n$ riadkov popisujúcich autá. V $i$-tom z nich sú tri čísla $a_i$, $b_i$, $t_i$ ($0\\leq a_i\<b_i\\leq s$, $t_i \\leq 10^9$). Tie znamenajú, že $i$-te auto sa v čase $t_i$ pripojí na cestu $a_i$ kilometrov od Trnavy a odpojí sa v bode $b_i$ kilometrov od Trnavy.

## Formát výstupu

Vypíšte jedno číslo - počet možností, koľkými sa vie Dežo dostať do Nitry, modulo $10^9+7$.

## Hodnotenie

Je $8$ sád po $1$ bode. Platia v nich nasledujúce dodatočné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | |-----------------|-------|--------|--------|--------|--------|--------|--------|--------| | $1 \\leq n \\leq$ | $10$ | $20$ | $1000$ | $1000$ | $1000$ | $10^5$ | $10^5$ | $10^5$ | | $1 \\leq s \\leq$ | $100$ | $1000$ | $100$ | $1000$ | $2500$ | $10^6$ | $10^6$ | $10^9$ |

Navyše v sadách $4$ a $6$ je zaručené, že sa nikdy nenachádzajú dve autá v tom istom bode.

## Príklad

```vstup
5 5
0 3 0 
0 2 1
1 3 5
3 5 9
2 5 6
```

```vystup
10
```

Možné postupnosti áut sú $14$, $15$, $154$, $125$, $1234$, $1254$, $134$, $25$, $254$ a $234$.
","# Dežo

V tejto úlohe bolo treba nájsť počet spôsobov, ktorými sa vie Dežo dostať stopom z Trnavy do Nitry.

## Hrubá sila

Môžeme vyskúšať všetky možné podmnožiny áut. Zostáva zistiť pre danú podmnožinu či funguje.

Prvá vec čo potrebujeme zistiť je, v akom poradí tieto autá použijeme. Čas, v ktorom $i$-te auto prejde nejakým bodom $x$, vieme vypočítať ako $t_i + x - a_i$. To znamená, že z $i$-teho auta vieme prestúpiť do $j$-teho iba ak $t_i + x - a_i < t_j + x - a_j$, teda $t_i - a_i < t_j - a_j$. Na začiatku si teda môžeme všetky autá usporiadať podľa $t_i - a_i$ a potom vieme, že autá môžeme použiť iba v poradí v akom sú v tomto zozname.

Keď už máme určené poradie pre danú podmnožnu, musíme ešte skontrolovať, či náhodou nemáme $t_i - a_i == t_j - a_j$ pre nejaké dve po sebe idúce autá. To by znamenalo, že autá idú naraz a teda nestíhame prestúpiť.

Ak nám to časovo sedí, treba ešte zistiť či to sedí aj priestorovo. Prejdeme autá a pamätáme si interval $(l_i;r_i\\rangle$ v ktorom vieme skončiť po použití prvých $i$ áut. Prvé auto musí mať $a_1 = 0$ aby sme vedeli nastúpiť a potom $l_1=a_1$ a $r_1=b_1$. Do auta $i+1$ vieme prestúpiť práve vtedy, ak $a\_{i+1} \<= r_i \\wedge b\_{i+1} > l_i$. Ak $a\_{i+1} \<= l_i$, vieme presúpiť a potom aj vystúpiť v nejakom bode za $l_i$. Ak $a\_{i+1} > l_i$, vieme prestúpiť najskôr v bode $a\_{i+1}$ a teda vystúpiť v nejakom bode neskôr ako $a\_{i+1}$ (lebo sa musíme viezť nenulový čas). Teda $l\_{i+1} = \\max(l_i, a\_{i+1})$. Najneskôr vieme vystúpiť vždy v $b\_{i+1}$, teda $r\_{i+1}=b\_{i+1}$. Ak sa nám podarí prísť až do konca a $r_n=s$, je daná množina áut použiteľná.

Časová zložitosť tohoto riešenia je $O(n\\cdot 2^n+n\\log(n))$. Pamäťová zložitosť je $O(n)$.

## Dynamika

Pre každú neprázdnu podmnožinu áut, ak ich vieme postupne všetky použiť, vieme definovať interval v ktorom môžeme skončiť po tejto ceste. Bude to polootvorený interval v tvare $(l;r\\rangle$.

Pre každú trojicu $k, l, r$ si spočítame, koľko existuje podmnožín z prvých $k$ áut (máme ich usporiadané v poradí v akom idú), ktorých cesta končí v intervale $(l;r\\rangle$. Túto hodnotu si označime $D(k,l,r)$. Očividne $D(k,l,r)=0$ ak $l>=r$.

Povedzme, že to máme spočítané pre všetky $k\<i$ a ideme to počítať pre $k=i$. To vypočítame ako $D(i,l,r)=D(i-1,l,r) + d(i,l,r)$, kde $d(i,l,r)$ je počet nových ciest, ktoré použijú aj auto $i$.

Každá cesta končiaca autom $i$ končí najneskôr v bode $b_i$, teda pre všetky $l, r$ kde $r\\neq b_i$ máme $d(i,l,r)=0$. Tak isto pre $l\<a_i$ nevieme použiť $i$-te auto, keďže z neho vieme vystúpiť iba neskôr ako $a_i$, teda pre ne tiež $d(i,l,r)=0$.

Nech $j$ je posledné auto ktoré ide ostro skôr ako $i$ (teda sa z neho dá prestúpiť). Zvyšné hodnoty teraz vieme vypočítať ako:

- $d(i,a_i,b_i)=\\sum\_{l=0}^{a_i} \\sum\_{r=a_i}^s D(j,l,r)$, $+1$ ak $a_i=0$

- $d(i, l, b_i)=\\sum\_{r=l+1}^s D(j, l, r)$; pre $a_i\<l\<b_i$

Keď $a_i=0$, môžeme auto $i$ použiť aj ako úplne prvé. Takáto cesta končí v intervale $(a_i;b_i\\rangle$, preto pripočítame $1$ k $d(i,a_i,b_i)$.

Výpočet začneme tým, že $D(0,l,r)=0$ a potom postupne počítame $D(i,l,r)$ pre $i=1,2,3\\dots$.

Keď pridáme nové auto, nové hodnoty vieme vypočítať v čase $O(s^2)$, teda celková časová zložitosť je $O(n\\cdot s^2)$. Pamäťová zložitosť je tiež $O(n\\cdot s^2)$.

Pamäťová zložitosť sa zlepšiť na $O(s^2)$. Stačí si pamätať hodnoty $D(i,l,r)$ pre predchádzajúce $i$ a k tomu ešte hodnoty $D(j,l,r)$ pre posledné auto $j$, ktoré ide ostro skôr. Ďalšie hodnoty budú vždy zavisieť iba od týchto dvoch.

## Intervaláč

Lepšie riešenie vieme dosiahnuť tým, že si hodnoty budeme pamätať v súčtovom intervalovom strome. Keď vypočítame hodnoty pre $i$, budeme ich mať zapísané v $s$ intervaláčoch: jeden intervaláč pre každé $l$, v ktorom budeme mať hodnoty $D(i,l,r)$ pre $0\\leq r \\leq s$. Tieto intervaláče budeme upravovať pritom ako spracúvame ďalšie autá.

Vždy naraz spracujeme všetky autá ktoré idú naraz (podľa $t-a$). Nech sú to autá $i+1$ až $j$. Vieme, že $D(j,l,r)=D(i,l,r) + d(i+1,l,r) + d(i+1,l,r) \\dots d(j,l,r)$. Najprv teda vypočítame všetky $d(x,l,r)$ ($x \\in {i+1,\\dots,j}$) a potom v intervaláči pričítame tieto hodnoty.

Nemusíme počítať tie $d(x,l,r)$, o ktorých vieme, že sa vždy rovnajú $0$, teda stačí vždy vypočítať iba $d(x,l,b_x)$ pre $a_x\\leq l\<b_x$. Hodnotu $d(x,a_x,b_x)$ vieme vypočítať pomocou $s$ otázok na intervaláč v $O(s\\log s)$ a každú z $d(x,l,b_x)$ pre $a_x\<l\<b_x$ vypočítame jednou otázkou v $O(\\log s)$.

Časová zložitosť tohto riešenia bude $O(ns\\log s + s^2)$, pričom $s^2$ je kvôli skonštruovaniu intervaláča. Tohoto člena sa vieme zbaviť tým, že intervaláč budeme konštruovať dynamicky počas každej query. Pamäťová zložitosť je $O(s^2)$ alebo $O(ns\\log s)$ pri dynamickom intervaláči.

## Optimálne riešenie

V optimálnom riešení budeme používať iba dva intervaláče. Prvý $L(l)$ bude obsahovať počty ciest, ktorých interval začína v bode $l$, teda $L(l)=\\sum\_{r=0}^s D(i,l,r)$ (vždy pre nejaké konkrétne $i$) a druhý $R(r)$ bude obsahovať počty ciest, ktorých interval končí v bode $r$, teda $R(r)=\\sum\_{l=0}^s D(i,l,r)$. Súčty intervalov budeme označovať $L(a,b)=\\sum\_{i=a}^b L(i)$ a $R(a,b)=\\sum\_{i=a}^b R(i)$

Keď pridávame nejaké nové auto $i$, potrebujeme vypočítať počet ciest z ktorých sa naňho dá prestúpiť. To budú také cesty, ktorých interval sa prekrýva s intervalom $\\langle a_i;b_i \\rangle$. To vieme vypočítať ako $R(a_i,s)-L(b_i,s)$. Toľko bude nových ciest, ktoré použijú toto auto. Keďže interval každej z nich končí v bode $b_i$, intrvaláču $R$ stačí k $R(b_i)$ pričítať túto hodnotu.

Aktualizovať intervaláč $L$ bude o niečo komplikovanejšie, lebo začiatky intervalov ciest sú rôzne. Ak na auto $i$ prestúpime z cesty, ktorej interval začína skôr ako $a_i$, interval novej cesty bude začínať v bode $a_i$. Počet takýchto ciest vieme vypočítať ako $R(a_i,s)-L(a_i,s)$. Teda k $L(a_i)$ musíme pričítať túto hodnotu.

Zostávajú intervaly ktoré začínajú v $a_i$ a neskôr. Takéto intervaly majú prekryv práve vtedy, ak začínajú skôr ako $b_i$. Ak takýto interval začína v $l$, nový interval bude tiež začínať v $l$. To znamená, že pre všetky $a_i \\leq l < b_i$ musíme spraviť $L(l) += L(l)$, alebo teda $L(l)\\text{ \*= }2$. Takúto operáciu ""plus svoja hodnota"" vieme robiť lazy intervaláčom.

Vždy si najprv niekde zapíšeme aké operácie chceme na intervaláčoch spraviť a potom ich vykonáme, aby sme si počas výpočtu neprepísali staré hodnoty novými. Ak máme niekoľko áut, ktoré idú naraz, zapíšeme si najprv operácie pre všetky autá a až potom ich vykonáme. Treba si pri tom dať pozor ako vyhodnotíme operácie typu ""plus svoja hodnota"". Ak viacero áut chce aplikovať túto operáciu na rovnakej pozícii, vo výsledku musíme na tejto pozícii spraviť $\\times 3$. Ak by sme iba postupne dvakrát aplikovali túto operáciu, dostali by sme $\\times 4$. Toto vieme vyriešiť tým, že si v zvlášť dátovej štruktúre udržiavame akým číslom treba ktoré pozície vynásobiť a potom na konci to aplikovať.

Na to môžeme použiť napríklad mapu ($M$) a keď nám príde nejaké auto $i$, spravíme $M[a_i]\\text{ += }1$, $M[b_i]\\text{ -= }1$. Keď chceme zistiť, akým číslom treba vynásobiť pozíciu $x$, vieme to vypočítať ako $\\sum\_{i=0}^x M[i]$. Na konci teda iba preiterujeme túto mapu, pričom si pamätáme doterajší súčet a vždy týmto číslo vynásobíme interval medzi dvoma po sebe idúcimi kľúčmi tejto mapy. Ak máme takto $k$ áut, týchto intervalov bude najviac $2k$ a teda len toľko operácií musíme na intervaláči vykonať.

Keď prejdeme všetky autá, odpoveď zistíme jednoducho ako $R(s)$.

Pre každé auto spravíme iba konštantne veľa operácií s intervaláčom. teda časová zložitosť je $O(n\\log s)$. Pamäťová zložitosť je tiež $O(n\\log s)$. Obe zložitosti sú za predpokladu, že používame dynamické intervaláče.
",10
076130f0f5d3acd5,ksp,"# Zapisovanie trpaslíkov

Všetci určite poznáte rozprávku o Snehulienke a siedmich trpaslíkoch. Snehulienka sa stratila v lese, našla domček v ktorom bývali trpaslíci, bol tam strašný neporiadok, a ona začala upratovať... Viete prečo nemali trpaslíci doma upratané? Nie, nebolo to preto, že by boli leniví... Trpaslíci toho majú len veľa na práci. Preto majú presne rozdelené, kto má čo spraviť, podľa poradia v ktorom sa v daný deň zobudili. Prvý chystá raňajky, druhý pripravuje stôl, tretí varí čaj, štvrtý upratuje... Aby sa v činnostiach vystriedali, a tiež, aby nemusel Spachtoš vždy vstávať ako prvý, každý deň vstávajú v inom poradí.

Aby trpaslíci vedeli zistiť, že sa už vystriedali všetky poradia, používajú nasledovný systém:

- Každý z trpaslíkov má svoju obľúbenú cifru od $0$ do $9$.
- Keď trpaslík ráno vstane, napíše svoju obľúbenú cifru na tabuľu, hneď za poslednú, ktorá tam bola. Takto vznikne každý deň na tabuli jedno číslo.
- Trpaslíci si počítajú súčet čísel, ktoré sa objavujú na tabuli -- predtým, ako idú spať, pripočítajú číslo z tabule k súčtu.
- Keď je súčet dostatočne veľký, vystriedali sa všetky poradia a môžu sa začať striedať (a sčítavať) odznova.

Systém je dokonalý, no trpaslíci majú jeden problém. Nevedia, aký súčet má byť na tabuli po tom, čo sa vystriedali všetky poradia. Niekedy si tak nevšimnú, že sa už vystriedali a nasledujúce ráno nevstane nikto. Práve v takýto deň prišla Snehulienka a tá sa ako silná žena a nádejná programátorka rozhodla vyriešiť tento problém raz a navždy.

## Úloha

Pre jednu domácnosť trpaslíkov dostanete jedno číslo $c_i$, ktoré vzniklo na tabuli v prvý deň. Zistite, aký bude súčet čísel z tabule, keď sa vystriedajú všetky poradia trpaslíkov. Stručne povedané, zistite súčet všetkých permutácií cifier čísla $c_i$.

Úlohu vyriešte pre $n$ rôznych domácností trpaslíkov.

## Formát vstupu

Na prvom riadku je číslo $n$ ($1 \\leq n \\leq 10^5$). Nasleduje $n$ riadkov, v každom z nich je jedno číslo $c_i$ ($0 \\leq c_i \\leq 10^{12}$). Žiadne číslo iné ako 0 nezačína nulou.

## Formát výstupu

Vypíšte $n$ riadkov, na $i$-tom riadku bude súčet permutácií cifier $i$-teho čísla zo vstupu. Každý súčet sa zmestí do 64 bitovej premennej (typu `Int64` v Pascale, `long long` v C++).

## Príklad

```vstup
5
2
47
33
750
4247
```

```vystup
2
121
66
2664
113322
```

_Trpaslík s cifrou $2$ býva sám, preto musí vždy vstať prvý. Pre trpaslíkov s ciframi $4$ a $7$ existujú dve poradia, ako môžu vstať ($47$ a $74$). Trpaslíci v tretej domácnosti majú rovnaké obľúbené cifry, ale aj tak ich rozlišujeme a preto majú tiež dve možnosti._
","# Zapisovanie trpaslíkov

## Hrubá sila

Riešenie hrubou silou vyzerá tak, že postupujeme presne podľa zadania. Postupne si vygenerujeme každú permutáciu cifier zadaného čísla a potom všetky takto vytvorené čísla sčítame. V jazyku `C++` sa to dá robiť pomocou funkcie `next_permutation()`, ktorá generuje ďalšiu permutáciu poľa. V Pythone sa na to dá použiť knižnica `itertools`. Ak si počet cifier zadaného čísla označíme $k$, tak takéto riešenie má časovú zložitosť $O(k!)$ ($k$ faktoriál) a na testovači by malo získať 2 body.

## Optimálne riešenie

Najprv potrebujeme zistiť, koľko rôznych permutácií $k$ cifier vlastne existuje. Ak chceme z $k$ cifier vyrobiť číslo, dôležité je, v akom poradí ich za seba naukladáme. Na prvé miesto môžeme dať ľubovoľnú z cifier, takže máme $k$ možností. Na druhé miesto už nemáme $k$ možností, ale iba $k-1$. Jedna cifra (aj keď nevieme ktorá) totiž leží na prvej pozícii. Preto máme pre druhé miesto iba $k-1$ možností, čo je dokopy pre prvé dve miesta $k\\cdot (k-1)$ možností.

Neprekvapivo, pre tretie miesto máme $k-2$ možností a tak ďalej. Na poslednom, $k$-tom mieste máme len 1 možnosť, lebo nám zostala posledná nezaradená cifra. Dokopy máme teda $k \\cdot (k-1) \\cdot (k-2) \\ldots 2 \\cdot 1$ možností. Takýto súčin čísel od 1 po $k$ zvykneme tiež označovať $k!$ ($k$ faktoriál).

Označme si cifry nášho čísla zľava doprava ako $a_k\\ a\_{k-1} \\ldots a_2\\ a_1$. Toto číslo si teda môžeme zapísať aj ako:

$$10^{k-1}\\cdot a_k+10^{k-2}\\cdot a\_{k-1}+\\ldots +10^1\\cdot a_2+10^0\\cdot a_1$$

Je jasné, že to, koľko zaváži daná cifra, je dané aj jej poradím v čísle. Skúsme teraz vypočítať, akú hodnotu pridá cifra $a_1$ do súčtu všetkých permutácií. Ak dáme cifru $a_1$ na prvú pozíciu zľava, tak nám do súčtu pridá $10^{k-1}a_1$. Potrebujeme už len zistiť, v koľkých permutáciách bude $a_1$ na prvom mieste. Keď si však takýmto spôsobom zafixujeme prvú cifru, ostane nám $k-1$ cifier, ktoré chceme uložiť na $k-1$ pozícií. Máme teda $(k-1)!$ rôznych čísel, kedy je $a_1$ na prvom mieste.

Ak dáme cifru $a_1$ na druhú pozíciu zľava, bude pridávať do súčtu hodnotu $10^{k-2}a_1$ a opäť $(k-1)!$ krát, lebo zafixovaním druhej pozície nám opäť ostane $k-1$ cifier na $k-1$ pozícií. To isté bude platiť pre ľubovoľné miesto, kam našu cifru $a_1$ uložíme. Ak toto všetko sčítame, dostaneme celkovú hodnotu, ktorú do súčtu permutácií pridá cifra $a_1$ a táto hodnota bude:

$$10^{k-1}a_1(k-1)! + 10^{k-2}a_1(k-1)! + \\ldots + 10^1a_1(k-1)! + 10^0a_1(k-1)!$$

Po vyňatí $a_1$ a $(k-1)!$ získame jednoduchší tvar:

$$a_1(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

Táto istá úvaha však platí aj pre ľubovoľnú cifru, nie len pre $a_1$. Keďže sú cifry od seba nezávislé, celkový súčet permutácií bude určite rovný súčtu hodnôt, ktoré pridajú jednotlivé cifry. Výsledný súčet všetkých permutácií preto bude

$$a_1(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1) + a_2(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1) + \\ldots + a_k(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

čo môžeme opäť upraviť na oveľa jednoduchší tvar:

$$(a_1+a_2+\\ldots+a_k)(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

Výsledok teda vieme vypočítať ako súčin troch členov. Prvý z nich je súčet cifier, druhý je $(k-1)!$, čo je $(k-1)(k-2)\\ldots 1$ a tretí súčet mocnín 10. Každý z týchto členov vieme vypočítať v čase $O(k)$, čo je teda výsledná časová zložitosť nášho programu. Pamäťová zložitosť je dokonca konštantná $O(1)$, keďže cifry zadaného čísla vieme počítať postupne jeho delením 10.
",2
4df46bbb4b56f339,ksp,"# Treba sa najesť

V krajine, kde sa piesok lial a voda sypala, je jazierko s radom kameňov. Kamene sú v poradí označené písmenami reťazca $S$ -- prvý kameň má písmeno $S[0]$, druhý $S[1]$ atď. Na každom kameni je kúsok pizze. Žabiak Žaba je hladný a preto chce preskákať cez čo najviac kameňov. Nie je to ale také jednoduché, pretože na rozdiel od žiab v normálnom svete nemôže skočiť do vody, v sypajúcej vode totiž plávať nevie. Vie sa však po brehu jazera vrátiť zase na začiatok a skákať po kameňoch odznova. Kamene sú naviac príliš malé na to, aby sa na nich otáčal, čiže nemôže skákať na predchádzajúce kamene, je ale dostatočne silný na to, aby doskočil na kameň ľubovoľne ďaleko.

Problém je ešte zapeklitejší, pretože v krajine práve vládne krutovládca s menom $T$ a ten vydal rozkaz, že ak niekto nebude skákať po kameňoch, ktoré tvoria reťazec $T$, tak ich roztrhne ako žabu. Keby Žaba nebol prototypom dobrého občana, všetko by bolo jednoduchšie. Preskákal by postupne po každom kameni a dúfal, že si ho nikto nevšimne. To však nie je ochotný spraviť, a preto teraz rozmýšľa, či vie skočiť na každý kameň v jazierku a pritom neporušiť vládcov rozkaz.

## Úloha

Máme dva reťazce, $S$ a $T$. Z reťazca $S$ vieme vytvoriť podreťazec tak, že z neho vyškrtneme niektoré písmená a zvyšné zachováme v pôvodnom poradí. Zoberme si všetky podreťazce $S$, ktoré sú zhodné s $T$. Zistite, či každý znak reťazca $S$ patrí aspoň do jedného takéhoto podreťazca.

## Formát vstupu

Na prvom riadku vstupu je číslo udávajúce počet testovacích zád. Sád je najviac sto. Nasledujú dva riadky pre každú sadu, na ktorých sú reťazce $S$ a $T$. Reťazce pozostávajú z malých písmen anglickej abecedy a nie sú prázdne. Dĺžka každého reťazca nepresiahne $10^5$ a dĺžka všetkých reťazcov v jednom vstupe nepresiahne $10^6$.

## Formát výstupu

Vypíšte `ano`, ak sa každý znak reťazca $S$ nachádza aspoň v jednom z podreťazcov tvoriacich slovo $T$. Inak vypíšte `nie`.

## Hodnotenie

Sú $4$ testovacie sady, každá za $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | :----:| :-------:| :--------:| :----------:| | dĺžka každého reťazca $\\leq$ | $100$ | $1,000$ | $10,000$ | $100,000$ |

## Príklad

```vstup
3
haha
ha
zabajezaba
zaba
kamen
ak
```

```vystup
ano
nie
nie
```
","# Treba sa najesť

Predtým než sa ponoríme do riešenia, zaveďme si notácie zľahčujúce zápis niektorých vzťahov. `A[i:j]` je súvislý úsek reťazca `A`, ktorý začína na $i$-tom písmene a končí na $j$-tom písmene (použitý zápis teda zodpovedá polootvorenému intervalu). Tu treba zdôrazniť fakt, že ľavý index sa berie vrátane, ale pravý index sa neberie. Navyše, ak vynecháme ľavý index, znamená to začiatok slova a vynechanie pravého indexu znamená koniec slova. Teda `A[:]` je v tomto prípade celý reťazec `A`^[Táto notácia zodpovedá tomu, ako sa s reťazcami pracuje v Pythone.]. Okrem toho, ak povieme, že `A` _sa zmestí do_ `B`, budeme tým myslieť to, že `A` je podreťazcom `B`. Posledné dôležité výrazy, ktoré možno už poznáte, sú prefix a suffix. Prefix označuje súvislú časť reťazca, ktorá začína na jeho začiatku, teda `A[:i]` a suffix označuje súvislú časť reťazca, ktorá končí na jeho konci, teda `A[i:]`.

Začnime si ujasnením toho, čo musí platiť pre dvojicu reťazcov `S` a `T`, pre ktoré je odpoveď `ano`. Vieme, že každý znak z `S` na pozícii $i$ (pre $0 \\leq i < |S|$) sa musí nachádzať v nejakom podreťazci tvoriacom `T`. To znamená, že musí existovať také $j$, že $j$-ty znak v `T` je rovnaký ako $i$-ty znak v `S` a zároveň sa `T[:j]` zmestí do `S[:i]` a `T[j+1:]` sa zmestí do `S[i+1:]`.

Ako prvé by sme si teda mohli rozmyslieť, ako overiť, že sa reťazec `A` zmestí do reťazca `B`. To je však pomerne jednoduché. Postupne budeme prechádzať reťazcom `B`, pričom si pamätáme index do `A`, ktorý nám hovorí, ako dlhý prefix `A` sme už v `B` videli. Počiatočná hodnota tohto indexu je, samozrejme, 0. Ak narazíme v `B` na znak, ktorý sa zhoduje s písmenom na tomto indexe v `A`, posunieme index o jedna ďalej. A na konci reťazca `B` iba overíme, že sme prešli celým `A`. Časová zložitosť tohto postupu je lineárne závislá od dĺžky `B`. To je však príliš pomalé, ak to chceme robiť pre každú dvojicu znakov v `S` a `T`.

My si však dokážeme takúto informáciu získať aj rýchlejšie, a to dynamickým programovaním. Musíme si totiž uvedomiť, že naše otázky sa netýkajú náhodných reťazcov. Zakaždým sa pýtame iba na to, či sa nejaký prefix `T` zmestí do prefixu `S` (a rovnako so sufixami). Pre každý prefix `S` by sme si mohli predpočítať, aký najdlhší prefix `T` sa doň zmestí. Jednak vďaka tomu vieme odpovedať na ľubovoľnú otázku, lebo dlhšie prefixy sa určite nezmestia a všetky kratšie sa zmestiť musia, a jednak vieme tieto hodnoty počítať v jednom prechode a to práve spomínaným dynamickým programovaním.

Ak je `T[:j]` podreťazcom `S[:i]`, potom určite bude `T[:j]` aj podreťazcom `S[:i+1]`, pretože sme len pridali písmeno. Ale naviac, ak sa `S[i]` rovnalo `T[j]`, tak vieme, že aj `T[:j+1]` je podreťazcom `S[:i+1]`. Rovnakým postupom ako predtým, pomocou jedného indexu do `T` si teda vieme predpočítať pole, ktoré nám pre ľubovoľný prefix `S` povie, aký najdlhší prefix `T` sa doň zmestí. Toto isté, akurát odzadu, vieme spraviť aj pre suffixy. Teraz už vieme ľahko zistiť, či sa `T[:j]` nachádza v `S[:i]`, stačí sa pozrieť, aký najdlhší prefix `T` sa zmestí do `S[:i]`, čo máme predpočítané v poli, a porovnať ho s $j$.

V tomto bode máme riešenie s časovou zložitosťou $O(|S| \\cdot |T|)$. Pre každý index $i$ v reťazci `S` vyskúšame každý možný index $j$ v `T` a overíme, či sú tieto znaky rovnaké a či sa zvyšok reťazca `T` zmestí do príslušných častí `S`, čo pomocou predpočítaných hodnôt vieme robiť v konštantnom čase. Predpočítanie hodnôt však trvá iba $O(|T|)$ a ich používanie konštantný čas, najpomalšia časť riešenia je teda tá, kde pre znak z `S` zisťujeme, ktorý znak z `T` mu priradiť. Túto časť by sme teda chceli urýchliť.

Majme $i$-ty znak z $S$ a najdlhší možný prefix, ktorý sa zmestí do `S[:i]` je `T[:j]`. To znamená, že $i$-ty znak musí zodpovedať niektorému z prvých $j+1$ znakov $T$, inak by sa zvyšný prefix `T` do `S[:i]` nezmestil. Nech je teda $i$-ty znak napríklad `x`. Potom tento znak musí zodpovedať niektorému `x` z prvých $j+1$ znakov reťazca `T`. Uvedomme si však, že je vhodné vybrať čo najneskorší výskyt `x` v `T[:j+1]`. Prefix^[Prefix ako predpona, nie Prefix ako vedúci.] totiž bude stále vyhovovať, a čím väčšiu hodnotu si vyberieme, tým kratší suffix stačí dať do `S[i+1:]`. To znamená, že ak sa $i$-ty znak z `S` nachádza v nejakej podpostupnosti tvoriacej `T`, tak to musí byť aj v prípade, keď je toto $i$-te písmeno najpravejší výskyt v `T[:j+1]`.

Chceli by sme preto vedieť rýchlo odpovedať na otázku: Ktorá najpravejšia pozícia `T[:j]` obsahuje písmeno $x$? Pre každé písmeno si vytvoríme pole dĺžky $|T|$, kde na pozícii $k$ bude posledná pozícia daného písmena v prefixe `T` dĺžky $k$. To sa počíta ľahko, keďže buď je táto hodnota rovnaká ako znak predtým, alebo je to hodnota aktuálnej pozície, ak je na nej hľadaný znak.

Časová zložitosť predpočítania polí je lineárna od dĺžky reťazca `S` a časová zložitosť počítania výskytov písmen je lineárna od dĺžky reťazca `T` a dĺžky abecedy (v tomto prípade ju môžeme považovať za konštantu 26). Nakoniec netreba zabudnúť na počet vstupov $n$. Výsledná časová zložitosť je $O(n \\cdot (|S| + |T|))$. Pamätať si potrebujeme iba dve polia dĺžky $|S|$ a 26 polí dĺžky $|T|$ a táto informácia nazáleží na počte vstupov, pamäťová zložitosť je teda $O(|S| + |T|)$.
",5
beb761a731cf8991,ksp,"# Iba aby hladný nebol

Neďaleho hovniválovho bytu je park, v ktorom je síce dosť chodníkov na to, aby sa dalo dostať z každého na každý, ale netvoria žiaden cyklus. Hovniválovi sa teda určite nestane, že by chodil dokola mysliac si, že už o chvíľu určite príde na chodník s lahodnou pochutinou.

Taký park by ale bez neporiadnych psíčkarov vôbec nebol lákavý. Kde-tu sa vyskytne mäkká, hnedastá kôpka maškrty. Jednoducho raj pre hovniválov. Ten náš má vymyslenú vynikajúcu stratégiu. Každú križovatku chodníkov si očísloval. Vždy, keď ide do parku zháňať niečo pod zub, rozhodne sa, ktorých $k$ križovatiek postupne navštívi. Tieto križovatky nemusia byť priamo spojené chodníkom. Medzi dvoma križovatkami sa vždy presúva najkratšou možnou cestou. Ako tak kráča po chodníkoch, dúfa, že aspoň na jednom z nich nájde voňavú pochúťku.

Hovnivála by zaujímalo, koľko rôznych prechádzok, na ktorých nájde aspoň nejakú tú podslinku, si vie naplánovať.

## Úloha

Poznáte popis parku. O každej z $n$ križovatiek viete, ktoré z čísel od $1$ do $n$ jej hovnivál priradil. Každé dve križovatky majú rôzne čísla.

Križovatky sú rôzne pospájané chodníkmi. Chodníkov je $n - 1$ a platí, že sa po nich dá dostať z každej križovatky do každej inej.

Na každom chodníku sa buď nachádza, alebo nenachádza exkrement.

Prechádzka dĺžky $k$ je postupnosť $k$ križovatiek. Križovatky v postupnosti **nemusia** byť priamo spojené hranou. Dokonca môže tá istá križovatka byť v postupnosti viackrát za sebou.

Hovnivál si vždy najskôr vyberie prechádzku dĺžky $k$ a následne sa medzi križovatkami vo zvolenej prechádzke presúva najkratšou možnou cestou.

Vašou úlohou je zistiť, koľko rôznych prechádzok dĺžky $k$ si môže hovnivál zvoliť, aby pre každú z nich platilo, že počas nej prejde po aspoň jednom chodníku s exkrementom.

## Formát vstupu

Na prvom riadku sa nachádzajú čísla $n$ -- počet križovatiek a $k$ -- dĺžka prechádzky.

Nasleduje $n - 1$ riadkov. V každom z nich sa nachádzajú čísla $a$, $b$, $x$. Tieto čísla hovoria, že existuje chodník medzi križovatkami $a$ a $b$ a exkrement sa na ňom nachádza, ak $x = 1$ a nenachádza, ak $x = 0$.

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet rôznych prechádzok dĺžky $k$, počas ktorých hovnivál prejde po aspoň jednom chodníku s exkrementom modulo $10^9 + 7$.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2--3 | 4 | |:--------------- |-----: | ---------: | ------------: | | $2 \\leq n \\leq$ | $10$ | $100,000$ | $100,000$ | | $2 \\leq k \\leq$ | $5$ | $10$ | $1,000,000$ |

## Príklad

```vstup
5 4
1 3 0
2 3 0
3 4 1
4 5 0
```

```vystup
528
```

_Vhodnými prechádzkami sú tu napríklad [1, 5, 3, 2], alebo [3, 3, 5, 3]. Nevhodnou je napríklad [1, 3, 2, 1]._

```vstup
3 3
1 2 0
3 2 0
```

```vystup
0
```

_Žiadna prechádzka nevyužíva chodník s exkrementom, pretože v celom parku žiadny taký chodník nie je._
","# Iba aby hladný nebol

Na vstupe sme mali strom. Našou úlohou bolo spočítať, koľko existuje postupností vrcholov dĺžky $k$ takých, že počas prechádzania postupnosti prejdeme po aspoň jednej označenej hrane. Takéto postupnosti budeme nazývať dobrými.

## Hrubá sila

Riešenie hrubou silou je priamočiare, nie však jednoduché. Nezľaknite sa preto, ak ho budete čítať. Vzorové riešenie sa ukáže ako omnoho jednoduchšie.

Môžeme si postupne vygenerovať všetky možné postupnosti dĺžky $k$ a pre každú z nich overiť, či je dobrá, alebo nie.

Na implementáciu takéhoto riešenia vieme použiť napríklad rekurzívny backtracking. Keď máme postupnosť vygenerovanú, musíme overiť, či je dobrá. To vieme napríklad tak, že pre každý vrchol v postupnosti pustíme [BFS](https://www.ksp.sk/kucharka/bfs/), či [DFS](https://www.ksp.sk/kucharka/dfs/). V tomto prehľadávaní overíme, či na najkratšej ceste z aktuálneho vrchola postupnosti do nasledujúceho prejdeme po označenej hrane.

Inou, o niečo krajšou možnosťou by bolo predpočítať si pre každú dvojicu vrcholov, či sa na najkratšej ceste medzi nimi nachádza označená hrana. Potom by sme vedeli už počas rekurzie zisťovať, či sme cez nejakú označenú hranu prešli, alebo nie. Vyhli by sme sa tak overovaniu na konci rekurzie. Toto predpočítanie vieme spraviť drobnou úpravou algoritmu Floyda a Warshalla.

Možných postupností $n$ vrcholov dĺžky $k$ je $n^k$. Každú z nich samostane vygenerujeme a overíme, či je dobrá. V závislosti od implementácie nám to bude trvať niečo medzi $O(kn^{k + 1})$ a $O(n^{k + 3})$. Pamäť bude tiež v závislosti od implementácie $O(n)$ až $O(n^2)$. Závisí to od toho, či si pamätáme iba strom, alebo si niečo predpočítame pre každú dvojicu vrcholov.

## Vzorové riešenie

Stačí použiť bežný trik. Ak nevieme jednoducho spočítať počet dobrých ciest, možno vieme ľahko zistiť počet zlých. Dobré potom zrátame tak, že od počtu všetkých odpočítame počet zlých.

Už vieme, že počet všetkých postupností je $n^k$.

Ako vyzerá zlá postupnosť? Neprejdeme počas nej po žiadnej označenej hrane. Skúsme teda zo stromu odstrániť všetky označené hrany. Týmto sa nám strom rozpadne na niekoľko komponentov. Každá zlá postupnosť potom musí byť **celá** v jednom komponente. Totiž, keby zahŕňala zlá postupnosť vrcholy z rôznych komponentov, museli by sme niekedy prejsť z jedného komponentu do druhého. Jedinou možnosťou, ako by sme to vedeli, je označená hrana. To je ale spor s predpokladom, že táto postupnosť je zlá.

Keď teda chceme zistiť počet zlých postupností, stačí nám ich vypočítať pre každý komponent zvlášť. Hodnoty pre jednotlivé komponenty potom iba sčítame.

Koľko zlých postupností dĺžky $k$ je v komponente veľkosti $x$? To už predsa vieme, je to niečo podobné ako počet postupností v celom strome, akurát teraz nemá veľkosť $n$, ale $x$. Bude to teda $x^k$.

Nech sa nám odobratím označených hrán strom rozpadol na $c$ komponentov. Ich veľkosti sú $x_1, \\ldots, x_c$. Potom počet **dobrých** postupností je $n^k - \\sum\_{i=1}^{c} x_i^k$.

Na zrátanie veľkostí komponentov vieme použiť jedno [DFS](https://www.ksp.sk/kucharka/dfs/).

Takéto riešenie by malo získať $6$ bodov. Na plný počet musíme naviac použiť umocňovanie v logaritmickom čase. O tomto jednoduchom triku si môžete viac prečítať [tu](https://www.ksp.sk/kucharka/modularna_aritmetika/#wiki-toc-rychle-umocnovanie).

DFS potrebuje $O(n)$ času. Následne veľkosť každého komponentu umocníme na $k$-tu. Komponentov je najviac $n$. Takéto riešenie teda bude mať časovú zložitosť $O(n \\log k)$.

Pamätať si potrebujeme celý strom. Pamäťová zložitosť je preto $O(n)$.
",6
4a0f929cd77ad10c,ksp,"﻿# Zygrov dlhoročný sen ...

Zygro sa už niekoľko rokov nevie zbaviť sna o švédskej dedinke so zázračným spôsobom platenia^\[Referencia na [príklad](http://www.ksp.sk/ulohy/zadania/1037/) z minulej série. \].

V tejto dedinke sa za nákupy platí nie celou sumou, ale len ciferným súčtom sumy. Ak máte za zmrzlinu zaplatiť 512 eur, zaplatíte len $5+1+2=8$ eur a 504 ste ušetrili.

Zygro vyskúšal už všetko možné, ale sen sa stále vracia. Obsah je vždy rovnaký: zakaždým ide do obchodu a niečo si kúpi. Po prebudení si pamätá iba to, koľko peňazí ušetril. Jeho veštkyňa mu odporučila, aby si tieto čísla zapisoval (predpovedajú vraj jeho budúcnosť).

Zygro už síce veštkyňu nenavštevuje, no v zapisovaní pokračuje. Je totiž presvedčený, že musia mať nejaký význam. Nech sa však čísla snaží spracovať akokoľvek, výsledok je vždy nezmyselný. Posledná vec, ktorú ešte nevyskúšal, je zistiť, koľko peňazí by v dedinke zo sna minul, ak by sa v nej platilo normálnym spôsobom. Sám to však nevládze spočítať a preto prosí o radu vás.

## Úloha

Zázračné platenie funguje nasledovne: Nech je skutočná cena nákupu $n$ a ciferný súčet $n$-ka je $c$. Zygro pri zázračnom platení zaplatí $c$ peňazí a teda pri tomto nákupe ušetrí $n-c$ peňazí.

Máte k dispozícii Zygrove záznamy z predošlých rokov. Každý záznam je celé nezáporné číslo $m = n-c$, množstvo peňazí, ktoré Zygro ušetril zázračným platením pri nákupe. Vašou úlohou je zistiť, aké ceny mohli byť Zygrovi naúčtované za nákup pri platbe štandardným spôsobom, teda aké mohli byť hodnoty $n$.

## Formát vstupu

V prvom riadku vstupu je jediné číslo $z$ ($1 \\leq z \\leq 1,000$), udávajúce počet záznamov. Nasleduje $z$ riadkov vstupu. V $i$-tom riadku vstupu je jediné číslo $m_i$ ($0 \\leq m_i \\leq 10^{18}$), udávajúce množstvo peňazí, ktoré Zygro ušetril pri $i$-tom nákupe. Všimnite si, že $m_i$ sa nezmestí do bežnej (32-bitovej) celočíselnej premennej. Pokiaľ programujete v Pascale, odporúčame vám použiť typ `int64`, v C++ typ `long long`.

## Formát výstupu

Vypíšte $z$ riadkov. Na $i$-tom riadku vypíšte všetky možné ceny pre pôvodný nákup zoradené od najmenšej po najväčšiu. Medzi hodnotami majú byť medzery, no za poslednou hodnotou medzera byť nesmie! V prípade, že neexistuje žiadna cena nákupu v platbe štandardným spôsobom, vypíšte prázdny riadok.

## Príklady

```vstup
1
504
```

```vystup
510 511 512 513 514 515 516 517 518 519
```

*Ak bola pôvodná cena 510, tak potom Zygro zaplatil $5+1+0 = 6$. Teda ušetril dokopy $510 - 6 = 504$ peňazí. $511 - (5+1+1) = 504, 512 - (5+1+2) = 504, \\dots$*

```vstup
3
144
585
576
```

```vystup
150 151 152 153 154 155 156 157 158 159

590 591 592 593 594 595 596 597 598 599
```
","# Zygrov dlhoročný sen ...

## Ciferný súčet

Na začiatok si povieme, ako zistiť ciferný súčet čísla $c$. Na výpočet ciferného súčtu použijeme operáciu modulo -- zvyšok po delení. Posledná cifra čísla $c$ je zvyšok po delení číslom 10, alebo $c \\mod 10$. Vydelením čísla $c$ číslom 10 ho ""skrátime"" o poslednú cifru.

Rovnakú myšlienku preto môžeme použiť aj na predposlednú cifru, predpredposlednú cifru... Postup budeme opakovať, až kým nebudeme vedieť všetky cifry. Skončíme vtedy, keď sa nám číslo zmenší na nulu. Cifry čísla $c$ si budeme postupne sčítavať do premennej.

## Úloha

Zázračné platenie fungovalo nasledovne: Nech je skutočná cena nákupu $c$. Zygro pri zázračnom platení zaplatí $ciferny_sucet(c)$ peňazí a teda pri tomto nákupe ušetrí $n = c-ciferny_sucet(c)$ peňazí.

Úlohou bolo nájsť každé číslo $c$, pre ktoré platí, že ak od neho odčítame jeho ciferný súčet, tak dostaneme číslo na vstupe, teda $n$.

Nech máme zadanú ušetrenú sumu $n$. Keďže vieme, že každá pôvodná cena $c$ musela byť aspoň tak veľká ako číslo $n$, môžeme úlohu riešiť tak, že postupne skúšame všetky čísla $c \\geq n$ a testujeme, či po odčítaní ich ciferného súčtu dostaneme číslo $n$. Otázkou však zostáva, kedy môžeme prestať skúšať ďalšie, väčšie, čísla $c$.

## Horné ohraničenie na hodnotu $c$

Môžeme si všimnúť, že za nákup v hodnote $c$ môžeme zaplatiť najviac $9 \\cdot len(c)$ peňazí, kde $len(c)$ je počet cifier čísla $c$. Vždy teda ušetríme aspoň $c - 9\\cdot len(c)$ peňazí, preto platí nerovnica: $$n \\geq c - 9\\cdot len(c)$$ Z tohto zápisu vieme odvodiť horné ohraničenie pre hodnotu $c$ $$c \\leq n + 9\\cdot len(c) $$ potrebujeme však odhadnúť $len(c)$ pomocou $n$. Na rýchlostnej programátorskej súťaži by sme si zvolili nejakú hodnotu, ktorá by určtite stačila pre nájdenie všetkých možných riešení (napr.: $len(c) < 2 \\cdot len(n)$). Nezhoršili by sme tak asymptotickú časovú zložitosť a riešenie by sme mali naprogramované rýchlo. Pre úplnosť si ale dokážeme presnejší odhad.

Aká je teda dĺžka čísla $c$ vzhľadom na dĺžku čísla $n$? Ukážeme si, že dĺžky týchto dvoch čísel sa môžu líšiť najviac o jedna.

- Ak je $c$ jednociferné, po odčítaní ciferného súčtu sa dĺžka výsledku nezmení, $n$ má teda tiež jednu cifru.
- Ak je $c$ dvojciferné, $ciferny_sucet(c) \\leq 18$. Pre všetky čísla $c \\geq 28$ sa po odčítaní $ciferny_sucet(c)$ jeho dĺžka nezmení, takže $n$ bude tiež dvojciferné. No a ak je $c$ menšie ako 28, výsledné číslo $n$ bude možno jednociferný (napr. pri číslach 11 až 19).
- Ak je $c$ $k$-ciferné, $ciferny_sucet(c) \\leq 9k$. Pre všetky $c \\geq 10^{k-1} + 9k$, odčítaním ciferného súčtu jeho dĺžku nezmeníme. Inak môže byť $n$ len o 1 cifru kratšie. Na skrátenie o dve cifry by totiž muselo platiť, že ciferný súčet je aspoň $9 \\cdot 10^{k-2}$.^[Ak chceme zo 6-ciferného čísla (najmenšie je 100,000) dostať číslo štvorciferné (najväčšie je 9,999 ), musíme odčítať aspoň 90001).] Dostaneme teda nasledovnú nerovnicu: $9\\cdot 10^{k-2} < ciferny_sucet(c) \\leq 9k$. Táto nerovnica však zjavne nie je splnená pre $k$ väčšie alebo rovné trom.

Vieme teda, že po odčítaní ciferného súčtu z čísla $c$ nemôže vzniknúť číslo s počtom cifier zmenšeným o 2. Toto môžeme zapísať ako: $$len(c) - len(n) = len(c)-len(c - ciferny_sucet(c)) \\leq 1$$ čím dostávame odhad $len(c) \\leq 1 + len(n)$ a teda spojením týchto dvoch úvah môžeme ohraničiť $c$ pomocou $n$: $$c \\leq n+9\\cdot (1+len(n))$$ Posledný krok, ktorý ešte musíme spraviť, je zistenie dĺžky čísla v desiatkovom zápise.

Môžeme použiť funkciu podobnú tej, čo rátala ciferný súčet. Kým je číslo väčšie ako 0, budeme ho deliť 10 a zväčšovať si počítadlo počtu cifier.

Iný spôsob je využiť desiatkový logaritmus. Pre všetky kladné celé čísla platí $len(n) = \\lfloor \\log\_{10}(n) \\rfloor + 1$, kde $\\lfloor n \\rfloor$ je dolná celá časť $n$. Pre 0 pridáme špeciálny prípad, keďže počet cifier čísla nula je 1, čo nesedí s naším vzorčekom. Horná hranica pre $c$ bude teda $n + 9 \\cdot (\\lfloor \\log\_{10}(n) \\rfloor + 2)$.

#### Zložitosť

Ciferný súčet čísla $c$ zistíme v čase $O(\\log\_{10}(c))$. Avšak, $c$ a $n$ má takmer rovnako veľa cifier ($c$ má nanajvýš o jednu viac), preto je to zároveň čas $O(\\log\_{10}(n))$. Pre zadané $n$ skúšame hodnoty od $n$ po $n + 9(\\lfloor \\log\_{10}(n) \\rfloor + 2)$, teda dokopy $9\\lfloor \\log\_{10}(n) + 2 \\rfloor$ čísel. To znamená, že vypočítať riešenie pre jedno $n$ trvá $O(\\log\_{10}^2(n))$. No a na vstupe máme $z$ záznamov, preto je výsledná časová zložitosť $O(z \\cdot \\log\_{10}^2(n))$.

Pamäťová zložitosť je $O(1)$, pretože máme iba konštantný počet premenných a výsledky môžeme rovno vypisovať.

## Rýchlejšie, matematické riešenie

Na túto úlohu sa ale dá pozrieť aj čisto matematicky. Povedzme, že by mal Zygro zaplatiť sumu $c$. Toto číslo si môžeme zapísať pomocou jeho cifier ako $$c = 1 \\cdot c_0 + 10 \\cdot c_1 + 100 \\cdot c_2 \\ldots $$ pričom $c_i$ je $i$-ta cifra čísla $c$. Koľko je potom $n = c - ciferny_sucet(c) $? Ciferný súčet je len súčet cifier a teda dostávame: $$n = 1 \\cdot c_0 + 10 \\cdot c_1 + 100 \\cdot c_2 \\ldots - (c_0 + c_1 + c_2 + \\ldots) = (10-1) \\cdot c_1 + (100-1) \\cdot c_2 \\ldots $$

Z tohto čísla potom potrebujeme zrekonštruovať pôvodné $c$, teda jeho cifry. Vidíme, že $n$ nám o nultej cifre $c$ absolútne nič nepovie. To znamená, že posledná cifra $m$ môže byť ľubovoľná. Ak teda nejaké riešenie existuje, je ich rovno $10$.

Ďalej potrebujeme nájsť cifry $c_1, c_2, \\ldots c_q$, pre ktoré platí vyššie uvedená rovnosť $n = (10-1) \\cdot c_1 + (100-1) \\cdot c_2 + \\ldots + (10^q -1) \\cdot c_q$, kde $q$ je počet cifier $c$, čo vieme, že je najviac počet cifier $n$ plus jedna.

Algoritmus je potom nasledovný. Zoberieme $n$ a nájdeme $q$. Zistíme si celočíselný podiel $\\frac{n}{10^q -1 }$, čím dostaneme $c_q$. Od $n$ odčítame $(10^q -1) \\cdot c_q$ a zmenšíme $q$ o jedna. Takto pokračujeme, až kým $q$ neklesne na nulu, čo nastane po $O(\\log n)$ krokoch.

Posledné, čo musíme skontrolovať, (môžeme to robiť aj počas rátania jednotlivých cifier) je zistiť, či sú nájdené čísla $c_1, c_2, \\ldots c_q$ naozaj cifry -- čísla od $0$ po $9$. Ak sú všetky naozaj ciframi, zistili sme všetky, okrem nultej, ktorá ale môže byť ľubovoľná. Stačí už len vypísať.

Vhodným udržiavaním si potrebných čísel vieme úlohu pre jedno $n$ vyriešiť v čase $O(\\log(n))$ s pamäťou $O(1)$. Celkové riešenie má potom časovú zložitosť $O(z \\log(n))$ a pamäťovú zložitosť $O(1)$.

## O počte cifier a odhade časovej zložitosti

Mnohí z vás radi v riešeniach prehlasovali počet cifier každého $n$ za konštantu, a teda aj časovú zložitosť za konštantnú.

Odhad časovej zložitosti je veľmi praktická vec. Robíme ho preto, aby sme vedeli približne predpovedať (ešte pred naprogramovaním), ako dlho bude program bežať, keď mu budeme dávať rôzne veľké vstupy. V našej úlohe je $n$ jedným z dvoch parametrov. Bolo by teda veľmi *praktické* vedieť, čo sa bude diať keď ho budeme meniť. Preto je odhad $O(\\log n)$ informatívnejší.

Samozrejme, keďže $n$ mohlo mať najviac 18 cifier, tak to, či $n=12$ alebo $n=123456789012345678$ ovplyvní čas behu programu minimálne. Preto môžeme prakticky tvrdiť, že beh programu nezávisí od veľkosti $n$ (teda, že má program konštantnú časovú zložitosť). Takéto zdôvodnenie ale treba v popise riešenia vždy spomenúť.

Ak by sme úlohu riešili pre veľaciferné čísla, nemohli by sme používať štandartné aritmetické operácie (napr. v C++) alebo by čas výpočtu týchto operácií veľmi závisel od veľkosti čísel (Python, vlastná aritmetika s veľkými číslami). Takýto program by si vyžadoval iné odhady zložitosti.
",4
d70885906a47c3b2,ksp,"﻿# O Vlejdovom bicykli

Vlejd chce bicykel, a ako správny hipster sa rozhodol, že si ho postaví sám. Základom bicykla je, samozrejme, trojuholníkový^\[Vlejd má rád trojuholníky. Viď [príklad 6](https://www.ksp.sk/ulohy/zadania/1019/) z ostatnej série.\] rám (na obrázku ružovou). Naň si Vlejd zohnal niekoľko starých kovových rúriek, z ktorých plánuje tri vybrať a pozvárať ich do tvaru trojuholníka. Následne chce rám natrieť hipsterskou ružovou farbou, ktorej má toľko, že ňou vie natrieť rúrky, ktoré sú spolu dlhé $d$ centimetrov.

Keďže by bola škoda po otvorení nepoužiť všetku ružovú farbu (zvyšok by zaschol a musel by sa vyhodiť), chce zistiť, či sa medzi jeho rúrkami nachádzajú tri také, ktoré tvoria trojuholník s obvodom presne $d$ centimetrov. (Ak také rúrky nemá, farbu si ušetrí na neskôr, vyberie iné rúrky a rámu uháčkuje slušivý obal z tyrkysovej priadze.) Pomôžete mu?

## Úloha

Na vstupe dostanete obvod $d$, počet rúrok $n$ a dĺžky jednotlivých rúrok $r_1, \\dots, r_n$.

Zistite, či sa z niektorých troch rúrok (môže sa stať, že viacero rúrok je rovnako dlhých, ale každú môžete použiť len raz) dá poskladať trojuholník s obvodom $d$.

## Formát vstupu

Na prvom riadku vstupu je počet testovacích sád $t$.

Nasledujú dva riadky pre každú sadu (dokopy $2t$ riadkov). Na prvom riadku sú vždy dve celé čísla $n$ a $d$ ($1 \\leq d \\leq 10^9$) -- počet rúrok a obvod trojuholníka. Na druhom riadku je $n$ celých čísel $r_1, \\dots, r_n$ -- dĺžky rúrok.

Pre jednotlivé vstupy platia nasledovné obmedzenia:

| Číslo vstupu | 1 | 2 | 3 | 4 | 5 | 6 | |-----------------| ---:| ---:| ---:| ---:| ---:| ---:| | $t$ | $1,000$ | $1,000$ | $500$ | $200$ | $100$ | $50$ | | Maximálne $n$ | $10$ | $50$ | $200$ | $1,000$ | $2,000$ | $5,000$ | | Maximálne $r_i$ | $1,000$ | $1,000$ | $10^8$ | $10^6$ | $10^9$ | $10^9$ |

## Formát výstupu

Pre každú testovaciu sadu vypíšte jeden riadok obsahujúci slová `DA SA` ak sa z rúrok na vstupe dá poskladať trojuholník s daným obvodom a `NEDA SA` inak.

## Príklad

```vstup
3
2 10
6 4
5 12
1 2 3 4 5
4 12
11 1 10 1
```

```vystup
NEDA SA
DA SA
NEDA SA
```

*V prvom prípade nemáme dosť rúrok na trojuholník; v druhom prípade môžeme postaviť trojuholník 3-4-5; v treťom prípade síce platí, že $1+1+10 = 12$, ale trojuholník z toho ani Vlejd nespraví.*
","# O Vlejdovom bicykli

Na získanie 7-8 bodov za tento príklad stačilo bruteforce riešenie *""vyskúšame všetky trojice""* s časovou zložitosťou $O(n^3)$. (Samozrejme, aj tu si treba dať pozor na to, že ak tri rúrky majú tvoriť trojuholník, musí pre ne platiť, že súčet dĺžok ľubovoľných dvoch rúrok je väčší než dĺžka tretej rúrky).

Riešenie vieme zlepšiť využitím informácie o obvode trojuholníka. Namiesto zmýšľania v štýle *""vyskúšame všetky trojice, či náhodou nebudú mať súčet $d$,""*, použijeme štýl *""vyskúšame dvojice, dopočítame si dĺžku tretej strany trojuholníka a overíme či máme tyčku správnej dĺžky.""* Overenie sa dá spraviť napríklad binárnym vyhľadávaním, čím by sme dosiahli časovú zložitosť $O(n^2 \\log n)$. Aby sme vedeli binárne vyhľadávať, musíme na začiatku algoritmu pole utriediť, ale to nie je žiaden problém, pretože zložitosť triedenia je $O(n \\log n)$.

\\medskip

Ešte lepšie riešenie vieme dosiahnuť prístupom: *""Vyskúšame všetky možnosti pre najdlhšiu rúrku, jej dĺžku označíme $r_i$, a pokúsime sa zistiť, či sa medzi paličkami nachádzajú dve so súčtom dĺžok $d - r_i$, pričom obe sú nanajvýš také dlhé ako $r_i$.""*

Prečo nám toto pomôže? Pretože v utriedenom poli čísel vieme nájsť dve také, ktoré majú súčet $x$, v lineárnom čase. Stačí použiť dvoch bežcov: dva pointre ukazujúce do poľa, na začiatku inicializované na začiatok a koniec poľa. Pokiaľ je súčet prvkov, na ktoré ukazujú, menší ako $x$, posunieme ľavý pointer doprava. Pokiaľ je súčet prvkov, na ktoré ukazujú, väčší ako $x$, posunieme pravý pointer doľava. Ak je súčet rovný $x$, našli sme prvky, ktoré sme hľadali. Nuž a pokiaľ sa stane, že ľavý pointer je napravo od pravého pointra, v poli sa nenachádzajú také dva prvky, ktorých súčet by bol $x$.

Prehoďme pár slov o tom, prečo to funguje a prečo to má lineárnu časovú zložitosť. Pokúšame sa zistiť, či vo vzostupne utriedenom poli $a_0$ až $a_k$, sú dve čísla $a_i$, $a_j$ také že $a_i + a_j = x$.

Pokiaľ $a_0 + a_k > x$, tak pre všetky $i\\geq 0$ platí, že $a_i + a_k > x$ a teda $a_k$ nemôže byť $a_j$. Preto môžeme $a_k$ zahodiť. Analogicky, keď $a_0 + a_k < x$, môžeme zahodiť $a_0$. Po zahodení dostaneme o jedna kratšie pole, na ktorom riešime rovnakú úlohu.

Keďže zahadzujeme len tie prvky, ktoré nemôžu byť hľadanými $a_i$, $a_j$, tak buď tieto prvky časom nájdeme, alebo zistíme, že sme všetko zahodili a prvky sa v poli nenachádzajú. V každom kroku, v ktorom sme nenašli odpoveď, sme postupnosť skrátili, takže časová zložitosť je $O(k)$, kde $k$ je počiatočná dĺžka postupnosti.

\\medskip

Takže celý algoritmus bude fungovať takto: pole dĺžok rúrok si utriedime, postupne si každú rúrku (jej dĺžku označíme $r_i$) zvolíme za ""najdlhšiu rúrku trojuholníka"". Pokiaľ $2r_i \\geq d$, rovno vieme, že to, čo by sme poskladali, nebude trojuholník. V opačnom prípade sa pokúsime ku nej nájsť (v časti poľa, v ktorej sú len kratšie rúrky) dve také rúrky, ktoré majú súčet dĺžok rovný $d - r_i$. Ak sa podarilo, vypíšeme `DA SA`, ak sa to nepodarí pre žiadnu ""najdlhšiu rúrku trojuholníka"", vypíšeme `NEDA SA`. Časová zložitosť algoritmu pre jednu testovaciu sadu je $O(n^2)$. Jeho pamäťová zložitosť je $O(n)$.

\\medskip
",6
6342759b96d72136,ksp,"# Marťan a snehová búrka

Ako všetci dobre vieme, Marťania náš často navštevujú vo svojich lietajúcich tanieroch. Marťan Denys práve dostal vodičský preukaz. Rozhodol sa ho naplno využiť a priletieť na Slovensko po legendárnu kofolu a horalky (tie na Marse nedostať). To však precenil svoje letecké schopnosti, pretože zabudol na ďalšiu vec, ktorú na Marse nemajú^[takmer] -- atmosféru. A Denys si to nevedomky namieril rovno do snehovej búrky.

Neostávalo mu nič iné, ako zavolať do KSP^[Kerbal Space Program] a oznámiť svoje núdzové pristátie na jednej z ich pristávacích dráh. Tisícky KSPákov na ňu okamžite vybehli v snahe byť prvými, ktorí Denysa privítajú. To však nie je úplne jednoduché -- Denysa snehová búrka kotrmáca hore-dolu, a tak síce dokáže technikou Kontrolovaného Samovoľného Pádu zaručiť, že ""pristane"" na dráhe, nevie však, kde na nej sa nakoniec ocitne.

Každý vedec si teda vybral nejaké miesto na dráhe, na ktoré sa postavil a úzkostlivo čaká, kde Denys nakoniec skončí. Hneď ako pristane, každý z nich sa plnou rýchlosťou rozbehne jeho smerom.

KSP programátorom sa podarilo pomocou simulácie vypočítať niekoľko pravdepodobných miest na dráhe, na ktorých by Denys mohol skončiť. KSPákov teraz pre každé z týchto miest nesmierne zaujíma, kto by sa k Denysovi dostal ako prvý, keby Denys pristál na tomto mieste. KSP potrebuje vašu pomoc!

## Úloha

Pristávacia dráha je veľmi dlhá, rovná cesta. Pozíciu každého KSPáka či možného Denysovho pristátia si preto vieme jednoducho vyjadriť vzdialenosťou od jej začiatku v metroch.

Každý KSPák sa postavil na nejaký meter $x_i$ na pristávacej dráhe a keď Denys pristane, rozbehne sa k nemu rýchlosťou $v_i$ metrov za sekundu. Pre každú polohu pristátia v zozname zistite, ktorí KSPáci by Denysa privítali ako prví, keby pristál na nej.

## Formát vstupu

V prvom riadku vstupu sú dve celé čísla $n, q$ ($1 \\leq n,q \\leq 300,000$): počet KSPákov a počet možných miest, na ktorých Denys možno nakoniec pristane. KSPáci sú očíslovaní od $1$ po $n$.

Nasleduje $n$ riadkov, $i$-ty z nich obsahuje dve celé čísla $x_i, v_i$ -- začiatočnú polohu a rýchlosť KSPáka číslo $i$. Dvojice $x_i, v_i$ sú navzájom rôzne. Platí $0 \\leq x_i < 10^9$ a $0 < v_i \\leq 10^9$.

Nakoniec, v poslednom riadku vstupu je $q$ medzerou oddelených celých čísel $y_1, y_2, \\dots, y_q$ ($0 \\leq y_j < 10^9$) -- zoznam možných pristávacích miest. Sú navzájom rôzne a žiadne z nich sa nerovná začiatočnej polohe niektorého KSPáka.

## Formát výstupu

Vypíšte $q$ riadkov. V $j$-tom z nich vypíšte počet KSPákov, ktorí by Denysa privítali ako prví, keby pristál na $y_j$-tom metri pristávacej dráhy -- teda počet takých $i$, pre ktoré $1 \\leq i \\leq n$ a zlomok $\\frac{|x_i - y_j|}{v_i}$ je najmenší cez všetky $i$. Následne do toho istého riadku vypíšte čísla všetkých takýchto KSPákov, zoradené vzostupne.

## Hodnotenie

Pre jednotlivé testovacie sady platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | |:----------:|:---:|:---:|:---:|:-----:|:------:|:------:|:------:|:------:| | $n,q \\leq$ | $500$ | $3,000$ | $25,000$ | $50,000$ | $75,000$ | $100,000$ | $200,000$ | $300,000$ |

Navyše, v sadách $3,4,5$ platí $x_i < y_j$ pre všetky zmysluplné $i, j$ -- teda všetci KSPáci stoja naľavo od všetkých možných pristávacích miest.

## Príklady

```vstup
4 7
10 5
30 1
20 4
100 1
5 31 22 15 85 60 61
```

```vystup
1 1
1 2
1 3
1 1
2 1 4
2 1 3
1 1
```

```vstup
3 4
10 5
30 1
20 4
31 85 60 61
```

```vystup
1 2
1 1
2 1 3
1 1
```

_Toto je príklad vstupu v sadách 3,4,5_
","# Marťan a snehová búrka

## Stará dobrá hrubá sila

Ako inak -- úloha sa dá riešiť aj hrubou silou. Pre každé pristávacie miesto si pamätáme zoznam KSPákov v jeho výsledku a najlepší čas, za ktorý títo KSPáci k nemu pribehnú -- na začiatku si tento čas inicializujeme na nekonečno. Potom jednoducho prejdeme celý zoznam KSPákov, keď natrafíme na niekoho s rovnakým časom príchodu ako doterajší najlepší, pridáme si ho do zoznamu, a ak na niekoho s lepším časom, čas si zmeníme naň, zoznam premažeme a pridáme tam len tohto najnovšieho.

Pre každé z $q$ pristávacích miest prejdeme celý zoznam $n$ KSPákov, spravíme konštantne veľa operácií a niekdy premažeme doterajší zoznam -- do tohto zoznamu však vždy pridáme nanajvýš $n$ KSPákov, teda pre jedno pristávacie miesto spravíme $O(n)$ operácií, čiže dokopy dostávame časovú zložitosť $O(nq)$. Toto postačuje na prvé dve sady, s dostatočne rýchlym jazykom a implementáciou aj na tretiu. Pamätáme si všetkých $n$ KSPákov a otázky vieme riešiť po jednej, pričom v rámci jej riešenia si pamätáme zoznam dĺžky nanajvýš $n$, čiže máme pamäťovú zložitosť $O(n)$.

_Viete povedať, ktorá časť tejto implementácie je 'pomalá'?_

### Poznámka o výstupe

Jedna otázka, ktorá vám mohla po prečítaní zadania skrsnúť, je ako veľký môže vlastne byť výstup. Keby totiž skoro každý KSPák mohol mať najlepší čas na skoro každom mieste pristátia, museli by sme vypísať až $O(nq)$ čísel, čo by sme teda vo väčších sadách nestihli bez ohľadu na to, ako by sme hľadali odpoveď.

Takéto niečo však nemôže nastať vďaka podmienkam v zadaní, to jest _pristávacie miesta sú navzájom rôzne, a Denys nikdy nepristane na niektorom KSPákovi_, a _dvojice $x_i, v_i$ sú navzájom rôzne_. Toto nám vyplynie z pozorovania, ktoré spravíme popri vymýšľaní vzorového riešenia.

## Jednosmerné riešenie

Pozrime sa teda na ľahšiu verziu úlohy -- naše riešenie musí mať síce oveľa lepšiu časovú zložitosť, nemusíme sa však starať o to, že KSPáci sa ku každému pristátiu hrnú z oboch strán. V momente, keď Denys pristane, všetci KSPáci sa jednoducho rozbehnú doprava ako rýchlo vládzu.

Ak si vypočítame pozíciu každého predbehnutia medzi dvoma KSPákmi, úlohu môžeme riešiť jednoduchým zametacím algoritmom. Postupne pôjdeme po pristávacej dráhe zľava doprava a budeme si pritom udržiavať poradie KSPákov, v akom prejdú cez našu aktuálnu pozíciu. Na začiatku sa nachádzame naľavo od najľavejšieho KSPáka a naše poradie je zatiaľ prázdne (lebo cez našu pozíciu nikdy nijaký KSPák neprejde). Vždy, keď prechádzame cez štartovaciu pozíciu nejakého KSPáka, pridáme si ho do nášho poradia, konkrétne na čelo (keďže na danej pozícii začína, bude tam ako prvý)^[z KSPákov začínajúcich na rovnakej pozícii môžeme všetkých, až na najrýchlejšieho, ignorovať]. Vždy, keď prejdeme cez pozíciu, kde nejaký KSPák predbehne iného, vymeníme si týchto dvoch KSPákov v našom poradí. Keď prechádzame cez pristávacie miesto, zapíšeme si ako odpoveď KSPáka, ktorý je momentálne prvý v poradí (a v prípade, že sa na tej istej súradnici udejú aj nejaké predbehnutia, zapíšeme sem aj ostatných s rovnakým časom).

Problém je však v tom, že predbehnutí medzi KSPákmi môže byť až $\\frac{n \\cdot (n-1)}{2}$, keby boli KSPáci zoradení zľava doprava zostupne podľa rýchlosti. Uvedomme si ale, že drvivá väčšina predbehnutí v skutočnosti vôbec nie je dôležitá. Ak totiž ľubovoľného KSPáka niekto predbehne, môžeme ho už úplne ignorovať -- predbehol ho nejaký rýchlejší KSPák, takže už nikdy vo vedení nebude. To znamená, že pri simulácii predbehnutia môžeme namiesto vymenenia dvoch KSPákov v poradí úplne vyhodiť predbehnutého KSPáka z poradia. Pre každého KSPáka tak budeme simulovať iba prvé predbehnutie, keď bol predbehnutý iným KSPákom. A takýchto predbehnutí je nanajvýš $n$. Tu si všimnime, že okrem KSPáka, ktorý bol sám na čele preteku, sa do odpovede na otázku dostane iný len vtedy, keď práve v tom momente predbehne ešte nepredbehnutého KSPáka. Keďže takýchto predbehnutí je $O( n)$, celkový počet KSPákov v odpovediach je $O(n+q)$ (dokonca tesný odhad je práve $n+q$).

Teraz však máme problém, že nevieme, kde tieto dôležité predbehnutia nastanú. Nemôžeme si ich len tak vypočítať na začiatku, lebo nevieme, medzi ktorými dvojicami KSPákov nastanú a skúšať všetky dvojice by bolo príliš pomalé. Namiesto toho to budeme robiť postupne. Okrem poradia KSPákov si budeme pamätať ešte zoznam všetkých pozícií, kde niektorý KSPák z nášho poradia predbehne KSPáka, ktorý je momentálne v poradí **tesne** pred ním. Ak sa nám tento zoznam podarí udržiavať aktuálny, vždy keď bude treba odsimulovať nejaké predbehnutie, toto predbehnutie budeme mať v zozname, teda o ňom budeme vedieť.

Vždy, keď pridávame KSPáka na čelo poradia, vypočítame si pozíciu, kde ho predbehne KSPák, ktorý bol na čele doteraz (ak ho predbehne) a pridáme si ju do zoznamu predbehnutí. Keď simulujeme, že nejaký KSPák $A$ predbehol KSPáka $B$, toto predbehnutie vyhodíme zo zoznamu. Okrem toho sa pozrieme, či KSPák $A$ nepredbehne niekedy neskôr aj KSPáka, ktorý bol doteraz v poradí tesne pred $B$ (označme ho $C$) a ak áno, pridáme si do zoznamu predbehnutí pozíciu, kde ho predbehne. Nakoniec sa ešte pozrieme, či sme v zozname nemali, že $B$ predbehne $C$ a ak áno, vymažeme toto predbehnutie zo zoznamu (keďže už nie je aktuálne).

Pozíciu, kde nejaký KSPák $X$ predbehne KSPáka $Y$ vypočítame jednoducho ako $x\_{Y} + \\frac{x\_{Y}-x\_{X}}{v\_{X}-v\_{Y} } \\cdot v\_{Y}$.

Všimnime si, že so zoznamom predbehnutí manipulujeme, iba keď pridávame KSPáka, alebo keď simulujeme predbehnutie, teda dokopy maximálne $2n$ krát.

Už si musíme len vybrať vhodné dátové štruktúry. Zoberme si poradie KSPákov. Od neho potrebujeme $q$ krát pristúpiť k vedúcemu KSPákovi, $O(n)$ krát pridať KSPáka na začiatok poradia a $O(n)$ krát vyriešiť predbehnutie, ktoré zahŕňa zmazanie jedného prvku (predbehnutého KSPáka) a nájdenie KSPáka, ktorý sa ocitne tesne pred predbiehajúcim KSPákom. Na túto úlohu sa hodí spájaný zoznam, ktorý všetky tieto operácie dokáže robiť v konštantnom čase.

Ak sa nám však nechce implementovať spájaný zoznam, môžeme namiesto neho použiť usporiadanú množinu, ktorá je v mnohých jazykoch už implementovaná, napríklad `set` v C++. Prvky pritom budeme usporiadavať podľa štartovacej pozície (keďže v poradí máme iba nepredbehnutých KSPákov, sú usporiadaní rovnako, ako boli na začiatku). Táto dátová štruktúra je o logaritmus pomalšia než spájaný zoznam, časovú zložitosť nám však nepokazí, lebo iné časti algoritmu sú pomalšie.

Ďalšiu dátovú štruktúru si musíme zvoliť na efektívne zistenie, ktorú udalosť máme spracovať ďalšiu -- prechod na ďalšieho KSPáka, konkrétne predbehnutie, alebo odpovedanie na pristávacie miesto. Tieto udalosti chceme riešiť usporiadané podľa pozície, na ktorej sa udejú, a musíme do nej $O(n+q)$ krát udalosť pridať, a teda aj $O(n+q)$ krát vybrať a zmazať nasledujúcu udalosť. Toto vieme vykonať prioritnou frontou (napr. haldou), ako je ` priority_queue` v C++. V tejto prioritnej fronte teda budeme mať aj náš zoznam predbehnutí. Z tohoto zoznamu sme však občas potrebovali aj mazať (keď nejaké predbehnutie prestalo byť aktuálne), čo bežná halda nepodporuje. To vyriešime nasledujúcou fintou: neaktuálne prvky nebudeme mazať, ale pri výbere z prioritnej fronty budeme kontrolovať, či je vyberaný prvok ešte aktuálny. Druhá možnosť je použiť ako prioritnú frontu usporiadanú množinu.

Budeme teda $O(n+q)$ krát pridávať/mazať prvok z prioritnej fronty ktorá bude mať $O(n+q)$ prvkov, toto nám zaberie $O((n+q) \\log (n+q))$ času a $O(n+q)$ pamäte. Taktiež budeme musieť $O(n)$ krát pridávať a vyhadzovať KSPákov zo spájaného zoznamu s poradím, čo nám zaberie $O(n)$ času (alebo, ak použijeme usporiadanú množinu, $O(n \\log n)$ času) a $O(n)$ pamäte. Dokopy teda celé naše riešenie zaberie $O((n+q) \\log (n+q))$ času a $O( n+q)$ pamäte.

## A už len čelom vzad

No a čo nám od tohto riešenia chýba k verzii, keď sú KSPáci hala-bala rozmiestnení medzi pristátiami? Naše riešenie si vlastne vie poradiť s ľubovoľným vstupom, ak by naša otázka bola _""pre každé pristávacie miesto povedz tých KSPákov, ktorí by sa k nemu dostali najrýchlejšie, keby všetci bežali doprava""_. Stačí nám teda úlohu vyriešiť ešte raz, ale v opačnom smere -- teraz všetci KSPáci budú bežať len doľava, a KSPákov, pristátia a predbehnutia budeme spracovávať v poradí sprava doľava. Ešte poznamenáme, že o dosť príjemnejšie na implementáciu ako skopírovanie celého kódu a menenie dátových štruktúr, aby teraz zoraďovali udalosti naopak ako predtým, je napísať si jednosmerné riešenie ako funkciu, spustiť ju raz na danom vstupe a následne celý vstup otočiť (všetkým KSPákom zmeníme súradnice z $x_i$ na $10^9-x_i$ a pristávacím miestam z $y_i$ na $10^9-y_i$). Potom našu funkciu zavoláme ešte raz, a máme vyhraté. Treba len mierne pozmeniť zapisovanie odpovede -- keď ideme KSPáka zapísať, najprv sa pozrieme, či už pre dané pristávacie miesto nemáme už nejakú odpoveď, a ak áno, aký čas majú KSPáci, ktorí tam boli predtým zapísaní.

Časová aj pamäťová zložitosť ostáva rovnaká -- naše riešenie len použijeme dva krát.
",9
5ab960bd117a8dae,ksp,"# Zaujímavé poháre

Majka obľubuje poháre, a preto si nedávno kúpila sadu $n$ pohárov. Samozrejme, nie sú to len také obyčajné poháre, to by bola nuda. Majkine poháre majú navzájom rôzne objemy. Tieto objemy sú celé čísla od 1 do $n$. (Všetky objemy sú udávané v decilitroch.)

Keď Syseľ uvidel tieto poháre, hneď sa s nimi chcel nejak zahrať. Majka preto vymyslela nasledovnú hru: Naleje do všetkých pohárov okrem jedného vodu, a potom povie Sysľovi číslo $v$: celkový objem vody v pohároch. Syseľ potom musí uhádnuť, ktorý pohár je prázdny.

## Formát vstupu

Vstup má jeden riadok a v ňom dve celé čísla $n$ a $v$ oddelené medzerou.

Platí $1 \\leq n \\leq 10^9$ a $1 \\leq v \\leq 10^{18}$. Navyše môžete predpokladať, že všetky testovacie vstupy sú riešiteľné: $v$ vždy naozaj zodpovedá tomu, že všetky poháre okrem jedného sú plné.

V polovici testovacích vstupov bude dokonca platiť, že $n\\leq 1,000$. S takýmito vstupmi by si mali poradiť aj menej efektívne programy.

## Upozornenie

Dajte si pozor na to, že váš program musí pracovať aj s hodnotami, ktoré sa nezmestia do bežnej (32-bitovej) celočíselnej premennej. Na ich uloženie potrebujete použiť premennú s dostatočne veľkým rozsahom -- napríklad `int64` v Pascale alebo `long long` v C++.

Takisto si dajte pozor, že kombinovanie 32-bitových a 64-bitových premenných nemusí dopadnúť podľa vašich očakávaní. Napríklad vynásobenie dvoch 32-bitových premenných vráti 32-bitové číslo bez ohľadu na to, či sa tam výsledok zmestí (ak nie, hodnota pretečie) a do akej premennej výsledok uložíte.

## Formát výstupu

Vypíšte jediný riadok a v ňom jediné číslo $x$ -- objem prázdneho pohára.

Nezabudnite ukončiť riadok znakom konca riadku. Teda napríklad v Pascale vypíšte výsledok volaním `writeln(vysledok)`, v C++ zase volaním `cout << vysledok << endl`.

## Príklad

```vstup
6 18
```

```vystup
3
```

*Pohár s objemom 3 dl je prázdny. Plné poháre majú dokopy objem 1+2+4+5+6 = 18 dl.*
","# Zaujímavé poháre

V tomto vzorovom riešení si predstavíme viacero možných spôsobov, ako riešiť tento problém, a po ich porovnaní vyberieme ten najefektívnejší.

Pomerne jednoduchý spôsob je postupne skúšať, ktorý pohár nám chýba, a potom overiť, či súčet objemov ostatných pohárov je rovný $v$. Na spočítanie objemu zvyšných pohárov potrebujeme urobiť $n$ operácií. A musíme to spraviť $n$ krát, pre každý pohár, ktorý by mohol chýbať, takže urobíme $n \\cdot n$ operácií. Časová zložitosť tohto algoritmu je teda $O(n^2)$^\[Ak ste ešte nikdy nepočuli o $O$-notácii, tak si o nej môžete niečo prečítať na stránke [ksp.sk/riesenie/zlozitost](http://www.ksp.sk/riesenie/zlozitost)\].

Nedalo by sa toto riešenie zlepšiť? Musíme skutočne skúšať každý pohár? Začnime tým, že sčítame objem všetkých pohárov a tento súčet si označíme $s$. Objem pohára, ktorý nám chýba je zjavne $s - v$. Takto sme zlepšili zložitosť nášho programu na $O(n)$, keďže nám stačí sčítať $n$ čísel.

Všimnime si, že najpomalšia fáza v našom algoritme je vypočítať súčet objemov všetkých pohárov, čo je v podstate súčet $1 + 2 + \\dots + n$. Pre takýto špeciálny súčet, ale existuje matematický vzorec. A na jeho odvodenie sa používa pekný matematický trik.

Napíšme si na papier postupnosť $1$ až $n$ a pod ňu ešte raz tú istú postupnosť, ale v obrátenom poradí.

$$ \\begin{array}{\*{13}c} 1 &+& 2 &+& 3 &+& \\cdots &+& (n-2) &+& (n-1) &+& n \\ n &+& (n-1) &+& (n-2) &+& \\cdots &+& 3 &+& 2 &+& 1 \\end{array} $$

Všimnime si, že súčet v každom stĺpci je $n+1$. Takže súčet čísel v oboch riadkoch je $n(n+1)$. Avšak, každé číslo sme zarátali dvakrát, takže súčet jedného riadku je polovica celkového súčtu, t.j. $\\frac{n(n+1)}{2}$. Takto vieme súčet objemov všetkých pohárov vypočítať v konštantnom čase dosadením do vzorca. Pamäťová zložitosť je tiež konštantná.
",2
e7cff6b05a099049,ksp,"# Áááá, záplavy

Kde bolo tam bolo, v pradávnom Egypte bola sieť $n$ hrobiek posvätných hovniválov prepojená $n-1$ cestičkami. Celý komplex mal krásnu stromovú štruktúru.

Ale táto idylka bola každoročne narušovaná masívnymi záplavami. Záplavy zaplavujú všetko okolo, vrátane hrobiek posvätných hovniválov. Hlavný architekt Dano prišiel za faraónom s famóznou myšlienkou. Čo keby konečne vybudovali tie protipovodňové zábrany z Egyptofondov o ktorých sa už tak dlho hovorí?

Faraón sa poradil so všetkými svojimi kňazmi, a rozhodol, že vôľa vyššej moci je taká, že protipovodňové zábrany vybudujú, ale musia mať tvar obdĺžnika. Navyše, istý hlavný správca hrobiek Čížoš vyhlásil, že keďže treba šetriť, nemôžu postaviť viac ako dve protipovodňové zábrany.

Akoby situácia nebola už príliš komplikovaná, kancelár správy posvätných hovniválov prišiel s požiadavkou, aby boli ochránené hrobky dostupné práve tak, aby sa dalo chodiť na púť a nestratiť sa. Na púť sa vždy ide od nejakej hrobky do inej po predpripravených cestičkách. Aby sa teda pútnici nestratili, navrhoval kancelár mať v dvoch obdĺžnikoch výhradne hrobky na trati púte.

Architekt Dano sa tak chystal pustiť sa do tej namáhavej práce navrhovania, kadiaľ má ísť bariéra, keď zistil že nevie ktorou trasou má vlastne ísť tohtoročná púť. A nebol v tom sám -- netušil to ani faraón, ani kňazi, ani Čížoš, ani kancelár. Vlastne jediné, čo sa dozvedel, bolo, že vhodná trasa púte sa niekomu v dostatočnom predstihu prisní! No to by bolo! Teraz musí vymyslieť, ako preusporiadať hrobky, aby vedel na akúkoľvek trasu púte postaviť protipovodňové ochrany.

Pomôžte mu!

## Úloha

Toto je __interaktívna__ úloha. Má dve časti.

Existuje $n$ hrobiek posvätných hovniválov a $n-1$ cestičiek (ktoré musia existovať aj po premiestneni hrobiek) tvoriacich strom.

Pohrebisko je štvorcová pláň s rozmermi $n\\times n$ a hrobky môžu byť presunuté iba na celočíselné súradnice.

V prvej časti úlohy dostanete popis cestičiek a váš program vypíše rozloženie hrobiek v rovine.

Po postavení pohrebiska sa viacerým rôznym kňazom snívalo, ktorá púť by bola vhodná. Pre každého zistite, kde by mali byť protipovodňové zábrany postavené. Pochopiteľne, dve obdĺžnikové zábrany by sa nemali prekrývať.

## Formát vstupu a výstupu

Na prvom riadku vstupu je číslo $n$ -- počet hrobiek, $n \\leq 50,000$.

Na ďalších $n-1$ riadkoch je popis cestičiek: na $i$-tom riadku sú dve čísla oddelené medzerou, $a_i$ a $b_i$, $1 \\leq a_i, b_i \\leq n$, $a_i \\neq b_i$.

Následne váš program má vypísať $n$ riadkov, na každom riadku dve celé čísla, $x_i$ a $y_i$ oddelené medzerou. $0 < x_i, y_i \\leq n$. Na $i-tom$ riadku výstupu by mali byť súradnice, kde postaviť $i$-tu hrobku.

Následne na vstupe dostanete niekoľko popisov vysnených pútí. Úloha je **online**, ďalší popis púte dostanete až po úspešnom vypísaní barikád pre predchádzajúcu.

Keď dostanete na vstupe nulu, znamená to, že ste na všetko správne odpovedali a máte ukončiť program.

Každý sen pozostáva z dvoch čísel hrobiek, v ktorých začína a končí púť.

Odpoveď na každú požiadavku vypíšte v nasledovnom formáte:

V prvom riadku vypíšte číslo $k$ ($1 \\leq k \\leq 2$) - počet protipovodňových zábran. Následne vypíšte $k$ riadkov, v každom štyri čísla: $x_1$, $y_1$, $x_2$ a $y_2$ -- súradnice ľavého dolného a pravého horného rohu (v tomto poradí). ($1 \\leq x_1 \\leq x_2 \\leq n$ a $1 \\leq y_1 \\leq y_2 \\leq n$).

Ak ste odpovedali správne, na vstupe dostanete popis ďalšieho sna (alebo 0 označujúcu ukončenie testovania). Ak nie, testovač vypíše -1. Ak sa váš program vtedy neukončí, hrozí, že miesto `WA` dostanete `TLE` alebo `EXC`.

Aby checker fungoval, ako má, **je nutné**, aby sa po vypísaní pozícií hrobiek a obdĺžnikov výstup presunul z pamäte na štandardný výstup pomocou príkazu `cout.flush()` v C++ alebo `sys.stdout.flush()` v Pythone, pre iné jazyky si vyhľadajte.

## Hodnotenie

Sú 4 sady vstupov. V polovici z nich tvoria cestičky binárny strom (z každej hrobky idú najviac tri cestičky).

Počet snov v žiadnej sade nepresiahne $100,000$.

V prvých dvoch sadách platí, že aj počet hrobiek, aj počet snov je najviac $1000$.

## Príklad

```vstup
3       // prvá časť vstupu
1 2
2 3
1 1     // prvá púť
1 3     // druhá púť
0       // ukončenie vstupu
```

```vystup
1 1     // pozície hrobiek
1 2
2 2
1       // odpoveď na prvú otázku
1 1 1 1
2       // odpoveď na druhú otázku
1 1 1 2
2 2 2 2
```

_Prvú púť pokrýva len jednu hrobku. Stačí jedna protipovodňová zábrana, zakrývajúca presne hrobku číslo 1. V druhom prípade môžeme napríklad postaviť prvú zábranu obklopujúcu prvé dve hrobky a druhú obklopujúcu hrobku 3._ _Znaky '//' sa v skutočnom vstupe a výstupe neobjavia, ani vy ich nevypisujte. Slúžia len na ilustráciu interakcie_
","# Áááá, záplavy

Táto úloha má dve časti. V prvej potrebujeme položiť strom (sieť hrobiek posvätných hovniválov) do roviny ($n \\times n$ mriežky), tak aby sme následne v druhej časti vedeli pre ľubovoľný pár vrcholov vybrať dva neprekrývajúce sa obdĺžniky, ktoré pokrývajú presne vrcholy na ceste medzi nimi.

Predstavme si zakorenený strom. Vtedy si každú cestu vieme rozdeliť na dve časti, v ktorých ideme len hore:

Nápad, na ktorom vzorák postavíme, je nasledovný: zakoreníme strom a posadíme ho do roviny tak, aby sme každú cestu dohora vedeli položiť do obdĺžnika.

Následne, aby sme pre pár vrcholov našli (najviac) dva neprekrývajúce sa obdĺžniky, najskôr nájdeme ich najbližšieho spoločného predka. Takto cestu rozdelíme na dve cesty dohora a tie vieme pokryť.

## Položenie stromu do roviny

### Binárny strom

Najskôr si zobme prípad binárneho stromu. Položme koreň stromu do ľavého horného rohu.

Koreň má najviac dvoch synov. Zjednodušene, prvý podstrom dáme do ľavého dolného, a druhý do pravého horného rohu, ako na obrázku.

Následne všetky obdĺžniky z prvého podstromu nepretínajú druhý podstrom a naopak.

Myšlienka je, položiť podstromy do ich podobdĺžnikov rekurzívne.

Začnime technickými detailami: chceme aby odbdĺžniky na podstromy nezdieľali žiadne $x$- any $y$- súradnice. To vieme dosiahnuť napríklad tak, že zistíme počet vrcholov v podstrome číslo jedna. Určíme stromu štvorec veľkosti tohto podstromu, končiaci v ľavom dolnom rohu (ako na obrázku). Potom druhému podstromu tiež určíme štvorec zodpovedajúci jeho veľkosti - ""ukotvený"" v pravom hornom rohu. Keďže súčet veľkostí podstromov je $n - 1$, použité súradnice sa nebudú prekrývať. V prípade, že vrchol má len jedného syna, podstrom položíme do štvorca so stranou $n - 1$.

Následne, zavoláme rekurzívnu funkciu na menšie štvorce a položíme do nich podstrom. Pre ilustráciu, pre strom v prvom obrázku dostaneme nasledovný obrázok:

Pri takomto uložení stromu do roviny platí nasledovné. Pre každý vrchol $v$, všetky vrcholy od neho dohora a doľava sú jeho predkovia (rozmyslite si to). Každý syn je buď viac doprava alebo nižšie ako jeho rodič, takže pre cestu z $v$ do predka $p$ nám vždy stačí vziať obdĺžnik s pravým dolným rohom vo $v$ a ľavým horným rohom v $p$.

Takéto uloženie stromu do roviny vieme jednoducho implementovať pomocou dvoch DFS (jedno na zistenie veľkostí podstromov a druhé na samotné uloženie stromu) v $O(n)$ čase aj pamäti.

### Všeobecný prípad

Čo v prípade, že se strom nie je binárny? Použijeme podobnú techniku ako pri binárnych stromoch. Avšak, namiesto rozdelenia štvorca na dva podštvorce ho rozdelíme na toľko podštvorcov, koľko má koreň synov, podľa diagonály (ak by sme strom z príkladu hore zakorenili v 6, potom dostaneme rozdelenie ako na ďalšom obrázku).

Podštvorce sa nám do štvorca zmenstia, keďže suma veľkostí podstromov je $n - 1$. Argument, prečo toto položenie do roviny funguje, je veľmi podobný ako pri binárnom strome: zoberme si ľubovoľný vrchol $v$: všetky vrcholy naľavo hore od $v$ musia byť jeho predkovia (súrodenci $v$ a iná rodina je vždy buď napravo alebo dole). Keďže sú položení vo vhodnom poradí (rodič je vždy naľavo hore od detí), každý obdĺžnik s pravým dolným rohom vo vrchole $v$ obsahuje práve nejakú cestu hore. A naopak, každá cesta hore je položená v obdĺžniku s pravým dolným rohom vo $v$ a ľavým horným rohom v predkovi.

Toto uloženie stromu do roviny je tiež v lineárnom čase a pamäti.

## Ako zodpovedať otázky

Keď už sme strom položili do roviny, prídeme k druhej časti problému. Majme daný pár vrcholov, $v$ a $w$ a chceme nájsť dva neprekrývajúce sa obdĺžniky, tak aby pokrývali práve cestu medzi $v$ a $w$. Začneme tým, že nájdeme najbližšieho spoločného predka (pozri nižšie). Máme dve možnosti: buď je najbližší spoločný predok jeden z vrcholov $v$, $w$ (bez ujmy na všeobecnosti, nech je to $w$). Potom vieme položiť celú cestu do jedného obdĺžnika, s pravým dolným rohom vo $v$ a ľavým horným rohom v $w$.

Na obrázku je príklad pre $w = 6$, $v = 7$:

Druhý prípad nastáva, ak najbližší spoločný predok nie je ani $v$, ani $w$. Povedzme, že je to nejaký vrchol $p$. V tom prípade cestu rozdelíme na dve cesty hore: (napríklad) od $v$ do $p$ a od $w$ do jedného zo synov v $p$. Nemôžeme položiť do obdĺžnikov cesty z $v$ do $p$ aj $w$ do $p$, pretože potom by mali prekryv. Keď nájdeme vrchol, do ktorého chceme viesť cestu z $w$, potom už jednoducho získame dva obdĺžniky: jeden má rohy vo $v$ a $p$ a druhý v $w$ a správnom synovi $w$.

Na obrázku je príklad pre $v = 5$ a $w = 2$:

### Najbližší spoločný predok

Posledný problém je nájdenie najbližšieho spoločného predka. Najbližší spoločný predok $v$ a $w$ je najhlbší taký vrchol (teda najbližší k $v$ a $w$), že jeho podstrom obsahuje oba $v$ a $w$.

Naivné hľadanie najbližšieho spoločného predka vyzerá asi takto: (bez ujmy na všeobecnosti, nech $v$ je hlbší vrchol ako $w$) z vrchola $v$ ideme hore (po rodičoch) kým sa nedostaneme na rovnakú hĺbku, v akej je $w$. Ak sme takto vošli do vrchola $w$, potom $w$ je nabližší spoločný predok. Ak nie, pokračujeme hore, tentoraz posunieme vždy $v$ a $w$ naraz, až kým sa nestretnú. Vrchol, v ktorom sa stretnú je najbližší spoločný predok. Toto má časovú zložitosť lineárnu v hĺbke stromu, čo môže byť lineárne v $n$, takže dostaneme čas $O(n)$ na query. Toto riešenie nám dá polovicu bodov.

Hľadať to vieme aj rýchlejšie, a to napríklad v čase $O(\\log n)$ na query (pozri [kuchárku](https://www.ksp.sk/kucharka/lca/)). V tomto čase vieme nájsť predka o $k$-generácií vyššie. Ak vieme hĺbku najbližšieho spoločného predka (označme ju ako $h_p$, a hĺbky v ktorej sú $v$ a $w$ postupne ako $h_v$ a $h_w$), potom do jedného obĺžnika dáme cestu z $v$ do predka o $h_v - h_p$ generácií vyššie od $v$ (najbližšieho spoločného predka) a do druhého cestu z $w$ do predka $w$ o $h_w - h_p - 1$ vyššie (v prípade že najbližší spoločný predok nie je jeden z koncových vrcholov). Rohové body obdĺžnikov teda vieme nájsť v čase $O(\\log n)$ na query, čo nám stačí na plný počet bodov.
",9
a171e424da841ab4,ksp,"# Mandarínske kráľovské problémy

V Mandarínsku žije samoľúby král Nenásytnan Veľký, ktorý má rád mandarínky. Má ich až tak rád, že každý deň počas mandarínkovej sezóny jednu zje^[Voľakedy ich jedol viac, ale to mu jeho diétny asistent zakázal, pretože sa nezmestil na kráľovskú fotografiu.]. A keďže on je veľmi nenástytný tak každý deň musí zjesť tú najväčšiu čo sa v predchádzajúci deň v Mandarínsku urodila. V Mandarínsku počas sezóny narastie každý deň $n$ mandariniek. Tieto mandarínky sa potom rovnomerne poukladajú na jednu dlhú linku, kde ich manuálne zoraďujú pracovníci od najmenšej po najväčšiu s cieľom aby sa najväčšia mandarínka dostala priamo na kráľovský stôl. Každý pracovník je zamestnaný na určitom úseku linky a jeho úlhou je usporiadať mandarínky na linke podľa veľkosti v rámci jeho úseku (rozsahu rúk).

Keďže aj do Mandarínska prišla pandémia, z hygienických dôvodov sa môže na každom pracovisku nachádzať naraz iba jeden zamestnanec. Podľa nariadenia hlavného hygienika Mandarínska sú zamestnanci každý deň púšťaní do práce postupne podľa ich zamestnaneckého čísla. Každý z nich tam môže byť iba nevyhnutný čas a potom musí ísť domov.

Tento postup musí dodržiavať aj mandarínková triediaca linka. Šéf tejto linky Kleofáš Múdry rozmýšla ako ho najlepšie implementovať. Počas prvých dní pandémie do firmy púšťal všetkých zamestnancov postupne, tak ako to vyžaduje nariadenie. Potom si však uvedomil, že keďže jedinou úlohou celej linky je nájsť najväčšiu mandarínku a poslať ju ku kráľovi, možno by mohol ako dobrý šéf nechať niektorých svojich zamestnancov doma. Teraz rozmýšla nad tým koľko zamestnancov reálne musí chodiť do práce aby linka plnila to na čo bola určená. Viete mu s tým pomôcť?

## Úloha

Na triediacej linke sa v pravidelných rozostupoch nachádza $n$ mandaríniek. Vo firme pracuje $m$ zamestnancov. Každý z nich príde do práce a podľa veľkosti vzostupne utriedi mandarínky na linke medzi $a_i$-tou a $b_i$-tou vrátane, pričom na linke udržiava pravidelné rozostupy. Kleofáš chce vybrať čo najmenej zamestnancov tak, aby vedel zaručiť že ak by prišli do práce iba oni, tak nech je najväčšia mandarínka na začiatku dňa na linke na ľubovolnom mieste, na konci dňa vždy skončí na pozícii $n$. Zistite koľko najmenej zamestnancov musí vybrať do smeny. Nezabudnite že do práce musia prísť v poradí podľa zamestnaneckého čísla.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve celé čísla $n,m$ ($1 \\leq n,m \\leq 300,000$) -- denná produkcia Mandarínska a počet zamestnancov na linke. Na ďaľších $m$ riadkoch sa nachádzajú intervaly na ktorých pracujú jednotliví zamestnanci. Na $i$-tom riadku sa nachádzajú čísla $a_i$ a $b_i$ ($1\\leq a_i \\leq b_i \\leq n$), kde $[a_i, b_i]$ je interval ktorý je triedený zamestnancom so zamestnaneckým číslom $i$.

## Formát výstupu

Na výstup vypíšte jediné číslo -- minimálny počet zamestnancov, ktorý musia prísť do práce na to, aby sa najväčšia mandarínka zaručene dostala na poslednú pozíciu na triediacej linke. V prípade že je na triediacej linke už teraz taký zmätok, že aj bez vynechania zamestnanca sa najväčšia mandarínka nie nutne dostane ku kráľovi, vypíšte $-1$.

## Hodnotenie

Sú $4$ sady vstupov. V jednotlivých sadách platia nasledovné obmedzenia:

1. $n \\leq 10$, $m \\leq 10$
1. $n \\leq 100$, $m \\leq 100$
1. $n \\leq 300,000$, $m \\leq 2,000$
1. $n \\leq 300,000$, $m \\leq 300,000$

## Príklady

```vstup
6 2
1 4
4 6
```

```vystup
2
```

_Obaja zamestnanci musia prísť do práce, inak by sa najväčšia mandarínka z pozície 3 nemohla dostať na koniec linky na pozíciu 6._

```vstup
6 2
4 6
1 4
```

```vystup
-1
```

_V tomto prípade ak sa najväčšia mandarínka nachádza na pozícii 3 tak keď príde do práce prvý zamestnanec tak ju neposunie a druhý zamestnanec ju posunie iba na pozíciu č. 4. Aj keď prídu do práce všetci zamestnanci, najväčšia mandarínka na konci dňa nemusí byť na poslednej pozícii._

```vstup
6 3
1 4
2 5
3 6
```

```vystup
2
```

_Stačí ak do práce príde iba prvý a tretí zamestnanec. Ak najväčšia mandarínka začínala medzi pozíciami 1 až 4, prvý zamestnanec ju umiestni na pozíciu 4. Tretí zamestnanec ju stadiaľ vie položiť na koniec, a zvláda aj prípad kedy mandarínka bola na začiatku na pozícií 5._
","# Mandarínkové kráľovstvo

Pozrime sa na to, aké podmienky musí vybraná postupnosť zamestnancov spĺňať, aby sa najväčšia mandarínka dostala z ľubovoľnej začiatočnej pozície na poslednú. Pre jednoduchosť sa pozrime na prvú mandarínku a ako ona bude cestovať v rámci vybranej množiny zamestnancov.

Vždy, keď mandarínka prejde rukami nejakého zamestnanca, tým že je najväčšia sa ocitne na konci intervalu, ktorý má tento zamestnanec na starosti. Preto precestuje nejakou podpostupnosťou zamestancov až na koniec. Každý ďalší zamestnanec v tejto postupnosti sa prekrýva v pracovnom intervale s intervalom predchádzajúceho zamestnanca. Zároveň na to, aby druhý zamestnanec mandarínku vôbec zodvihol, musí jeho interval končiť až po konci predchádzajúceho intervalu. Posledný zamestnanec, ktorého rukami mandarínka prejde ju dá na posledné miesto. Všimnime si tiež, že táto postupnosť, ktorou prejde najväčšia mandarínka, je istým spôsobom minimálna. To znamená, že keby iba táto časť zamestancov prišla do práce, tak ľubovoľná mandarínka z ľubovoľnej pozície by sa dostala na koniec.

Toto sa dá dokázať tak, že sa paralelne pozrieme na dva prípady: Na to, keď je mandarínka na začiatku na prvej pozícii a na to, keď je na pozícii P. Ak mandarínka z pozície P neskončila na konci na správnej pozícii, tak musela skončiť skôr. Teda mandarínka z pozície 1 ju musela predbehnúť. Pozrime sa na moment, kedy ju predbehla. Zistíme, že v tom momente úradoval jeden konkrétny zamestnanec. Ten mandarínku začínajúcu na pozícii 1 presunul na koniec svojho intervalu, ale mandarínku začínajúcu na pozícii P nie. Toto je však spor, keďže mandarínka z pozície P je tiež najväčšia v tom svojom prípade.

Z tohto vyplýva, že hľadáme najkratšiu možnú postupnosť zamestnancov takú, aby sa prvá mandarínka vedela dostať na poslednú pozíciu. Musí teda spĺňať to, že v postupnosti sú zamestnanci, kde každý ďaľší sa v intervale práce prekrýva s predchádzajúcim a kde aj konce intervalov v poradí rastú.

Na to aby sme našli túto podmnožinu intervalov môžeme použiť dynamické programovanie. A to takým spôsobom, že si pre každú pozíciu budeme pamätať, na koľko najmenej skokov medzi intervalmi sa najväčšia mandarínka vie dostať z prvej pozície na túto. Na začiatku sa mandarínka vie dostať na prvú pozíciu na 0 skokov a na ostatné pozície na nekonečne veľa skokov (inými slovami, nevie sa tam dostať). Potom prichádzajú postupne zamestnanci. Každý zamestnanec môže najväčšiu mandarínku na koniec svojho intervalu preniesť až potom, čo najväčšia mandarínka do tohto intervalu vstúpi. Teda na koniec svojho intervalu do poľa zapíše minimum čísel nájdených v intervale plus jedna.

Priamočiara implementácia tejto myšlienky je taká, že si tieto hodnoty ukladáme do poľa. Potom pre každého zamestnanca nájdeme minimum intervalu ktorý mu prislúcha. Následne, ak je toto číslo menšie ako to, ktoré tam máme aktuálne napísané, tak ho prepíšeme. Na nájdenie minima môžme potrebovať spraviť $O(n)$ krokov. Preto celkovo môže byť časová zložitosť až $O(mn)$.

Lepším riešením môže byť napríklad použiť [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/). Ten nám umožní zistiť minimum intervalu v čase $O(log n)$. Tým sa nám zlepší časová zložitosť na $O(m log n + n)$. Pamäťová zložitosť bude kvôli zamestnancom a intervalovému stromu $O(n + m)$.
",8
f2be6d847ee9c75f,ksp,"# Osvetlenie

Korporácia Svetelných Prístrojov konečne predstavila svoj nový produkt. Je ním systém osvetlenia, ktorý sa skladá zo žiaroviek usporiadaných do mriežky $n\\times m$ a ku každej žiarovke prislúcha jedno tlačidlo, ktoré ju má prepínať.

Keď už bola výroba v plnom prúde, zistili, že niekomu z Federácie Kazisvetov a Sabotérov sa podarilo prepísať ich schémy, a teda všetky vyrobené kusy obsahujú chybu. Konkrétne, keď prepnete niektorú žiarovku, prepnú sa aj všetky susedné žiarovky (za susedné považujeme $4$ žiarovky, ktoré sú od nej hore, dole, napravo a naľavo). Čo spraviť so všetkými týmito vadnými kusmi? Začali ich predávať ako špeciálnu edíciu.

Po krátkom čase bol ich technical support zahltený požiadavkami typu: ""Dá sa nejak zapnúť táto a hentá a tamtá a ešte tieto tu žiarovky?"". Samozrejme, nikto nemá čas tieto požiadavky riešiť, a preto potrebujú vašu pomoc.

## Úloha

Na vstupe dostanete požadovaný stav, ktoré žiarovky majú byť zapnuté a ktoré vypnuté. Na začiatku sú všetky žiarovky vypnuté a vašou úlohou je zistiť, ktoré tlačidlá treba stlačiť, aby sa žiarovky dostali do požadovaného stavu.

## Formát vstupu

Na prvom riadku dostanete dve celé čísla ($1 \\le n, m \\le 30$). Nasleduje $n$ riadkov, ktoré popisujú mriežku žiaroviek. Každý z nich sa skladá z $m$ čísel, ktoré môžu byť $0$ alebo $1$. $0$ znamená, že daná žiarovka má byť vypnutá a $1$ znamená, že daná žiarovka má byť zapnutá.

## Formát výstupu

Ak riešenie neexistuje, vypíšte $-1$.

Ak existuje, vypíšte $n$ riadkov po $m$ čísel. Vypíšte $0$, ak tlačidlo, ktoré patrí žiarovke na danom mieste, nemá byť stlačené a $1$, ak má byť stlačené.

## Hodnotenie

Sú $4$ sady vstupov. Platia v nich nasledovné obmedzenia:

1. $n, m \\le 10$
1. $n, m \\le 20$
1. $n, m \\le 30$, existuje vždy práve jedno riešenie
1. $n, m \\le 30$

## Príklady

```vstup
3 3
1 1 1
1 1 1
1 1 1
```

```vystup
1 0 1
0 1 0
1 0 1
```

```vstup
3 2
0 1
0 0
1 1
```

```vystup
-1
```
","# Osvetlenie

V tejto úlohe bolo treba určiť, ktoré tlačidlá, prepínajúce žiarovku spolu s jej susedmi, treba stlačiť, aby sme dosiahli požadovanú konfiguráciu zapnutých žiaroviek.

## Pomalšie riešenie

Dôležité pozorovanie je, že keď si zafixujeme, ktoré tlačidlá v prvom riadku stlačíme, zvyšok je už jednoznačný. Pozrime sa na žiarovky v prvom riadku potom, ako stlačíme tlačidlá v prvom riadku. Niektoré sú v správnom stave a niektoré sú v nesprávnom. Tie žiarovky, ktoré sú nesprávne, musíme ešte prepnúť a jediné tlačidlo ktoré ešte môžeme použiť je to priamo pod ňou (tlačidlá v prvom riadku máme zafixované). Naopak, tlačidlo pod správnou žiarovkou nesmieme prepnúť, lebo by sme ju prepli do nesprávneho stavu. To nám jednoznačne určuje, ktoré tlačidlá v druhom riadku treba stlačiť.

Takto môžeme pokračovať. Teraz každú žiarovku v druhom riadku vieme prepnúť len tlačidlom priamo pod (tie v prvom a druhom riadku sú určené) a teda vieme, ktoré tlačidlá v treťom riadku treba stlačiť.

Toto opakujeme postupne pre všetky riadky, až kým určíme ktoré všetky tlačidlá budú stlačené.

Stačí nám teda vyskúšať všetky možnosti pre prvý riadok, podľa vždy toho určiť zvyšok a skontrolovať, či dosiahneme, že všetky žiarovky sú správne.

Dokopy je $2^m$ možností pre prvý riadok. Každú možnosť vyskúšame v $O(nm)$. Časová zložitosť tohto riešenia je $O(2^nnm)$.

## Zrýchlenie

Toto riešenie vieme zrýchliť pomocou bitovej mágie. Každý riadok žiaroviek budeme reprezentovať jedným číslom, ktorého binárna reprezentácia hovorí o tom, ktoré žiarovky sú zapnuté a ktoré sú vypnnuté. Tak isto budeme reprezentovať stlačené a nestlačené tlačidlá.

Potom pomocou bitových operácií (`^`, `<<`, `>>`, `&`, `|`) vieme vyhodnotiť každý riadok v konštantnom čase:

1. Máme číslo ktoré reprezentuje tlačidlá ktoré chceme stlačiť, nazvime ho $s$. Na základe toho chceme aktualizovať aktuálny stav žiaroviek. Riadok nad a riadok pod nám stačí zmeniť na **xor** (`^`) hodnoty toho riadku a $s$. Takto sa zmenia bity na tých miestach, kde boli jednotky v $s$. V aktuálnom riadku potrebujeme prepnúť žiarovky na miestach kde bolo stlačené tlačidlo a ešte naľavo a napravo od nich. Najprv na riadok aplikujeme **xor** s $s$, čím prepneme tie na stlačených miestach. Potom môžeme použiť bitový posun doprava a doľava (`>>`, `<<`) na to, aby sme dostali jednotky na pozíciach napravo a naľavo od stlačených tlačidiel. Riadok teda ešte pre**xor**ujeme `s>>1` a `s<<1`, čím prepneme tieto žiarovky. Nakoniec si treba dať pozor aby sme odstránili jednotky za $m$-tou pozíciou, ktoré mohli vzniknúť bitovým posunom. Na to použijeme **and** (`&`) s číslom `(1<<m)-1`, ktoré má jednotky na prvých $m$ pozíciach.
1. Ako druhý krok musíme porovnať aktuály stav žiaroviek s očakávaným stavom žiaroviek, aby sme zistili, ktoré tlačidlá v ďalšom riadku treba stlačiť. Na to použijeme znova **xor** aktuálneho stavu s očakávaným stavom. Na miestach kde sa líšia dostaneme $1$ a na ostatných miestach $0$.

## Vzorové riešenie

Označme si $z\_{i,j}$ požadovaný stav žiarovky ($0$ = vypnutá, $1$ = zapnutá) v riadku $i$ a stĺpci $j$, ktorý dostaneme na vstupe. Podobne si označme $t\_{i,j}$ stav tlačidla ($0$ = stlačené, $1$ = nestlačené) v riadku $i$ a stĺpci $j$.

Celú úlohu teraz vieme zapísať pomocou sústavy lineárnych rovníc modulo $2$. Hľadáme také hodnoty premenných $t\_{i,j}$, aby platili rovnice typu:

$t\_{i,j}+t\_{i+1,j}+t\_{i-1,j}+t\_{i,j+1}+t\_{i,j-1} \\equiv z\_{i,j}\\ (\\textrm{mod}\\ 2)$

To znamená, že z tých piatich tlačidiel, ktoré vedia prepnúť danú žiarovku, musí byť počet stlačených modulo $2$ rovnaký, ako požadovaný stav žiarovky.

Na vyriešenie takejto sústavy rovníc môžeme použiť [Gaussovu eliminačnú metódu](https://en.wikipedia.org/wiki/Gaussian_elimination). Treba len dať pozor na to, že sme modulo $2$, teda $1+1=0$ a podobne.

Gaussova eliminácia pri $k$ rovniciach o $k$ neznámych má časovú zložitosť $O(k^3)$. V našom prípade je $k=nm$, teda časová zložitosť celého prgramu je $O((nm)^3)$.
",9
25bdfeea5062c4bf,ksp,"#Zárobkom do nového roka

""2016? No do ..... bre."" zahundral hračkár Hilbert. Rozlepil oči, utrel si zemiakový šalát tečúci z ucha a dal si rozbehový krémeš na dobré ráno. Sviatky ako majú byť. Treba ale ísť do práce a urobiť koncoročnú uzávierku. Vianoce sú totiž každoročne výdatné na zákazníkov a aj na tržby. Hilbert už presne vie, ako to funguje. Do obchodu príde človek a kúpi prvý darček, ktorý mu je ponúknutý. Človek zaň zaplatí a beží do ďalšieho obchodu. Je prakticky jedno, o aký predmet sa jedná. Dokonca ani nezáleží na cene, pokiaľ nie je príliš vysoká. Všetko závisí od toho, ako málo času ostáva do Vianoc -- čím menej času, tým väčšie výčitky svedomia má konkrétny nešťastník, a tým viac je ochotný za darček zaplatiť.

Hilbertovi sa stačí pozrieť na hodinky a hneď vie, koľko peňazí môže zákazník minúť. No a to sa dá úžasne využiť. Stačí vždy nájsť najdrahší darček, ktorý je daný človek ešte ochotný kúpiť a ponúknuť mu ho. Hilbertovo podnikavé srdce teraz kruto zaplakalo. Tento prešibaný plán počas minulého roka ani raz nepoužil... To sa však s novým rokom zmení!

Hilbert by predsa len rád vedel, ako by bol jeho biznis prekvital, ak by túto metódu použil už predošlé Vianoce. Podarilo sa mu zrekonštruovať zoznam ľudí, ktorí prišli do jeho obchodu, no nie je si úplne istý, koľko mohol na každom z nich zarobiť.

## Úloha

Na vstupe máte **vzostupne usporiadané** ceny darčekov v Hilbertovom obchode. Postupne k nemu prichádzajú ľudia. Každý človek má maximálne množstvo peňazí, ktoré je ochotný minúť na darček. Človek, ktorý príde neskôr bude vždy ochotný minúť **aspoň toľko** ako ten, čo prišiel pred ním. Pre každého človeka vypíšte cenu najdrahšieho darčeka, ktorý si ešte môže dovoliť, a ktorý mu teda Hilbert ponúkne. Po tom, čo si ho zákazník kúpi, ho už Hilbert nemôže ponúkať ďalej.

## Formát vstupu

Na prvom riadku sú dve čísla $n$ a $m$ ($1 \\leq n \\leq 1,000,000$, $1 \\leq m \\leq 1,000,000$) -- počet darčekov, ktoré má Hilbert v obchode a počet zákazníkov, ktorý k nemu prídu.

Na druhom riadku je **vzostupne usporiadaná** postupnosť $n$ kladných celých čísel $c_i$ ($1\\leq c_i \\leq 10^9$) -- ceny darčekov v Hilbertovom obchode.

Na treťom riadku je **vzostupne usporiadaná** postupnosť $m$ kladných celých čísel $p_i$ ($1\\leq p_i \\leq 10^9$) -- množstvo peňazí, ktoré je ochotný minúť $i$-ty zákazník.

V polovici sád navyše platí, že $1 \\leq n \\leq 1,000$ a $1 \\leq m \\leq 1,000$.

## Formát výstupu

Pre každého zákazníka vypíšte cenu najdrahšieho darčeka, ktorý mu môže Hilbert ponúknuť. Ak taký nie je, vypíšte $0$.

## Príklad

```vstup
8 10
1 2 2 2 5 7 10 20
1 1 2 3 6 6 15 21 21 22
```

```vystup
1 0 2 2 5 2 10 20 7 0

```

_Druhému zákazníkovi nevie Hilbert ponúknuť žiadny darček, lebo jediný predmet s cenou nanajvýš 1 si kúpil prvý zákazník. Takisto si všimnite, že aj keď je deviaty zákazník ochotný za darček zaplatiť až cenu 21, Hilbert mu vie ponúknuť iba predmet s cenou 7, lebo zvyšné rozpredal predošlým zákazníkom._
","# Zárobkom do nového roka

Najjednoduchšie, čo môžeme spraviť, je celú situáciu simulovať. Budeme si jednoducho pamätať všetky darčeky, ktoré ešte Hilbert nepredal, a postupne ich predávať. Otázkou je, ako to vieme robiť rýchlo.

## Riešenie hrubou silou

Stačí mať jedno pole (C++ vector), v ktorom si udržiavame ceny ešte nepredaných darčekov. Na ňom potom potrebujeme robiť nasledovné operácie:

1. Nájdenie darčeku s najvyššou cenou neprevyšujúcou nejakú hranicu
1. Predanie (odstránenie) darčeka

Operáciu 1 vieme robiť triviálne v čase $O(n)$. Stačí prejsť všetky darčeky a pamätať si, aký najdrahší sme zatiaľ videli. Odstraňovanie darčeku je za normálnych okolností tiež lineárne, lebo musíme posunúť všetky darčeky za ním. Dá sa ale urobiť finta na skonštantnenie tohoto času. Môžeme totiž najprv vymeniť chcený darček s posledným a potom iba vector o jedna skrátiť. Podobne by sme daný darček mohli len prepísať na $0$. S časovou zložitosťou si ale aj tak veľmi nepomôžeme.

Pre každého človeka, čo príde do obchodu, musíme nájsť darček v $O(n)$ a teda dostaneme riešenie v čase $O(nm)$ s pamäťou $O(n)$, ktoré nám získa $2$ body.

Mohlo by nám napadnúť, že operácia 1 sa by sa mohla dať vyriešiť binárnym vyhľadávaním. Potom by sme ju vedeli robiť v $O(\\log(n))$. Problém ale je, že pre operáciu 2 by sme nevedeli použiť našu fintu (tá totiž nezachováva usporiadanie) a stále by sme ostali na čase $O(nm)$.

## Riešenie hrubou STL^\[Standard library: [http://www.cplusplus.com/reference/stl/](http://www.cplusplus.com/reference/stl/)\] silou

Binárne vyhľadávanie nám síce veľmi nepomohlo, **binárny vyhľadávací strom** nám ale pomôcť môže. Je to štruktúra, ktorá zvláda pridávanie nových prvkov, vymazávanie a vyhľadávanie prvkov a to všetko v čase $O(\\log(n))$. Takáto funkcionalita je už implementovaná v štandardnej C++kovej knižnici pod krycím názvom **multiset**. Stačí túto čarovnú štruktúru inicializovať, naplniť ju darčekmi, a potom v nej len vyhľadávať pomocou metódy **lower_bound** a vymazávať pomocou **erase**. Nakoľko pridávanie je logaritmické, vieme ju naplniť v čase $O(n\\log(n))$ a pre každého človeka vyhľadávať a mazať tiež v $O(\\log(n))$. Dostaneme teda riešenie v čase $O(n\\log(n) + m\\log(n))$. Vďaka tomu, že sú darčeky na vstupe usporiadané, je vkladanie možné aj v konštantnom čase a teda výsledná časová zložitosť by bola len $O(n + m\\log(n))$, čo ale nie je podstatné zlepšenie. Pamäťovú zložitosť máme stále $O(n)$. Toto riešenie je dostatočne rýchle pre všetky testovacie sady, no plný počet za popis neprinesie.

## Optimálne riešenie

Zatiaľ sme takmer vôbec nevyužili usporiadanie darčekov a ľudí na vstupe. To by nám mohlo napovedať, že ešte nemáme optimálne riešenie. Predstavme si nasledujúcu situáciu: do obchodu príde Ferko a kúpi nejaký darček. Keď po ňom príde Jožko, aký darček kúpi? Jožko je určite aspoň tak bohatý ako Ferko. Buď si kúpi niečo, čo mohol kúpiť aj Ferko, alebo kúpi niečo, čo si Ferko nemohol dovoliť. Inak povedané, keď prišiel do obchodu Ferko, mal množinu darčekov, ktoré si mohol dovoliť. Z nej si vybral ten najdrahší. Keď potom prišiel Jožko, tiež mal množinu darčekov, ktoré si mohol dovoliť. V nej boli **všetky** tie darčeky, čo si mohol dovoliť Ferko (okrem toho, ktorý si Ferko kúpil) a všetky, ktoré si Ferko kúpiť nemohol, no Jožko už áno.

To znamená, že nám stačí udržiavať množinu kúpiteľných a množinu nekúpiteľných darčekov. Keď príde nový človek, presunieme z nekúpiteľných do kúpiteľných všetky darčeky, ktoré si daný človek už môže dovoliť. Teda niekoľko najlacnejších nekúpiteľných darčekov prehlásime za kúpiteľné. Potom zistíme, či je množina kúpiteľných darčekov prázdna a ak nie je, predáme z nej najdrahší darček. Na začiatku sú všetky darčeky nekúpiteľné a vieme, že na vstupe sú **vzostupne** usporiadané. Vďaka tomu si môžeme nekúpiteľné darčeky pamätať vo fronte^[Jednoduchá dátová štruktúra -- zoznam, do ktorého na jednom konci vkladáme prvky a na druhej strane ich vyberáme.], do ktorej ich najprv dáme. Kúpiteľné si potom môžeme pamätať v zásobníku^[Zoznam, do ktorého vkladáme a z ktorého vyberáme na rovnakom konci]. Potom, keď budeme presúvať nejaký darček D z nekúpiteľných do kúpiteľných, tak vieme, že D bol najlacnejší z nekúpiteľných a bude najdrahší z kúpiteľných.

Nakoľko každé presunutie robíme v konštantnom čase a každý darček presunieme maximálne raz, dostávame riešenie s časovou zložitosťou $O(m+n)$ a potrebnou pamäťou $O(n)$.

Všetky spomenuté dátové štruktúry sa dajú pekne implementovať pomocou poľa.

Prípadne vieme použiť aj knižničné funkcie a štruktúry ako queue (fronta) a stack (zásobník).
",4
291eabc8df4f003d,ksp,"# Hurá leto!

Prišlo leto. Poznáte to, prázdniny, oddych, kľud. Žaba sa tiež tešil na túto udalosť. Prišiel domov, hodil sa na posteľ a okamžite z nej spadol.

Celý ubolený sa spamätávajúc pozerá, čo sa stalo s jeho útulnou a pohodlnou postieľkou, že ho takto odmieta. Na jeho zhrozenie zistil, že mama Žabica mu poupratovala izbu a natlačila všetko do škatulí pod Žabovu posteľ. Trochu jej to ale nevyšlo. Posteľ teraz stojí nakrivo, pretože škatule sú vyššie ako samotná posteľ!

Žaba sa teda rozhodol, že vynesie škatule na povalu. Chcel by to ale, pochopiteľne, urobiť na čo najmenej otočení. Začal ukladať škatule jednu na druhú, no všimol si, že niektoré sú trochu vlhké. Ako vieme, vlhké, poloprázdne škatule udržia menej, než také škatule plné kníh (tie vydržia hocičo). Žaba teda odhadol pevnosť každej škatule, usporiadal ich podľa svojich odhadov a konečne išiel spať. Pomôžte mu a rozdeľte škatule na čo najmenej veží, aby ich mohol odniesť, keď vstane.

## Úloha

Máte pred sebou $n$ rovnako veľkých škatúl, líšiacich sa iba ich pevnosťou, usporiadaných podľa ich pevnosti. *Pevnosť* škatule predstavuje počet škatúľ, ktoré môžu byť vo veži položené nad danou škatuľou (teda škatuľa s pevnosťou $0$ musí byť na vrchu veže, škatuľa s pevnosťou $1$ môže byť buď na vrchu alebo druhá zhora atď.). Zistite, koľko najmenej veží vie Žaba z týchto škatúľ postaviť, ak musí použiť všetky škatule!

## Formát vstupu

Na začiatku vstupu sa nachádza číslo $n$ ($1 \\leq n \\leq 10^5$) -- počet škatúľ, ktoré Žaba našiel pod posteľou. Na ďalšom riadku je $n$ medzerou oddelených čísel (zoradených vzostupne) popisujúcich pevnosti jednotlivých škatúľ -- číslo na $i$-tom mieste určuje pevnosť $i$-tej škatule. Pevnosť každej škatule je celé číslo medzi $0$ a $10^5$ vrátane.

## Formát výstupu

Na výstup vypíšte jedno číslo -- najmenší počet veží, ktorý sa dá postaviť za použitia všetkých škatúľ.

## Upozornenie

Na získanie plného počtu bodov za popis je potrebné vyriešiť túto úlohu v najlepšej možnej asymptotickej časovej zložitosti. Plný počet bodov za program sa dá získať aj riešeniami s trochu horšou časovou zložitosťou.

## Príklad

```vstup
3
0 1 2
```

```vystup
1
```

_Všetky škatule môžeme naukladať do jednej veže._

```vstup
4
2 2 2 2
```

```vystup
2
```

_Ak by sme chceli postaviť iba jednu vežu, najspodnejšia škatuľa by musela mať pevnosť aspoň 3. Môžeme však postaviť dve veže po dve škatule, alebo jednu vežu z troch škatúľ a jednu vežu z jednej škatule._
","# Hurá leto!

Toto vzorové riešenie má dve časti. V prvej časti sa pozrieme, ako má Žaba ukladať škatule, aby vytvoril čo najmenej kôp. V druhej časti budeme riešiť, ako toto uloženie efektívne vypočítať.

Mohli by sme sa do toho pustiť intuitívne. Postavíme si najsilnejšiu škatuľu a začneme na ňu ukladať ostatné škatule. Tento prístup má ale svoje problémy. Napríklad, ak máme ďalšiu, rovnako pevnú škatuľu, nevieme, či ju máme položiť na tú prvú, alebo si ju máme šetriť do ďalšej kopy. Konkrétny príklad: ak máme iba dve škatule s pevnosťou $1$, oplatí sa ich postaviť na seba. Na druhú stranu, ak máme navyše ešte dve škatule s pevnosťou $0$, viac sa nám oplatí ""jednotkové"" škatule rozdeliť.

## Austrália

Skúsme sa na to teda pozrieť opačne. Stavajme kopy ""odvrchu"". Novú kopu začneme jej najslabšou škatuľou. Ďalej budeme pridávať čoraz silnejšie škatule, vždy na *spodok* kopy.

Teraz už k samotnému ukladaniu škatúľ. Berme škatule od najslabšej po najpevnejšiu a ukladajme ich do kôp. Vždy, keď ukladáme nejakú škatuľu, musíme sa rozhodnúť, či ňou začneme novú kopu, alebo ju pridáme pod nejakú už existujúcu. Ak sme sa rozhodli pridať škatuľu pod niektorú z už existujúcich kôp, musíme si navyše vybrať pod ktorú. Prirodzene sa nám núka položiť škatuľu pod najväčšiu kopu, ktorú je ešte schopná uniesť, aby sme ""neplytvali pevnosťou"". Pokiaľ naša škatuľa nie je schopná uniesť žiadnu z existujúcich kôp, začneme novú kopu. Takýmto spôsobom vieme rozdeliť všetky škatule do niekoľkých kôp. Dostaneme ale zaručene najmenší možný počet kôp?

## Zdôvodnenie správnosti

Treba si uvedomiť, že môže existovať viacero spôsobov, ako škatule rozdeliť na najmenší možný počet kôp. Tieto spôsoby budeme ďalej volať *optimálne riešenia*. My chceme ukázať, že náš postup rozdelí škatule jedným z nich. Nato si ukážeme, že po každej pridanej škatuli v našom postupe je ešte možné doplniť ostatné škatule tak, aby sme dostali jedno z optimálnych riešení. Ak toto bude platiť aj po pridaní poslednej škatule, znamená to, že sme vytvorili optimálne riešenie.

Predpokladajme, že sme už umiestnili prvých $k$ škatúľ a ešte stále je možné doplniť ostatné škatule tak, aby vzniklo optimálne riešenie. Škatuľu, ktorú by náš algoritmus umiestnil ako ďalšiu (teda $k+1$-vú najslabšiu škatuľu) označme $X$ a miesto, kam by ju dal, označme $m$. Doplňme ostatné škatule tak, aby vzniklo optimálne riešenie a pozrime sa, kde v ňom je škatuľa $X$. Ak náš algoritmus nechcel škatuľou $X$ začať novú kopu, môžu nastať 3 prípady:

1. Škatuľa $X$ sa nachádza na mieste $m$.

1. Škatuľa $X$ je niekde inde a na mieste $m$ sa nachádza nejaká iná škatuľa $Y$. Vieme, že všetky škatule slabšie než $X$ sú umiestnené tam, kam ich dal náš algoritmus. To znamená, že škatuľa $Y$ nemôže byť jedna z nich, a teda musí byť aspoň tak pevná, ako škatuľa $X$. Ak teraz vymeníme škatule $X$ a $Y$, škatuľa $Y$ určite bude schopná niesť záťaž, ktorú predtým niesla škatuľa $X$. Škatuľa $X$ sa tým ocitne na mieste $m$, kam ju chcel dať aj náš algoritmus, a teda tiež určite unesie svoj náklad. Takto sme dostali iné riešenie Žabovej úlohy, ktoré je tiež optimálne (má rovnako veľa kôp) a navyše má škatuľu $X$ na mieste $m$.

1. Škatuľa $X$ je inde ako na mieste $m$ a miesto $m$ je prázdne. V takom prípade môžeme škatuľu $X$ preniesť na miesto $m$. Škatuľa $X$ svoj nový náklad určite unesie, rovnako aj všetky ostatné škatule (škatuliam, ktoré boli pod $X$ sa náklad odľahčil o škatuľu $X$, ostatným sa nezmenil). Opäť sme dostali optimálne riešenie, kde je škatuľa $X$ na mieste $m$.

Ak náš algoritmus chcel škatuľou $X$ začať novú kopu, znamená to, že by neuniesla žiadnu z kôp, ktoré existovali po umiestnení prvých $k$ škatúľ. Aj v optimálnom riešení preto $X$ musí byť v nejakej inej kope. Za miesto $m$ teraz budeme považovať vrch kopy obsahujúcej škatuľu $X$. Ak je $X$ navrchu tejto kopy, situácia je rovnaká ako v prípade 1, ak nie je navrchu, situácia je rovnaká ako v prípade 2.

V každom prípade existuje optimálne riešenie, v ktorom je škatuľa $X$ na mieste $m$, teda aj keby sme nechali náš algoritmus umiestniť prvých $k+1$ škatúľ, zvyšné škatule by sa určite dali doplniť do optimálneho riešenia.

Ak našu predošlú úvahu urobíme pre $k=0$, dostávame, že prvú škatuľu náš algoritmus umiestni dobre, t.j. bude možné doplniť zvyšné škatule do optimálneho riešenia. Zopakovaním úvahy pre $k=1$ dostávame, že aj druhú škatuľu náš algoritmus umiestni dobre. Úvahu postupne zopakujeme pre $k = 2, 3, \\dots, n-1$ a dostaneme, že aj keď necháme náš algoritmus umiestniť všetkých $n$ škatúľ, bude možné doplniť zvyšných $0$ škatúľ do optimálneho riešenia^\[Technike, ktorú sme práve použili, sa hovorí *matematická indukcia*\]. To ale znamená, že náš algoritmus vytvoril optimálne riešenie.

## Implementácia

Ukázali sme si algoritmus, ktorým Žaba môže ukladať škatule. Teraz ešte napísať program, ktorý to odsimuluje.

Jedno z pozorovaní, ktoré nám pomôžu pri implementácii je, že ono si nám vlastne netreba pamätať, čo v kope je, stačí nám vedieť veľkosť kopy. Prečo? Keď škatule vkladáme na spodok kopy, potrebujeme iba skontrolovať, či počet vecí na tejto kope nie je väčší, než pevnosť škatule. Toto nám o dosť zjednoduší programovanie nášho riešenia.

Ako vidíme, skutočne len pre každú škatuľu prechádzame všetky potenciálne kôpky a uložíme to na prvú, na ktorú má naša aktuálna škatuľa dosť pevnosti. Toto riešenie má ale časovú zložitosť $O(n^2)$. Zoberme si napríklad, že všetky škatule čo dostaneme, by boli z papundekla, teda pevnosti 0. Pre každú škatuľu musíme prejsť všetky doteraz urobené kôpky a vyrobiť si novú.

## Optimalizácia

Ďalšie z našej série pozorovaní je, že vyššie uvedený algoritmus má vedľajší efekt. V každom kroku nášho algoritmu sú všetky kôpky zoradené zostupne, podľa veľkosti! Ako správny KSP-áci toto predsa hneď musíme zneužiť. Čo vieme robiť na zoradenom poli? No predsa binárne vyhľadávanie!

Medzi zoradenými kôpkami teda vieme pomocou binárneho vyhľadávania, v čase $O(\\log n)$, nájsť našu ideálnu kôpku pre aktuálnu škatuľu. Toto nám zlepší celkovú časovú zložitosť na $O(n \\log n)$.

Implementovanie samotnej funkcie `bin_najdi_kopku` nechávame ako cvičenie pre čítateľa.

## Viac optimalizácií

Keď sa trochu zamyslíme nad vyššie spomínanou optimalizáciou, zistíme, že my vlastne vôbec nemusíme binárne vyhľadávať v takomto poli kôpok.

Predpokladajme, že prvých zopár škatúľ už máme nejako rozostavaných a teraz ideme umiestniť skupinu škatúľ s rovnakou pevnosťou. Kam by ich dal náš $O(n \\log n)$ algoritmus? Najskôr by ich dával pod prvú kôpku, ktorú sú schopné udržať. Následne by pokladal ďaľšie škatule pod túto istú kôpku, až dokedy by nebola príliš veľká pre našu silu škatúľ. Pokiaľ je už aktuálna kôpka príliš veľká, posunieme sa na ďaľšiu. Ďaľšia kôpka je zaručene dostatočne malá na to, aby sme pod ňu mohli umiestniť aspoň jednu škatuľu.

Keď prechádzame na škatule s väčšou pevnosťou, tieto pevnejšie škatule sú určite schopné uniesť všetky existujúce kopy. Má teda zmysel sa po tomto prechode vrátiť opäť na prvú kôpku a postup opakovať, teraz už ale so silnejšími škatuľami.

Tento algoritmus má časovú zložitosť $O(n)$, keďže pre každú škatuľu nájdeme príslušnú kopu v konštantnom čase. Všetky doteraz spomínané riešenia majú pamätovú zložitosť $O(n)$, pretože si potrebujeme pamätať iba dve polia dĺžky najviac $n$: pevnosti škatúľ a veľkosti kôp.

Toto je naše optimálne riešenie a dostaneme zaň pekných 8 bodov.

*Poznámka:* Pochopiteľne, konverzia, ktorú funkcia `skatule_sily` vykonáva nie je vôbec potrebná ku korektnej funkčnosti nášho algoritmu. Tento upravený formát vstupu nám iba umožňuje mať prehľadnejší kód v `pocet_kopok`.

## Exotika

Náš miestny zelovocár s exotickými riešeniami vymyslel aj riešenie, ktoré má časovú zložitosť $O(n)$ a pamäťovú $O(1)$. Funguje na trochu inom príncípe ako všetky naše riešenia, ktoré sú konštruktívne - snažia sa škatule naozaj rozdeliť na kopy. Toto riešenie je nekonštruktívne. Pre každú škatuľu na základe jej pevnosti a počtu slabších škatúľ vypočíta dolný odhad na počet všetkých kôp. Nájsť toto riešenie je pekným cvičením pre trochu skúsenejších riešiteľov.
",4
48832225442184d0,ksp,"# Hurá na Oravu

Andrej trávil túto ukrutnú zimu na chate v lyžiarskom stredisku na Orave. Ako každý správny lyžiar. Jedného dňa našiel na samom spodku strediska billboard s reklamou na najlepšiu pečenú klobásku na Orave. Bufet s klobásou sa mal nachádzať pri jednej z mnohých staníc lanovky, ktoré sa v stredisku nachádzali. Informácie na billboarde tiež obsahovali šifrovanú mapu popisujúcu cestu k bufetu.

Mapa k bufetu sa skladala iba z písmen `L` a `P`. Lyžiarske stredisko, v ktorom sa lyžoval, totiž vyzeralo nasledovne. Na samom spodku, teda tam kde stál Andrej, bola stanica lanovky s číslom 1. Tou sa mohol vyviezť buď na vrch ľavého alebo pravého svahu. Každý z týchto svahov mal na vrchole ďalšiu stanicu lanovky, z ktorej sa opäť dalo vyviezť na vrch ľavého alebo pravého svahu, na ktorých vrcholoch boli ďalšie stanice s lanovkami vedúcimi doľava a doprava...

Každá stanica lanovky bola naviac označená jedným číslom a pre tieto čísla platila nasledovná vlastnosť. Keď sa človek vyviezol ľavou lanovkou, dostal sa do stanice s číslom dvakrát väčším ako bolo číslo stanice, z ktorej vychádzal. A ak si vybral pravú lanovku, toto číslo bolo o jedna väčšie ako dvojnásobok východzej stanice. Ako správny gurmán (a lyžiar) si Andrej povedal, že musí zistiť, či billboard vraví pravdu a vydal sa na cestu za klobáskou.

Prešlo niekoľko dní a Andrej sa stále nevracal. Jeho rodina teda horskej službe nahlásila, že sa stratil cestou za najlepšou klobáskou Oravy. To bol pre záchranárov dostatočný záchytný bod a ponáhľali sa k billboardu s mapou, aby zistili, pri ktorej stanici lanovky by Andrej mohol byť. Nanešťastie, billboard bol poškodený a niektoré písmená mapy boli nečitateľné. Zúfalí záchranári teraz potrebujú vašu pomoc. Pri ktorých staniciach sa môže nachádzať bufet s klobáskou a snáď aj Andrej?

## Úloha

Vašou úlohou je napísať program, ktorý na výstup vypíše súčet všetkých čísel staníc lanovky, pri ktorých môže byť bufet s klobáskou. K dispozicii máte mapu skladajúcu sa zo znakov `L`, `P` a `*`. Znak `*` reprezentuje poškodené miesta na mape, na ktorých mohol byť pôvodne ľubovoľný zo znakov `L` a `P`. Táto mapa popisuje cestu k bufetu začínajúcu pri stanici číslo 1.

Mapa sa číta zľava doprava. Ak sa nachádzame na stanici s číslom $k$, tak pri písmene `L` sa musíme posunúť doľava do stanice $2k$ a pri písmene `P` doprava do stanice $2k + 1$. Pri znaku `*` musíme počítať s obomai možnosťami -- stanicami $2k$ aj $2k+1$.

## Formát vstupu

Vstup tvorí jediný riadok obsahujúci postupnosť znakov `L`, `P` a `*`, ktorá popisuje mapu ku klobáske. Táto postupnosť bude mať dĺžku najviac $10^5$.

## Formát výstupu

Na výstup vypíšte jedno číslo -- súčet všetkých čísel staníc lanovky, pri ktorých sa môže nachádzať bufet. Keďže toto číslo môže byť pomerne veľké, vypíšte iba jeho zvyšok po delení $1,000,000,007$.

## Príklady

```vstup
P*L*
```

```vystup
106
```

*Mapa popisuje cestu od stanice číslo $1$. V prvom kroku musíme ísť doprava (znak `P`), teda do stanice $3$. Následne nevieme, ktorým smerom ísť, môžeme preto ísť buď do stanice $6$ alebo $7$. Ďalší krok vedie doľava, teda sa môžeme ocitnúť buď pri stanici $12$ (naľavo od $6$) alebo $14$ (naľavo od $7$). Nakoniec opäť nevieme, ktorým smerom ísť, takže bufet môže byť pri ľubovoľnej zo staníc $24$, $25$, $28$ alebo $29$. Hľadaný súčet je preto $24 + 25 + 28 + 29 = 106$.*

```vstup
**
```

```vystup
22
```
","# Hurá na Oravu

Našou úlohou bolo nájsť súčet čísel všetkých staníc, na ktorých mohol Andrej skončiť, ak sa riadil pokynmi na mape, na ktorej boli pôvodne iba dva typy pohybu -- vľavo a vpravo. Vypočítať číslo novej stanice bolo pritom veľmi jednoduché. Ak Andrej stál pri stanici s číslom $k$ a pohol sa doľava, dostal sa do stanice $2k$, ak išiel doprava, tak do stanice $2k +1$. V úlohe bol však jeden zádrheľ. Keďže niektoré pokyny na mape boli nečitateľné (`*`), museli sme pri nich brať do úvahy obe možnosti.

## Simulácia

Na začiatok môžeme skúsiť odsimulovať Andrejov pohyb po lyžiarskom stredisku. Pokyny z mapy budeme spracovávať jeden po druhom a celý čas si budeme pamätať čísla všetkých staníc, na ktorých sa Andrej mohol nachádzať. Na začiatku bol Andrej v stanici číslo 1.

Pokyny sa spracovávajú jednoducho. Ak je na mape `L`, tak prejdeme cez všetky čísla a vynásobíme ich 2, pri `P` k nim okrem zdvojnásobenia pripočítame 1. Jediný problém je znak `*`, pri ktorom z každej stanice vedú dve možnosti. Preto si zapamätáme obe z nich, ak bol Andrej v stanici $k$ tak po znaku `*` mohol byť aj v stanici $2k$ aj v $2k + 1$. Po spracovaní všetkých znakov z mapy jednoducho spočítame výsledné čísla staníc, čím dostaneme hľadanú odpoveď.

Problémom je však pamäťová a časová zložitosť. Pri každom znaku `*` zdvojnásobujeme počet čísel, ktoré si musíme pamätať. Preto ak by na mape boli samé `*`, čo sa stať môže, tak pamäťová aj časová zložitosť je $O(2^n)$.

## Optimalizácia

Keď sa snažíme zlepšiť nejaké riešenie, vždy sa oplatí zamyslieť sa nad tým, či **nerobíme niečo zbytočne**. Hľadaným výsledkom je súčet všetkých staníc, kde sa Andrej môže nachádzať. Nepotrebujeme však vedieť, ktoré konkrétne stanice to sú. Možno si ich teda nemusíme pamätať.

Predstavme si, že Andrej môže byť v staniciach s číslami $p$, $q$, $r$ a $s$. Ak pôjde doľava (`L`), tak bude môcť byť v staniciach $2p$, $2q$, $2r$ a $2s$, ktorých súčet je dvakrát väčší ako súčet predchádzajúcich čísel. Ak si teda budeme pamätať iba jediné číslo -- súčet všetkých možných staníc -- tak ho pri znaku `L` vieme ľahko upraviť.

Pri znaku `P` majú nové stanice súčet $$(2p + 1) + (2q + 1) + (2r + 1) + (2s + 1) = 2(p+q+r+s) + 4$$ Súčet sa opäť zdvojnásobil, naviac sa k nemu ale pripočítal počet staníc, v ktorých Andrej mohol byť. Vidíme, že pamätať si iba súčet nestačí, musíme si k nemu zapamätať aj počet staníc, v ktorých Andrej môže byť. Pomocou týchto dvoch čísel už vieme spracovať aj znak `P`.

Ostal nám znak `*`. Pri ňom by bol súčet nových staníc $$2p + 2q + 2r + 2s + (2p+1) + (2q+1) + (2r+1) + (2s+1) = 4(p + q + r + s) + 4$$ Súčet sa teda zoštvornásobil a naviac sa k nemu pripočítal počet staníc. To však nie je problém pomocou našich dvoch hodnôt vypočítať. Vieme preto rýchlo spracovať aj znak `*`. Pri ňom však nemôžeme zabudnúť, že počet staníc, v ktorých Andrej môže byť, sa zdvojnásobí.

Naše riešenie teda opäť spracováva mapu znak po znaku, tentokrát si však pamätá iba dve hodnoty -- súčet a počet staníc, v ktorých sa Andrej môže nachádzať. Ukázali sme si, že pri každom znaku vieme tieto dve čísla jednoduchým spôsobom upraviť na novú hodnotu. A aby sme nepracovali s príliš veľkými číslami, tak ich po každej operácii modulujeme číslom $1,000,000,007$.

Pamäťová zložitosť našeho riešenia bude konštantná ($O(1)$), pretože si pamätáme iba dve premenné. Časová bude lineárna od dĺžky mapy, teda $O(n)$, pretože každý znak vieme spracovať v konštantnom čase úpravou najviac dvoch čísel.
",4
f4209e770f188e88,ksp,"# Toto nie je heslo

Konečne sa to stalo. Je na svete nová celotrojstenová infraštruktúra. Je úplne dokonalá, spĺňa všetko, by si od nej čakal. Je univerzálna pre všetky semináre, dlhodobo udržateľná, dobre zdokumentovaná... Vyskakuješ meter dvadsať od šťastia. Nič ti nemôže pokaziť tento úžasný pocit. Kontroluješ si inbox tvojho trojsten mailu, v ktorom nachádzaš samé pochvalné maily od vedúcich, mobil na stole ti pípa od všetkých tých pochvalných správ na Slacku. Čo je to ale za divný zvuk? Veď to znie ako zvonenie mobilu... Zrazu si uvedomíš, že si zase zaspal v T2^[Miestnosť kde sídli KSP na Matfyze] na gauči, pomaly otvoríš oči, a uvedomíš si, že to bol iba sen. Zdvihneš mobil, a zisťuješ, čo sa zase deje. Volá nejaký Trojsten vedúci, že, ehm, ako to povedať, nevie svoje heslo do Trojsten účtu.

Ale že to nie je až taká tragédia, lebo predtým ako ho zabudol, si vymyslel pomôcku ako zmenšiť počet možných hesiel. Vyrobil si papieriky, na ktoré si napísal slová, o ktorých vie, že sa na všetkých pozíciách líšia od hesla. A dokonca, týchto papierikov je presne $n$.

Vzápätí ale dodáva, že on by ti vlastne nevolal, on tie možnosti vyskúša aj sám, ale potrebuje, aby si mu umožnil mať väčší počet pokusov na zadanie hesla. Po chvíli frfľania súhlasíš, a kým sa stihneš spýtať, koľko pokusov potrebuje, tak už máš na stole všetky tie papieriky... To aby si si zase všetko zistil sám...

## Úloha

Na každom z $n$, $1\\leq n \\leq 1,000$ papierikov je napísané slovo, ktoré tvoria len malé písmená anglickej abecedy. Všetky tieto slová sú rovnako dlhé, majú najviach $13$ znakov, a majú rovnakú dĺžku ako heslo. O všetkých slovách viete, že sa na všetkých pozíciách líšia od hesla (i-te písmeno slova sa líši od i-teho písmena hesla). Koľko je hesiel, ktoré sa líšia od všetkých slov?

## Formát vstupu

Na prvom riadku sa nachádza číslo $n$, počet slov, o ktorých vieme, že sa líšia od hesla na každej pozícii. Na každom z nasledujúcich $n$ riadkov sa nachádza jedno slovo. Všetky tieto slová sú rovnako dlhé.

## Formát výstupu

Vypíšte jedno číslo - počet možností ktoré ostávajú pre heslo.

## Príklad

```vstup
3
pes
les
tri
```

```vystup
13248
```

*Možností sú napríklad ""aaa"", ""aab"", ""kon"", ""ale"", ""nie"" ..., no nie ""eee"" či ""lod"".*

```vstup
2
raz
dva
```

```vystup
13824
```
","# Toto nie je heslo

Anglická abeceda má $26$ rôznych písmen. Teda ak by neexistoval žiadny papierik (a poznali by sme dĺžku hesla), tak by sme pre každú pozíciu mali $26$ možností, aký znak dosadiť. Ak heslo má $d$ znakov, tak výsledný počet možných hesiel by bol rovný $26^d$. My ale vieme, že nejaký papierik určite existuje. Potrebujeme teda pre každú pozíciu vylúčiť všetky znaky, ktoré sa nachádzajú na tej pozícii na niektorom papieriku.

## Pomalé riešenie

To, čo potrebujeme zistiť ako prvé, je dĺžka nášho hesla. Vezmeme si ľubovoľné slovo na vstupe a zistíme, koľko má znakov. Zo zadania vieme, že rovnako veľa znakov bude mať aj heslo, ktoré hľadáme. Potom si vytvoríme pole $P$ dĺžky hesla, a na každom indexe bude toto pole obsahovať pole, v ktorom bude všetkých 26 písmen abecedy. Každé takéto pole bude hovoriť o tom, ktoré znaky sme pre danú pozíciu v hesle ešte nevylúčili. Následne budeme prechádzať slová na papierikoch. Pri každom indexe $i$ v tomto slove, odstránime daný znak v poli $P[i]$ (ak tam ešte je). Takto prejdem všetky slová, a nakoniec zistíme súčin počtov písmen, ktoré ostali v poliach a tým dostaneme náš výsledný počet hesiel.

Pozrime sa však na časovú zložitosť. Pre každé slovo musíme prejsť celé heslo, a pre každý znak musíme prejsť celé pole s písmenami, ktoré sme ešte nevylúčili (aby sme zistili, či tam to písmenko je), a následne, ak tam je, tak ho musíme vymazať. To pri dĺžke poľa $w$ môže trvať až $O(w)$. Ak si teda označíme dĺžku hesla ako $l$, tak zložitosť je $O(n l \\cdot 26)$ (Áno, $26$ je síce len konštanta, ale uvedomme si, že ak by v hesle mohli byť aj iné znaky ako malé písmená anglickej abecedy, táto konštanta by prestávala byť zanedbateľná. V prípade, ak ste veľkosť abecedy v poppise nespomínali, tak sme za to body nestrhávali.).

## Vzorové riešenie so setom

Pre zlepšenie zložitosti môžeme namiesto polí v poli $P$ použiť množiny -- `set` (Ak ste ešte o niečom takom nepočuli, tak tento odstavec pokojne preskočte :) ) Rovnako v nich budeme na začiatku ukladať 26 písmen a za každým keď nejaké písmeno pre danú pozíciu vylúčime, vyhodníme ho zo setu na danej pozícii v poli. Takto zlepšíme časovú zložitosť overovania či to písmeno môžeme použiť a zlepšíme zložitosť mazania tohoto písmena (podľa toho, aký `set` použijeme, tak pri počte prvkov v sete $p$ to môže byť buď na $O(\\log p)$, alebo $O(1)$). Výsledok vypočítame tak isto, teda ako súčin dĺžok setov.

## Vzorové riešenie s poľom

Iné riešenie môže byť také, že v poli nebudú sety, ale zase polia, ale s trochu iným významom. Polia budú mať dĺžku $26$ (1 index pre jedno písmeno abecedy) a na začiatku budú obsahovať samé nuly. Každé pole znova označuje, ktoré písmená sa na danom indexe v hesle môžu/nemôžu nachádzať, a to takým spôsobom, že index $0$ znamená, že či môžeme použiť písmenko $a$, index $1$ písmenko $b$, a tak ďalej... Znova prejdeme všetky slová a pre každé písmenko v slove si poznačíme do nášho dvojrozmerného poľa, že ho už nemôžme použiť.

Výsledok potom nájdeme tak, že si v každom vnútornom poli spočítame počet núl a vypíšeme súčin týchto počtov núl.

Treba si uvedomiť, že číslo ktoré je výsledkom môže byť dosť veľké. Vzhľadom na obmedzenia vstupov zo zadania, dĺžka hesla môže byť najviac $13$ znakov, a existuje aspoň $1$ papierik, takže v najhoršom prípade pre každú pozíciu vylúčime len $1$ znak. Teda výsledný počet možností bude $25^{13}$, čo je číslo ktoré sa nezmestí do $32$ bitovej premennej, ale zmestí sa do $64$ bitovej.

## Časová a pamäťová zložitosť

Musíme prejsť každé slovo na vstupe, pričom počet slov je $n$, a ich dĺžku si označme $l$. Pre každý znak slova urobím len konštantné operácie (zápis do poľa na konkrétny index). Pri počítaní výsledku prejdem n polí dĺžky $26$. Takže výsledná zložitosť bude $O(nl + 26 n)$, čo je $O(nl)$. Toľko času spotrebujeme aj na samotné načítanie vstupu, takže môžeme povedať že lepšie sa to ani nedá ;).

Do pamäte si uložím pole $n$ polí dĺžky $26$. Teda zaberieme pamäť $O(26 n) = O(n)$.
",1
9bd0d7fb7cbc3da4,ksp,"# Váľanie hypergúľ

""Mohol by si ísť kúpiť teplé rožky do obchodu pls?"" dožadovala sa matka, ""Rada by som čoskoro konzumovala raňajky!"" ""Ach jaj,"" povzdychol som si, ale nie nahlas, iba v mysli. Nadmieru ma kokoší, keď ma niekto vyrušuje počas ranného online Krúžku Sústredeného Pozerania Tiktoku.

Cesta do obchodu nie je dlhá, ale tak či tak sa ju oplatí skrátiť crossom cez lúky a iné trávnaté plochy. Každých ušetrených 10 sekúnd je jeden pozretý BimBam navyše. Brodím sa vysokým porastom, ale čo to? ""Nebodaj je to Scarabeus Multidimensionalis?!"" zhíknem pošepky. Tento druh chrobáčika intímne poznám, totiž, pozeral som o ňom 30 minútový dokumentárny film. Dospelé jedince tejto živočíšnej triedy si vaľkajú vlhké guľky potravy do ktorých nakladú vajíčka, z ktorých sa vyliahnu larvy. Tento konkrétny model hlavohrudca však navyše využíva obranný mechanizmus viacdimenzionálnych hyperguliek na zmätanie predátorov. V tomto prípade to má však nežiadaný efekt vyvolania extrémneho záujmu z mojej strany.

Keď som sa znova uvedomil, všimol som si, že sa trochu stmieva. Zdá sa, že som vcelku veľkú časť dňa strávil podrobným skúmaním týchto nezvyčajných guľôčok. Asi už nebudú mať teplé rožky. Nebol to však premárnený čas! Všimol som si, že vnútro guliek prekypuje životom. Vyliahnuté larvy sa v nich hýbu hore-dole v stovkách dimenzií. Častokrát sa stane, že sa vydajú na obrovské dobrodružstvo len aby nakoniec skončili na tom istom mieste, kde začali. Kvôli rokom súťaží, sústredení a iné, mi z mysle reflexívne vyšplechla otázka: ""Koľko takýchto rôznych bezvýznamných dobrodružstiev môžu absolvovať?""

Jóój, ale už ma rozbolel čobrdík a nechcem zmeškať večerníček,[^1] tak čo keby ste na to odpovedali **vy**?

## Úloha

Na lúke som stretol veľa guliek rôznych dimenzionalít, každú z nich som nejaký čas sledoval. V guľke je larva, ktorá sa neustále hýbe -- každú sekundu sa pomotká v smere jednej dimenzie o jednotku vzdialenosti. Guľky sú v porovnaní s larvami omnoho väčšie, takže sa nikdy nestane že by sa prekopali ku okraju.

Pozíciu v $D$-dimenzionálnom priestore vieme zapísať ako zoznam $D$ súradníc, teda $D$ celých čísel. Larvy sú jednoduché tvory, teda sa iba rozhodnú kam sa chcú pohnúť a následne sa jednu sekundu hýbu rovnakou rýchlosťou rovnakým smerom v práve jednej dimenzii. Potom zastanú, hlboko sa zamyslia a proces opakujú. Za jednu sekundu sa teda vedia dostať do miest, ktoré sa od ich aktuálnej pozície líšia v práve jednej súradnici o práve $1$.

Pre každú guľku ma zaujíma, koľkými rôznymi spôsobmi sa vie larva za stanovený čas prevandrovať na miesto, z ktorého začala.

## Formát vstupu

Na vstup vstúpi počet guliek na lúke $G$, následne nasleduje $G$ riadkov, na $i$-tom riadku dve čísla -- počet dimenzií $d_i$ a počet sekúnd $c_i$.

## Formát výstupu

Na výstup vypíšte $G$ riadkov, na $i$-tom riadku vypíšte odpoveď pre $i$-tu guľku modulo $10^9+7$.

## Obmedzenia

Vstupy budú rozdelené do 4 sád. Každá sada bude hodnotená 2 bodmi. Platia v nich nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:----------------- | ---: | ----: | -----: | --------: | | $0 \\leq G \\leq$ | $10$ | $100$ | $1000$ | $10,000$ | | $1 \\leq d_i \\leq$ | $7$ | $50$ | $50$ | $200$ | | $0 \\leq c_i \\leq$ | $7$ | $15$ | $50$ | $200$ |

## Príklad

```vstup
4
1 0
1 2
2 1
3 4
```

```vystup
1
2
0
90
```

[^1]: %5Bhttps://youtu.be/TT7iw3TzEjg%5D(https://youtu.be/TT7iw3TzEjg)
","# Váľanie hypergúľ

Samozrejme pre nepárne časy nikdy neexistuje žiadna cesta (trojitý zápor) a teda otázky s nepárnymi časmi už ďalej nebudeme rozoberať.

## Prvé dve sady

Na prejdenie prvej sady nám stačí pre každú otázku simulovať pohyb larvy backtrackingom. Nech $D$ je počet dimenzií a $C$ je počet sekúnd pohybu larvy, teda počet krokov čo má spraviť. Na začiatku je pozícia larvy zoznam $D$ núl. V každom kroku rekurzie sa skúsime pohnúť pre každú dimenziu do každého z dvoch smerov. V rekurzii hĺbky $C$ sa pozrieme, či je pozícia znova $D$ núl a ak áno, výsledok zvýšime o jedna. Pri backtrackingu sa veľmi oplatí prerušiť rekurziu ak vieme, že aktuálny stav určite nevedie k výsledku. V tejto úlohe je to napríklad ak je vzdialenosť od začiatku väčšia ako čas čo nám zostáva. Časová zložitosť pre riešenie bez rušenia rekurzie je $O(Q \\cdot (2D)^C)$.

Riešenie druhej sady je podobné, ale využije šikovnejšiu reprezentáciu pozície larvy. Vo výsledku nás nezaujíma, či sa larva najprv pohla v smere prvej či druhej dimenzie. Pozíciu vieme reprezentovať iba ako pole $P$, kde na $i$-tom indexe bude počet dimenzií, pre ktoré sme vo vzdialenosti $i$. Toto nám samo o sebe veľmi nepomáha -- musíme ešte zmeniť ako sa vnárame do rekurzie. Namiesto toho aby sme si vybrali jednu dimenziu v ktorej sa pohneme, vyberieme si skupinu dimenzií s rovnakou vzdialenosťou (teda jeden index v $P$). Môžeme si všimnúť, že nech sa pohneme v ľubovoľnej z nich, následná reprezentácia pozície larvy bude rovnaká. Teda vieme vykonať vnáranie sa do rekurzie iba raz, a výsledok vynásobiť počtom dimenzií v tejto skupine. Horný odhad časovej zložitosti pre riešenie bez rušenia rekurzie je $O(Q \\cdot C^C)$, keďže teraz v rekurzií skúšame $2$ smery pre $C/2$ skupín (vzdialenosť v ľubovoľnej dimenzií nemôže byť viac, inak by sme sa nestihli vrátiť). Môžeme si všimnúť, že ide naozaj iba o horný odhad, keďže $100 \\cdot 15^{15}$ by určite neprešlo v časovom limite.

Obe riešenia predpokladali, že si pri rekurzií budeme stavové pole posielať ako referenciu, lebo to by sme vždy mali robiť. V tom prípade budú pamäťové zložitosti iba lineárne závislé od veľkosti týchto poli, teda $O(D)$ pre prvú a $O(C)$ pre druhú sadu.

## Posledná sada

Pozrime sa na limity vstupov. $G$ je veľké. Nie je dobré počítať odpoveď pre každú otázku nanovo. Nerobme to. Niečo si predpočítajme. Čo ak máme odpoveď pre každý čas menší ako $C$ pre každú dimenziu menšiu ako $D$? Vieme z týchto informácií niečo vypočítať? Možno $C+2$ pre každé $D$, možno $D+1$ pre každé $C$? Ukážeme si to druhé z nich.

Najprv si ale predstavme ako vyzerá nejaká valídna trasa: Ak sa larva pohne v určitej dimenzií niektorým smerom, bude sa niekedy neskôr musieť pohnúť opačným. Teda trasu dĺžky $c$ v $d$ dimenziách si vieme predstaviť ako postupnosť $c$ Jahodových a Karamelových čísel od $1$ po $d$ (kde Jahodové čísla reprezentujú opačný pohyb voči Karamelovým), ktoré vieme rozdeliť do Jahodovo-Karamelových dvojíc, kde čísla v rámci dvojice sú si rovné.

Naspäť k počítaniu. Majme výsledok $V(c,,d)$ vypočítaný pre každú dvojicu $(c,,d)$, kde $c \\leq C$ je dĺžka trasy a $d \\leq D$ je počet dimenzií ktoré môžeme na danej trase použiť. Potom vieme vypočítať aj $V(c,,D+1)$, pre ľubovoľné $c \\leq C$. Výsledok $V(c,,D+1)$ je počet postupnosti Jahodových a Karamelových čísel od $1$ po $D+1$ s hore uvedenými vlastnosťami. Každú takúto postupnosť vieme vytvoriť z postupnosti Jahodových a Kararamelových čísel od $1$ po $D$, do ktorej pridáme niekoľko Jahodových a Karamelových čísel s hodnotou $D+1$. To koľko čísel $D+1$ pridáme nám určuje, akú dĺžku mala postupnosť pred tým ako sme ich pridali. Teda ak pridáme $x$ čísel, pridávame ich do postupnosti s parametrami $(c-x,,D)$, ktorých vieme že je $V(c-x,,D)$.

Potrebujeme ešte zistiť, koľkými spôsobmi vieme týchto $x$ čísel do postupnosti pridať. Máme $x$ čísel, všetky sú od seba na nerozoznanie. Potrebujeme ich ochutiť tak, aby polovica z nich bola Jahodová a polovica Karamelová (aby sme vo výsledku skončili v dimenzií $D+1$ na pozícii 0). Teda potrebujeme vybrať $x/2$ prvkov z $x$, čo vieme spraviť $\\binom{x}{x/2}$ spôsobmi. Teraz máme postupnosť $x$ ochutených čísel s hodnotou $D+1$ a postupnosť $c-x$ ochutených čísel s hodnotami od $1$ po $D$ a chceme zistiť, koľkými spôsobmi ich vieme skombinovať do jednej. Výsledná postupnosť bude mať $c$ prvkov a ak vyberieme na ktorých pozíciách budú čísla s hodnotou $D+1$, jednoznačne to určí pozíciu zvyšných $c-x$ čísel. Vidíme teda, že to vieme spraviť $\\binom{c}{x}$ spôsobmi.

Keďže počet postupností s parametrami $(c-x,,D)$, počet ochutení a počet premiešaní daných dvoch postupností sú nezávislé operácie, *počet postupností s parametrami $(c,,D+1)$ v ktorých má $x$ čísel hodnotu $D+1$* bude súčinom týchto troch čísel. Nakoniec počet postupností s parametrami $(c,,D+1)$ bez obmedzenia na $x$ bude súčet výsledkov pre každé $x$ od $0$ po $c$ vrátane. Výsledok teda vieme zapísať ako: $V(c,,D+1) = \\sum\_{x=0}^{c}{V(c-x,,D) \\cdot \\binom{x}{x/2} \\cdot \\binom{c}{x}}$

Hodnoty $V(c,,0)$ sú triviálne (pre $c=0$ je to $1$, pre ostatné $0$). Postupne budeme zvyšovať $d$ pre ktoré vždy pre všetky $c$ vypočítame $V(c,,d)$. Toto spravíme pre všetky $c$ a $d$ potrebné na zodpovedanie všetkých otázok na vstupe.

Všetko čo sme tu vymysleli by však bolo celkom premárnené ak by sme taktiež nevedeli rýchlo počítať $\\binom{y}{x}$. To vieme robiť veľa rôznymi spôsobmi -- najjednoduchším je predpočítanie si Pascalovho trojuholníku, ale dá sa aj predpočítanie faktoriálov a ich inverzov pre modulo alebo vypočítanie podielu ako rozdiel množín faktorizácie faktoriálov.

Časová zložitosť tohoto riešenia je $O(Q + C^2 \\cdot D)$, keďže predpočítavame tabuľku s rozmermi $C \\times D$ s časovou zložitosťou $O(C)$ pre každý prvok. Pamäťová zložitosť bude $O(C \\cdot D)$, alebo $O(Q + C \\cdot D)$ ak sa rozhodneme najprv nájsť maximálne hodnoty $C$ a $D$ na vstupe a nemuseli tak počítať prebytočné masívnu tabuľku.
",8
9bc786d49afbbed2,ksp,"# Dvojičky

Ísť na rodinnú oslavu asi nebol až taký dobrý nápad ako by sa mohlo zdať. Nie že by koláče neboli fajn, alebo by si nemal rád svojich čudných príbuzných, ale tá tvoja rozvetvená rodina... Teda, aj tá by bola v pohode, ak by ste nemali v rodine toľko dvojičiek.

Našťastie, nikdy si nemusel vedieť mená tvojich príbuzných, ich vek, a ani to, či sú dvojičky... Až doteraz... Prikývol si sestre tety vnučky krstnej tvojej starej mamy z druhého kolena, že jej pomôžeš s jej nečakaným nápadom, odovzdávaním ceny pre najstaršie dvojičky z minulej oslavy.

Sestra tety vnučky krstnej tvojej starej mamy z druhého kolena cenu odovzdala, nechala ti fotku z predošlej oslavy a išla sa najesť koláčov a kapustnice. Aj ty by si sa rád najedol, no po chvíli ťa, ako jej asistenta, začali prenasledovať nespokojné dvojičky, ktoré cenu nedostali s tým, aby si im dokázal, že cena bola odovzdaná správnemu páru dvojičiek.

Chcú teda, aby si im povedal, koľko párov dvojičiek bolo na oslave, a aké staré boli najstaršie dvojičky... Na tvojom mieste by som im rýchlo, ale najmä správne, odpovedal. Chceš od nich predsa dostať na Vianoce nejaké darčeky...

## Úloha

Dostanete veky ľudí, ktorí sú zachytení na fotke. Týchto ľudí je $n$. Na oslave sa nachádzalo $n+1$ ľudí. Človek, ktorý fotku fotil, nebol na fotke. Ľubovolní dvaja ľudia, okrem dvojice tvoriacej dvojičku, sú rozdielne starí.

Vypíšte, koľko najviac párov dvojičiek mohlo byť na oslave, a vek najstaršieho možného páru dvojičiek, ktorý bol na oslave, pričom môžete predpokladať, že na oslave sa nachádzal aspoň jeden pár dvojičiek.

## Formát vstupu

Vstup tvorí dvojica riadkov, ktorá popisuje fotku z oslavy.

V prvom riadku sa nachádza číslo $1\\leq n \\leq 100,000$ , počet ľudí na fotke.

Na druhom riadku sa nachádza $n$ čísel $a_i$ oddelených medzerami, $1\\leq a_i \\leq 200,000$^[Okrem dvojičiek nie je vo vašej rodine výnimočná ani dlhovekosť.], ktoré označujú veky ľudí na fotke.

## Formát výstupu

Vypíšte dve, medzerou oddelené čísla. Koľko najviac párov dvojičiek mohlo byť na oslave, a najväčší možný vek páru dvojičiek, ktorý bol na oslave.

## Príklad

```vstup
8
12 12 16 102 47 16 102 47
```

```vystup
4 102
```
","# Dvojičky

Vašou úlohou bolo zistiť vek najstaršieho možného páru dvojičiek, a najväčší možný počet dvojičiek na oslave. K správnemu vyriešeniu úlohy si bolo potrebné uvedomiť, že aj fotograf môže byť dvojička, a dokonca môže byť aj súčasťou najstaršieho páru dvojičiek.

Pri hľadaní maximálneho veku páru dvojičiek, sa môže stať buď, že najstarší pár dvojičiek je na fotke, alebo ho tvorí najstarší jednotlivec z fotky a fotograf. Z tohto nám teda vyplýva, že vek najstaršieho možného páru dvojičiek bude maximum z vekov na fotke, bez ohľadu na to, či je tam tento vek dvakrát, alebo len raz.

Celkový počet dvojičiek na oslave ale nemusí byť rovný počtu dvojičiek na fotke. Môže byť o jedna väčší. Tento prípad nastane vždy, keď je na fotke aspoň jeden jednotlivec. Potom fotograf a tento jednotlivec tvoria spoločne dvojičky.

Keď už vieme, čo máme urobiť, pozrime sa na to, ako to urobiť.

## Riešenie v čase $O(n)$ a pamäti $O(maximalny_vek)$

Chceli by sme vedieť zistiť počet ľudí daného veku. To vieme urobiť tak, že si najprv vytvoríme pole dĺžky $maximalny_vek$, ktoré celé vynulujeme. Jednotlivé hodnoty na indexoch tohoto poľa budú predstavovať počty ľudí daného veku. Následne prechádzame veky na fotke a zväčšujeme hodnotu na indexe daného veku o jedna. Na konci v celom poli spočítame počet indexov (počet vekov) s hodnotou $2$ (počet dvojičiek), a zistíme, či existuje index s hodnotou $1$(nejaký jednotlivec na zdvojičkovanie s fotografom). Takto zistíme najväčší možný počet dvojičiek. Maximálny vek dvojičiek nájdeme ako najväčší index v poli s nenulovou hodnotou. Úlohu sme teda vyriešili v časovej zložitosti $O(n + maximalny_vek)$, a pamäťovej zložitosti $O(maximalny_vek)$.

## Riešenie v čase $O(n log(n))$ a pamäti $O(n)$

Najprv si veky z fotografie utriedime^\[funkcia `sort` vo väčšine programovacích jazykov\]. Následne si prejdeme pole a hľadáme miesta, kde majú dva za sebou nasledujúce prvky v poli rovnakú hodnotu (dvojičky). Ak existuje nejaký jednotlivec, teda $pocet_dvojiciek \\cdot 2 \\neq n$, môže tento človek urobiť dvojičku s fotografom, čiže zvýšime počet dvojičiek o $1$. Maximálny možný vek dvojičiek je posledný prvok v poli, keďže pole máme utriedené od najmenšieho po najväčšie.
",1
bb2691e22c6f81bf,ksp,"# Kruhová knižnica

V základnej škole Kráľa Svätopluka Prvého majú obrovskú knižnicu. Je to veľká kruhová miestnosť, v ktorej je pozdĺž stien nad sebou umiestnených $n$ dlhých políc. Každá polica je kruhová a ide kolom dokola celej miestnosti. (Samozrejme, sú tam aj dvere, takže nejde úplne dokola, ale tie pre túto úlohu nie sú zaujímavé.) Každú policu si teda môžeme predstaviť ako kružnicu.

Na každú policu sa vojde $s$ kníh, pre jednoduchosť majú všetky rovnakú šírku. Na každej z nich je zároveň práve jedna (špeciálna) červená kniha. Medzi inými je tam aj Červená algebra, no sú tam aj knihy, ktoré sú červené len preto, že ich obaly nespolušní žiaci zafarbili voskovkami.

## Úloha

Knihovníkovi sa nepáči, ako sú červené knihy na náhodných miestach a nepríjemne to bije do očí. Bol by rád, keby sa všetky červené knihy nachádzali nad sebou v jednom stĺpci. Zároveň by chcel, aby sa knihy presunuli o čo najmenšiu celkovú vzdialenosť.

Vzdialenosť meriame po polici popri stene (teda nie krížom cez miestnosť). Knihy nie je možné meniť medzi policami (každá kniha musí ostať vo svojeje polici). Celkovú vzdialenosť dostaneme tak, že sčítame vzdialenosť, o ktorú sa posunula kniha na každej polici. Knihovník si môže vybrať, ktorým smerom chce knihu posúvať (doľava alebo doprava).

Pozície, na ktorých sú knihy, si môžeme očíslovať od $0$ do $s-1$, pričom susedné pozície sú vždy $i$ a $i+1$, ale aj $0$ a $s-1$ (police sú kruhové). Ak napríklad máme policu s dĺžkou na $s=16$ kníh a chceme premiestniť červenú knihu z pozície $4$ na pozíciu $13$, môžeme ju posunúť v smere rastu čísel (doprava) o $9$ pozícií ($13-4=9$). Lepšie je však posunúť ju opačným smerom, takto prekoná vzdialenosť iba $7$ pozícií (vzdialenosť $4$ na pozíciu $0$ a $16-13=3$ na pozíciu $13$).

Pomôžte knihovníkovi nájsť optimálny spôsob premiestnenia kníh.

## Formát vstupu

Na prvom riadku dostanete čísla $n$ a $s$ -- počet políc v knižnici a veľkosť jednej police.

Na druhom riadku sa nachádza $n$ celých čísel z rozsahu od $0$ do $s-1$ -- pozície červenej knihy v jednotlivých policiach.

## Formát výstupu

Vypíšte jedno číslo -- najmenšiu celkovú vzdialenosť, o ktorú je potrebné červené knihy presunúť. Nezabudnite na znak konca riadka.

## Hodnotenie

Sú štyri sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |-----: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $8$ | $1000$ | $100,000$ | $100,000$ | | $1 \\leq s \\leq$ | $16$ | $2000$ | $100,000$ | $10^{9}$ |

## Príklad

```vstup
5 5
0 1 2 3 4
```

```vystup
6
```

_Knižnica má $5$ políc, každá má veľkosť $5$. Rozmiestnenie kníh vyzerá takto (X je červená kniha):_

```
|X....|
|.X...|
|..X..|
|...X.|
|....X|
```

_Police sú kruhové, teda pravý okraj je napojený na ľavý. Jedno možné riešenie je presunúť všetky knihy do stĺpca (na pozície) $2$, v jednotlivých riadkoch teda vykonáme presuny o $2$, $1$, $0$, $1$ a $2$ pozície, dokopy je to $6$. V tomto prípade sme kruhovosť nevyužili, ale rovnako dobre ju využiť vieme a na $6$ krokov presunúť všetky knihy do stĺpca $0$ či ktoréhokoľvek iného._

```vstup
3 10
0 0 8
```

```vystup
2
```

_Knihu v tretej polici posunieme o dve pozície vpravo, čím sa dostane z pozície $8$ cez pozíciu $9$ na pozíciu $0$._

```
|X.........|
|X.........|
|........X.|
```

```vstup
2 5
2 3
```

```vystup
1
```

_Knihy sú v susedných stĺpcoch, stačí jednu presunúť k druhej._

```
|..X..|
|...X.|
```
","# Kruhová knižnica

## Pomalé riešenie

Predstavme si, že by sme vedeli, do ktorého stĺpca (na ktorú pozíciu) chceme presunúť všetky červené knihy. Označme túto pozíciu $c$. Vieme nejako vypočítať vzdialenosť, o ktorú treba posunúť knihu, ktorá sa práve nachádza na pozícii $p$?

Mohli by sme ju presunúť bez využitia cyklickosti políc. Takto sa kniha posunie o vzdialenosť $|p-c|$, kde $|x|$ značí absolútnu hodnotu čísla $x$ (teda číslo po odobratí znamienka). Ak by sme ju chceli posunúť opačným smerom, teda cez hranicu medzi pozíciami $0$ a $s-1$, táto vzdialenosť by bola doplnkom vyššie uvedenej vzdialenosti do celého kruhu (čiže do $s$). V tomto prípade teda dostávame vzdialenosť $s - |p-c|$. Z týchto dvoch vzdialeností vieme vybrať tú menšiu a toto urobiť a posčítať pre všetky police.

Keďže cieľovú pozíciu nepoznáme, musíme vyskúšať všetkých $s$ možných. Pre každú z nich prejdeme všetky knihy a vyberieme najlepšiu pozíciu. Máme tak riešenie s časovou zložitosťou $O(ns)$, ktoré zvládne vyriešiť prvé 2 sady.

## Efektívnejšie riešenie jednoduchšej úlohy

Pozrime sa teraz na jednoduchšiu úlohu, v ktorej police nie sú cyklické, ale majú ľavý a pravý koniec. V takomto prípade je odpoveď jednoduchá -- je ňou medián čísel na vstupe. Medián postupnosti je jej stredná hodnota, teda číslo, ktoré po usporiadaní postupnosti skončí v strede. Ak je čísel nepárne veľa, je táto hodnota jednoznačne určená. Ak je čísel párne veľa, medián je definovaný ako priemer dvoch prostredných, ale ako riešenie úlohy je možné vziať ľubovoľnú hodnotu medzi dvomi prostrednými (alebo rovno jednu z nich) a bude to rovnako dobré optimálne riešenie.

Prečo je riešením vždy medián? Začnime s tým, že cieľovú pozíciu, kam chceme knihy premiestniť, dáme úplne naľavo, takže každá kniha bude musieť byť presunutá o určitú vzdialenosť doľava. Keď teraz začneme našu pozíciu posúvať doprava, knihám, ktoré sú od nej napravo, sa potrebná vzdialenosť bude znižovať, zatiaľ čo knihám, ktoré sú od nej naľavo, sa bude znižovať.

Ak je napravo od cieľovej pozície $j$ kníh a naľavo $i$, posunom o 1 doprava sa celkový súčet vzdialeností zmenší o $j$ a zvýši o $i$, pričom nejaké knihy sa môžu začať nachádzať na opačnej strane od tejto pozície.

Na začiatku sú všetky knihy napravo a približujú sa, na konci sú všetky naľavo a vzďaľujú sa. Ideálnym riešením je stav, kedy je naľavo aj napravo rovnako veľa kníh (vtedy zvyšovanie začne predbiehať znižovanie), čo je práve vtedy, keď sme v mediáne. (Pre prostredný prvok platí, že naľavo aj napravo od neho je rovnako veľa prvkov.)

## Vzorové riešenie

Túto myšlienku vieme zovšeobecniť na riešenie našej úlohy. Začnime s cieľovou pozíciou $0$ a poďme ju posúvať (po kruhu) doprava. Počítajme si pritom, koľko pozícií sa približuje a koľko sa vzďaľuje. Keď poznáme aktuálny celkový súčet vzdialeností a pohneme cieľovou pozíciou, na základe týchto hodnôt vieme celkový súčet aktualizovať.

### Ktoré knihy sa k nej približujú a ktoré sa vzďaľujú?

Ak je cieľová pozícia $0$, približujú sa tie, ktoré sú na pozícii najviac $s/2$ (najkratšia cesta pre ne vedie priamo k menším pozíciám) a vzďaľujú sa tie, ktoré sú na pozícii väčšej ako $s/2$ (pre ne je optimálne ísť k $0$ doprava cez vyššie pozície).

### Kedy sa mení, či sa kniha približuje alebo vzďaľuje

Keď s cieľovou pozíciou prídeme na pozíciu nejakej knihy, táto sa doteraz približovala a odteraz sa začne vzďaľovať. Pri našich kruhových pozíciách môže nastať ešte jeden typ situácie, a to ten, že sa kniha prestane vzďaľovať a začne približovať. Deje sa to vtedy, keď sme na kruhu presne oproti nej. Cieľová pozícia sa od nej vzdialila natoľko, že už je pre knihu lepšie k nej ísť opačným smerom a v tomto smere sa približuje.

Keď sa však pustíme do implementácie, uvedomíme si, že to nie je také jednoduché. Pre párne $s$ sa kniha v istom momente prestane vzďaľovať a hneď sa začne približovať, napríklad pre $s=100$ a knihu na pozícii $10$ sa toto stane, keď cieľová pozícia je $60$.

Avšak pre nepárne $s$ sa to stane na neceločíselnej pozícii, napríklad pre $s=101$ a knihu na pozícii $10$ sa to stane, keď cieľová pozícia je $60.5$. My však pracujeme iba s celočíselnými pozíciami. Pre knihu ostáva vzdialenosť rovnaká pre cieľovú pozíciu $60$ aj $61$.

Elegantný spôsob riešenia tohto problému je taký, že si nebudeme pamätať len počet kníh, ktoré sa približujú a vzďaľujú, ale aj počet takých, ktoré svoju vzdialenosť nemenia. V tomto stave vie byť každá kniha len po dobu presunu cieľovej pozície o $1$ (a po dobu $0$ pri párnom $s$ -- nechceme mať zvlášť implementáciu pre párne a pre nepárne $s$).

### Dajme to všetko dokopy

Vzorové riešenie teda bude vyzerať nasledovne: najskôr si vypočítame súčet vzdialeností, keby sme všetky knihy chceli presunúť na pozíciu $0$. Tiež si napočítame počet približujúcich sa a vzďaľujúcich sa kníh (a tých, čo svoju vzdialenosť pri posune z $0$ na $1$ nezmenia, to sú tie na pozícii $\\frac{s+1}{2}$, ak to je celé číslo).

Cieľovú pozíciu posúvame doprava a udržiavame si aktuálny súčet vzdialeností a najlepší doteraz nájdený. Aby sme nemuseli prechádzať $10^9$ pozícii v 4. sade, stačí si uvedomiť, že zaujímavé pozície sú len tie, kde sa niečo mení. Pre každú knihu je to jej pozícia a jedna alebo dve pozície presne naproti nej (podľa parity $s$). Tieto udalosti si vieme predpočítať dopredu, usporiadať podľa súradnice a postupne ich všetky spracovať.

Časová zložitosť riešenia je $O(n \\log n)$, pretože výpočet hodnôt pred začatím posúvania cieľovej pozície spravíme v $O(n)$, potom utriedime $3n$ udalostí v $O(n \\log n)$ a následne každú udalosť spracujeme v konštantnom čase. Každá udalosť je totiž iba zmena stavu jednej knihy (približuje sa/vzďaľuje sa/nemení sa). Pamäťová zložitosť je $O(n)$.
",5
4b3e639ccb555f92,ksp,"# Otepľovanie v Absurdistane

Ako iste viete, v dôsledku globálneho otepľovania sa topia ľadovce a kvôli tomu stúpajú hladiny oceánov. V niektorých nízko položených krajinách, ako je napríklad Absurdistan, to potom spôsobuje problémy. So stúpajúcou hladinou mora totiž stúpa hladina podzemnej vody a -- keďže Absurdistan má veľmi priepustné podložie -- s ňou aj hladina nadzemnej vody. A tak postupne v rôznych kotlinách, údoliach a priehlbinách vznikajú nové jazerá, ktorým Absurdistanci vymýšľajú nové názvy.

## Úloha

Absurdistan má tvar obdĺžnika, ktorý si pre účely tejto úlohy rozdelíme na $r \\times s$ políčok. Každé políčko má svoju nadmorskú výšku^[Pre jednoduchosť, za nadmorskú výšku budeme považovať nadmorskú výšku na začiatku zatápania, nie výšku nad aktuálnou hladinou mora. Nadmorská výška v našom chápaní sa teda počas zatápania meniť nebude.] -- celé číslo z rozsahu $0$ až $H$. Hladina podzemnej vody je na začiatku $0$. Každý rok hladina vody stúpne o $1$ a všetky políčka, ktoré sa ocitli pod hladinou (ich nadmorská výška je ostro menšia ako výška hladiny), sa zatopia.

Každé zatopené políčko v Absurdistane je oficiálne súčasťou nejakého jazera. Pre jednoduchosť predpokladajme, že názvy Absurdistanských jazier sú nezáporné celé čísla. Každý rok sa v Absurdistane zíde Kartografická Spoločnosť Patriotov a každému zatopenému políčku $P$ určí, ktorého jazera je súčasťou, podľa nasledujúcich pravidiel:

- Každé políčko, ktoré bolo zatopené už aj rok predtým, ostáva súčasťou jazera, ku ktorému patrilo doteraz.

- Pre každé novozatopené políčko $P$ skúsime nájsť políčko $R$ také, že $R$ bolo zatopené už aj pred rokom, z $P$ sa dá dostať do $R$ idúc iba po zatopených políčkach (pričom z jedného políčka vieme vždy ísť iba na políčka susediace stranou, ale nie na políčka susediace rohom) a cesta po vode z $P$ do $R$ je najkratšia možná. Políčko $P$ sa stane súčasťou rovnakého jazera ako $R$. Ak je viacero možných políčok $R$, vyberieme také, ktorého jazero má najmenšie číslo.

  Ak sa z $P$ nedá po vode dostať na žiadne políčko, ktoré bolo zatopené už pred rokom, políčko $P$ a všetky zatopené políčka, na ktoré sa z $P$ dá dostať, budú prehlásené za novovzniknuté jazero.

- Novovzniknutým jazerám sa názvy priradia nasledovne: Prechádzame cez všetky políčka obdlžníka, pričom postupujeme po riadkoch zhora nadol, a v rámci riadka zľava doprava. Vždy, keď nájdeme zatopené políčko patriace k nejakému novovzniknutému jazeru, ktoré ešte nemá názov, toto jazero nazveme najmenším nepoužitým nezáporným celým číslom.

Všimnite si, že keď sa v dôsledku stúpania hladiny dve jazerá zlejú do jednej súvislej vodnej plochy, oficiálne sú to stále dve rôzne jazerá s presne vymedzenými hranicami. Pre lepšie pochopenie týchto pravidiel si môžete pozrieť vzorový príklad s vysvetlením.

Vašou úlohou bude pre každé políčko zistiť číslo jazera, ku ktorému bude toto políčko patriť po $H+1$ rokoch, teda keď už bude celý Absurdistan zatopený.

## Formát vstupu

V prvom riadku vstupu sú dve kladné celé čísla $r, s ,(r \\cdot s \\leq 250,000)$ -- počet riadkov a počet stĺpcov obdĺžnika. V druhom riadku je jedno kladné celé číslo $H ,(H \\leq 250,000)$. Nasleduje $r$ riadkov, každý z nich obsahuje $s$ medzerami oddelených celých čísel z rozsahu $0$ až $H$ -- nadmorské výšky jednotlivých políčok.

## Formát výstupu

Vypíšte $r$ riadkov a v každom z nich $s$ medzerami oddelených čísel: čísla jazier, ku ktorým budú patriť jednotlivé políčka po úplnom zatopení Absurdistanu.

## Príklad

```vstup
8 8
4
3 1 1 1 2 2 0 0
3 1 2 2 2 0 2 1
0 0 2 2 1 0 2 1
0 0 2 2 1 2 2 1
1 3 2 2 1 1 1 1
4 4 3 3 4 4 4 4
0 0 4 3 2 1 2 0
4 0 4 2 1 0 0 3
```

```vystup
2 2 2 2 2 0 0 0
2 2 2 2 1 1 0 0
2 2 2 1 1 1 0 0
2 2 2 1 1 1 0 0
2 1 1 1 1 1 0 0
2 1 1 1 1 1 0 0
3 3 1 5 5 5 4 4
3 3 3 5 5 5 5 4
```

_Absurdistan bude po jednotlivých rokoch vyzerať nasledovne (modré oblasti sú zatopené, pričom svetlomodré sú novozatopené. Čísla v nezatopených políčkach udávajú nadmorskú výšku, čísla v zatopených udávajú číslo jazera):_
","# Otepľovanie v Absurdistane

### Prehľadávanie do šírky

V tomto riešení budeme hojne používať štandardný algoritmus _prehľadávanie do šírky_ (po anglicky _breadth-first search_, skratka BFS). O tomto algoritme existuje veľa materiálov všelikde po internete^\[napríklad <https://ksp.mff.cuni.cz/tasks/25/cook4.html>, <https://people.ksp.sk/~baklazan/UFO-Prask_2016_jar/zbornik_Prask.pdf> (od strany 20), ale aj <https://en.wikipedia.org/wiki/Breadth-first_search>\], preto ho v tomto vzorovom riešení nebudeme rozoberať.

### Naivné riešenie

Asi najjednoduchšie riešenie, ktoré nám napadne (ak dostatočne dobre poznáme BFS) je simulovať postupne jednotlivé roky zatápania Absurdistanu a každý rok označiť novozatopené oblasti tak, ako by to urobila Kartografická Spoločnosť Patriotov (KSP). Každý rok pri tom môžeme postupovať nasledovne:

1. Spustíme BFS, ktorému povolíme prehľadávať iba zatopené políčka, naraz zo všetkých políčok, ktoré boli zatopené už minulý rok^[Toto vieme jednoducho dosiahnuť tak, že na začiatku do fronty vložíme všetky zatopené políčka.]. Keď v tomto BFS z políčka $A$ objavíme dosiaľ neobjavené novozatopené políčko $B$, zaznačíme si, že $B$ patrí do rovnakého jazera ako $A$. Takýmto spôsobom bude každé novozatopené políčko priradené tomu jazeru, ktoré sa k nemu ""dostalo najskôr"", teda jazeru, ku ktorému bolo dané políčko po vode najbližšie (čo je presne to, čo podľa zadania chceme).

   Ostáva ešte doriešiť, ako zabezpečiť, aby v prípade remízy vyhralo jazero s nižším číslom. To sa dá vyriešiť napríklad nasledovne:

   - BFS neimplementujeme s frontou, ale budeme ho robiť po kolách. V každom kole vezmeme všetky políčka, ktoré boli objavené v predchádzajúcom kole (špeciálne v prvom kole vezmeme všetky políčka zatopené už minulý rok) a pozrieme sa na všetkých ich novozatopených susedov. Tých z nich, ktorých sme doteraz neobjavili, si zaznačíme ako objavených v tomto kole. V prvom kole teda objavíme novozatopené políčka, ktorých vzdialenosť od najbližšieho políčka zatopeného v minulých rokoch je $1$, v druhom kole objavíme políčka vzdialené $2$ atď.
   - Ak v nejakom kole objavíme jedno políčko $P$ viackrát (z rôznych smerov), pričom políčka, z ktorých sme ho objavili, patria do rôznych jazier, políčko $P$ priradíme tomu z nich, ktoré má najmenšie číslo.

1. Následne prejdeme cez všetky políčka obdĺžnika v rovnakom poradí ako KSP (teda zhora nadol, zľava doprava). Vždy, keď nájdeme novozatopené políčko $R$, ktoré ešte nemá určené číslo jazera, ktorému patrí (teda sme našli novovzniknuté jazero), vezmeme najmenšie číslo, ktoré sme pri označovaní jazier ešte nepoužili a týmto číslom označíme políčko $R$. Následne spustíme z políčka $R$ BFS idúce iba po novozatopených políčkach. Všetky políčka, ktoré toto BFS objaví, označíme rovnakým číslom jazera ako $R$.

#### Odhad zložitosti

Prvá časť nášho postupu (rozširovanie už existujúcich jazier) je BFS na grafe s najviac $r \\cdot s$ vrcholmi a $2 \\cdot r \\cdot s$ hranami, teda má zložitosť $O(r \\cdot s)$. V druhej časti musíme prejsť cez celú mapu, čo nás bude stáť $O(r \\cdot s)$ času a okrem toho ešte robíme nejaké BFS-ká. Keďže tieto BFS-ká púšťame v každom novovzniknutom jazere iba raz (keď objavíme prvé jeho políčko), navštívia dokopy každé novozatopené políčko neoznačené v kroku 1 práve raz, teda dokopy nám budú trvať nanajvýš $O(r \\cdot s)$ času. Odsimulovanie jedného roka nám teda bude trvať $O(r \\cdot s)$ času a potrebujeme odsimulovať $H$ rokov, preto časová zložitosť celého algoritmu je $O(H \\cdot r \\cdot s)$.

Pamäťová zložitosť je $O(r \\cdot s)$, nakoľko pre každé políčko si pamätáme iba konštantne veľa údajov a počas BFS máme v zozname vrcholov určených na prehľadanie vždy najviac $r \\cdot s$ vrcholov.

### Rýchlejšie riešenie

Naše riešenie sa ešte dá podstatne zrýchliť. Stačí si uvedomiť, že veľa vecí počítame zbytočne.

Prvá zbytočná vec, ktorú robíme, je, že aj v rokoch, keď sa nič neudialo (žiadne políčko nebolo zatopené) sa snažíme označovať novozatopené políčka a strávime tým $O(r \\cdot s)$ času. Prvou optimalizáciou by teda mohlo byť na začiatku si nejako poznačiť, v ktorých rokoch sa nič neudialo a tieto roky vynechať. To môžeme urobiť napríklad nasledovne:

1. Na začiatku si vyrobíme pomocné pole dĺžky $H+1$, kde si budeme pre každý rok pamätať, či sme videli nejaké políčko, ktoré bude zatopené v danom roku.
1. Následne postupne prejdeme všetky políčka obdĺžnika a pre každé políčko sa pozrieme, v ktorom roku bude zatopené (akú má nadmorskú výšku). K príslušnému roku si potom v našom poli poznačíme, že sa v ňom niečo udeje.

Toto celé nám bude trvať čas $O(r \\cdot s + H)$ ($+H$ je tam preto, lebo aj vytvorenie (vynulovanie) poľa stojí nejaký čas) a urobíme to za celý algoritmus iba raz, na začiatku. Následne budeme úlohu riešiť rovnako ako predtým, teda simulovať situáciu rok po roku. Na začiatku simulovania jedného roka sa ale najprv pozrieme, či sa v danom roku niečo zmení a ak nie, daný rok preskočíme. Takto teda roky, keď sa niečo deje, odsimulujeme v čase $O(r \\cdot s)$ a roky, keď sa nič nedeje, v čase $O(1)$. Časová zložitosť nášho algoritmu je teda $O(r \\cdot s \\cdot h + H)$ (tentoraz je tam to $+H$ preto, lebo aj v rokoch, keď sa nič neudialo, sme minuli $O(1)$ času), kde $h$ je počet rokov, keď sa niečo stane. Keďže rôznych nadmorských výšok môže byť na mape najviac $r \\cdot s$, platí $h \\leq r \\cdot s$, preto je zložitosť nášho algoritmu v najhoršom prípade $O(r \\cdot s \\cdot \\min(H, r \\cdot s) + H)$. Zlepšili sme sa teda v prípadoch, keď je $H$ ďaleko väčšie ako $r \\cdot s$ a v prípadoch, keď je na mape málo rôznych nadmorských výšok.

Vidíme, že v prípadoch, keď je na mape veľa rôznych nadmorských výšok, sme si veľmi nepolepšili. V takýchto prípadoch bude totiž veľa rokov, v ktorých sa zatopí iba maličké územie, ale my kvôli nemu urobíme veľa práce. To ale tiež vieme zlepšiť. V prvom kroku simulácie jedného roka spúšťame BFS zo všetkých doteraz zatopených políčok. Mnohé z nich ale nemusia susediť so žiadnym novozatopeným políčkom a preto ich prehľadaním nič neobjavíme.

V skutočnosti by nám teda stačilo BFS spustiť iba z tých políčok, ktoré susedia s niektorým novozatopeným políčkom. Týchto políčok môže byť najviac štyrikrát viac ako novozatopených políčok, keďže každé novozatopené políčko susedí s najviac štyrmi, preto by nám BFS trvalo iba $O(Z_i)$ času, kde $i$ je poradové číslo daného roku a $Z_i$ je počet políčok zatopených v tomto roku.

V druhom kroku simulácie jedného roka prechádzame celú mapu a hľadáme neoznačené novozatopené políčka, čo nám trvá $O(r \\cdot s)$ času. Ak by sme namiesto toho prechádzali iba cez novozatopené políčka a ostatné preskakovali, trvalo by nám to iba $O(Z_i)$ času.

Nakoniec z niektorých políčok púšťame BFS. Všetky tieto BFS-ká ale dokopy prehľadajú iba všetky neoznačené novozatopené políčka, ktorých je najviac $O(Z_i)$, teda dokopy trvajú najviac $O(Z_i)$ času. Vylepšený algoritmus teda môže vyzerať nasledovne:

1. Úplne na začiatku si vytvoríme zoznam $H+1$ zoznamov: pre každý rok zoznam políčok, ktoré budú v tomto roku zatopené, v poradí, v akom ich navštívi KSP (teda po riadkoch zhora nadol, v rámci riadka zľava doprava).
1. Prejdeme celú mapu, pričom každé políčko zapíšeme do zoznamu prislúchajúcemu roku, v ktorom bude dané políčko zatopené.
1. Následne simulujeme rok po roku, pričom simulácia jedného roka vyzerá nasledovne:
   1. Pozrieme sa na zoznam políčok zaplavených v tomto roku. Ak je prázdny, daný rok môžeme preskočiť. Ak nie, pre všetky políčka z tohto zoznamu sa pozrieme na všetkých ich susedov. Z tých susedov, ktorí boli zatopení už skôr, spustíme BFS, v ktorom popriraďujeme novozatopené políčka ich jazerám.
   1. Prejdeme znova zoznam políčok zatopených v danom roku a vždy keď nájdeme nejaké ešte nepriradené políčko, označíme toto políčko novým číslom jazera a spustíme z neho BFS, kde pooznačujeme aj zvyšok tohto novovzniknutého jazera.

Rok číslo $i$ takto odsimulujeme v čase $O(Z_i)$, teda dokopy nám všetky simulácie zaberú $O(Z_1 + Z_2 + \\dots + Z\_{H+1}) = O(r \\cdot c)$ času. Celý algoritmus teda pobeží v čase $O(r \\cdot c + H)$.
",6
40076f8eb04c638d,ksp,"# Lacný polozisk

Kubik zistil, že v Ebaystane sa dá kúpiť notebook a následne sa dá predať aj za dvojnásobok. Niekedy však notebook nefunguje, a tak Kubik získa menej, alebo je dokonca v strate. Predajcovia sú v Ebaystane postavaní, ako inak, do mriežky. O každom predajcovi Kubik vie, ako veľmi sa mu oplatí od neho notebook kúpiť. Presnejšie, pre každého predajcu si zrátal, aký zisk by mal, ak by od daného predajcu kúpil notebook.

V jeden deň sa Kubik vybral na nákupy. Postavil sa do ľavého horného rohu Ebaystanu. Teraz chce prejsť do pravého dolného rohu a chce pri tom dosiahnúť čo najväčší zisk. Má to ale problém. V Ebaystane je zakázané chodiť doľava, aby nenastali zrážky s inými nakupujúcimi, ktorí idú doprava. Kubik ale nemá času nazvyš a tak žiadneho predajcu nechce navštíviť viac, ako raz.

## Úloha

Ebaystan je mriežka rozmerov $R \\times C$. O každom políčku Kubik vie, koľko získa, ak cez dané políčko prejde. Keďže predajcovia sú otravní, po vstupe na políčko Kubik musí od daného predajcu notebook kúpiť.

Kubik začína v ľavom hornom rohu a chce skončiť v pravom dolnom. V týchto dvoch rohoch nie sú predajcovia. Ziskovosť týchto políčok je teda 0.

Kubik môže chodiť iba **hore**, **dole** a **doprava**. Naviac na žiadne políčko nemôže stúpiť viac, ako raz.

Koľko najviac vie Kubik zarobiť touto technikou nákupu za polovičnú hodnotu?

## Formát vstupu

Na prvom riadku vstupu sú dve celé čísla $R$ a $C$, počet riadkov a počet stĺpcov. Platí, že $2 \\leq R,,C \\leq 600$.

Nasleduje $R$ riadkov. V každom z týchto riadkov sa nachádza $C$ celých čísiel. Žiadne z týchto čísiel v absolútnej hodnote neprevýši $1000$. Je zaručené, že v ľavom hornom a pravom dolnom rohu je hodnota 0.

## Formát výstupu

Vypíšte jedno číslo - aký najväčší zisk vie Kubik dosiahnúť, ak začne vľavo hore, skončí vpravo dole, na žiadne políčko nestúpi viac, ako raz a zároveň bude chodiť iba hore, dole, a doprava.

## Hodnotenie

| Sada | 1 | 2 | 3 | 4 | |:----------------- | ---: | ---: | ----: | ----: | | $2\\leq R, C\\leq$ | $4$ | $10$ | $100$ | $600$ |

## Príklad

```vstup
3 5
0 6 3 -2 9
3 6 -1 8 2
5 -7 1 2 0
```

```vystup
37
```

*Kubik použije cestu DRURDDRUURDD, kde D je dole, R je doprava a U je hore. Zoberie teda postupne políčka s hodnotami 0, 3, 6, 6, 3, -1, 1, 2, 8, -2, 9, 2, 0.*
","# Lacný polozisk

Za úlohu sme mali prejsť z ľavého horného do pravého dolného políčka mriežky tak, aby sme maximalizovali súčet hodnôt prejdených políčok. Mohli sme pri tom chodiť iba hore, dole a doprava.

## Jednoducho, neefektívne, funkčne

Ak nevieme, čo s úlohou, niet lepšieho nápadu, ako napísať riešenie hrubou silou. Možno si potom niečo všimneme a budeme takéto riešenie vedieť prerobiť na nejaké rýchlejšie.

Nuž, keďže chceme hrubú silu, vyskúšajme všetky možnosti. Ináč povedané, skúsme postupne každú možnú cestu z ľavého horného, na pravé dolné políčko. Samozrejme, chceme skúšať iba tie cesty, kde nechodíme doľava, pretože to predsa nesmieme. Pre každú cestu zrátame súčet hodnôt prejdených políčok. Z nich nakoniec vypíšeme maximum.

Ako niečo takého naprogramovať? Jednoduchým riešením je rekurzia. O každom políčku si budeme pamätať, či už sme cez neho prešli, alebo nie. Tiež si budeme pamätať, na ktorom políčku aktuálne stojíme.

Aké máme možnosti, keď stojíme na políčku $[r, c]$? Môžeme sa pohnúť hore, teda na políčko $[r - 1, c]$, dole, teda na políčko $[r + 1, c]$, alebo doprava, teda na políčko $[r, c + 1]$. Samozrejme, ak je dané políčko už označené ako navštívené, alebo ak neexistuje (teda je mimo mriežky), tak naň stúpiť nemôžeme. Ktorú možnosť si vybrať? Keďže skúšame všetky možnosti, tak si postupne vyberieme všetky. Políčko, na ktoré sa rozhodneme ísť označíme ako navštívené. K aktuálnemu súčtu si pripočítame hodnotu daného políčka a rekurzívne sa zavoláme na to políčko. Ked sa vrátime z rekurzie, označíme ho opäť ako nenavštívené a skúsime ďalšiu možnosť. Takto postupne preveríme všetky 3 možnosti pre dané políčko.

Samozrejme, ak sa rekurziou zavoláme až na políčko $[R - 1, C - 1]$, tak sa ďalej nevoláme, ale iba si zapamätáme maximum z doterajšieho maxima a aktuálneho súčtu políčok a vrátime sa z rekurzie.

Technika, ktorú sme použili sa volá rekurzívny backtracking a na napísanie riešenia hrubou silou sa dá použiť veľmi často.

Akú to má zložitosť? Keďže skúšame všetky cesty, tak to určite bude aspoň toľko, koľko je ciest. A koľko to je? Nuž, to nie je celkom jednoduché.

Ľahko však spravíme horný odhad. Na každom z $RC$ políčok skúšame 3 možnosti. Každú cestu aj naozaj prejdeme. Najdlhšia možná cesta má nanajvýš $RC$ políčok. Horný odhad teda bude $O(RC \\cdot 3^{RC})$.

Môžeme spraviť aj dolný odhad. Keby sme chodili iba dole a doprava, tak by sme dokopy vždy spravili $R + C$ krokov. Práve $R$ z nich bude doprava. Počet takýchto ciest teda bude $(R + C) \\cdot {R+C \\choose R}$. Tým, že pridáme možnosť chodiť aj hore nám počet týchto ciesť nezníži.

Časová zložitosť nášho programu je niekde medzi tým. Malo by to stačiť na prvú sadu.

Pamäť je $O(RC)$.

## Z hrubej sily vzorák?

Ako sme už povedali, niekedy stačí malé pozorovanie, aby sme z riešenia hrubou silou spravili vzorák.

Skúsme si pre každé políčko zrátať, koľko by sme zarobili, keby sme na ňom začínali, ale nemohli stúpiť na políčko $[r, c]$.

Naša nová rekurzia si okrem súradníc políčka, na ktorom stojíme, pamätá aj to, na ktoré políčko nesmieme stúpiť. Nepotrebujeme teda už veľké dvojrozmerné pole navštívených políčok. Totiž, ak si pamätáme iba to, na ktorom políčku sme boli bezprostredne predtým, ako sme sa dostali na to aktuálne, tak určite na žiadne políčko nestúpime dvakrát. Je to kvôli tomu, že nemôžeme chodiť doľava. Rozmyslite si, že nám táto informácia naozaj stačí.

Dokonca nepotrebujeme ani súradnice predchádzajúceho políčka. Stačí nám vedieť smer, z ktorého sme prišli, čo si môžeme reprezentovať napríklad číslami 1, 2, 3. Naša rekurzia má teda stav `riadok, stlpec, odkial`.

Všimnime si teraz veľmi užitočnú vec. Ak už niekedy zrátame odpoveď pre nejaký stav `riadok, stlpec, odkial`, tak už nikdy ho nemusíme rátať znova. Stačí, ak si zapamätáme výsledok a keď ho budeme potrebovať zrátať nabudúce, iba sa pozrieme na ten výsledok, ktorý máme uložený.

Vnútro našej rekruzívnej funkcie teda bude vyzerať asi tak, že sa najskôr pozrieme, či už nie sme na pravom dolnom políčku. Ak áno vrátime ako odpoveď 0. Ak nie sme, tak sa pozrieme, či už nemáme výsledok pre aktuálny stav uložený. Ak áno, tak ho vrátime. Ak ho nemáme uložený, tak sa rekurzívne zavoláme do tých dvoch, alebo troch smerov, do ktorých môžeme. Skúšame totiž 3, ale z jedného sme možno prišli, takže tam nepôjdeme. Nakoniec si iba zapamätáme odpoveď pre aktuálny stav a vrátime ju.

Na konci iba vypíšeme odpoveď pre stav `0, 0, -1`.

Akú to má zložitosť? Každý stav zrátame v $O(1)$, pretože sa iba dvakrát rekurzívne zavoláme. Stavov je $R \\cdot C \\cdot 3$. Celková časová zložitosť teda bude $O(RC)$. Pamätáme si vstup a odpovede pre všetky stavy, takže aj pamäť bude $O(RC)$.

Jeden problém, ktorý sa môže vyskytnúť je hĺbka rekurzie. Môže nám totiž dôjsť miesto na zásobníku. To má ale jednoduché riešenie. Nezavoláme sa hneď na výsledný stav, ale budeme sa postupne volať od posledných stavov až k tomu, ktorý nás najviac zaujíma.

Technika zapamätávania si už zrátaných výsledkov sa zvykne označovať ako dynamické programovanie. My sme tu použili jeho rekurzívnu formu, ktorá sa často nazýva rekurzia s memoizáciou. Samozrejme, táto úloha sa dá riešiť rovnako jednoducho aj iteratívne, rekurzia je však pre množstvo ľudí o niečo intuitívnejšia.
",4
0f6f030eea66cda9,ksp,"# Obávaná skratka

Čo by to bolo za hry v Koloseu, keby sa ich nezúčastnili aj Galovia? Emanix^[Emanix v preklade znamená bojovník Pásomničej légie Galskej domobrany.] sa rozhodol zúčastniť sa na gladiátorských súbojoch. Na chrbát si pripol svoju obľúbenú zbraň^[squashovú raketu], do ruky zobral štít^[jeho časom takmer zabudnuté frisbee] a so svojím druidom Prefixom sa vydal na cestu. Pred cestou sa, samozrejme, poriadne najedol -- presne tak, ako sa na Gala patrí.

Cesta bola plná nástrah, preto sa Emanix musel pohybovať rýchlo. Po namáhavom dni sa dostali na rázcestie. Tam Prefix zazrel tabuľu, ktorá hovorila o úžasnej skratke ku Koloseu, ktorá vedie cez záhradky Rímskeho impéria. Čo však je horšie, miestni majú už plné zuby Galov, čo si tadiaľ skracujú cestu. Preto v momente, ako naši dvaja hrdinovia vkročia do nejakej záhradky, rozbehne sa za nimi strážny diviak. Ako správny projekt Rímskeho imperiálneho fondu regionálneho rozvoja má každá záhrada na začiatku tabuľku, na ktorej je napísané, za aký čas diviak votrelca v tejto záhradke chytí. Akonáhle votrelec opustí záhradku, diviak ho prestane prenasledovať (nejedná sa už o jeho územie, tak prečo by sa mal namáhať?).

Keďže bol Emanix po celom dni unavený^[Musel predsa nosiť svoju zbroj.], pohyboval sa konštantnou rýchlosťou $0.5, m/s$. Prefix sa ako verný pomocník ponúkol, že Emanixovi pomôže odniesť zbroj. Emanix ako silný emancipovaný Gal však odmietol. Namiesto toho sa rozhodol, že pokiaľ nebude stíhať ujsť pred diviakom, napije sa zo svojho čarovného nápoja, ktorý zvýši jeho rýchlosť dvojnásobne. Čarovný nápoj však účinkuje iba $k$ sekúnd a Prefix ako skúsený druid neodporúča užívať viac dávok naraz -- môže to mať veľmi nepriaznivé účinky na Emanixov metabolizmus. Hneď ako účinok nápoja vyprchá, Emanix si môže dať ďalší dúšok.

Emanix je teraz zvedavý, či sa dokáže dostať touto cestou až do Kolosea. Pomôžte mu zistiť, či dokáže prejsť cez všetky záhradky bez toho, aby ho dobehol nejaký diviak. Ak to Emanix dokáže, zistite, koľkokrát sa musí napiť zo svojho čarovného nápoja.

## Úloha

Na ceste sa nachádza $n$ záhradiek tesne za sebou (tam, kde jedna záhradka končí, ďalšia začína). Vašou úlohou je zistiť, či sú Emanix s Prefixom schopní dostať sa cez všetky záhradky bez toho, aby ich ktorýkoľvek diviak dohnal. Ak to dokážu, musíte tiež zistiť, koľko najmenej krát sa musí Emanix napiť zo svojho čarovného nápoja. O každej záhradke viete jej dĺžku $l$ a čas $t$ -- najdlhší čas, ktorý môže byť Emanix v danej záhradke (ak by tam bol dlhšie, dobehol by ho diviak).

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú dve čísla $n$ a $k$ ($1 \\leq n \\leq 5 \\cdot 10^5$, $1 \\leq k \\leq 10^{12}$). $n$ je počet záhradiek, $k$ je trvanie účinku čarovného nápoja v sekundách. Na druhom riadku sa nachádzádza postupnosť medzerami oddelených čísiel $l_1, l_2, \\dots, l_n$ ($1 \\leq l_i \\leq 10^6$), ktoré označujú dĺžky jednotlivých záhradiek v metroch. Na posledom riadku sa nachádza postupnosť medzerami oddelených čísiel $t_1, t_2, \\dots, t_n$ ($1 \\leq t_i \\leq 10^7$) - časy, za ktoré Emanixa a Prefixa v jednotlivých záhradkách dobehne diviak, v sekundách.

## Formát výstupu

Na výstup vypíšte, najmenej koľkokrát sa bude musieť Emanix napiť čarovného nápoja, aby cez záhradky stihli prejsť. Ak Emanix nedokáže cez záhradky prejsť, vypíšte $-1$.

## Príklady

```vstup
1 3
7
10
```

```vystup
2
```

_Emanix sa môže napiť napríklad hneď na začiatku. Za prvé $3$ sekundy prejde $3$ metre. Potom sa napije znovu a za ďalšie $3$ sekundy prejde ďalšie $3$ metre. Potom nápoj prestane účinkovať a posledný meter teda Emanixovi bude trvať $2$ sekundy. Ak by sa napil iba raz, počas trojsekundového účinku nápoja by stihol prejsť $3$ metre a na zvyšné $4$ by potreboval $8$ sekúnd, čo je dokopy viac než povolených $10$ sekúnd._

```vstup
3 100000
5 5 5
5 7 8
```

```vystup
1
```

```vstup
4 1000
1 2 3 4
10 9 10 9
```

```vystup
0
```

```vstup
3 3
3 3 3
3 3 2
```

```vystup
-1
```

_Cez poslednú záhradku Emanix nestihne prejsť, ani keby bol celý čas pod účinkom nápoja._
","# Obávaná Skratka

Ešte pred tým, ako sa pustíme do riešenia, si zopakujeme parametre zo vstupu. Zadanú máme dĺžku účinku čarovného nápoja $k$, dĺžky jednotlivých záhrad $l_1, \\dots, l_n$ a počty sekúnd $t_1, \\dots, t_n$, koľko sa v jednotlivých záhradách môže Emanix zdržať.

Najskôr sa pozrieme na to, ako by sa táto úloha dala vyriešiť, ak by Emanix prechádzal len cez jednu záhradu. Následne si ukážeme, ako takéto riešenie rozšíriť na viacej záhrad.

## Riešenie pre jednu záhradu

Predpokladajme, že Emanix chce prejsť cez záhradku dlhú $l$ a môže sa v nej zdržať maximálne $t$ sekúnd. Môžu nastať 3 prípady:

1. Emanix stihne ujsť pred diviakom bez použitia elixíru. Keďže jeho rýchlosť je $0.5 ,\\mathrm{m}/\\mathrm{s}$, čas ktorý sa Emanix v záhrade zdrží zrátame ako $2 \\cdot l$. Tento prípad teda nastane práve vtedy, keď $2 \\cdot l \\leq t$.

1. Emanix nevie utiecť pred diviakom ani s použitím elixíru. Jeho rýchlosť s elixírom je $1 ,\\mathrm{m}/\\mathrm{s}$, takže utiecť nestihne ak $l > t$.

1. Emanix nestihne prejsť bez elixíra, ale s elixírom to stihne. Toto nastane ak $l \\leq t < 2 \\cdot l$

V treťom prípade nás zaujíma, koľko elixírov potrebuje Emanix vypiť. Tu nám pomôže to, že za $s$ sekúnd s elixírom prejde Emanix rovnakú vzdialenosť ako za $2 \\cdot s$ sekúnd bez elixíru. Na toto sa dá pozerať aj tak, že ak chceme, aby nejakú vzdialenosť prešiel o $s$ sekúnd rýchlejšie, stačí aby bol $s$ sekúnd pod vplyvom elixíru. My si teda zrátame o koľko sekúnd by diviakovi nestihol ujsť ak by nepoužil elixír ($s = 2 \\cdot l - t$) a následne Emanix vypije aspoň toľko elixíru ($\\lceil \\frac{s}{k}\\rceil$).

## Viacero záhrad

Rozšírenie pre viacero záhradiek by bolo veľmi jednoduché, keby záhradky neboli nalepené jedna na druhú, lebo by sme ich mohli riešiť samostatne. Keďže však nasledujú tesne za sebou, tak elixír použitý v jednej záhradke môže posobiť aj v niekoľkých nasledujúcich, čo nám vie ušetriť niekoľko napití elixíru.

Ak pri niektorej záhradke nastane 2. prípad, Emanix nedokáže cez záhradky prejsť, teda môžeme rovno vypísať `-1`. Zamerajme sa ďalej už len na možnosť, že cez všetky záhradky Emanix stíha (možno len za pomoci elixíru) prejsť, teda vždy nastáva prípad 1. alebo prípad 3..

Budeme postupne riešiť jednotlivé záhradky od prvej až po poslednú. Vezmime si riešenie pre prvú záhradku. Ak nastane prípad 1., nič zaujímavé sa nám na probléme nezmení.

Rozoberme si teda prípad 3, kde Emanix potrebuje byť pod vplyvom elixíru $s$ sekúnd. Keďže elixíry vieme piť len po $k$-sekundových dávkach, tak sa nám mohlo stať, že musíme vypiť $a > s$ elixíru. Keďže v prvej záhradke potrebuje byť Emanix pod vplyvom elixíru iba $s$ sekúnd, môže si jeho vypitie načasovať tak, aby mu zvyšných $a-s$ sekúnd zostalo do ďalšej záhradky (inými slovami, vypiť elixír čo najneskôr ako môže). Toto sa zjavne oplatí, keďže riešenie prvej záhradky tým nijako nepokazíme a vieme len získať lepšie riešenie nasledujúcich záhradiek.

Pri riešení každej ďalšej záhradky už budeme predpokladať, že na začiatku $e$ sekúnd už Emanix má vypitý elixír. Ak celú záhradu prejde na $e$ elixíru, tak od zostávajúceho elixíru odrátame čas prejdenia tejto záhradky a presunieme sa na ďalšiu s novou hodnotou $e := e - l_i$ (kde $l_i$ je dĺžka aktuálnej záhradky).

Elixír sa nám však môže minúť aj uprostred. V tomto prípade je najjednoduchšie ,,odrátať'' od dĺžky záhrady a času diviaka časť, keď bol Emanix pod vpluvom zvyšku elixíru a ďalej záhradu riešiť ako záhradu bez počiatočného elixíru: $l_i := l_i - e;~ t_i := t_i - e$.

Pre každú záhradu teda zistíme, koľko elixírov na nej vypijeme. Už nám to len stačí sčítať (alebo počítať priebežne) a vypísať.

## Zložitosť

Pre každú záhradu robíme len niekoľko operácií v konštantnom čase. Náš algoritmus teda bude mať časovú zložitosť lineárnu od počtu záhrad $n$, čo označujeme ako $O(n)$. Ďalej si musíme pamatať dĺžku každej záhrady a čas, ktorý v nej môžme stráviť. No a keďže si pre každú záhradku potrebujeme pamätať konštantne veľa informácie, pamäťová zložitosť bude tiež $O(n)$.
",2
f8c9ebf4722ce619,ksp,"# Žiarivý zádrhel

Kde bolo tam bolo, za bielym oblúkovým mostom a za dvoma veľkými semafórovými križovatkami, bola raz jedna škola. V tejto škole bola jedna trieda, a jej triedny učiteľ Ondrej si ju veľmi pochvaľoval. Jej žiaci totiž chodili na informatické sútaže. Vyhrali na nich kopu trofejí, každú žiarivejšiu ako prechádzajúcu.

Jedného dňa si Ondrej povedal, že tak krásnych trofejí je v jeho kabinete škoda. Aby jeho žiaci mohli vidieť plody svojej práce, rozhodol sa, že ich vyloží na poličku v triede. Polička je však na všetky trofeje priúzka, Ondrej preto vystavil len tie najžiarivejšie.

Prišla jar, a spolu s ňou začalo do triedy prenikať čím ďalej tým viac slnečných lúčov. Polička s trofejami sa každé ráno trblietala prekrásnymi farbami. Ondrej si však po chvíli začal všímať aj jej temnú stránku. Trofeje žiarili tak výrazne, až to začalo všetkých v miestnosti oslepovať.

S tým treba niečo robiť! Ondrej teda vytiahol krabicu so zvyškom trofejí a začal dumať. Vie, ako najviac môže polička žiariť aby žiakov ešte neoslepovala. Zároveň ju však nechce mať ani o kúsok matnejšiu, žiaci si predsa zaslúžia vidieť tie najžiarivejšie trofeje.

Ondrej má na výber $n$ trofejí. Jeho žiaci vyhrávali čím ďalej tým žiarivejšie trofeje a tak $i$-ta trofej má žiarivosť $i$. Na poličku sa zmestí $k$ trofejí, jej žiarivosť je súčtom žiarivostí jednotlivých trofejí. Najväčšia žiarivosť poličky, akú si môže Ondrej dovoliť, je $s$. Pomôžete mu vybrať tie správne trofeje?

## Úloha

Spomedzi čísel $1, 2, ..., n$ vyberte $k$ takých, že ich súčet je presne $s$.

## Formát vstupu

Na vstupe dostanete tri celé čísla $n$, $k$, $s$ oddelené medzerami. $1 \\leq n\\leq 1,000,000$ -- počet trofejí, $1 \\leq k \\leq n$ -- šírka poličky, $1 \\leq s \\leq 2^{40}$ -- ideálna žiarivosť poličky.

Na prácu s veľkými číslami^[64-bitové čísla s rozsahom $-2^{63}$ až $2^{63}-1$] použite typ `long long` v C++ a `Int64` v Pascale.

## Formát výstupu

Na jediný riadok výstupu vypíšte $k$ medzerou oddelených čísel -- čísla (žiarivosti) trofejí, ktoré má Ondrej vyložiť na poličku. Na poradí vypísaných čísel nezáleží.

Ak dobrých výberov trofejí existuje viac, vypíšte ľubovoľný z nich. Ak žiadny dobrý výber trofejí neexistuje, vypíšte $-1$.

## Príklad

```vstup
6 3 11
```

```vystup
1 4 6
```

_Rovnako dobrý výber trofejí je napríklad aj $6$, $2$, $3$._

```vstup
5 2 10
```

```vystup
-1
```

_Dve najžiarivejšie trofeje, ktoré môže Ondrej vystaviť sú $4$ a $5$, ani tie však nie sú dosť oslnivé._
","# Žiarivý zádrhel

## Hrubá sila

Najjednoduchšia vec, ktorá sa dá spraviť, je postupne vyskúšať sčítať všetky $k$-tice čísel od $1$ po $n$, až kým nenarazíme na niektorú so súčtom $s$ a tú vypísať. V Pythone sa takéto riešenie hrubou silou dá veľmi jednoducho naprogramovať pomocou knižnice `itertools`.

V najhoršom prípade prejdeme všetký $k$-tice, ktorých je ${n \\choose k}$ a každú spracujeme v čase $O(k)$. Časovú zložitosť by sme mohli voľne zhora ohraničiť ako $O(k \\cdot n^{n/2})$ alebo ako $O(k \\cdot 2^n)$ (ak zhora ohraničíme kombinačné číslo veľkosťou súčtu $n$-tého riadku Pascalovho trojuholníka ${n \\choose k} \\leq 2^n$).

## Optimálne riešenie

Ako prvú vec si môžeme všimnúť, že úloha by sa nám výrazne zjednodušila, keby každý súčet mohol byť vybraný ako súvislý úsek čísel. Súčet takejto aritmetickej postupnosti vieme zrátať v konštantnom čase (pre súčet čísel $1, 2, \\dots n$ existuje známy vzorec $\\frac{n(n+1)}{2}$) a takýchto úsekov je menej. Teda riešenie prechádzajúce všetky takéto postupnosti by malo výrazne lepšiu časovú zložitosť ($O(n+k)$). A nielen to, už zo súčtu by sme rovno vedeli povedať, ktoré čísla v tejto postupnosti budú.

Takáto postupnosť sa však nedá nájsť vždy. Napríklad pre vstup ($n, k, s$) `6 3 11` je riešenie `2 3 4` primálo a `3 4 5` priveľa. Možno ale existuje postupnosť čísel s takýmto súčtom, ktorá je skoro súvislá.

Na náš príklad sa vieme pozrieť aj takto: keď z `2 3 4 5` vynecháme najväčšie číslo, súčet zvyšku bude primalý. Ak však vezmeme to najmenšie, súčet zvyšku bude priveľký. Nevieme vynechať nejaké číslo v strede tak, aby nám to sedelo? Vieme, a dokonca takéto čislo naozaj vieme vynechať vždy. Vynechávaním postupne čísel $2, 3, 4, 5$ sa nám zmenšuje súčet úseku a tento súčet dosiahne všetky hodnoty medzi $3+4+5=12$ a $2+3+4=9$.

Z postupnosti teda potrebujeme vynechať jedno číslo: (súčet postupnosti $-~s$).

Už len potrebujeme nájsť takúto postupnosť, z ktorej vieme jedno číslo vynechať a dostaneme súčet $s$.

Označme si prvé číslo tejto postupnosti ako $a$. Vieme, že táto postupnosť bude vyzerať ako $a, a+1, \\ldots a+k$. Chceme, aby súčet $a + (a+1) + \\ldots + (a+k-1) ~ \\leq ~s$, a pritom $a$ bolo čo najväčšie:

$$ a \\cdot k + \\left(0 + 1 + \\ldots + (k-1)\\right) \\leq s $$

$$ a \\leq \\frac{\\left(s - \\left(0 + 1 + \\ldots + \\left(k-1\\right)\\right)\\right)}{k}$$

Keďže chceme aby $a$ bolo celé číslo, potrebujeme zaokrúhliť pravú stranu rovnice nadol a dostávame priamo vzorec na jeho výpočet. Zaokrúhlenie za nás bude robiť celočíselné delenie $k$ na záver.

Zhrňme si teda riešenie. Najprv si vyrátame, ktorá súvislá postupnosť dĺžky $k+1$ nás zaujíma. Z tejto postupnosti potom vynecháme jedno číslo tak aby súčet zvyšku bol presne $s$ a postupnosť vypíšeme bez jedného čísla.

Časová zložitosť tohto algoritmu je $O(k)$ -- nájsť postupnosť $k+1$ čísel vieme v konštantnom čase, rovnako aj nájdenie vhodného čísla na vynechanie. Musíme však vypísať $k$ čísel.

Algoritmus sa dá implementovať s pamäťovou zložitosťou $O(1)$. V Pythone sa však rýchlejšie vypisuje po celých riadkoch. Preto si najprv vytvoríme celú postupnosť a potom ju naraz vypíšeme -- implementácia teda používa $O(k)$ pamäte.
",5
0123b2056f9974d2,ksp,"# Ááále, to sa spraví...

V okolí reaktoru vraj nejak stúpala radiácia, a tak každý intern vyfasoval jeden Geigerov-Müllerov počítač a poďho do terénu.

A ozaj, ony tie merania vyšli nejak divne. Ale to je určite len nejaká fluktuácia chalani, do reportu to tak nepíšte. Trošku to upravte, tak žeby dobre bolo, a ono to určite samo časom prejde.

## Úloha

Je $a$ internov, každý spravil presne $b$ meraní. Čísla $a$ a $b$ sú obe nepárne.

Medián všetkých meraní je hodnota, ktorá by bola uprostred, keby sme ich všetky usporiadali podľa veľkosti. Do reportu by sme potrebovali napísať také merania, ktorých medián bude **presne** $m$.

Každý intern môže klamať, a to tak, že prepíše nejaké svoje merania na ľubovolné hodnoty. Koľko najmenej internov musí v reporte klamať?

(Každý intern musí do reportu napísať nejakých $b$ čísel. Ak intern klame, nemusí nutne zmeniť všetky svoje hodnoty, môže upraviť len ľubovoľnú ich podmnožinu.)

## Formát vstupu

V prvom riadku vstupu sú čísla $a$, $b$ a $m$. V každom z nasledujúcich $a$ riadkov je $b$ čísel: merania spravené jedným z internov.

Všetky výsledky meraní aj číslo $m$ sú celé čísla z rozsahu od 0 po 99. (Keď intern klame, môže do reportu uviesť aj iné čísla, ak chce.)

Hodnoty $a$ a $b$ sú kladné celé čísla. V jednotlivých sadách platia nasledovné obmedzenia pre ich súčin:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | -----:| ----------:| -----------:| -----------:| | $\\max a\\times b$ | 7 | 99 | 999 | $99,999$ |

## Formát výstupu

Vypíšte jeden riadok a v ňom jedno číslo: minimálny počet internov, ktorí musia v reporte klamať, ak potrebujeme, aby medián všetkých $a\\times b$ meraní vyšiel presne $m$.

## Príklady

```vstup
5 5 8
1 2 3 4 5
10 9 8 7 6
25 24 23 22 21
18 16 17 19 20
11 13 12 14 15
```

```vystup
1
```

*Momentálne je medián všetkých meraní rovný 13. Na to, aby sa zmenšil na 8, napríklad stačí, ak štvrtý intern namiesto 18,16,17,19,20 dá do reportu 3,1,3,5,7.*

```vstup
5 5 8
1 2 25 24 23
3 4 22 21 20
5 6 19 18 17
7 16 15 14 13
8 12 11 10 9
```

```vystup
2
```

*Tu namerali interni tých istých 25 hodnôt, ale pri tom, ako ich majú teraz rozdelené, nestačí, aby klamal len jeden z nich.*

```vstup
1 5 30
30 50 10 20 40
```

```vystup
0
```

```vstup
1 5 27
30 50 10 20 40
```

```vystup
1
```

```vstup
3 1 20
10
10
10
```

```vystup
2
```
","# Ááále, to sa spraví...

Začneme tým, že si vyriešime jednoduchšiu úlohu: odignorujeme zatiaľ, že máme nejakých internov, a budeme sa zaujímať len o to, koľko najmenej *čísel* treba zmeniť, aby medián vyšiel presne $m$.

Predstavme si, že sme si všetky hodnoty usporiadali a pozreli sme sa do stredu poľa. Ak v strede poľa vidíme želanú hodnotu $m$, netreba meniť nič.

Ak vidíme hodnotu menšiu ako $m$, máme v poli priveľa malých čísel. Zistime si teda, pokiaľ v našom poli siahajú čísla menšie ako $m$. Nech sú primalé čísla nielen v strede poľa, ale aj na nasledujúcich $x-1$ políčkach. Čo to pre nás znamená? Aspoň $x$ spomedzi čísel v pôvodnom poli nutne musíme zväčšiť na aspoň $m$, inak budeme mať ešte stále priveľa malých čísel a v strede usporiadaného poľa bude naďalej primalá hodnota.

Na druhej strane však ľahko nahliadneme, že keď zmeníme *ľubovoľných* $x$ primalých hodnôt na hodnotu presne $m$, dostaneme platné riešenie. Totiž keď po tejto zmene preusporiadame prvky, prvky s novou hodnotou $m$ obsadia presne $x$ posledných políčok z úseku, v ktorom dovtedy boli primalé hodnoty -- a teda aj v strede poľa už dostaneme hodnotu $m$.

Situácia, keď sme v strede poľa uvideli priveľkú hodnotu, sa rieši symetricky.

## Späť k pôvodnej úlohe

Bez ujmy na všeobecnosti predpokladajme, že súčasný medián je primalý, potrebujeme teda niektoré prvky zväčšiť. A vyššie popísaným spôsobom vieme nájsť $x$ také, že určite treba spraviť aspoň $x$ zmien.

Pre každého interna si teraz zistíme, koľko má medzi svojími meraniami čísel menších ako $m$. Nanajvýš toľko ich samozrejme tento konkrétny intern vie zväčšiť na $m$. My hľadáme takú sadu internov, aby ich bolo čo najmenej a aby dokopy vedeli zväčšiť aspoň tých potrebných $x$ hodnôt. Je zjavné, že toto vieme spraviť pažravo: usporiadame si internov podľa toho, koľko hodnôt vedia zväčšiť na $m$, a budeme ich postupne brať (začínajúc tým, ktorý vie zmien spraviť najviac) až kým nebudú dokopy vedieť spraviť dostatočný počet zmien.

Zjavne platí, že keď nami vybraná skupina internov spraví ľubovoľných $x$ zmien (hodnoty menšej ako $m$ na hodnotu $m$), dostaneme platné riešenie. A tiež platí, že žiadna menšia skupina internov takto veľký počet zmien nevie spraviť, nájdené riešenie je teda optimálne.

## Implementácia

K implementácii už len podotknem, že usporadúvať samotné čísla vôbec netreba -- totiž si stačí v lineárnom čase spočítať, koľko je primalých a koľko je priveľkých. Pri usporadúvaní internov podľa počtu dobrých zmien, ktoré vedia spraviť, som použil CountSort, celkovo má teda nižšie uvedená implementácia časovú zložitosť lineárnu od veľkosti vstupu: $O(ab)$.
",6
abc1ea448a9ed6ae,ksp,"# Národné toaletné centrum

Ako každý rok, aj v roku 2022 Národné toaletné centrum zorganizovalo Zraz toaletárov. Pre veľkú popularitu tohto podujatia sa organizátori rozhodli obmedziť vstup verejnosti. Aby však nerozhnevali verných nadšencov Zrazu toaletárov, vymysleli súťaž, ktorá by umožnila tým najbystrejším zúčastniť sa.\
Filip, obrovský fanúšik porcelánových trónov, však veľmi bystrý nie je a žiada ťa aby si mu pomohol dostať sa na tohtoročný Zraz toaletárov.

## Úloha

IT oddelenie Národného toaletného centra vymyslelo takúto šifru: Dostaneme dve čísla $n$ a $k$ a text rozdelený na riadky, obsahujúci iba alfanumerické znaky a medzery. Aby sme Filipa dostali na Zraz toaletárov musíme šifru rozlúštiť. To urobíme následovne: Pre každý z riadkov vypíšeme $k$-ty znak riadku, pričom sa medzery **ne**počítajú ako znak. Môže sa stať, že v riadku bude nedostatočný počet znakov -- vtedy vypíšeme prázdny riadok.

## Formát vstupu

Na prvom riadku vstupu sú dve medzerou oddelené čísla: $n$ - počet riadkov textu a $k$ - index znaku, ktorý nás zaujíma (je šifrou). Ďalej na vstupe nasleduje $n$ riadkov textu.

## Formát výstupu

Na každý z $n$ riadkov vypíšete buď znak, ktorý je šifrou alebo prázdny riadok.

## Hodnotenie

Sú 4 sady vstupov. Pre prvé tri sady platia tieto obmedzenia:

| Sada | 1 | 2 | 3 | | :-------------- | ----: | --------: | ---------: | | $1 \\leq n \\leq$ | $50$ | $1,000$ | $10,000$ | | $1 \\leq k \\leq$ | $100$ | $500$ | $10,000$ |

Štvrtá sada zahŕňa špeciálne prípady.

## Príklad

```vstup
2 5
Narodne toaletne centrum
9800 navstevnikov
```

```vystup
n
a
```

_Všimnime si, že číslujeme od nuly, teda $k$ je naozaj indexom._

```vstup
3 2
Ako
sa
mas
```

```vystup
o

s
```

_Druhý riadok nemal dostatočný počet znakov, teda sme vypísali prázdny riadok._
","# Národné toaletné centrum {bodypopis=12 bodyprogram=8}

## Čo bolo našou úlohou

Našou úlohou bolo prejsť každý riadok vstupu a vypísať z neho $k$-te písmeno. Bolo treba ignorovať medzery, a ak bol riadok bez medzier kratší ako naše $k$, vypísať prázdny riadok.

## Ako sme to urobili

Mohli sme zvoliť viacero postupov. Tým najprimitívnejším bolo prechádzať každý znak z riadku, zapamätať si koľko nemedzerových znakov sme už prešli, a keď sa tento počet rovnal $k$, vypísať aktuálny znak. Ak sme sa dostali na koniec riadku a naše počítadlo bolo menšie ako $k$, vypíšeme prázdny riadok. Mohli sme taktiež využiť vstavané funkcie na nahradenie znakov medzery v riadku ""ničím"" a skontrolovať, či je riadok dlhší ako $k$. Ak áno vypísať jeho $k$-ty znak.

Časová zložitosť riešenia je $O(n \\cdot k)$. Pamäťová zložitosť je priamo úmerná dĺžke riadku($l$), teda $O(l)$.
",1
431b9224627ae339,ksp,"# Hady. Prečo to musia byť zrovna hady!?

Adam si chce pozrieť nový diel zo seriálu Mandalorian. Adam je fajnšmeker a chcel by si to pozrieť v najvyššej 4K kvalite, pre najlepší zážitok. Dokonca si kúpil aj novú televíziu, špeciálne kvôli tomuto seriálu (on Vám povie, že nie, ale neverte mu). Hodí sa do gauča, zapne Disney+ a pozerá sa. Nepozerá sa. Načítava sa.

Streamovať Mandalorian v 4K kvalite vyžaduje veľmi rýchly internet. Adam má dostatočne veľmi rýchly internet, ale nanešťastie, vo svojej sieti použil klasické, obojsmerné sieťové káble. Tieto káble sú ale zastarané a nie dosť rýchle na 4K kvalitu. Adamovi sa podarilo na populárnej stránke Krtkostarter™ nájsť nový druh sieťových káblov. Nové káble sú podľa ich vynálezcu, Krtka, kratšie, a teda rýchlejšie. Má to ale jeden háčik -- káble fungujú iba v jednom smere. Toto ale Adam nemá problém vyriešiť a tak objednal pár zväzkov týchto káblov.

Po pár mesiacoch, troch oddialeniach prvej várky (nejaké výmysly o zamorení továrne hadmi šípkovitými -- čo ešte nevymyslia) a zopár súdoch Adamovi prišiel balík s káblami. Ako to už ale býva s nakupovaním na Krtkostarter-i, nebolo to úplne to pravé orechové. Káble na sebe mali mať značenia, ktorým smerom vlastne fungujú. Po podrobnom preskúmaní si ale Adam všimol, že niektoré káble majú trochu divné označenie. Aby toho nebolo málo, niektoré káble sa začali hmýriť! Adam sa zvládne postarať o hmýriace sa hady, no musel Vás poprosiť o pomoc s triedením káblov. Pomôžte mu! (fakt si to už chce pozrieť!)

## Úloha

Na každom kábli sa nachádza reťazec zložený zo šípok -- znakov '\<' a '>'. Pokiaľ vynecháme všetky výskyty podreťazca susediacich ""zátvorkových"" šípok (reťazec `<>`), ostanú nám iba šípky, ktoré indikujú správny smer kábla. Na vstupe dostanete vždy jeden kábel a Vašou úlohou bude povedať, či je kábel ľavo-dátový alebo pravo-dátový.

## Formát vstupu

Na vstupe sa nachádza práve jeden riadok -- reťazec znakov '\<' a '>' -- náš kábel. Každý vstup má zaručené, že sa skladá iba z reťazcov `<>` a zvyšných znakov, ktoré budú vždy iba šípky smerujúce jedným smerom, doľava ('\<') alebo doprava ('>'). Adam kupoval iba kratšie káble, teda dĺžka reťazca $n$ nepresiahne $10^6$ znakov.

## Formát výstupu

Na výstup vypíšte práve jeden riadok s jedným z nasledujúcich reťazcov -- `lavo-datovy` pokiaľ je kábel ľavo-dátový, teda všetky jeho šípky, ktoré nepatria k šípkovým zátvorkám `<>`, mieria doľava. Nápodobne vypíšte reťazec `pravo-datovy`, pokiaľ je kábel pravo-dátový, teda všetky jeho nezátvorkové šípky ukazujú doprava.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3--4 | 5--8 | | :-------------- | ----: | -------: | ------------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $1,000,000$ |

## Príklad

```vstup
<
```

```vystup
lavo-datovy
```

_V prvom príklade má kábel iba jednu ľavú šípku a teda musí byť ľavo-dátový._

```vstup
<><><>><><>>><>><>
```

```vystup
pravo-datovy
```

_Druhý prípad je už trochu zamotanejší, no môžeme si všimnúť, že po troch pároch šípok narazíme na samotnú šípku smerom doprava. Vo zvyšku reťazca narazíme na ďaľšie osamelé šípky pravým smerom, no žiadnu osamelú smerom doľava, teda kábel musí byť pravo-dátový._
","# Hady. Prečo to musia byť zrovna hady!?

## Jedno riešenie

Máme teda naše káble, v celej ich jednosmernej kráse. Podľa zadania sa v nich nachádzajú iba znaky `<` alebo `>` (kvačky), a reťazce `<>` (3D dlaždice). Vedeli by sme spraviť to, že načítame celý vstup, prečístíme ho od `<>` reťazcov a zbytok, čo nám ostane, budú kvačky indikujúce správny smer. Stačí sa teda len na jednu z nich pozrieť a prehlásiť, ktorým smerom mieri. Toto riešenie nie je ale úplne efektívne, a to hlavne preto, že si musíme zapamätať všetky znaky zo vstupu, čo je $O(n)$ -- lineárna pamätová zložitosť. Časová zložitosť je ale taktiež lineárna -- $O(n)$ -- pretože iba vstup načítame, a zopár krát ho prejdeme. To je dobré, pretože aj tak potrebujeme lineárny čas už len na to, aby sme vstup načítali. Ak ste sa ešte neučili používať polia alebo reťazce (stringy), napísanie tohoto riešenia je skvelé cvičenie na oboznámenie sa ;)

## Lepšie riešenie

Prirodzene prichádza otázka, dá sa to lepšie? Áno, dá. Skúsme sa pozrieť na počty kvačiek, konkrétne ľavých a pravých. Majme dve premenné, v ktorých si budeme ukladať počet ľavých a pravých kvačiek, ktoré sme videli. Môžeme si všimnúť, že pokiaľ sa v reťazci nachádza `<>`, pripočíta sa nám ľavá aj pravá kvačka. Pokiaľ sa ale v reťazci nachádza iba ľavá alebo pravá, pripočíta sa nám iba príslušná premenná. Čo to znamená? Predstavme si, že sa v reťazci nenachádzajú reťazce `<>`. Ako tento reťazec vyzerá? Chvíľka napätia! Vyzerá nejako takto `<<<<<<<<`, takto `>>>>>>>>>>>`, alebo taaaaktoooo `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<`.

Pokiaľ sa vrátime k našemu počítaniu kvačiek, uvedomíme si, že po spočítaní nám ostane v jednej premennej viac započítaných kvačiek, ako v druhej. A to je naše riešenie. Spočítame ľavé/pravé kvačky, porovnáme, kde je ich viac a vyhlásime smer káblu. Toto riešenie má lepšiu pamäťovú zložitosť, konštantnú, teda $O(1)$. To znamená, že máme fixne pre akokoľvek veľký vstup iba dve premenné.[^1]

\[^1\]: Aj napriek tomuto má vzorové riešenie v Pythone pamäťovú zložitosť $O(n)$, pretože načítava celý vstup naraz. Načítavanie znak po znaku je totiž v Pythone trochu nepraktické.
",1
7e4f5a0ad4648004,ksp,"# Zanedbané zastávky

Kocúrkovo je to pravé mesto pre ľudí, ktorí sa vedia stratiť aj vo vlastnom byte. Je to totiž len jedna veľmi dlhá ulica. A keďže je taká dlhá, už roky tu jazdí mestská hromadná doprava.

Miestne autobusy jazdia po Kocúrkove tak, ako by ste od dlhej, rovnej ulice čakali. Pozdĺž ulice je postavených $n$ autobusových zastávok. Každá autobusová linka má dve konečné zastávky, medzi ktorými jej autobusy jazdia hore-dolu, pričom stoja aj na každej zastávke po ceste. Kocúrkovo je však Kocúrkovo a tak sa môže stať, že niektoré linky začínajú aj končia na rovnakej zastávke (a teda ich autobusy iba stoja na tejto zastávke).

Kocúrkovské zastávky začali pod náporom neúprosného času hrdzavieť a chátrať. Preto si starosta Kocúrkova povedal, že ich dá všetky zrekonštruovať. A keď už sa prerábajú, tak by to malo byť vidno. Nech na to ľudia do volieb nezabudnú.

Rekonštrukcia jednej zastávky trvá jeden deň. Je možné rekonštruovať aj viac zastávok naraz. Starosta by teda mohol všetky zastávky nechať zrekonštruovať v ten istý deň, ale pre jeho volebné preferencie to nemusí byť tá najlepšia možnosť. Ľudia si totiž rekonštrukciu budú pamätať lepšie, ak bude prebiehať dlhšie.

Starostovi hrá do karát to, že Kocúrkovo je známe svojimi klebetníkni. Stačí, aby sa na trase autobusovej linky prerábala jediná zastávka a v autobuse vrava neutíchne až do večera. Ak sa teda v nejaký deň na trase každej linky prerába aspoň jedna zastávka, v celej Kocúrkovskej hromadnej doprave sa rozpráva iba o rekonštrukcii.

## Úloha

Máte zadaný počet zastávok v Kocúrkove, počet liniek MHD a konečné zastávky, medzi ktorými tieto linky premávajú.

Starosta chce naplánovať rekonštrukciu zastávok tak, aby sa čo najdlhšie v autobusoch hovorilo iba o nej. Chce teda, aby od začiatku rekonštrukcie čo najdlhšie platilo, že na trase každej linky sa prerába aspoň jedna zastávka. Povedané ešte inak, starosta chce, aby sa čo najneskôr stalo, že na trase niektorej linky sa nebude prerábať žiadna zastávka.

A tu prichádzate na rad vy. Nájdite pre starostu Kocúrkova takýto plán a povedzte mu, koľko dní bude pri každej linke MHD aspoň jedna zastávka v rekonštrukcii. Pre každú zastávku teda naplánujte, v ktorý deň sa má prerábať.

## Formát vstupu

V prvom riadku vstupu sú dve medzerou oddelené celé čísla $n$ a $m$ - počet zastávok a počet autobusových liniek. Platí $1 \\leq n \\leq 1, 000, 000$ a $1 \\leq m \\leq 100, 000$.

Nasleduje $m$ riadkov, v každom z nich sú dve medzerou oddelené čísla $z_i$ a $k_i$ - poradové čísla konečných zastávok $i$-tej linky, od začiatku mesta. Platí $1 \\leq z_i \\leq k_i \\leq n$.

## Formát výstupu

Na prvý riadok výstupu vypíšte jedno číslo - po koľko dní od začiatku vieme rekonštruovať aspoň jednu zastávku na trase každej linky.

Na druhý riadok vypíšte $n$ medzerou oddelených čísel - čísla dní, kedy sa majú rekonštruovať jednotlivé zastávky (v poradí od začiatku mesta po koniec). Rekonštrukcia sa začína nultým ($0$) dňom. Ak existuje viac optimálnych riešení, vypíšte ľubovoľné z nich.

## Príklady

```vstup
5 3
1 3
2 5
4 5
```

```vystup
2
1 0 2 1 0
```

*Na trase prvej linky sa zastávky rekonštruujú v deň $1$, $0$ a $2$, takže ľudia si budú rekonštrukciu všímať $3$ dni. Podobne druhá linka. Pri tretej sa rekonštruuje v dni $0$ a $1$. Všetci si teda budú starostovu rekonštrukciu všímať aspoň $2$ dni.*
","# Zanedbané zastávky

Aj v tejto sérií sa tretia úloha dala vyriešiť prekvapivo jednoduchým algoritmom so zaujímavou myšlienkou.

Je zjavné, že niekedy nám nastane deň, kedy pri niektorej linke nebude prerábaná ani jedna zastávka. Keďže každý deň prerobíme aspoň jednu zastávku, po $n$ dňoch budú určite všetky hotové.

Podobne sa môžeme pozrieť na nejakú konkrétnu linku s $i$ zastávkami. Podobnú úvahu ako pre celé Kocúrkovo vieme spraviť aj pre túto linku. Na trase tejto linky najneskôr v $i$-ty deň nebude prerábaná ani jedna zastávka. Označme si $k$ počet zastávok na _najkratšej_ linke. Na tejto linke sa najneskôr $k$ ty deň nebude prerábať zastávka, tým pádom odpoveď na úlohu bude najviac $k$.

Teraz si ukážeme že plán rekonštrukcie dá naozaj spraviť tak, že prvá linka bez prerábanej zastávky sa zjaví až v $k$-ty deň.

## Úvaha

Pre lepšiu čitateľnosť si očíslujeme zastávky $0$ až $n-1$ namiesto $1$ až $n$.

Predstavme si, že od prvých dvoch Kocúrkovských zastávok jazdia linky dĺžky $k$. Prvá linka jazdí medzi zastávkami $0$ a $k-1$. Keďže máme $k$ dní, $k$ zastávok a chceme každý deň rekonštruovať aspoň jednu zastávku, tak môžeme napríklad rekonštruovať $i$-tu zastávku v deň číslo $i$.

Teraz sa pozrime na druhú linku, ktorá jazdí medzi zastávkami $1$ až $k$. Rekonštrukciu zastávok $1$ až $k-1$ už máme naplánovanú z prvej linky, a chýba v nej len deň číslo $0$. Nemáme teda inú možnosť, ako rekonštruovať zastávku $k$ v deň $0$.

Podobne, ak by sme mali linku aj medzi zastávkami $2$ a $k+1$, tak zastávka $k+1$ by musela byť rekonštruovaná v ten istý deň ako zastávka $1$, čiže v deň $1$. V tomto vzore vieme ľahko pokračovať aj ďalej, vo všeobecnosti sa zastávka $i$ bude rekonštruovať v deň $i \\bmod k$, čo znamená zvyšok po delení $i$ číslom $k$.

Takýto plán nám zaručí, že ľubovoľných $k$ po sebe idúcich zastávok bude rekonštruovaných v každom dni od $0$ až po $k-1$ v nejakom poradí. Tým pádom ľubovoľná linka dĺžky aspoň $k$ bude mať počas každého z prvých $k$ dní rekonštruovanú aspoň jednu zastávku.

## Implementácia

Zo vstupu potrebujeme okrem počtu zastávok $n$ a počtu liniek $m$ len dĺžku najkratšej linky $k$. Počet dní na výstupe potom bude práve $k$. Plán rekonštrukcie vyrobíme jednoducho. Zastávku číslo $i$ budeme prerábať v dni $i \\bmod k$.

Časová zložitosť takéhoto riešenia je $O(m)$ na načítanie vstupu a $O(n)$ na vypísanie odpovede, dokopy $O(n + m)$.

Pamäťová zložitosť je $O(1)$. Vo vzorovom kóde kóde v C++ si môžeme všimnúť, že na výpočet najkratšej dĺžky linky a vypísanie plánu rekonštrukcie nepotrebujeme žiadne polia ^[Kód v Pythone ich pre prehľadnosť používa.].
",4
76142b2cfa89743f,ksp,"# Kruhová knižnica

V základnej škole Kráľa Svätopluka Prvého majú obrovskú knižnicu. Je to veľká kruhová miestnosť, v ktorej je pozdĺž stien nad sebou umiestnených $n$ dlhých políc. Každá polica je kruhová a ide kolom dokola celej miestnosti. (Samozrejme, sú tam aj dvere, takže nejde úplne dokola, ale tie pre túto úlohu nie sú zaujímavé.) Každú policu si teda môžeme predstaviť ako kružnicu.

Na každú policu sa vojde $s$ kníh, pre jednoduchosť majú všetky rovnakú šírku. Na každej z nich je zároveň práve jedna (špeciálna) červená kniha. Medzi inými je tam aj Červená algebra, no sú tam aj knihy, ktoré sú červené len preto, že ich obaly nespolušní žiaci zafarbili voskovkami.

## Úloha

Knihovníkovi sa nepáči, ako sú červené knihy na náhodných miestach a nepríjemne to bije do očí. Bol by rád, keby sa všetky červené knihy nachádzali nad sebou v jednom stĺpci. Zároveň by chcel, aby sa knihy presunuli o čo najmenšiu celkovú vzdialenosť.

Vzdialenosť meriame po polici popri stene (teda nie krížom cez miestnosť). Knihy nie je možné meniť medzi policami (každá kniha musí ostať vo svojeje polici). Celkovú vzdialenosť dostaneme tak, že sčítame vzdialenosť, o ktorú sa posunula kniha na každej polici. Knihovník si môže vybrať, ktorým smerom chce knihu posúvať (doľava alebo doprava).

Pozície, na ktorých sú knihy, si môžeme očíslovať od $0$ do $s-1$, pričom susedné pozície sú vždy $i$ a $i+1$, ale aj $0$ a $s-1$ (police sú kruhové). Ak napríklad máme policu s dĺžkou na $s=16$ kníh a chceme premiestniť červenú knihu z pozície $4$ na pozíciu $13$, môžeme ju posunúť v smere rastu čísel (doprava) o $9$ pozícií ($13-4=9$). Lepšie je však posunúť ju opačným smerom, takto prekoná vzdialenosť iba $7$ pozícií (vzdialenosť $4$ na pozíciu $0$ a $16-13=3$ na pozíciu $13$).

Pomôžte knihovníkovi nájsť optimálny spôsob premiestnenia kníh.

## Formát vstupu

Na prvom riadku dostanete čísla $n$ a $s$ -- počet políc v knižnici a veľkosť jednej police.

Na druhom riadku sa nachádza $n$ celých čísel z rozsahu od $0$ do $s-1$ -- pozície červenej knihy v jednotlivých policiach.

## Formát výstupu

Vypíšte jedno číslo -- najmenšiu celkovú vzdialenosť, o ktorú je potrebné červené knihy presunúť. Nezabudnite na znak konca riadka.

## Hodnotenie

Sú štyri sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |-----: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $8$ | $1000$ | $100,000$ | $100,000$ | | $1 \\leq s \\leq$ | $16$ | $2000$ | $100,000$ | $10^{9}$ |

## Príklad

```vstup
5 5
0 1 2 3 4
```

```vystup
6
```

_Knižnica má $5$ políc, každá má veľkosť $5$. Rozmiestnenie kníh vyzerá takto (X je červená kniha):_

```
|X....|
|.X...|
|..X..|
|...X.|
|....X|
```

_Police sú kruhové, teda pravý okraj je napojený na ľavý. Jedno možné riešenie je presunúť všetky knihy do stĺpca (na pozície) $2$, v jednotlivých riadkoch teda vykonáme presuny o $2$, $1$, $0$, $1$ a $2$ pozície, dokopy je to $6$. V tomto prípade sme kruhovosť nevyužili, ale rovnako dobre ju využiť vieme a na $6$ krokov presunúť všetky knihy do stĺpca $0$ či ktoréhokoľvek iného._

```vstup
3 10
0 0 8
```

```vystup
2
```

_Knihu v tretej polici posunieme o dve pozície vpravo, čím sa dostane z pozície $8$ cez pozíciu $9$ na pozíciu $0$._

```
|X.........|
|X.........|
|........X.|
```

```vstup
2 5
2 3
```

```vystup
1
```

_Knihy sú v susedných stĺpcoch, stačí jednu presunúť k druhej._

```
|..X..|
|...X.|
```
","# Kruhová knižnica

## Pomalé riešenie

Predstavme si, že by sme vedeli, do ktorého stĺpca (na ktorú pozíciu) chceme presunúť všetky červené knihy. Označme túto pozíciu $c$. Vieme nejako vypočítať vzdialenosť, o ktorú treba posunúť knihu, ktorá sa práve nachádza na pozícii $p$?

Mohli by sme ju presunúť bez využitia cyklickosti políc. Takto sa kniha posunie o vzdialenosť $|p-c|$, kde $|x|$ značí absolútnu hodnotu čísla $x$ (teda číslo po odobratí znamienka). Ak by sme ju chceli posunúť opačným smerom, teda cez hranicu medzi pozíciami $0$ a $s-1$, táto vzdialenosť by bola doplnkom vyššie uvedenej vzdialenosti do celého kruhu (čiže do $s$). V tomto prípade teda dostávame vzdialenosť $s - |p-c|$. Z týchto dvoch vzdialeností vieme vybrať tú menšiu a toto urobiť a posčítať pre všetky police.

Keďže cieľovú pozíciu nepoznáme, musíme vyskúšať všetkých $s$ možných. Pre každú z nich prejdeme všetky knihy a vyberieme najlepšiu pozíciu. Máme tak riešenie s časovou zložitosťou $O(ns)$, ktoré zvládne vyriešiť prvé 2 sady.

## Efektívnejšie riešenie jednoduchšej úlohy

Pozrime sa teraz na jednoduchšiu úlohu, v ktorej police nie sú cyklické, ale majú ľavý a pravý koniec. V takomto prípade je odpoveď jednoduchá -- je ňou medián čísel na vstupe. Medián postupnosti je jej stredná hodnota, teda číslo, ktoré po usporiadaní postupnosti skončí v strede. Ak je čísel nepárne veľa, je táto hodnota jednoznačne určená. Ak je čísel párne veľa, medián je definovaný ako priemer dvoch prostredných, ale ako riešenie úlohy je možné vziať ľubovoľnú hodnotu medzi dvomi prostrednými (alebo rovno jednu z nich) a bude to rovnako dobré optimálne riešenie.

Prečo je riešením vždy medián? Začnime s tým, že cieľovú pozíciu, kam chceme knihy premiestniť, dáme úplne naľavo, takže každá kniha bude musieť byť presunutá o určitú vzdialenosť doľava. Keď teraz začneme našu pozíciu posúvať doprava, knihám, ktoré sú od nej napravo, sa potrebná vzdialenosť bude znižovať, zatiaľ čo knihám, ktoré sú od nej naľavo, sa bude znižovať.

Ak je napravo od cieľovej pozície $j$ kníh a naľavo $i$, posunom o 1 doprava sa celkový súčet vzdialeností zmenší o $j$ a zvýši o $i$, pričom nejaké knihy sa môžu začať nachádzať na opačnej strane od tejto pozície.

Na začiatku sú všetky knihy napravo a približujú sa, na konci sú všetky naľavo a vzďaľujú sa. Ideálnym riešením je stav, kedy je naľavo aj napravo rovnako veľa kníh (vtedy zvyšovanie začne predbiehať znižovanie), čo je práve vtedy, keď sme v mediáne. (Pre prostredný prvok platí, že naľavo aj napravo od neho je rovnako veľa prvkov.)

## Vzorové riešenie

Túto myšlienku vieme zovšeobecniť na riešenie našej úlohy. Začnime s cieľovou pozíciou $0$ a poďme ju posúvať (po kruhu) doprava. Počítajme si pritom, koľko pozícií sa približuje a koľko sa vzďaľuje. Keď poznáme aktuálny celkový súčet vzdialeností a pohneme cieľovou pozíciou, na základe týchto hodnôt vieme celkový súčet aktualizovať.

### Ktoré knihy sa k nej približujú a ktoré sa vzďaľujú?

Ak je cieľová pozícia $0$, približujú sa tie, ktoré sú na pozícii najviac $s/2$ (najkratšia cesta pre ne vedie priamo k menším pozíciám) a vzďaľujú sa tie, ktoré sú na pozícii väčšej ako $s/2$ (pre ne je optimálne ísť k $0$ doprava cez vyššie pozície).

### Kedy sa mení, či sa kniha približuje alebo vzďaľuje

Keď s cieľovou pozíciou prídeme na pozíciu nejakej knihy, táto sa doteraz približovala a odteraz sa začne vzďaľovať. Pri našich kruhových pozíciách môže nastať ešte jeden typ situácie, a to ten, že sa kniha prestane vzďaľovať a začne približovať. Deje sa to vtedy, keď sme na kruhu presne oproti nej. Cieľová pozícia sa od nej vzdialila natoľko, že už je pre knihu lepšie k nej ísť opačným smerom a v tomto smere sa približuje.

Keď sa však pustíme do implementácie, uvedomíme si, že to nie je také jednoduché. Pre párne $s$ sa kniha v istom momente prestane vzďaľovať a hneď sa začne približovať, napríklad pre $s=100$ a knihu na pozícii $10$ sa toto stane, keď cieľová pozícia je $60$.

Avšak pre nepárne $s$ sa to stane na neceločíselnej pozícii, napríklad pre $s=101$ a knihu na pozícii $10$ sa to stane, keď cieľová pozícia je $60.5$. My však pracujeme iba s celočíselnými pozíciami. Pre knihu ostáva vzdialenosť rovnaká pre cieľovú pozíciu $60$ aj $61$.

Elegantný spôsob riešenia tohto problému je taký, že si nebudeme pamätať len počet kníh, ktoré sa približujú a vzďaľujú, ale aj počet takých, ktoré svoju vzdialenosť nemenia. V tomto stave vie byť každá kniha len po dobu presunu cieľovej pozície o $1$ (a po dobu $0$ pri párnom $s$ -- nechceme mať zvlášť implementáciu pre párne a pre nepárne $s$).

### Dajme to všetko dokopy

Vzorové riešenie teda bude vyzerať nasledovne: najskôr si vypočítame súčet vzdialeností, keby sme všetky knihy chceli presunúť na pozíciu $0$. Tiež si napočítame počet približujúcich sa a vzďaľujúcich sa kníh (a tých, čo svoju vzdialenosť pri posune z $0$ na $1$ nezmenia, to sú tie na pozícii $\\frac{s+1}{2}$, ak to je celé číslo).

Cieľovú pozíciu posúvame doprava a udržiavame si aktuálny súčet vzdialeností a najlepší doteraz nájdený. Aby sme nemuseli prechádzať $10^9$ pozícii v 4. sade, stačí si uvedomiť, že zaujímavé pozície sú len tie, kde sa niečo mení. Pre každú knihu je to jej pozícia a jedna alebo dve pozície presne naproti nej (podľa parity $s$). Tieto udalosti si vieme predpočítať dopredu, usporiadať podľa súradnice a postupne ich všetky spracovať.

Časová zložitosť riešenia je $O(n \\log n)$, pretože výpočet hodnôt pred začatím posúvania cieľovej pozície spravíme v $O(n)$, potom utriedime $3n$ udalostí v $O(n \\log n)$ a následne každú udalosť spracujeme v konštantnom čase. Každá udalosť je totiž iba zmena stavu jednej knihy (približuje sa/vzďaľuje sa/nemení sa). Pamäťová zložitosť je $O(n)$.
",5
9ad2ce8461287ca3,ksp,"# Dievčatá sú náročné

Zima pomaly končí a Samo tak konečne môže vyjsť na Orave von z domu. Na Orave sa okrem krásnej prírody prebúdzajú zo zimného spánku aj krásne dievčatá a Samo to hneď chce využiť a nájsť si medzi nimi svoju vyvolenú.

Skúša používať zaručene osvedčené hlášky aj komplimenty, ale vždy mu utečú. Ako tak raz smutný sedel doma a surfoval po internete, vyletela na neho reklama na knihu, ktorá vraj spraví z hocikoho Cassanovu.

Samo okamžite klikol a kúpil. Po troch dlhých dňoch čakania mu kniha došla a on sa hneď pustil do čítania. Hneď ho však nadšenie prešlo - zistil, že musí byť vtipný, sebavedomý, štýlový, dobrodružný, nepredvídateľný, zaujímavý, energický, tajomný, so zmyslom pre detajl, odlišný od ostatných, milý, charizmatický, bohatý a krásny...

Samo má skoro všetky tieto vlastnosti, no po dlhom uvažovaní sa rozhodol, že predsa len ešte popracuje na jednej z nich. Prišiel na to, že najväčšie šance bude mať ak sa stane tajomnejším. Ženy totiž podľa knihy nikdy nemôžu vedieť presne, čo od nich chceš a vždy ich musíš nechať váhať.

Odteraz pri ženách hovorí len tvrdenia, ktoré majú viacero významov. Ak by sa dala jeho veta pochopiť príliš málo spôsobmi, dievča by ho hneď odhalilo, vedelo by presne, čo chce povedať a celá tajomnosť by bola fuč. Naopak, ak by sa dala pochopiť príliš veľa spôsobmi, dievča by vôbec nepochopilo, čo vlastne Samo hovorí.

Tu príchádzate na rad vy. Pomôžte Samovi a povedzte mu, koľkými spôsobmi vie dievča pochopiť jeho vetu.

## Úloha

Na vstupe dostanete logický výraz zložený z rôzných premenných, negácii, konjukcií a disjunkcií. Vašou úlohou je zistiť, koľkými spôsobmi vieme za premenné dosadiť pravdu alebo nepravdu tak, aby bol výraz pravdivý. Aby čísla, s ktorými pracujete, neboli príliš veľké, vypisujte ich zvyšok po delení $10^9 + 7$.

## Formát vstupu

Vstup je zložený z jedného riadku - logického výrazu. Dĺžka výrazu nebude väčšia ako $700,000$ znakov. Logický výraz zadefinujeme rekurentným vzťahom. Môže nadobudnúť jednu zo štyroch hodnôt:

- `X` -- Premenná. **Každé `X` označuje odlišnú premennú**, za rôzne `X` sa teda môžu dostadiť rôzne pravdivostné hodnoty.
- `OR(`*výraz*`,`*výraz*`)` -- Disjunkcia. Výraz je pravdivý, ak aspoň jeden z vnútorných výrazov je pravdivý.
- `AND(`*výraz*`,`*výraz*`)` -- Konjucia. Výraz je pravdivý ak oba vnútorné výrazy sú pravdivé.
- `NOT(`*výraz*`)` -- Negácia. Výraz je pravdivý, ak je vnútorný výraz nepravdivý.

Môžete predpokladať, že vstup je korektne uzátvorkovaný a neobsahuje medzery, ani iné operátory ako vyššie popísané.

## Formát výstupu

Vypíšte jedno číslo: počet možností, ako vieme dosadiť pravdu a nepravdu za premenné tak, aby bol výraz pravdivý, modulo $10^9 + 7$.

## Príklad

```vstup
AND(X,OR(X,X))
```

```vystup
3
```

*Dosádzame za $3$ premenné, máme teda $2^3 = 8$ možností. Výraz bude pravdivý, ak za naše tri premenné dosadíme $(pravda, pravda, pravda)$, $(pravda, pravda, nepravda)$ alebo $(pravda, nepravda, pravda)$.*

```vstup
NOT(OR(X,X))
```

```vystup
1
```

*Jediná možnosť je za obe premenné dosadiť $nepravdu$.*
","# Dievčatá sú náročné

Našou úlohou bolo zistiť, koľkými spôsobmi vieme doplniť premenné tak, aby bol zadaný logický výraz pravdivý. Pri takýchto úlohach je fajn sa ako prvé zamyslieť nad tým, ako sa dá tento výraz reprezentovať v pamäti.

## Ako výraz reprezentovať

Výraz obsahuje mnoho zátvoriek a v nich ďalšie výrazy. Každú logickú spojku alebo premennú si vieme reprezentovať ako vrchol v strome. (Ak vám slovíčko ""strom"" v súvislosti s informatikou nič nehovorí, odporúčam prečítať si časť o stromoch [tu](https://www.ksp.sk/kucharka/grafy_uvod/).) V tomto strome má každý vrchol buď $0$, $1$ alebo $2$ synov---vrcholy reprezentujúce výrazy (*operandy*), ktoré sú v jeho zátvorkách.

Napríklad `OR(X_1, NOT(X_2))` reprezentujeme vrcholom pre `OR`, ktorý má ako synov vrcholy `X_1` a `NOT`. Tento `NOT` má syna `X_2`.

Otázka je, ako z textovej reprezentácie výrazu dostaneme takýto strom? Budeme ho zostrojovať rekurzívne, od koreňa k listom. Predstavme si, že text čítame zľava doprava. Na začiatku sa určite nachádza jedna zo značiek `AND`, `OR`, `NOT` alebo `X`. Podľa toho, ktorý z týchto prípadov nastal, vieme, čo máme ďalej v texte očakávať:

- Ak sme prečítali `AND` alebo `OR`, bude nasledovať `(`, výraz, `,`, výraz, `)`. Takže stačí rekurzívne načítať prvý operand, prečítať čiarku `,`, načítať druhý operand a prečítať koncovú zátvorku `)`. Vrátime vrchol príslušného typu, ktorého synovia sú načítané operandy.
- Ak sme prečítali `NOT`, postupujeme podobne. Jediný rozdiel je v tom, že máme len jeden operand a nemusíme prečítať čiarku.
- Ak sme prečítali `X`, vrátime vrchol reprezentujúci premennú.

Keď máme načítaný vstup a uložený v strome, vieme sa vrhnúť na prvé riešenie.

## Ako vieme nájsť ohodnotenie výrazu

Všimnime si, že ak máme vyhodnotených všetkých synov nejakého vrcholu, tak vieme v konštantnom čase zistiť ohodnotenie tohto vrcholu. Toto tvrdenie nie je nejako závratné, spočíva len v tom, že spočítame hodnotu logickej funkcie v tomto vrchole. Z tohto tvrdenia ale vyplýva dôležitejšie---predstavme si, že poznáme hodnoty všetkých listov (premenných). Potom vieme v lineárnom čase zistiť hodnotu celého výrazu.

Spravíme to takto: ak chceme vyhodnotiť nejaký vrchol, vyhodnotíme najprv všetkých jeho synov a následne v konštantnom čase vyhodnotíme logickú funkciu z hodnôt synov. Vieme, že listy už máme ohodnotené, takže ak to budeme vyhodnocovať rekurziou, má kde zastať. Takémuto algoritmu to bude trvať $O(n)$, kde $n$ bude počet vrcholov. Toto môžeme jednoducho odhadnúť ako dĺžku vstupu. Pre každý vrchol spravíme iba konštantný počet operácii.

Nás zaujíma počet takých ohodnotení, pri ktorých je vstupný výraz pravdivý. Môžeme vyskúšať všetky možné ohodnotenia, pre každé zistiť hodnotu celého výrazu a spočítať tie, ktoré sú pravdivé. Všetkých možností ohodnotenia máme najviac $2^n$ a teda časová zložitosť riešenia je $O(n \\cdot 2^n)$.

Týmto riešením mohol váš program získať $2$ body.

## Vzorové riešenie

Skúsme si náš problém vyriešiť pre najmenšie možné stromy.

Pre strom skladajúci sa z jedného `X` máme práve jednu možnosť ako môže byť pravdivý: ak za `X` dosadíme $1$.

Pokiaľ máme strom `NOT(X)`, je práve jedna možnosť ako môže byť pravdivý: ak `X` je nepravdivé. Všeobecne, počet možnosťí ako môže byť `NOT(výraz)` pravdivý je počet možností, ako môže byť `výraz` nepravdivý. Pre strom `OR(X,X)` máme tri dosadenia, ako získať pravdivý výraz: $(0,1)$ , $(1,0)$ a $(1,1)$. Pre strom `AND(X,X)` je zasa len jedno: $(1,1)$.

Pri vyhodnocovaní `NOT` sme si všimli zaujímavú vec: ak by sme vedeli, koľkými spôsobmi môžu byť jeho synovia nepravdivý, vedeli by sme hneď povedať, koľkými spôsobmi môže byť `NOT` pravdivý. Myšlienka, ktorá nás môže napadnúť je, či sa toto nedá použiť aj pre ostatné typy vrcholov.

Poďme teda skúsiť vyhodnotiť `AND(výraz1, výraz2)` s tým, že pre `výraz1` aj `výraz2` vieme, koľkými spôsobmi môžu byť pravdivé. Označme tieto počty postupne $p_1$ a $p_2$. Hľadáme počet možností, v ktorých sú aj `výraz1` aj `výraz2` pravdivé. Tí, čo už mali trocha kombinatoriky hneď vidia, že to je $p_1 \\cdot p_2$---pre každú možnosť, v ktorej je `výraz1` pravdivý, existuje $p_2$ možností, v ktorých je aj `výraz2` pravdivý.

Kebyže vieme, koľkými spôsobmi možu byť `výraz1` a `výraz2` nepravdivé, vieme zistiť dokonca aj to, koľkými spôsobmi môže byť `AND(výraz1, výraz2)` nepravdivý. Označme si teda $n_1$ a $n_2$ počty nepravdivých možností pre vyrazy 1 a 2. `AND(výraz1, výraz2)` je nepravdivý v troch prípadoch

- `výraz1` je nepravdivý a `výraz2` je nepravdivý: $n_1 \\cdot n_2$ možností
- `výraz1` je pravdivý a `výraz2` je nepravdivý: $p_1 \\cdot n_2$
- `výraz1` je nepravdivý a `výraz2` je pravdivý: $n_1 \\cdot p_2$

Teda `AND` je nepravdivý v toľkoto prípadoch:

$$n_1 \\cdot n_2 + p_1 \\cdot n_2 + n_1 \\cdot p_2.$$

Rovnakým spôsobom vieme vymyslieť, ako z počtov možností detí vrcholu `OR` zistiť počty možností samotného vrcholu `OR`.

Takže ak vieme, koľkými spôsobmi vedia byť deti nejakého vrcholu pravdivé a koľkými spôsobmi vedia byť nepravdivé, vieme zistiť aj pre tento samotný vrchol rovnakú informáciu. Použijeme pri tom len pomocou pár násobení v prípade `AND` a `OR`, a výmenou hodnôt v prípade `NOT`. A o listoch stromu vieme, že je práve jedna možnosť ako môžu byť pravdivé, a práve jedna ako môžu byť nepravdivé.

Tu si zoberieme myšlienku z brute forcu---keď sme chceli zistiť vyhodnotenie stromu s nejakými hodnotami vrcholov, rekurzívne sme ho prešli a pre každý vrchol sme z jeho synov zistili jeho hodnotu. V našom riešení môžme spraviť to isté, len pre každý vrchol zo synov zistíme, koľkými spôsobmi môže byť pravdivý a koľkými nepravdivý. Riešenie bude potom počet pravdivých spôsobov pre koreň.

Časová zložitosť je $O(n)$, keďže pre každý vrchol v konštantom čase zistíme jeho hodnotu. Pamäťová je $O(n)$, nakoľko si pamätáme celý strom.
",5
449dc53ebbae6c9b,ksp,"# Éra pečúceho slnka

Za posledný týždeň sa Emo spálil na slnku každý deň. Jeho frajerku to už prestalo baviť, takže teraz sa musí každé ráno natrieť opaľovacím krémom.

Emo sa okolo ôsmej, keď ešte slnko tak nepáli, vydá zo svojho domčeku do jediného domčeku v meste, ktorý má opaľovací krém. Do tohto domčeku nemusí viesť priama cesta, preto po ceste bude musieť navštíviť niekoľko ďalších domčekov, ktoré sú poprepájané chodníkmi. Medzi každými dvoma domčekmi je najviac jeden chodník ktorý ich spája. Aby nemusel zbytočne šliapať, zvolí si trasu najkratšiu -- teda takú, ktorá vedie cez čo najmenej domčekov.

Vy z výšin sledujete Emov osud a nechcete, aby jeho život skĺzol do každodennej rutiny a chodil každý deň tou istou cestou. Radi by ste sieť chodníkov navrhli tak, aby tam najkratších možných ciest bolo viacero.

Rozhoďte kocky osudu na stôl, máchnite žezlom večnosti a vymyslite plán mesta, ktorý bude mať vyššími mocnosťami stanovený počet rôznych najkratších trás!

## Úloha

Od vyšších mocností dostanete číslo $k$. Vašou úlohou bude vytvoriť taký plán mesta -- domčekov a chodníkov medzi nimi -- v ktorom vedie medzi dvoma zvolenými domčekmi práve $k$ rôznych najkratších ciest. A aby mesto nebolo príliš veľké, môže mať najviac tisíc domčekov.

## Formát vstupu

Vstup obsahuje jedno jediné číslo $k$ ($1 \\leq k \\leq 1,000,000,000$) -- počet najkratších možných ciest medzi Emovým domčekom a opaľovacím krémom.

## Formát výstupu

Správny výstup tvorí popis ľubovoľného mesta spĺňajúceho všetky zadané podmienky.

Popis mesta musí mať nasledovnú formu. Na prvom riadku výstupu sú dve medzerou oddelené čísla -- $d$ a $c$. Číslo $d$ označuje počet domčekov vo vašom meste a musí preň platiť $2 \\leq d \\leq 1,000$. Číslo $c$ označuje počet chodníkov v meste a musí preň platiť $1 \\leq c \\leq 1,000,000$. Nasledujúcich $c$ riadkov výstupu popisuje jednotlivé chodníky.

Domčeky v meste si očíslujeme od 1 po $d$. Domček číslo 1 je dom, v ktorom býva Emo a domček číslo $d$ dom, v ktorom je opaľovací krém. Popis chodníka je tvorený dvoma medzerou oddelenými číslami -- číslami domčekov, ktoré tento chodník spája. Po chodníkoch sa dá chodiť v oboch smeroch, a preto môžu byť uvedené v ľubovoľnom poradí. Teda chodník $2~1$ je ten istý ako chodník $1~2$.

Vo vami uvedenom meste by malo platiť, že medzi domčekmi 1 a $d$ vedie práve $k$ rôznych najkratších ciest.

## Hodnotenie

Vaše riešenia budú testované na ôsmych sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:---------------- | ----:| -----:| ------:| -------:| -------:| -------:| -------:| -------:| | $$ 0 < k \\leq $$ | $30$| $500$| $5000$| $10^{5}$| $10^{6}$| $10^{9}$| $10^{9}$| $10^{9}$|

## Príklad

```vstup
1
```

```vystup
2 1
1 2
```

_Výsledné mesto má dva domčeky a jeden chodník vedúci medzi nimi. Ale správny by bol napríklad aj popis mesta s troma domčekmi a dvoma cestami, ktoré by viedli medzi domčekmi $1~2$ a $2~3$._

```vstup
3
```

```vystup
10 11
8 5
3 6
2 9
5 9
7 4
3 1
8 3
2 4
1 7
10 9
6 2
```

_V tomto príklade sú tri rôzne najkratšie cesty dĺžky 5. Sú to cesty $1-7-4-2-9-10$, $1-3-6-2-9-10$ a $1-3-8-5-9-10$._
","# Éra pečúceho slnka

Konštrukčná úloha, ktorá má neskutočné množstvo správnych riešení. Ukážeme si, čo je kameň úrazu tejto úlohy, čo s ním a nakoniec aj nejaké jedno možné^[samozrejme najkrajšie] riešenie.

## Kameň úrazu

Najtragickejšia veta zadania je tá, že počet domov vami navrhnutého mesta nesmie presiahnuť $1,000$. Prečo? Predstavme si, že by sme na toto nemali žiadne obmedzenie. Stačí nám vytvoriť niekoľko neprekrývajúcich sa ciest. Okrem štartovacieho a cieľového domu budeme mať v meste ešte $k$ ďalších, prechodných domov. Každý prechodný dom spojíme chodníkom so štartom aj s cieľom.

V našej úlohe je však počet ciest podstatne väčší, ako počet domov, ktoré môžeme použiť. Nejakým spôsobom potrebujeme na malý počet pridaných domov dosiahnuť veľký počet rovnako dlhých ciest. Dámy a páni, predstavujem vám:

## Diamant

*Diamantom* budeme nazývať štyri domy spojené do kosoštvorca. Keď jeden z domov prehlásime za začiatok a dom oproti (cez uhlopriečku) za koniec, tak medzi nimi existujú práve 2 najkratšie cesty (dĺžky 2). Na tomto útvare je super, že sa dajú skladať za seba. Ak naskladáme 5 diamantov za seba (koniec jedného bude začiatkom druhého), dosiahli sme $2^5=32$ možných rôznych najkratších ciest (každá postupnosť vľavo-vpravo-vľavo-vľavo-vľavo, vľavo-vpravo-vľavo-vľavo-vpravo, atď. je iná cesta). A to celé len za cenu $3 \\times 5 + 1 = 16$ domov.

Ak chceme $2^{30} = 1,073,741,824$ ciest, stačí naskladať 30 diamantov za seba, za cenu $3 \\times 30 + 1 = 91$ domov. Celkom dobré, nie?

Takže ak $k$ je mocnina dvojky, len poskladáme príslušný počet diamantov. Čo však, ak nie je? Žiaden problém.

## Príklad

Predstavme si, že $k=10=8+2=2^3+2^1$. Toto nám vraví, že nejako by sa to mohlo dať, ak použijeme dve diamantové reťaze (série naskladaných diamantov), jednu zloženú z troch a druhú z jedného diamantu.

Reťaz s tromi diamantami obsahuje 8 ciest dĺžky 6, reťaz s jedným diamantom 2 cesty dĺžky 2. Keďže všetky cesty musia byť rovnako dlhé (aby boli všetky najkratšie), potrebujeme si cesty v kratšej reťazi nejako predĺžiť. To urobíme tak, že pred ňu pripojíme 4 vrcholy, ktoré nebudú mať inú úlohu, ako predlžovať cestu cez krátku reťaz. Takto upravené reťaze potom už len zapojíme vedľa seba (pridáme im spoločný štart a spoločný cieľ). Tadá.

Takýmto postupom vieme vyskladať ľubovoľné číslo.

## V kocke

Každé číslo sa dá zapísať v binárnom zápise. To predstavuje, z akých mocnín dvojky sa skladá. Napr. $13 = 1101_2 = 2^3+2^2+2^0$. Pre tieto mocniny dvojky postavíme príslušné reťaze a všetky reťaze predĺžime na dĺžku najdlhšej. Takto upravené reťaze zapojíme vedľa seba a hotovo!

## Koľko domov minieme?

Tak a teraz nepríjemná otázka s ešte horším zistením. Aby sme dokázali vytvoriť mesto s $2^{29} - 1 = 536,870,911 = 11111111111111111111111111111_2$ najkratšími cestami (čo je stále menej ako maximálna hodnota zo zadania), potrebujeme všetky reťaze dĺžok $1, 2, \\dots, 28$. Už len vyskladanie tohto nám minie $4 + 7 + 10 + \\dots + 85 = 1246$ domov. Príliš veľa. Čo s tým vieme robiť?

## Posledný trik

Trikom je nestavať veľa reťazí, ale iba jednu. Zo všetkých našich reťazí si necháme iba tú s najväčšou dĺžkou. Do tejto reťaze sa na niekoľkých miestach pripojíme vhodne dlhými cestičkami zo začiatku tak, aby sme využili len nejakú jej podčasť. Napríklad pre $k = 50 = 110010_2$ to bude vyzerať takto:

Koľko stojí toto? Diamantová reťaz môže mať dĺžku najviac $29$ diamantov, čo je $29 \\times 3+1 = 88$ domov. Okrem toho máme ešte začiatočný dom, koncový dom a cestičky pripájajúce sa na reťaz (takzvané *slíže*). Slíž pripájajúci sa na reťaz za $x$-tým diamantom má dĺžku $2 x$. Ak by sme mali slíže všetkých možných dĺžok od 1 po 29 diamantov, dokopy by stáli $2 + 4 + 6 + \\dots + 58 = 870$ domov.

Dokopy teda nebudeme potrebovať viac než $88 + 2 + 870 = 960$ domov a sme strašne šťastní, pretože to je pod $1,000$ :). Samozrejme, nejaké malé (a možno aj väčšie) optimalizácie sa ešte dajú porobiť, netreba ich však.
",5
6d4ecb4e9e5ec37c,ksp,"# Havo sem, havo tam

Julka má veľa psíkov. A ono je to veľmi super vec, až do momentu, keď s toľkými psíkmi musí ísť von. Tak si vymyslela takýto plán: Keďže býva v dome s veľkou záhradou, tak len skontroluje, či je poriadne zatvorená brána a vždy keď nejaký psík chce ísť von, tak ho pustí, nech si behá po dvore. Chvíľu to fungovalo fajn, ale potom zistila, že musí stále sledovať, či nejaký psík nechce ísť von alebo dnu. Dvierka pre psíky ešte nemá namontované. Po pár dňoch si však všimla, že každý psík ide von len jeden krát za deň a to vždy v rovnakom čase a na rovnako dlho. Julka si zapísala tento interval pre každého psíka a teraz by si chcela nakresliť rozvrh časov. Na to ale potrebuje vedieť, aké široké stĺpčeky môže kresliť. Bohužial má Julka veľmi veľa úloh a fakt veľa psíkov, tak nemá čas si to sama spočítať. Pomôžete jej?

## Úloha

Rozvrh má jeden stĺpec pre celý deň, ktorý je rozdelený po milisekundách. V tomto rozvrhu budeme značiť intervaly jednotlivých psíkov. Ak sa však dva intervaly prekrývajú, musíme každý zaznačiť len na polovicu stĺpca, ak sú 3 tak na tretinu a tak ďalej (viď obrázok). Julka dáva veľký dôraz na konzistenciu, takže ak sa dva intervaly niekde prekrývajú, musia byť ich časti v rozvrhu rovnako široké. Stĺpček pre jeden interval navyše musí byť v každom úseku rovnako široký (nemôže niekde byť širší, lebo je tam viac intervalov a niekde užší, lebo je tam menej intervalov). Vašou úlohou je pre každý interval vypísať, akú časť stĺpčeka zaberie v rozvrhu.

## Formát vstupu

Na prvom riadku vstupu sa nachádza celé číslo $n$ -- počet psíkov. Nasleduje $n$ riadkov, kde každý z riadkov obsahuje dve celé čísla $s_i$ a $e_i$, pričom $s_i$ je čas vypustenia $i$-teho psíka do záhrady a $e_i$ je čas návratu $i$-teho psíka do domu, $0 \\leq s_i < e_i < 10^9$, psík je vonku počas intervalu $\\langle s_i, e_i )$.

## Formát výstupu

Vypíšte $n$ riadkov, na každom z nich jedno celé číslo $a_i$ -- $i$-ty psík zaberie v rozvrhu $1/a_i$ stĺpčeka.

## Hodnotenie

Sú 4 sady vstupov, v ktorých platia tieto obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :-------------- | ----: | --------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $10,000$ | $100,000$ |

## Príklad

```vstup
3
1 3
2 5
6 7
```

```vystup
2
2
1
```

```vstup
3
1 3
2 5
4 6
```

```vystup
2
2
2
```

_Keďže psíci 1 a 3 nie sú v záhrade naraz, vie ich Julka vyznačiť do rovnakého stĺpca._
","# Havo sem, havo tam

Na začiatok si môžeme všimnúť, že na poradí, v akom sú intervaly na vstupe nezáleží. Prvá vec čo by nás mala v takomto prípade napadnúť, je zoradiť vstup.

## Pomalé riešenie

Pozrime sa najprv, ako vôbec zistiť správnu odpoveď. Zo zadania si môžeme všimnúť, že v rozvrhu budú akési skupinky intervalov, ktoré sa niekde prekrývajú a teda majú všetky rovnakú šírku. Keď si intervaly zoradíme podla času začiatku, asi nás neprekvapí, že takéto skupinky budú tvoriť súvislé úseky. Stačí si uvedomiť, že ak takáto skupinka niekde končí, tak všetky ďalšie intervaly musia začínať až za koncom každého intervalu z tejto skupinky.

Ostáva nám už len tieto skupinky identifikovať a zistiť, akú majú šírku. Skupinku môžeme vytvárať tak, že budeme postupne pridávať intervaly z našeho utriedeného poľa, a aby sme zistili či doň patrí ďaľší interval, budeme si pamätať najväčšie číslo z koncov intervalov v danej skupinke.

Zistiť šírku je o niečo ťažšie, no zatiaľ sa uspokojíme s tým, že po každom pridanom intervale sa pozrieme koľko z doterajších sa s ním prekrýva -- teda končí neskôr ako začína on. Na prvý pohľad sa to možno nezdá, ale takýto prístup naozaj bude fungovať. Určite nám takto nevyjde väčší výsledok ako by mal, lebo všetky intervaly, na ktoré sa pozeráme sa prekrývajú s našim začiatkom, teda sa musia prekrývať aj navzájom. Už nám stačí sa len zamyslieť, pri ktorom intervale nájdeme to hľadané maximum prekrývajúcich sa intervalov. Spomedzi tých intervalov ktoré sa v tom momente prekrívajú, niektorý začína ako posledný. Keďže začína ako posledný, všetky ostatné máme už pridané a teda ich nájdeme ako prekrývajúce sa a vyjde nám správna maximálna šírka.

## Rôzne vylepšenia

Môžeme si všimnúť, že jediná problematická časť v predošlom riešení je tá, kde zisťujeme šírku. Ak máme skupinku, ktorá obsahuje veľa intervalov (napríklad všetky), dosiahli by sme až kvadratickú časovú zložitosť. Potrebujeme teda zistiť, ako to robiť šikovnejšie.

Jedna možnosť je pozrieť sa na to ako na čiastkový problém a použiť vhodnú dátovú štruktúru. Napríklad binárne vyhladávacie stromy alebo haldu. Takéto riešenie môže byť napríklad v C++ pomerne jednoduché, no Python nemá takúto štruktúru v štandardnej knižnici. Pozrime sa teda radšej na iné a krajšie riešenie.

## Užitočný trik

Ukážeme si trik ktorý nám pomôže ku jednoduchšiemu riešeniu. Tento prístup sa niekedy nazýva aj zametanie a spočíva v tom, že sa budeme posúvať od začiatku časovej osy po koniec a počítať si kolko intervalov je v danom momente aktívnych. Aby sme však neprechádzali všetky čísla, v ktorých sa nič nedeje, najprv si do jedného poľa uložíme všetky začiatky a konce intervalov, spolu s informáciou o tom, či ide o začiatok alebo koneic a ktorému intervalu patrí. Následne toto pole usporiadame podľa času (začiatku resp. konca), a prechádzame cyklom od začiatku po koniec. Pamätáme si počet aktívnych intervalov, pričom ak nejaký skončí, zmenšíme počet o jeden a ak nejaký začne, tak zase zväčšíme o jeden.

Ku kompletnému riešeniu nám stačí si pamätať najväčší počet aktívnych intervalov a zoznam intervalov, ktoré sme už stretli. Keď narazíme na situáciu, že máme nula aktívnych intervalov, znamená to, že nejaká skupinka skončila. Zapíšeme si aktuálne maximum pre všetky uložené intervaly, vynulujeme maximum a uložené intervaly, a pokračujeme.

## Časová a pamäťová zložitosť

Takéto riešenie má časovú zložitosť $O(n\\cdot \\log(n))$ kvôli usporiadaniu poľa. Pamäťová zložitosť bude lineárna, pretože každé číslo zo vstupu budeme mať uložené len konštantný počet krát, a nič naviac.
",4
90dc2396e1b1026e,ksp,"# Overené informácie

KSP má tri písmena. P je $16$. písmeno, S je $19$. a K je $11$. Keď odstránime dve jednotky z čísel $16$ a $19$ dostaneme $6$ a $9$. Koľko je $9$? To je $3 \\cdot 3$. Opakujem! Tri krát tri! TRI krát TRI. Koľko je $6$? To je $3 + 3$. TRI + TRI! Náhoda? Myslím, že nie! Trojsten confirmed.

Niektoré veci proste nie sú náhodné. Čo sa stane, keď spojíte všetky ""é"" na tejto strane? Dostanete trojuholníky. Všetky trojuholníky! Každé Tri ""é"" tvoria trojuholník. To nie je náhoda! Trojuholníky nie sú náhoda. Prečo? Koľko majú strán? TRI! Keď veci tvoria veľa trojuholníkov, to nie je náhoda!

## Úloha

Máte zadané body v rovine. Zistite, ako veľmi nenáhodné sú, teda vrcholy koľkých trojuholníkov tvoria.

## Formát vstupu

Na prvom riadku vstupu je počet rôznych bodov $n$ ($0\\leq n\\leq 4,000$).

Nasleduje $n$ riadkov a na každom sú dve celé čísla $x_i$, $y_i$ ($-100,000 \\leq x_i, y_i \\leq 100,000$), ktoré sú súradnicami daného bodu.

## Formát výstupu

Vypíšte počet trojuholníkov s vrcholmi v daných bodoch.

## Príklady

```vstup
5
4 5
21 22
5 6
0 1
-5 -4
```

```vystup
0
```

*Tieto body sú jednoznačne náhodné.*

```vstup
5
0 0
3 3
3 0
0 3
1 -1
```

```vystup
10
```

*Toto naozaj nemôže byť náhoda.*
","# Overené informácie

## Najhrubšia sila

Najprv si potrebujeme uvedomiť, kedy tri body tvoria trojuholník. Vždy, keď nie sú na jednej priamke. Ako sa to dá otestovať? Môžeme si vyjadriť rovnice všetkých strán potenciálneho trujuholníka a porovnať ich. Nejde to aj ľahšie? Samozrejme, že ide. Stačí nám totiž vyrátať len smernice daných úsečiek (tangens uhlu, ktorý zvierajú s osou $x$) a ak sú rovnaké, tak sú dané úsečky rovnobežné a teda nemôžu tvoriť trojuholník. Ale ide to ešte ľahšie.

Môžme si uvedomiť, že trojuholník je len na jednej priamke (teda to nie je trojuholník) práve vtedy, keď má nulový obsah. Najjednoduchší a najlepší spôsob, ako zistiť, či tri body $A,B,C$ ležia na jednej priamke, je spočítať \\emph{vektorový súčin} vektorov $(C-A)$ a $(B-A)$ a overiť či je nulový. V dvoch rozmeroch vypočítame vektorový súčin $v\\times u = vx \\cdot uy - ux \\cdot vy$, kde napr. $vx$ je $x$-ová zložka vektora $v$.

Výhody vektorového súčinu:

- Je rýchly a jednoduchý.
- Pokiaľ body mali celočíselné súradnice, tak vektorový súčin môžeme spočítať v celých číslach, čím sa vyhneme nepresnostiam.
- Funguje aj pre všelijaké patologické prípady, kedy je viac bodov na rovnakom mieste a podobne.

No a už máme prvé riešenie. Prejdeme všetky trojice bodov (dávame si ale pozor na opakovania) a pre každú trojicu si zistíme, či tvorí korektný trojuholník. Dostávame riešenie v čase $O(n^3)$.

## O hľadaní v priamkách

Dôležitá myšlienka na ceste k lepšiemu riešeniu je, že to môžeme počítať aj naopak. Keby každá trojica bodov tvorila trojuholník, tak by sme mali $\\frac{n(n-1)(n-2)}{6}$ trojuholníkov. Potom, ak by sme vedeli zrátať počet trojíc, ktoré netvoria trojuholníky, tak ich len odrátame a máme riešenie. Budeme teda rátať trojice bodov, ktoré netvoria trojuholník, resp. ktoré ležia na jedne priamke. Od teraz uvažujme len priamky, na ktorých sú aspoň 2 body z našej množiny. Potom maximálny počet rôznych priamok je $\\frac{n(n-1)}{2}$, čo nie je až tak veľa.

V podstate by sme chceli pre každú priamku zistiť, koľko bodov na nej leží. Ale potrebujeme to spraviť rýchlo. Napríklad to môžeme spočítať tak, že najprv preskúmame priamky, ktoré prechádzajú prvým bodom, potom priamky, ktoré prechádzajú druhým, atď.

Ku každému bodu si vieme vyrátať smernice (uhol, aký zviera s osou $x$) všetkých priamok, ktoré ním prechádzajú. Prejdeme teda všetky ostatné body, vyrátame smernicu a uložíme si ju. Takýchto smerníc potom budeme mať $n-1$. Niektoré smernice budú rôzne, ale budú tam nejaké zhluky rovnakých smerníc.

Čo ale znamená, že pre dva body nám vyjde rovnaká smernica? No to, že sú spolu s pôvodným bodom na tej istej priamke a teda netvoria trojuholník. Ak nám pre $m$ bodov vyjde tá istá smernica, tak aj s pôvodným máme $m+1$ bodov, ktoré ležia na jednej priamke a netvoria trojuholníky. Dokopy to je $\\frac{m(m-1)}{2}$ trojíc, ktoré netvoria trojuholníky a je v nich pôvodný bod. Na to, aby sme vedeli zistiť, koľkokrát sme dostali ktorú smernicu si ich môžeme jednoducho usporiadať a prejsť. (Prípadne sa dajú pamätať v tzv. mape.) Oba postupy nás stoja čas $O(n \\log(n))$.

Nakoľko tento postup musíme urobiť pre každý bod, dostávame riešenie s časovou zložitosťou $O(n^2 \\log(n))$. Pamätať si musíme len pôvodné body a pre jeden aj všetky smernice. Pamäťová zložitosť je teda $O(n)$. Pri celom tomto postupe si ale treba dávať pozor na to, že každú trojicu, ktorá netvorí trojuholník zarátame trikrát. Druhá nepríjemnosť je, že smernice nie sú celé čísla. Tu pomôže, že smernica je len podiel dvoch celých čísel (lebo súradnice trojuholníkov sú celočíselné) a takéto racionálne číslo si vieme pamätať ako dvojicu (`pair<>` v C++). Tieto zlomky však treba previesť do základného tvaru, teda vydeliť najväčším spoločným deliteľom (funkcia `__gcd()` v C++).
",8
648eac95a2bd9f21,ksp,"# Strieborné bubáky

Bubu sa rozhodol, že si zaobstará nejaké tie strieborné bubáky. Lenže bubáky nerastú len tak na strome. Pre bežných smrteľníkov je dosť náročná úloha niekde také bubáky zohnať. Bubu však nie je žiadny amatér a vie, ako na to.

Existuje totiž stará baňa, v ktorej trpaslíci zakopali svoje poklady. A Bubuho plán je ich vykopať. Miesto už pozná, potrebuje si už len zaobstarať správne vybavenie, konkrétne dobrý krompáč. Čím lepší krompáč, tým viac ním Bubu vyťaží. Lenže lepšie krompáče zvyčajne aj viac stoja.

Bolo by treba vymyslieť optimálnu stratégiu nakupovania krompáčov. Bubu by si to v skutočnosti vedel spočítať aj sám, ale zrovna sa mu nechce. A tak prichádzate do hry vy.

## Úloha

Na začiatku (v deň 0) má Bubu našetrených $B$ strieborných bubákov.

Na trhu sa dá zohnať $N$ krompáčov. Krompáč $i$ ($1 \\leq i \\leq N$) bude dostupný iba v deň $i$, stojí $c_i$ bubákov a Bubu ním vykope $b_i$ bubákov za deň. Bubu si môže kúpiť nový krompáč iba v prípade, že má dosť peňazí, t.j. ak má aspoň $c_i$ bubákov. Keď tak spraví, starý krompáč okamžite zahodí a potom používa nový krompáč, až kým ho znovu nevymení za ďalší.

Koľko najviac bubákov vie mať Bubu v deň $N+1$, ak zvolí správne dni, kedy nakúpiť krompáče?

## Formát vstupu

V prvom riadku je $N$ a $B$ - počet krompáčov a začiatočný počet bubákov. Nasleduje $N$ riadkov, v $i$-tom z nich sú dve čísla $c_i, b_i$ - cena $i$-teho krompáča a počet bubákov, ktoré ním Bubu vykope za deň.

## Formát výstupu

Vypíšte jedno číslo - najväčší počet bubákov, ktorý vie mať Bubu v deň $N+1$.

## Hodnotenie

V prvej sade platí $1 \\leq N \\leq 1,000$, $1 \\leq c_i, b_i \\leq 1,000$.

V druhej sade platí $1 \\leq N \\leq 200,000$, $1 \\leq c_i, b_i \\leq 10^9$.

## Príklady

```vstup
5 10
1 1
11 100
11 10
1 5
20 15
```

```vystup
30
```

*V prvom dni si Bubu kúpi krompáč. V druhom dni si nemôže dovoliť krompáč za $11$, ale v treťom dni už áno a kúpi si ho. Tým za ďalšie tri dni vyťaží $30$ bubákov. Ak by si kúpil krompáč aj v posledný deň, vedel by ním síce ťažiť viac, ale stojí $20$ bubákov, a tak by skončil v deň $N+1$ len s $15$ bubákmi.*
","# Strieborné bubáky

## Dynamika

Prvá vec, ktorá pravdepodobne skúsenému riešiteľovi napadne, keď sa pozrie na túto úlohu je: ""dynamické programovanie"". Otázkou len je, ako si dobre zadefinovať stavy, aby sme si z menších stavov vedeli jednoducho vypočítať väčšie. Jednoduchý plán by bol definovať $dp[t]$ = najväčší počet bubákov, ktorý viem mať v deň $t$ (t.j. po $t$ použitiach nejakého krompáča, hneď po tom ako sme sa rozhodovali, či kupujeme krompáč v deň $t$). Avšak, $dp[t]$ nevieme priamočiaro vypočítať iba z predošlých stavov. Pri úvahách záleží na tom, ktorý krompáč použijeme zo dňa $t-1$ na deň $t$. Preto sa núka zadefinovať stavy nasledovne: \
$dp[t][j] =$ náš najväčší možný počet bubákov v deň $t$, ak aktuálne máme krompáč $j$ (ten, ktorý bolo možné kúpiť v deň $j$)

Môžeme to vnímať tak, že na začiatku máme krompáč $0$, ktorý ťaží $0$ bubákov za deň. Teraz vieme medzi stavmi jednoducho prechádzať:

- pre $j < t$: $dp[t][j] = dp[t-1][j]+b_j$,
- pre $j = t$: $dp[t][j] = -c_t+\\max \\lbrace dp[t][0], \\dots, dp[t][t-1] \\rbrace$,
- pre $j > t$: $dp[t][j] = -\\infty$.

Takže môžeme počítať odpoveď pre jednotlivé stavy podľa $t$ vzostupne a pre fixné $t$ vzostupne podľa $j$. Nakoniec finálnu odpoveď nájdeme ako $\\max \\lbrace dp[N+1][0], \\dots dp[N+1][N] \\rbrace$. Časová zložitosť tohoto riešenia je $O(N^2)$.

## Už to len zrýchliť

Pokúsime sa vylepšiť naše doterajšie riešenie. Chceli by sme dátovú štruktúru. Tá by si udržovala aktuálny deň $t$, pre tento aktuálny deň naše možnosti zodpovedajúce dvojiciam $(j, dp[t][j])$, kde $j \\leq t$ reprezentuje náš aktuálny krompáč (posledný, ktorý sme sa rozhodli kúpiť). Navyše chceme, aby sa táto štruktúra dala ľahko upraviť pri prechode do dňa $t+1$.

Ak by sme si pre každý krompáč $j$ skutočne stále pamätali $dp[t][j]$, tak by bol update z $t$ na $t+1$ časovo náročný (priamočiaro to nejde lepšie ako v $O(N)$). Skúsme sa toho teda vzdať. Napriek tomu však budeme chcieť byť schopný (pri troche úsilia) v aktuálnom dni vypočítať hodnotu $dp[t][j]$ pre ľubovoľné $j$.

Pre konkrétne $j$ sa $dp$ v čase vyvíja priamočiaro. $dp[j][j]$ treba vypočítať náročne, ale potom je to už jednoduché: $dp[t][j] = (t-j)b_j+dp[j][j]$. To nás navádza na myšlienku, že v našej štruktúre bude stačiť mať pre fixné $j$ iba hodnotu $dp[j][j]$.

Update z času $t$ na $t+1$ sa tak zvrháva na to, ako pridať $t+1$. Ako spočítať $dp[t+1][t+1]$? Toto je ťažká vec. Na to, aby sme to vedeli rátať by bolo dobré mať krompáče v našej štruktúre utriedené podľa ich aktuálnej hodnoty $dp$. Potom by výpočet bol triviálny. Chceš $dp[t+1][t+1]$? Zober zo štruktúry (v čase $t+1$, pred pridaním krompáča $t+1$) krompáč $j_0$ s najväčším $dp[t+1][j_0]$. Potom $dp[t+1][t+1] = dp[t+1][j_0]-c\_{t+1}$. Ako však udržiavať štruktúru utriedenú?

Vezmime fixný deň $t$. Krompáč $j \\leq t$ nazvime *nadbytočný*, ak

- existuje krompáč $k \\leq t$ taký, že ($dp[t][k] > dp[t][j]$ a $b_k \\geq b_j$) alebo ($dp[t][k] = dp[t][j]$ a $b_k > b_j$), ALEBO
- existuje krompáč $k \\leq t$ taký, že $dp[t][k] = dp[t][j]$ a $b_k = b_j$ a $k > j$.

Ak sa nám v nejakom čase stane, že je nejaký krompáč nadbytočný, tak na neho môžeme navždy zabudnúť. A presne to aj budeme robiť.

Navyše si všimnime, že ak v čase $t$ máme v štruktúre iba nenadbytočné krompáče a utriedime ich podľa $b_j$, tak ich hodnoty $dp[t][j]$ musia v tomto poradí (nie nutne ostro) klesať. Skutočne, ak $b_j \\leq b_k$ a zároveň $dp[t][j] \\leq dp[t][k]$, tak aspoň jeden z nich je nadbytočný. Takže nám stačí udržovať nenadbytočné krompáče utriedené podľa ich $b_j$, v prípade zhody podľa $j$ vzostupne. Konkrétna implementácia môže byť napríklad ako `set` v C++ (binárny vyvažovaný strom) s prvkami tvaru $(b_j, j)$.

Ako si však udržovať v štruktúre iba nenadbytočné krompáče? Deň sa práve zmenil z $t$ na $t+1$, ešte sme však nepridali krompáč $t+1$. Potrebujeme spraviť dve úpravy:

- Odstránenie nadbytočných krompáčov: V štruktúre máme krompáče $j_0, \\dots, j_m$ zoradené podľa $b_j$. Ak sa nejaký krompáč $j_i$ stal nadbytočným, tak si všimnime, že je nadbytočný s krompáčom $k = j\_{i+1}$ (v definícii vyššie). Budeme preto udrživať set udalostí $U$, v ktorom pre každý krompáč $j_i$ v našej štruktúre budeme mať udalosť $(t\_*, j_i)$ hovoriacu, že v čase $t\_*$ sa $j_i$ stane nadbytočným (s $k = j\_{i+1}$). Potom vieme ľahko spraviť úpravu poradia: Pokiaľ je v $U$ udalosť s časom $\\leq$ ako $t+1$, vezmi príslušný krompáč, odstráň ho z poradia a updatni udalosti $U$.
- Pridanie krompáču $t+1$ a odstránenie tým vzniknutých nadbytočných krompáčov: Toto je jednoduché. Pozrieme sa kam do poradia by patril $t+1$. Ten je buď hneď nadbytočný (v takom prípade ho nepridáme vôbec), alebo nie je (v takom prípade ho pridáme a prípadne povyhadzujeme krompáče, ktoré sa tým stali nadbytočné (tie sú nutne v poradí susedné pod ním)).

Poznamenajme, že nám nevadí, keď v konkrétnej implementácii budú pre nejaké $j\_\*$ v $U$ zostávať aj zastaralé udalosti.

## Zhrnutie

Udržujeme si aktuálny deň $t$, nenadbytočné krompáče v poradí podľa $(b_j, j)$ a set udalostí $U$.

Update z $t$ na $t+1$ vyzerá nasledovne:

- Pokiaľ je v $U$ udalosť s $t\_\* \\leq t+1$, vyhoď príslušný krompáč zo štruktúry (stal sa nadbytočný) a pridaj nové udalosti do $U$. Opakuj.
- Nájdi $j_0$ s najmenším $b\_{j_0}$ (a preto najväčším $dp[t+1][j_0]$), z toho spočítaj $dp[t+1][t+1]$.
- Ak $t+1$ nie je nadbytočný, pridaj ho a povyhadzuj krompáče, ktoré sa stali nadbytočné (v poradí susedné pod ním).

Na konci (v dni $(N+1)$), jednoducho nájdeme $j_0$ s najmenším $b\_{j_0}$ a odpoveď bude $dp[N+1][j_0]$.

Celkovo spravíme $O(N)$ operácii s oboma setmi a tieto operácie sú v $O(\\log N)$. Celková zložitosť bude $O(N \\log N)$. Pamäťová zložitosť bude $O(N)$.
",8
149db4f3d51538e9,ksp,"# Zaspatý krtko

Určite poznáte krtka Peťka. Celé dni vyspáva v svojej podzemnej nore a zobudí sa iba vtedy, keď sa ide najesť. Našťastie, býva priamo pod jabloňovým sadom, stačí sa mu teda vykopať hore, pojesť čo najviac jabĺk a vrátiť sa do svojho pelechu, aby tam pokračoval vo svojej obľúbenej činnosti.

Jabloňový sad je vlastne rad $n$ stromov, pod ktorými sú napadané jablká. Peťko si vždy vyberie nejaký súvislý úsek jabloní, vykope sa na jeho začiatku, potom prejde až k jeho koncu a zakope sa späť pod zem. Popritom zje všetky jablká, na ktoré narazí.

Niektoré jablká však padli už veľmi dávno a preto zhnili. Peťko je však takmer úplne slepý a preto nevie rozlíšiť zhnité jablko od toho zdravého. Časom sa už zmieril s tým, že na to, aby sa dobre najedol, musí zjesť aj nejaké hnilé jablká. Snaží sa však, aby rozdiel medzi počtom zdravých a zhnitých jabĺk, ktoré zje, bol čo najväčší.

Po tomto príbehu je vám určite ľúto chudáka Peťka, s jeho ťažkým životným štýlom. Môžete mu však pomôcť. Stačí ak mu poradíte, ktorý úsek jabloní si má vybrať, aby sa čo najlepšie najedol.

## Úloha

Na vstupe dostanete popis jabloňového sadu ako postupnosť celých čísel. Pre každý strom budete vedieť, aký je rozdiel počtu zdravých a hnilých jabĺk pod týmto stromom. Keďže Peťko zje pod každým stromom všetky jablká, toto je naozaj jediná informácia, ktorú potrebujete.

Zistite, ktorý zo súvislých úsekov si má Peťko vybrať, aby bol rozdiel medzi počtom zdravých a zhnitých jabĺk, ktoré zje, najväčší možný.

## Vstup

Prvý riadok vstupu obsahuje prirodzené číslo $n$ ($1 \\leq n \\leq 1,000,000$) udávajúce počet stromov v sade.

Druhý riadok obsahuje $n$ celých čísel $p_i$ ($-1,000,000,000 \\leq p_i \\leq 1,000,000,000$) -- rozdiely dobrých a zlých jabĺk pod jednotlivými stromami.

## Výstup

Vypíšte jeden riadok a v ňom dve čísla $a$, $b$. Nech $a$ ($1 \\leq a \\leq n$) je strom, pri ktorom sa má Peťko vykopať a $b$ je počet stromov (vrátane stromu $a$), ktoré má prejsť smerom doprava. Ak existuje viacero riešení, vypíše ľubovoľné z nich.

## Príklady

```vstup
15
-1 -1 -1 1 2 3 4 5 -10 -10 -10 1 2 3 4
```

```vystup
4 5
```

*Krtkovi sa oplatí vykopať pri strome číslo 4 s počtom jabĺk 1, spapať potom 2, 3, 4 a 5 jabĺk pri nasledujúcich stromoch. Neoplatí sa mu ísť ďalej, takže sa zakope pri strome číslo 8.*

```vstup
5
-2 10 2 -3 4
```

```vystup
2 4
```

```vstup
3
1000000000 1000000000 1000000000
```

```vystup
1 3
```

*Dajte si pozor na veľkosť premennej, v ktorej si budete pamätať súčet!*

```vstup
5
-47 -42 -17 -13 -12
```

```vystup
3 0
```

*Môžte si všimnút že správnych riešení je 5.*
","# Zaspatý krtko

V tejto úlohe sa dalo spraviť celkom priamočiare riešenie, ktoré by potrebovalo čas $O(n^2)$, jednoducho tak, že vyskúšame súčet čísel v každom súvislom úseku. Napríklad pre každý začiatok úseku skúsime postupne pričítavať prvky sprava a popritom všetkom si budeme udržiavať, aký najvyšší súčet sme doposiaľ videli, kde začínal úsek s týmto súčtom a aký bol dlhý.

Takéto riešenie síce nedostane plný počet bodov, ale je lepšie mať aspoň niečo.

## Jeden prístup

Jedna spásonosná myšlienka, ktorá vám mohla napadnúť, je pozrieť sa na úlohu ako na úseky kladných^[resp. nezáporných] a záporných čísel. Správny úsek bude začínať na začiatku nejakého kladného úseku a končiť na konci nejakého kladného úseku.

Ďalšie úvahy teda mohli sledovať, kedy sa nám oplatí prepojiť dva kladné úseky, aj keď sú oddelené úsekom záporným. Netreba však vymýšľať ťažké podmienky, môžme si napríklad pre každé číslo zistiť, aký najlepší výsledok vieme dosiahnuť, keď ním budeme končiť, s tým, že povolíme, aby tento výsledok bol nula, pokiaľ každý, ktorý končí našim číslom, bude záporný ^[Vtedy predsa môžme zobrať prázdny úsek.].

Tak sa nám úloha totiž zjednoduší, ak chceme výsledok končiaci nejakým číslom, bude to buď nula, alebo súčet tohto čísla s výsledkom pre predošlé číslo. Nakoniec si už stačí len všimnúť, že nepotrebujeme všetky medzivýsledky ukladať, ale stačí nám udržiavať si akési lokálne a akési globálne najlepšie riešenie.

Dostali sme sa teda k optimálnemu riešeniu s časovou zložitosťou $O(n)$ a pamäťou $O(1)$.

## Druhý prístup

Napriek tomu si ešte rozoberieme druhé, možno menej intuitívne, ale za to lepšie zovšeobecniteľné riešenie. Pozrieme sa, čo nám pomôže, ak si pre každú pozíciu vyrátame súčet čísel od začiatku po túto pozíciu. Takéto čísla budeme volať prefixové súčty. Keď sa nad tým zamyslíme poriadnejšie, súčet každého súvislého úseku vieme popísať rozdielom dvoch prefixových súčtov.

Ak by sme takto chceli spočítať najväčší súčet, ktorý končí na nejakej nami určenej pozícii, stačí nám zistiť, aký najmenší prefixový súčet sme videli naľavo od seba, lebo najväčší výsledok dostaneme samozrejme, pokiaľ od nášho nemenného čísla odčítame čo najmenšie číslo.

Čo teda spravíme: Prejdeme pole zľava doprava, budeme si počítať prefixové súčty a pamätať si doteraz najmenší videný prefixový súčet a doteraz najlepší videný výsledok. Ten prípadne upravíme, ak je rozdiel nášho aktuálneho prefixového súčtu a najmenšieho videného súčtu lepší, ako najlepší doterajší výsledok. Zložitosti budú rovnaké ako v predošlom prístupe.
",5
2d9d3d05429fc579,ksp,"# Ťahanie Kalerábu

Záhradník Adam mal veľmi úspešný rok. Zeleniny v jeho záhrade mu narástli do neuveriteľných rozmerov. Toto je síce pekné pri tekviciach, ktoré sa vďaka sezónnemu sviatku predajú veľmi rýchlo, ale pri istom type zeleniny to je problém. Napríklad taká repa, keď je veľká, ťažko sa zo zeme vyťahuje a Adam si na pomoc musel zavolať dedka, babku, sestru, mačku a myš. Takto sa im podarilo repu vytiahnuť, no majú ešte jeden väčší problém: masívny kaleráb, v zemi zakorenený tak pevne, že potrebujú ešte viac ľudí ako na repu. Na pomoc si teda zavolali susedov, kamarátov, známych a aj ich domáce zvieratá a za odmenu im sľúbili domáce sladkosti.

Susedia tak prišli do Adamovej záhrady v nejakom poradí. Toto poradie musí ostať rovnaké počas celého procesu organizácie a ťahania kalerábu. Samozrejme, pri kalerábe musí byť čo najsilnejší človek. Zlaté pravidlo ťahania kalerábov je, že za každým človekom so silou $F$, musí byť človek, ktorý má silu presne $F-1$. Zoberme si príklad, kde človek A, ktorý má silu 5 je pred človekom B. Človek B teda musí mať silu 4. Ak by bol človek B silnejší, človeka A potiahne moc silno a celý rad spadne. Ak by bol slabší, kaleráb sa im vytiahnuť nepodarí. Adam je skúsený záhradník, a vie mať akúkoľvek silu a vie sa postaviť kamkoľvek do radu. Adam má teda rad ľudí, z ktorých musí niektorých vypustiť, aby sa splnilo zlaté pravidlo ťahania kalerábov. Adam sa vie taktiež postaviť hocikde s hocijakou silou. Bude mať však ale dosť starostí s ťahaním a už potrebuje pomôcť s organizáciou. Pomôžete mu postaviť čo najdlhši rad, ktorý tieto pravidlá spĺňa?

## Úloha

V záhrade je $N$ ľudí, každý so silou $F_i$ kde $i$ je poradie, v ktorom prišiel daný človek. Vašou úlohou je vypustiť z radu niekoľko ľudí, a vsunúť do radu Adama tak, aby tento rad spĺňal zlaté pravidlo, a zároveň bol čo najdlhší. Stačí zistiť dĺžku najdlhšieho možného radu.

## Formát vstupu

Na prvom riadku dostanete dve čísla: $1 \\leq N \\leq 500,000$ -- počet ľudí v rade a $1 \\leq M \\leq 50,000,000$ -- najsilnejšieho človeka v rade. Na druhom riadku dostanete $N$ čísel $F_i$ oddelených medzerami -- silu $i$-tého človeka v rade.

## Formát výstupu

Na výstup vypíšte jedno číslo $L$ -- najväčšiu možnú dĺžku radu.

## Príklad

```vstup
10 12
1 3 5 7 9 2 4 8 12 10
```

```vystup
4
```

Najlepšie riešenie je napríklad zobrať čísla 1, 2 a 4 z radu a postaviť Adama so silou 3 na správne miesto.

```vstup
6 5
1 2 3 4 5 4
```

```vystup
6
```
","# Ťahanie Kalerábu

## Pomalý bruteforce

Tento príklad vieme spraviť celkom jednoducho v exponenciálnom čase. Pôjdeme od začiatku cez všetky čísla, a po každom čísle sa rozvetvíme na dve možnosti: s použitím Adama a bez použitia. Ak Adama použijeme, dáme mu silu o jedna väčšiu, ako je naše aktuálne číslo, a v tejto vetve ho už použiť nemôžeme. Takto vieme prejsť všetky možnosti použitia Adama a stačí si nám zapamätať najdlhšiu takúto vetvu. Takéto riešenie bude mať časovú zložitosť $O(2^N)$, pretože na každom čísle musíme prejsť cez dve vetvy. Dajú sa tu rôzne veci zoptimalizovať, avšak zložitosť bude stále $O(2^N)$, a takéto riešenie bude teda veľmi pomalé.

## Lepší bruteforce

Čo ak by sme si pre každého človeka v rade pamätali dve čísla? Prvé číslo bude vyjadrovať, koľko ľudí je za ním takých, že spolu tvoria reťaz, ktorá spĺňa naše pravidlá. Toto číslo si označíme písmenom $A$. Druhé číslo bude vyjadrovať to isté, až na to, že v nejakom momente je v tomto rade aj Adam. Toto číslo označíme ako $B$. Budeme takto prechádzať cez všetkých ľudí. Pre každého nového človeka nájdeme posledného človeka v rade, ktorý je o jedna slabší a človeka, ktorý je o dva slabší. Novému človeku nastavíme číslo $A$ na silu človeka o 1 slabšieho plus jedna, pretože sa pridal do radu. Číslo $B$ je troška komplikovanejšie.

Číslo $B$ má dve možnosti: buď to môže byť číslo $B$ človeka o jedna slabšieho plus jedna alebo to môže byť číslo $A$ človeka o dva slabšieho plus dva. Druhá možnosť vyjadruje možnosť, kde sme Adama doteraz nepoužili a až teraz sme ho vsunuli do radu. Takto prejdeme cez všetkých ľudí a riešenie je najväčšie číslo s použitím Adama, pretože to vyjadruje Adam vždy predĺži rad o jedna. Samozrejme sa môže stať, že v rade nie je človek o jedna alebo o dva slabší. V takom prípade je tento človek začiatkom reťaze a začne teda od nuly.

Toto riešenie má kvadratickú časovú zložitosť v závislosti od počtu ľudí, pretože pri pridaní každého človeka musíme v najhoršom prípade prejsť všetkých predchádzajúcich ľudí, teda je časová zložitosť $O(N \\cdot N) = O(N^2)$ teda kvadratická. Pamäťová zložitosť je lineárna od počtu ľudí ($O(N)$), keďže si pre každého človeka pamätáme dve čísla.

## Optimálne riešenie

Od lepšieho bruteforcu k optimálnemu riešeniu je už len jeden krok. Namiesto toho, aby sme si pamätali tieto údaje pre každého človeka, budeme si tieto údaje pamätať pre každú možnú silu človeka. Teraz namiesto toho, aby sme prehľadávali posledného človeka s nejakou silou, stačí nám použiť hľadanú silu ako index poľa, ktorú vieme nájsť v konštantnom čase. Polia vieme na začiatku naplniť nasledovne: pole reprezentujúce rad bez Adama naplníme nulami, pretože Adama sme nepoužili a človek, ktorý hľadá takúto silu bude prvý v tomto rade. Pole reprezentujúce čísla $B$ naplníme jednotkami, pretože v tomto prípade použijeme Adama hneď na začiatku.

## Prečo nám netreba max()

Môže sa nám stať, že v rade stoja dvaja alebo viacerí ľudia s rovnakou silou. Keď vyrátame prvého takého človeka, jednoducho uložíme čísla do poľa. Ak nájdeme ďalšieho človeka s takouto silou, vieme, že teraz pracujeme s číslami, ktoré sú rovnaké alebo lepšie, ako keď sme túto silu rátali naposledy, pretože teraz pracujeme s nadmnožinou čísel s akou sme pracovali minule. Táto optimalizácia nebola potrebná na dosiahnutie plného počtu bodov, avšak je to zaujímavé pozorovanie, ktoré môže byť pre vás v budúcnosti užitočné.
",5
0b571e91e9c1cf9e,ksp,"# Organizačné opletačky

Hurááá! Prázdniny! Povedal si Samko a začal sa tešiť na ničím nerušený oddych. Konečne bude môcť robiť všetko, na čo počas roka nebol čas. Dievčatá, plávanie, opaľovanie sa, dievčatá, ochutnávka kávy, dievčatá, hranie spoločenskej hry, dievčatá, sledovanie obláčikov\\footnote{Konkrétne deviatich.}, učenie sa, spoločenská hra, ochutnávka nemeckých klobás, dievčatá, spánok, spoločenská hra, túra a tak ďalej. Keď má človek ale toľko plánov, musí si ich poriadne naplánovať.

Začal teda rozmýšľať, čo ktorý deň urobí. Nie všetko sa totiž hodí na ľubovoľný deň. Napríklad takého 5.9. určite nie je čas na dievčatá, ale deň po tom je už fajn. Takisto Samko vie, že v jeden deň spraví maximálne jednu vec. Ak by totiž riešil dievčatá, tak na taký spánok mu naozaj čas nezostane.

Prišiel teda s perfektným nápadom. Na každý deň si stanovil štyri (nie nutne rôzne) alternatívy\\footnote{Tzv. mokrý, suchý, zamračený a slnečný variant, aj keď taká káva sa dá ochutnávať vždy.}. Potom sa znovu zamyslel\\footnote{Sranda, že sa to stáva skôr cez prázdniny.} a poriadne si spísal, aké veci chce cez prázdniny naozaj stihnúť\\footnote{Viď zoznam vyššie.}. Na poradí mu nezáleží, ale ak si raz naplánoval opaľovanie a opaľovanie, tak sa chce naozaj opaľovať dva krát. Je však naozaj možné, aby stihol všetky naplánované aktivity?

## Úloha

Prázdniny majú $n$ dní. Na každý deň má Samko vybrané štyri možné aktivity, z ktorých môže maximálne jednu ten deň vykonávať. Na celé prázdniny má zoznam $k$ aktivít, ktoré chce stihnúť. Je to ale možné? Koľko najviac toho dokáže absolvovať?

## Formát vstupu

V prvom riadku vstupu je číslo $n$ ($1\\leq n \\leq 10,000$) udávajúce počet prázdninových dní. Nasleduje $n$ riadkov so štyrmi číslami $a_1 , a_2, a_3, a_4 \\leq 1,000,000$ oddelenými medzerou, predstavujúce možné aktivity na daný deň. V nasledujúcom riadku je číslo $k$ ($1 \\leq k \\leq 10,000$) udávajúce počet aktivít, ktoré chce Samko cez prázdniny stihnúť. V nasledujúcom riadku sa nachádza $k$ kladných čísiel menších ako $1,000,000$, popisujúce jednotlivé aktivity.

## Formát výstupu

Vypíšte jedno číslo -- najväčší počet aktivít, ktoré môže Samko cez prázdniny naozaj stihnúť.

## Príklad

```vstup
5
1 2 2 1
2 2 3 4
3 2 6 7
10 3 2 1
10 2 1 5
5
2 10 2 2 2
```

```vystup
5
```

_S výnimkou predposledného dňa sa bude zúčastňovať aktivity číslo $2$. V predposledný deň sa zúčastní aktivity $10$._

```vstup
5
1 5 2 8
1 2 5 9
1 3 4 6
1 5 1 2
2 1 7 8
5
1 2 3 4 5
```

```vystup
4
```

_Tu sa Samko musí rozhodnúť, či si dá tretí deň aktivitu 3 alebo 4. Jednu z nich určite neabsolvuje._
","# Organizačné opletačky

Najprv sa pozrime na to, čo po nás vlastne zadanie chce. Potrebujeme nejako vhodne povyberať z každého dňa konkrétnu aktivitu tak, aby sme čo najlepšie pokryli všetky aktivity, ktoré chce Samko stihnúť. Pre nás je ale vhodnejší iný pohľad: hľadajme také pospájanie aktivít s dňami (v ktorých sa daná aktivita vyskytuje), kde každý deň je spojený s najviac jednou aktivitou zo Samkovho zoznamu a podobne aj každá aktivita je spojená s najviac jedným dňom. Skúsenejší riešitelia hneď zbadajú párenie, dokonca (a našťastie) na bipartitnom grafe.^[Bipartitný graf je taký, u ktorého vieme vrcholy rozdeliť do dvoch množín, tzv. partícií, tak, aby žiadne hrany neviedli v rámci jednej partície.]

Zostavíme si teda graf, v ktorom ako vrcholy jednej partície pôsobia aktivity, ktoré chce Samko stihnúť, a ako vrcholy druhej partície pôsobia jednotlivé dni, ktoré má k dispozícii. Hrana medzi dňom a aktivitou existuje práve vtedy, keď ju môže Samko v ten deň vykonávať. Nás bude zaujímať, koľko najviac hrán z tohto grafu vieme vybrať tak, aby žiadne dve nemali spoločný koncový vrchol. Takúto množinu hrán nazveme maximálnym párením. Počet hrán maximálneho párenia bude našou hľadanou odpoveďou.

## Maximálne párenie

Pre popis algoritmu hľadajúceho maximálne párenie si zavedieme ešte jeden pojem: zlepšujúca cesta v nejakom už vybratom (nie maximálnom) párení $P$. Ide o postupnosť neopakujúcich sa vrcholov (spojených hranami), ktorá začína v nespárenom vrchole $v_0$, pokračuje po nepoužitej hrane do nejakého vrchola $u_0$. Kým táto cesta neskončí v nespárovanom vrchole, pokračuje ďalej z vrchola $u_i$ do vrchola $v\_{i+1}$, po hrane z párenia $P$, z ktorého pokračuje do vrchola $u\_{i+1}$ opäť po hrane, ktorá sa v párení $P$ nenachádza. Všimnime si, že cesta ide z vrcholov $v$ po nespárenej hrane a z vrcholov $u$ po spárenej. Keďže cesta začína vo vrchole $v_0$ a končí v nejakom vrchole $u_k$, bude obsahovať viac nespárených, než spárených hrán.

Keď nájdeme zlepšujúcu cestu v nejakom párení, vieme toto párenie zväčšiť o 1, pokiaľ ""preklopíme"" hrany na tejto zlepšujúcej ceste, čiže tie hrany z cesty, ktoré sme mali pôvodne v párení, z neho odstránime a zvyšné doňho pridáme. Existuje dôkaz, že párenie je maximálne práve vtedy, keď v ňom neexistuje zlepšujúca cesta[^formal].

\[^formal\]: Ak by ste si to chceli formálne dokázať, najjednoduchší postup pre netriviálnu implikáciu je nepriamy dôkaz. Vezmete si nejaké nie maximálne párenie a nejaké maximálne, pozriete sa, ako by vyzerali komponenty grafu, ktorý bude obsahovať všetky vrcholy, ale len hrany, koré sú aspoň v jednom z párení, a zistíte, že musí existovať zlepšujúca cesta.

Preto sa bude celé riešenie párenia zaoberať hľadaním zlepšujúcich ciest na bipartitnom grafe. Označme si partície tohto grafu ako $A$ a $B$. Stačí nám používať obyčajné prehľadávanie do hĺbky, ktoré vždy začne napríklad v (každom) nespárenom vrchole z $A$, pôjde do každého možného vrchola z $B$ po nespárenej hrane, potom po spárenej hrane späť do vrchola z $A$, atď. atď., až dôjde do nespáreného vrchola z $B$. V tomto momente ""preklopí"" všetky hrany.

Toto celé sa bude opakovať, kým sa nestane, že nenájdeme žiadnu zlepšujúcu cestu. Vtedy však môžeme byť spokojní, lebo sme objavili maximálne párenie.

Časová zložitosť takéhoto riešenia je $O(m \\cdot (v + h))$, kde $m$ je veľkosť maximálneho párenia, $v$ je počet vrcholov nášho grafu a $h$ je počet hrán tohto grafu. $m$ vieme zhora odhadnúť ako $min(n, k)$, $v = n + k$. V najzákernejšom prípade však môže byť počet hrán až $n \\cdot k$, napríklad ak máme $k$-krát tú istú aktivitu, ktorá sa môže vykonať v každý deň.

## Kam ďalej

Prvé možné zlepšenie je v samotnom algoritme hľadajúcom maximálne párenie. Keby sme namiesto prehľadávania do hĺbky použili prehľadávanie do šírky, vieme nájsť viacero zlepšujúcich ciest naraz a vieme to ukopať k časovej zložitosti $O(h \\cdot \\sqrt{v})$^\[[Pre záujemcov](http://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm)\].

S tým sa však neuspokojíme a potiahneme to kúsok ďalej. Čo nám vedelo strašne pokaziť časovú zložitosť, boli viacnásobné aktivity. S nimi sa vieme vysporiadať tak, že všetky rovnaké aktivity pospájame do jedného vrchola, v ktorom si nejako označíme, že s ním môže byť pospájaných viacero rôznych dní. Namiesto toho, aby sme nejako čarovne upravovali pôvodný algoritmus pre párenie, si ukážeme, ako sa celá úloha dá previesť na úlohu o maximálnom toku v grafe.

Na to si zostrojíme ešte trošku iný graf. Ten bude ohodnotený a orientovaný a bude obsahovať dva špeciálne vrcholy, takzvaný _source_ a _sink_, ďalej vrcholy pre každý deň a pre každý druh aktivity. Zo _source_ pôjde hrana do každého dňa s váhou $1$. Z každého dňa pôjdu hrany váhy $1$ do tých aktivít, ktoré sa dajú v ten deň vykonávať. Tu si treba uvedomiť, že každý druh aktivity bude mať priradený nanajvýš jeden vrchol, takže týchto hrán už bude nanajvýš $4n$. Nakoniec pôjdu hrany z jednotlivých aktivít do _sink_, s váhou rovnou tomu, koľkokrát chce Samko danú aktivitu počas prázdnin vykonať. Ak chceme znížiť nejaké konštanty, vrcholy budeme vytvárať len pre tie aktivity, ktoré chce Samko vykonať počas prázdnin.

## Maximálne toky

V takomto novom grafe nás bude zaujímať, koľko najviac vody vie tiecť zo _source_ do _sink_. Obmedzenia sú nasledovné: Z každého vrchola okrem _source_ a _sink_ musí odtekať presne toľko vody, koľko doňho priteká a po každej hrane môže tiecť najviac toľko vody, aká je jej váha. Ľahko si všimneme, že každý validný tok zodpovedá nejakému konkrétnemu páreniu na pôvodnom grafe.^[Stačí sa pozrieť, po ktorých hranách medzi dňami a aktivitami tečie voda.]

Ako sa taký najväčší tok hľadá? Opäť budeme potrebovať zaviesť rafinovaný pojem zlepšujúcej cesty. K tomu budeme potrebovať do nášho orientovaného grafu prirobiť fiktívnu spätnú hranu ku každej normálnej hrane, na začiatku s kapacitou $0$. V pôvodných hranách si budeme pamätať, koľko vody nimi môže **ešte** pretiecť, v spätných, koľko vody tečie pôvodnými hranami. Teraz budeme hľadať také cesty, ktoré začínajú v _source_, prechádzajú po hranách s nenulovými hodnotami a končia v _sink_.

Čomu to zodpovedá: Budeme hľadať nejaký spôsob, ako cez náš graf pretlačiť ďalší prúd veľkosti $1$. Keď pôjdeme po obyčajných hranách, bude to zodpovedať tomu, že cez ne posielame nový prúd. Keď pôjdeme po spätnej hrane z $u$ do $v$, znamená to, že sme si rozmysleli, kade tiekol prúd predtým z $v$ a pošleme ho nejakým novým smerom.

Tieto zlepšujúce cesty môžme opäť hľadať starým osvedčeným prehľadávaním do hĺbky zo _source_. Akonáhle dôjdeme do _sink_, hodnoty všetkých hrán, po ktorých sme prešli, znížime o $1$ a k nim opačným hranám naopak zvýšime hodnoty o $1$. Rozmyslite si, že opäť platí príjemná vlastnosť, že ak nevieme nájsť zlepšujúcu cestu, znamená to, že náš tok je už naozaj najväčší možný.

Časová zložitosť takéhoto riešenia bude $O(p \\cdot (v + h))$, kde $p$ je veľkosť toku, čiže naša odpoveď, $v$ a $h$ sú počty vrcholov a hrán, pričom tentoraz vieme odhadnúť $v = n + k + 2$, $h \\leq 5n + k$, takže po vhodnom dosádzaní a prepisovaní je horný odhad $O((n + k)^2)$. Pamäťová zložitosť takéhoto riešenia bude $O(n + k)$^[Tu sa hodí ešte poznamenať, že pre všeobecné grafy existujú aj lepšie tokové algoritmy, ale vďaka malému hornému odhadu veľkosti toku nám v tomto prípade stačí aj takéto ""pomalé"" riešenie.].
",10
049474da9452d3e2,ksp,"# Nádoby

Samo má doma veľa hadov. Chcel si kúpiť veľa hadíc (samíc hadov), aby neskôr mal aj veľa háďat. Tak si ich objednal z nemenovaného internetového obchodu, ale keď mu prišla zásielka, postihlo ho nepríjemné prekvapenie. Miesto hadíc (samíc hadov) mu omylom poslali hadice (hadice). No čo už, pomyslel si, nájdem si teda inú zábavu. A našiel si inú zábavu.

## Úloha

Máme sústavu $n$ nádob poprepájaných hadičkami. Na začiatku sú všetky nádoby prázdne. Nad prvou nádobou je kohútik, cez ktorý sa do tohto systému napúšťa voda. Funguje princíp spojených nádob.

Hadičkou začne voda pretekať, až jej hladina v niektorej z incidentných nádob dosiahne úroveň najvyššieho bodu danej hadičky. Vtedy sa rast hladiny v tej nádobe zastaví a začne sa napúšťať tá druhá a cez ňu prípadne ďalšie. Až sa hladiny vyrovnajú, zostanú vyrovnané navždy a ak napúšťanie pokračuje, budú stúpať súčasne.

Vašou úlohou je zistiť, z ktorej nádoby voda pretečie.

## Formát vstupu

Na prvom riadku sú dve medzerou oddelené čísla $n$ a $k$ -- počet nádob a počet hadičiek. Nádoby sú očíslované od $1$ po $n$.

Na druhom riadku je $n$ čísel, $d_1$ až $d_n$ -- výšky, v ktorých sa nachádza dno danej nádoby. Na treťom riadku je $n$ čísel, $h_1$ až $h_n$ -- výšky horných okrajov jednotlivých nádob.

Nasleduje $k$ riadkov popisujúcich jednotlivé hadičky. Na $i$-tom riadku je päť medzerou oddelených celých čísel, $x_i$, $y_i$, $a_i$, $b_i$, $c_i$. Táto hadica spája nádoby $x_i$ a $y_i$. Platí $x_i \\neq y_i$. Pripája sa do nádoby $x_i$ vo výške $a_i$ a do nádoby $y_i$ vo výške $b_i$. Jej najvyšší bod je vo výške $c_i$. Platí $a_i < c_i > b_i$ a koncové body hadice sú vyššie ako dno nádoby ku ktorej sa pripájajú. Koncový bod však môže byť vyššie ako horný okraj nádoby, v takomto prípade cez neho môže do nádoby voda iba natekať (vytekať nie).

Medzi tou istou dvojicou nádob môže viesť aj viac ako jedna hadička.

Všetky výškové údaje sú celé čísla z intervalu od $0$ do $10^9$ vrátane a sú navzájom rôzne.

## Formát výstupu

Vypíšte jedno číslo, číslo nádoby ktorá pretečie.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3--5 | 6 | 7--8 | |:--------------- |--------: | --------: | ------------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $10,000$ | $100,000$ | | $1 \\leq k \\leq$ | $1,000$ | $10,000$ | $100,000$ | $100,000$ |

## Príklad

```vstup
3 3
20 10 0
90 50 60
1 2 25 15 35
2 3 30 40 45
1 3 70 75 80
```

```vystup
2
```

*Keď hladina v nádobe 1 dosiahne výšku 35, začne sa napĺňať nádoba 2. Potom čo aj v nádobe 2 dosiahne výšku 35, voda začne stúpať v oboch nádobách súčasne, až kým nedosiahne výšku 45, kedy sa začne napúšťať nádoba 3. Keď voda aj v nej dosiahne výšku 45, začne voda stúpať vo všetkých nádobách súčasne, až dokým nedosiahne výšku 50, keď začne pretekať cez okraj nádoby 2 a hladina už ďalej stúpať nebude nikde.*

```vstup
5 6
30 50 70 40 90
300 280 290 210 110
1 2 220 200 230
3 4 100 120 170
3 4 130 60 150
4 5 160 190 260
1 5 180 250 270
4 2 140 80 240
```

```vystup
4
```

*Hoci je nádoba 5 najnižšia, voda sa do nej nedostane, skôr sa vyleje z nádoby 4.*
","# Nádoby

V tejto úlohe sme mali sústavu spojených nádob poprepájaných hadičkami, pričom do prvej nádoby sa napúšťala voda. Našou úlohou bolo zistiť, z ktorej nádoby sa voda vyleje.

## Pozorovania

Môžme si všimnúť, že mnohé informácie, ktoré na vstupe dostaneme, pre nás vlastne nemajú žiaden význam. Voda začne tiecť z jednej nádoby do druhej, keď hladina dosiahne výšku najvyššieho bodu hadice, ktorou sú prepojené. Výšky koncových bodov hadice na to nemajú žiaden vplyv, môžme ich teda ignorovať. Výška dna nádoby tiež nič neovplyvňuje.

## Pomalé riešenie

Budeme si pamätať, v ktorých nádobách už je voda, a v ktorých ešte nie.

Zakaždým preiterujeme všetky hadičky, aby sme našli tú, ktorá spája už zaplavenú nádobu s ešte nezaplavenou a spomedzi všetkých takýchto má najnižší vrchol. To nám povie, ktorá nádoba sa najbližšie zaplaví. Ak je však najnižšia výška vrchného okraja spomedzi už zaplavených nádob nižšia ako vrchol tejto hadičky, voda sa vyleje z najnižšej spomedzi už zaplavených nádob.

Časová zložitosť takéhoto riešenia je $O(n \\cdot k)$.

## Vzorové riešenie

Problém s predchádzajúcim riešením je, že zakaždým, keď sme chceli vedieť, do ktorej nádoby voda ďalej potečie, nám to zabralo veľmi veľa času. Tu nám pomôže [halda](https://www.ksp.sk/kucharka/halda/).

Použijeme haldu, na ktorej budú udalosti dvoch typov, pretečenie cez okraj nádoby a pretečenie z jednej nádoby do druhej. Halda bude utriedená podľa výšky, ktorú musí voda dosiahnuť, aby udalosť nastala (teda pri udalostiach prvého typu výška nádoby, a pri udalostiach druhého typu výška najvyššieho bodu hadice). Udalosť s najnižšou výškou bude na vrchu haldy.

Na začiatku máme v halde iba udalosti, ktoré sa týkajú prvej nádoby.

Simulácia teda bude vyzerať takto. Zakaždým z haldy vyberieme udalosť s najnižšou výškou. Ak je to pretečenie cez hadičku do druhej nádoby, v ktorej ešte voda nie je, udalosti súvisiace s touto nádobou (pretečenie cez jej okraj, a cez hadičky do susedných nádob) pridáme do haldy a zapamätáme si, že tu je voda. Ak je to pretečenie cez okraj, máme odpoveď, ďalej už simulovať nemusíme.

## Časová zložitosť

Jedna operácia vkladania alebo vyberania z haldy s $s$ prvkami nám zaberie $O(\\log s)$. Na halde môže byť najviac $2k+n$ udalostí (pre každú nádobu pretečenie cez okraj a pre každú hadičku pretečenie do jednej alebo druhej strany). Koľko operácii budeme robiť? Určite nie viac ako $4k+2n$, pretože každú udalosť môžme najviac raz vložiť a raz vybrať z haldy. Časová zložitosť teda bude $O((4k+2n)\\cdot \\log(4k+2n)) = O((n+k)\\cdot \\log(n+k))$.

## Pamäťová zložitosť

Okrem vecí zo vstupu si potrebujeme držať v pamäti ešte našu haldu ($O(n+k)$) a jedno pole, na to, aby sme vedeli, v ktorých nádobách už je voda ($O(n)$), čo je dokopy $O(n+k)$.
",6
7ed2ca2b7c4f77c9,ksp,"# Žrúti

V prísne tajnej KSP miestnosti T2 je koberec. Kedysi vraj býval modrý, teraz však už pohltil toľko prachu, omrviniek, vlasov a kadečoho ďalšieho, že je skôr sivý. Kubík sa teda rozhodol, že je najvyšší čas koberec opäť povysávať. S hrôzou však zistil, že za tú dobu, čo tam koberec ležal, na ňom začalo všeličo rásť. Dokonca sa v ňom vytvoril samostatný ekosystém! Spozoroval dva typy organizmov: predátorov a korisť. Predátori sú (prekvapivo) špecifickí tým, že žerú korisť. Korisť je špecifická tým, že sa množí.

Kubík má teraz dilemu; nemôže predsa vysávať ekosystém! Radšej by bol, keby ekosystém prirodzene vymrel. Totiž, keby sa stalo, že predátori požerú všetku korisť, nebudú mať čo jesť a vymrú. Ak sa to nestane, bude musieť zavolať deratizátorov. Je ochotný chvíľu s vysávaním počkať, ale má to vôbec zmysel? Čo ak sa ekosystém rozrastie a potom sa ho nezbaví už nikto?

## Úloha

Pre jednoduchosť budeme náš ekosystém modelovať po kolách. V každom kole sa postupne udeje nasledovné:

- Každý predátor zožerie $p$ kusov koristi. V prípade, že na toto nežije dostatočne veľa koristi, predátori vyžerú všetku žijúcu korisť a v ďalšom kole pomrú od hladu.

- Každá korisť, ktorá ostala, sa nahradí $k$ novými korisťami.

V ekosystéme môžu nastať tri prípady:

- Po nejakom (konečnom) počte kôl vymrie všetka korisť a následne aj predátori. Vtedy hovoríme, že ekosystém _vymrie_.

- Ekosystém bude schopný fungovať donekonečna a množstvo koristi bude rásť nad všetky medze. Vtedy hovoríme, že ekosystém _rastie_.

- Ekosystém síce bude žiť donekonečna, ale existuje nejaké číslo $H$ také, že množstvo koristi nikdy neprekročí $H$. Vtedy hovoríme, že ekosystém je v _rovnováhe_.

Zistite, ktorý z týchto prípadov nastane.

## Formát vstupu

V prvom riadku sú štyri celé čísla $a, b, p, k$ - začiatočný počet predátorov, začiatočný počet kusov koristi, počet koristi, ktorú za jedno kolo jeden predátor skonzumuje, a počet koristi, ktorá vznikne z jednej pôvodnej koristi (pôvodná korisť zanikne a bude nahradená $k$ novými). Platí $1\\leq a, b, p, k\\leq 10^4$.

Dávajte si pozor na veľkosť čísel, s ktorými pracujete. Keď napríklad vynásobíte tri čísla zo vstupu, výsledok sa vám nemusí zmestiť do 32-bitovej premennej.

## Formát výstupu

Na výstupe vypíšte jedno slovo (bez úvodzoviek): ""vymrie"" , ""rastie"" alebo ""rovnovaha"" podľa toho, ktorý prípad nastane.

## Príklady

```vstup
3 15 4 2
```

```vystup
vymrie
```

*V ekosystéme sú traja predátori a $15$ kusov koristi. V prvom kole predátori zožerú $12$ kusov koristi a zvyšné $3$ sa rozmnožia na $6$. V druhom kole už nie je pre predátorov dosť koristi, preto zožerú všetku a následne umrú.*

```vstup
2 4 2 10
```

```vystup
vymrie
```

\*Všetka korisť bude zožraná už v prvom kole. \*

```vstup
2 5 2 10
```

```vystup
rastie
```

*Po prvom kole bude žiť $10$ kusov koristi, po druhom $60$, ...*

```vstup
1 2 1 2
```

```vystup
rovnovaha
```

*V každom kole najprv predátor zožerie jednu z dvoch koristí, následne sa tá druhá korisť rozmnoží opäť na dve.*
","# Žrúti

Keďže predátorov je vo všetkých kolách rovnako veľa, každé kolo zožerú rovnako veľa koristi (pokiaľ nevymreli od hladu). Množstvo vzniknutej koristi však závisí od toho, koľko jej je. Čím viac koristi je, tým viac jej vznikne. To však znamená, že pokiaľ v prvom kole množstvo koristi stúpne, musí stúpnuť aj v druhom kole a každom neskoršom, pretože ich ubudne rovnako veľa ale pribudne ich viac. Podobne, pokiaľ v prvom kole množstvo koristi klesne, musí jej množstvo klesnúť aj v ďalších kolách.

Na vyriešenie tejto úlohy nám teda stačí odsimulovať jediné kolo ekosystému a pozrieť sa, koľko koristi sme mali predtým a koľko máme po kole.

Ak máme teda na začiatku $a$ predátorov a $b$ kusov koristi, tak za jedno kolo nám najprv zmizne $a\\cdot p$ kusov koristi, čiže nám ich ostalo $b-(a\\cdot p)$ kusov. Táto korisť sa rozmnoží a budeme mať $(b-(a\\cdot p))\\cdot k$ kusov koristi. Porovnáme teda $b$ a $(b-(a\\cdot p))\\cdot k$. Podľa toho, ktoré číslo je väčšie alebo či sú čísla rovnaké ľahko určíme, čo sa stane s ekosystémom. Musíme sa ale uistiť, že používame dostatočne veľké premenné, aby sa nám do nich číslo zmestilo.

## Časová a pamäťová zložitosť

Riešenie úlohy zahŕňa len spočítanie a porovnanie niekoľkých čísel, ktorých je vždy rovnako veľa, bez ohľadu na vstupné dáta. Časová zložitosť bude konštantná, čiže $O(1)$. Taktiež si nemusíme pamätať nič iné, len daných pár čísel. Pamäťová zložitosť bude teda tiež konštantná: $O(1)$.
",1
db026532a7d6cfa9,ksp,"# Objednaná elektronika

Adam, Buj, Cecília^[Naozaj neexistuje KSPák, ktorého meno sa začína na C.] a Dávid nedávno zistili, že každému z nich chýba nejaký kus elektroniky. Adamovi chýba server, Bujovi lietajúci dron, Cecílii elektrická zubná kefka a Dávidovi obrazovka s ešte väčším rozlíšením, ako má teraz. Čo teda spravili? Išli na stránku Internetového obchodu s najotravnejšou reklamou na svete^[ Ďalej len IONRS.] a objednali si, čo potrebovali.

I nastal deň, keď si všetci štyria mali vyzdvihnúť svoju objednávku. Prišli preto do centrály IONRS, zaplatili a každý z nich dostal papierik, na ktorom bolo napísané nejaké číslo a ich meno^[Keby náhodou prišli do predajne ľudia s rovnakým menom, treba ich odlíšiť číslami.]. Následne sa zaradili do množstva ľudí čakajúcich na výdaj. V IONRS to totiž funguje tak, že objednané (a už zaplatené) predmety prichádzajú zo skladu na bežiacom páse, kde ich zloží šikovná pracovníčka, vyhlási číslo a meno priradené k danému predmetu a príslušný človek si ho ide zobrať.

Naši štyria kamaráti teda počúvali vyvolávané čísla a čakali, kedy odznie to ich. Ako prvý prišiel na rad Adam so svojím serverom. O niečo neskôr bolo vyvolané Bujove číslo a on si radostne začal rozbaľovať svojho drona. Keď už dron lietal, prišla po páse Cecíliina zubná kefka a posledný prišiel na rad Dávid.

Keď sa vracali z tohto výletu, stretli na ulici vešticu, a tá sa ich spýtala, aké čísla mali v IONRS na papierikoch. Tvrdila totiž, že sa podľa toho dá odhadnúť ich budúcnosť. Ak by v tom čísle boli samé štvorky a sedmičky, mali by nesmierne šťastie, pokiaľ ale spomenuté číslo bolo deliteľné trinástkou, nemuselo by to pre nich dopadnúť práve najlepšie.

Naši hrdinovia však zistili, že si svoje čísla nepamätajú a papieriky odovzdali, keď si vyzdvihovali nákup. Pamätali si len, že súčin Adamovho a Bujovho čísla bol rovnaký, ako súčin Cecíliinho a Dávidovho. Na internete sa tiež dá pozrieť zoznam čísel vyhlásených v daný deň, samozrejme už bez priradených mien a predmetov. Teraz by chceli vedieť, koľko takých štvoríc čísel zo zoznamu mohlo patriť im. Ak by tam bola len jedna, bolo by to jasné...

## Úloha

Na vstupe dostanete postupnosť $n$ čísel, označme si ich postupne $x_1$ až $x_n$. Nájdite počet všetkých rôznych štvoríc $(a,b,c,d)$, pre ktoré platí, že

- $x_a \\cdot x_b = x_c \\cdot x_d$
- $1 \\leq a < b < c < d \\leq n$

($a$, $b$, $c$, $d$ vyjadrujú pozíciu Adamovho, Bujovho, Cecíliinho a Dávidovho čísla v zozname.)

## Formát vstupu

Na prvom riadku je číslo $n ~ (1 \\leq n \\leq 1,000)$ -- počet čísel v postupnosti.

Na druhom riadku sa nachádza $n$ čísel oddelených medzerou, $x_1$ až $x_n$, čiže jednotlivé čísla, ktoré boli vyhlásené v IONRS. Platí, že $0\\leq x_i\\leq 10^9$.

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet takých štvoríc $a$, $b$, $c$ a $d$, že $x_a\\cdot x_b = x_c \\cdot x_d$ a $1 \\leq a < b < c < d \\leq n$.

## Príklady

```vstup
5
1 12 3 4 3
```

```vystup
2
```

*Buď mali čísla $1,12,3,4$ alebo $1,12,4,3$.*

```vstup
6
1 1 1 1 1 1
```

```vystup
15
```

*Ľubovoľná štvorica spĺňa $x_a \\cdot x_b = x_c \\cdot x_d$*

```vstup
10
1 2 3 4 5 6 7 8 9 10
```

```vystup
0
```

*Ak by boli vyhlásené tieto čísla, tak určite $x_a \\cdot x_b < x_c \\cdot x_d$*
","# Objednaná elektronika

## Hrubá sila

Máme zistiť, koľko rôznych kombinácií štyroch čisel zo vstupu je dobrých. Teda, koľko je štvoríc $(A, B, C, D)$ takých, že $x_A \\cdot x_B = x_C \\cdot x_D$ a $1 \\leq A < B < C < D \\leq n$. Spravíme to teda prvým spôsobom, ktorý nás napadne -- vyskúšame všetky štvorice. Tento bruteforce spravíme vnorením štyroch for-cyklov a jeho časová zložitosť je $O(n^4)$.

## Nepočítajme nič dvakrát

Problém s naším riešením je, že veľa vecí v ňom počítame stále dookola. Pre každú kombináciu indexov $A, B$ totiž raz prejdeme celý zvyšok poľa, kde kontrolujeme súčin čísel na pozíciách $C, D$. Ak by sme vedeli využiť informáciu o súčinoch $C, D$ viackrát, bez prechádzania poľa, mohli by sme náš algoritmus výrazne zrýchliť.

Rovnako dobré by bolo, keby sme vedeli rýchlo nájsť počet dvojíc indexov $A, B$ pre konkrétne $C, D$.

Vezmime si nasledujúce riešenie hrubou silou: postupne vyberáme dvojice $C, D$, a pre ne počítame výskyty dvojíc $A, B$ s rovnakým súčinom.

Zo zadania vieme, že $A, B$ sú vždy naľavo od $C, D$. Náš algoritmus teda prejde všetky dvojice čísel naľavo od $C$ a porovná ich súčin s $x_C \\cdot x_D$. Keď prejde všetky, tak si posunie $D$ doprava a začne počítať od začiatku. Keď program doráta všetky $D$, tak si posunie $C$, nastaví nové $D$ na $C+1$ a znova prezerá dvojice $A, B$ a posúva $D$, kým skontroluje všetky.

Pozrime sa na výpočet pre konkrétne $C$. Všimnime si, že pre každé $D$ hľadáme jemu príslušné $A, B$ medzi tými istými číslami. Nám však stačí, ak si na začiatku raz **predrátame počet výskytov súčinov $x_A \\cdot x_B$**. Potom už pre jednotlivé $D$ vieme rýchlo zistiť, koľko dvojíc $A, B$ má súčin $x_C \\cdot x_D$.

Takto si pre každé $C$ najprv spočítame počty dvojíc $A, B$ s rôznymi súčinmi, uložíme si počty do nejakej dátovej štruktúry a potom stačí posúvať $D$ a rýchlo vyberať z dátovej štruktúry počty dvojíc s daným súčinom $x_C \\cdot x_D$. Ak by sme odhadli čas vkladania/výberu z dátovej štruktúry ako $O(t)$, mohli by sme odhadnúť čas potrebný pre tento algoritmus ako $O\\left(n \\cdot (tn^2 + tn)\\right) = O(tn^3)$.

Keď už sme zrýchlili výpočet pri posúvaní $D$, pozrime sa, čo vieme zlepšiť na posúvaní $C$. Tu si môžeme všimnúť, že po posunutí $C$ sú počty súčinov vľavo od neho skoro také isté, ako pri starom $C$. Všetko, čo sa stalo je, že sme pridali súčiny so starým $C$ -- možnosti, kde sa vybrané $B$ rovná starému $C$. Teda keď si posunieme $C$, tak nemusíme zahodiť všetky predpočítané súčiny, ale stačí k nim pridať tieto nové.

Pre každé $C$ si teda do dátovej štruktúry najprv pridáme súčiny dvojíc prvkov na pozíciách $A$ a starého $C$ a potom opäť posúvame $D$ a vyberáme záznamy o počtoch dvojíc s požadovaným súčinom, čo trvá $O(tn + tn)$. Čas tohto algoritmu vieme odhadnúť ako $O\\left(n \\cdot (tn + tn)\\right) = O(tn^2)$.

## Ako si pamätať počty dvojíc s rovnakými súčinmi?

Už len zostáva vymyslieť, ako si počet súčinov zapamätáme -- akú dátovú štruktúru použijeme. Najjednoduchšie by bolo ukladať si počty do poľa, kde index bude hodnota súčinu. Avšak súčiny môžu nadobúdať hodnoty až $10^{18}$, a pole s takouto veľkosťou sa nám do pamäte nezmestí. Čísel na vstupe je ale najviac $1,000$, čiže rôznych súčinov bude najviac $10^6$. Ak by sme použili pole, väčšina indexov by teda mala hodnotou $0$, a sem-tam by sa nám tam objavila iná hodnota.

Našťastie, problém, ako si zapamätať a rýchlo pracovať s rozumne malým počtom ($10^6$) veľkých záznamov, už niekto vyriešil. Použijeme dátovú štruktúru [map](http://www.cplusplus.com/reference/map/map/), ktorá nám dovolí ukladať si dvojice `<súčin, počet dvojíc indexov A, B s daným súčinom>` tak, ako budeme potrebovať, ale nebude si zbytočne ukladať hodnoty, ktoré nepotrebujeme.

## Zložitosť

Podľa toho, či si zvolíme implementáciu mapy ako binárneho vyhľadávacieho stromu (`map`) alebo ako hashovacej tabuľky (`unordered_map`) dostaneme časovú zložitosť vkladania/upravovania/čítania $t = O(\\log n)$ alebo $t=O(1)$, teda celkovo $O(n^2 \\log n)$ alebo $O(n^2)$, keď použijeme predošlé odhady.

Pre pamäť si zoberieme najhorší prípad. Ak sú súčiny čísel na vstupe rôzne, tak si musíme do mapy uložiť $n(n-1)$ čísel. Pamäťová zložitosť bude teda $O(n^2)$
",8
ed7d4f3895d68000,ksp,"# Och, koho len mám zabiť?

Keď George R. R. Martin^[Toto je len umelecké meno nášho obľúbeného Georga, vševedca, všeumelca a dobrodruha.] začal písať svoju ságu A Song of Ice and Fire^[Z ktorej k dnešnému dátumu vyšlo už 5 kníh a bol k nej natočený úspešný seriál Game of Thrones.], túto otázku si kládol veľmi často. Veľmi rýchlo však dospel k presvedčeniu, že aj tak všetci musia zomrieť^[Valar morghulis.] a jeho knihy sa stali krvavým festivalom. Ako skúsený autor však vie, že je dôležité, v akom poradí jednotlivé postavy zomrú.

Má Bran zomrieť skôr ako Arya? A čo s Theonom, poprípade Petyrom Baelishom? Prežije Daenerys svojich drakov, alebo ju Drogon spáli svojim plameňom a potom zomrie v boji proti Jaimimu Lannisterovi? Všetky tieto otázky si musel George položiť a rozmýšľať, ktorá odpoveď je najlepšia. Postupne sa dopracoval k jednej možnej permutácii úmrtí, ktorá sa mu zdala ako veľmi dobrá.

Stále si však nebol istý (predsa len, všetkých možných permutácií je faktoriál veľa) a preto skúšal túto permutáciu zmeniť. Postupne vyskúšal všetky jej cyklické rotácie a porovnával ich medzi sebou. K najlepšiemu zisteniu však prišiel, keď lexikograficky zoradil všetky tieto cyklické rotácie jednu pod druhú a pozrel sa na čísla v poslednom stĺpci. Zdalo sa mu, že toto poradie úmrtí bude najlepšie možné.

Skôr ako si ho však zapísal, do izby vnikol prievan a odfúkol mu všetky papieriky s permutáciami. Zúfalý George si ale pamätá niekoľko prvých čísel jeho vysnívanej permutácie a to, že táto permutácia bola lexikograficky najmenšia možná s takýmto začiatkom. Pomôžte mu zistiť, ako vyzerá jeho zvolená permutácia, lebo zabije vaše obľúbené postavy ako prvé^[Samozrejme, zomrú aj tak, ale môžete im zabezpečiť trošku dlhší život, poprípade menej drastickú smrť.].

## Úloha

Najskôr si opäť zopakujme ako vznikla Georgova žiadaná permutácia. Na začiatku má permutáciu $P$ zloženú z $n$ prvkov -- čísel od $1$ po $n$. Postupne si zoberie všetky cyklické rotácie tejto permutácie. Cyklickú rotáciu permutácie dostanete tak, že odstránite niekoľko prvých členov $P$ a v takom istom poradí ich pridáte na koniec zvyšku tejto permutácie. Dostaneme teda $n$ cyklických permutácií, lebo aj pôvodná permutácia patrí medzi jej cyklické permutácie.

Tieto permutácie teraz lexikograficky usporiadame a v tomto poradí zoradíme pod seba. Permutácia je lexikograficky menšia ako iná permutácia, ak má na prvej pozícii zľava, kde sa tieto permutácie líšia, menšie číslo. Dostaneme tabuľku $n\\times n$. Teraz si zoberme posledný stĺpec tejto tabuľky a dostaneme Georgovu vysnívanú permutáciu. Sami si rozmyslite, že táto postupnosť je naozaj permutácia.

Ukážme si tento postup na príklade. Majme permutácia $P = (2, 4, 5, 1, 3)$.

```
cyklické rotácie       lexikograficky zoradené

2 4 5 1 3              1 3 2 4 5
4 5 1 3 2              2 4 5 1 3
5 1 3 2 4     ---->    3 2 4 5 1
1 3 2 4 5              4 5 1 3 2
3 2 4 5 1              5 1 3 2 4
```

Výsledná permutácia je $R = (5, 3, 1, 2, 4)$.

A teraz prichádza vaša úloha. Poznáte niekoľko začiatočných prvkov permutácie $R$, ktorá vznikla z nejakej permutácie $P$ vyššie spomínaným postupom. Naviac viete, že $R$ je lexikograficky najmenšia permutácia, ktorá mohla vzniknúť takýmto spôsobom a má daný začiatok. Zistite, ako vyzerá permutácia $R$.

## Formát vstupu

V prvom riadku je číslo $n$ udávajúce počet prvkov hľadanej permutácie. V druhom riadku je číslo $m$ -- počet začiatočných prvkov permutácie $R$, ktoré poznáte.

Tretí riadok obsahuje $m$ čísel, ktoré určujú prvých $m$ prvkov permutácie $R$.

## Formát výstupu

Vypíšte $n$ čísel, každé na samostatný riadok. Tieto čísla majú tvoriť permutáciu $R$, ktorá je lexikograficky najmenšia možná vzhľadom na podmienky vzniku a začiatočné prvky. V prípade, že takáto permutácia neexistuje, vypíšte reťazec *Chybny vstup*.

## Hodnotenie

Vo všetkých vstupoch bude platiť, že $n\\leq 10^5$ a $m \\leq \\min(n,10^5)$. Naviac môžete predpokladať, že v prvých dvoch testovacích sadách platí $n\\leq 10$ a v ďalších dvoch sadách platí, že $n \\leq 100$ a $m \\leq 50$.

## Príklady

```vstup
5
2
2 4
```

```vystup
2
4
1
5
3
```

```vstup
5
1
1
```

```vystup
Chybny vstup
```

```vstup
10
3
3 8 6
```

```vystup
3
8
6
1
2
5
4
9
10
7
```
","# Och, koho len mám zabiť?

Začnime tým, že si zopakujeme zadanie úlohy, keďže je mierne komplikované. Na začiatku sme mali permutáciu $n$ čísel, ktorú si označíme $P$. Zobrali sme všetky cyklické rotácie tejto permutácie a lexikograficky sme ich usporiadali. Z každej permutácie sme postupne zobrali posledné číslo (v takom poradí ako boli usporiadané), čím sme dostali permutáciu $R$. Nanešťastie, zachovalo sa nám iba niekoľko začiatočných čísel permutácie $R$, ale vieme, že zo všetkých vhodných permutácii, bola $R$ lexikograficky najmenšia. No a úlohou je nájsť permutáciu $R$.

A tu sa nachádza chyták tejto úlohy. Aj keď budeme hľadať permutáciu $R$, oveľa dôležitejšia bude pre nás permutácia $P$, hlavne fakt, že je to permutácia. Ak sme spravili cyklické permutácie $P$ a lexikograficky ich zoradili, dostali sme tabuľku $n\\times n$. Permutácia $R$ nám tvorí posledný stĺpec tejto tabuľky. Ale my poznáme aj prvý stĺpec. Musia to byť predsa čísla od $1$ po $n$ zoradené za sebou^[Ak robíme cyklické rotácie nejakej permutácie, pre každé možné číslo od $1$ po $n$ nám vznikne permutácia s týmto začiatkom. No a lexikografické usporiadanie potom musí triediť podľa týchto rôznych začiatkov.].

A čo nám určuje prvý a posledný stĺpec tejto tabuľky? Hovorí to o vzájomnom vzťahu za sebou idúcich čísel v permutácii $P$. Ak máme v nejakom riadku na začiatku číslo $x$ a na konci číslo $y$, znamená to, že v permutácii $P$ sa číslo $x$ nachádza hneď za číslom $y$. Permutáciu $P$ teda môžeme zapísať ako graf, kde vrcholy predstavujú čísla od $1$ po $n$ a šípka z vrcholu $x$ do vrcholu $y$ bude znamenať, že číslo $x$ sa v permutácii $P$ nachádza hneď za číslom $y$ (pričom prvé číslo permutácie $P$ sa nachádza hneď za posledným číslom $P$). Takto dostaneme jeden cyklus dĺžky $n$.

Toto je jediná podmienka, ktorú sa budeme snažiť dodržať. Pri vytváraní $R$ budeme postupne zisťovať závislosti, ktoré platia v $P$ a hrany zodpovedajúce týmto závislostiam budeme pridávať do našeho grafu. Budeme sa pritom snažiť, aby sme na konci naozaj dostali jeden veľký cyklus. Hocičo iné by znamenalo, že naše $R$ nevzniklo z **permutácie**.

Pre jednoduchosť vzoráku budeme predpokladať, že sa nezachovalo žiadne z čísel $R$, čiže $m=0$. V opačnom prípade sa zmení akurát to, že niektoré závislosti budú určené vopred a môže sa nám stať, že dáta nebudú konzistentné a povedú k sporu, ktorý spôsobí, že riešenie nebude existovať. V ďalšej časti si však aj tak povieme, čo tento spor je a preto táto časť programu je takmer totožná tej druhej.

Uvedomme si, ako vyzerá náš graf, ktorý reprezentuje permutáciu $P$, ak sme ešte nepridali všetky závislosti. V tomto grafe môže z každého vrcholu vychádzať najviac jedna hrana a naviac tu nemôže byť žiaden cyklus. Cyklus totiž môže vzniknúť až na úplnom konci. Ľubovoľný menší cyklus by znamenal, že už nikdy sa nám neporadí spraviť jeden veľký cyklus dĺžky $n$. Tento graf teda musí byť tvorený niekoľkými cestami.

Naviac, vnútorné vrcholy týchto ciest nás už nezaujímajú, lebo vieme, ktorý vrchol je pred nimi aj za nimi a viac hrán do nich ísť nemôže. Jediné zaujímavé sú teda vrcholy na začiatku a konci cesty. Počas našeho algoritmu si teda musíme udržiavať tieto začiatky a konce. Jedna rozumná reprezentácia je nasledovná: pre každý koncový vrchol nejakej cesty si budem pamätať začiatok tejto cesty (toto budeme mať v poli $K$) a pre každý začiatočný vrchol si pamätám koniec tejto cesty (pole $Z$).

Predstavme si, že už sme určili (alebo boli určené) prvých $i-1$ čísiel permutácie $R$ a máme vytvorený graf obsahujúce príslušené zistené závislosti. Pozeráme sa preto na $i$-ty riadok našej $n\\times n$ tabuľky. Na jej začiatku je číslo $i$ a chystáme sa určiť, aké najmenšie číslo $x$ môžeme dať na jej koniec. V našom grafe to vytvorí hranu z vrchola $i$ (ktorý je začiatok nejakej cesty) do vrchola $x$ (ktorý musí byť koniec nejakej cesty^[Rozmyslite si, prečo to platí, nie je to ťažké.]). Vieme teda, že číslo $x$ musí zodpovedať vrcholu na konci nejakej cesty a kedže $R$ sa snažíme spraviť lexikograficky najmenšie, vyberieme najmenšie možné $x$.

Toto má ale jeden prípad, keď to nemôžeme spraviť. A to práve vtedy, ak je $x$ na konci cesty, kde je $i$ na začiatku. Pridaním takejto závislosti by sme totiž vytvorili nechcený cyklus. V takom prípade ale môžeme zobrať druhé najmenšie $x$, keďže na konci cesty začínajúcej s $i$ je len jedno číslo. Toto je zároveň prípad, ktorý môže spôsobiť nekonzistenciu vstupných dát.

Posledné čo zostáva je, ako rýchlo nájsť najmenšie (poprípade druhé najmenšie) číslo z koncových vrcholov. Hneď by vás malo napadnúť, že môžeme použiť dátovú štruktúru *halda*, kde vieme skladovať tieto čísla a rýchlo vybrať najmenšie z nich (a na vybratie druhého najmenšieho proste vyberieme dve najmenšie čísla a to prvé vrátime).

Následne už len správne upravíme polia $Z$ a $K$. Začiatok tejto novej cesty bude vrchol $Z[x]$ a koniec bude $K[i]$. Správne úpravy budú teda $K\[Z[x]\]=K[i]$ a $Z\[K[i]\]=Z[x]$.

Zostáva nám už len odhadnúť pamäťovú a časovú zložitosť. Pamäte nám stačí $O(n)$, lebo si pamätáme len niekoľko lineárnych polí. Pri časovej musíme zarátať logaritmický faktor haldy, použijeme ju však lineárne veľa krát a preto bude časová zložitosť $O(n\\log n)$.
",9
7ef142dbc91dec7c,ksp,"# Ešte nás vidíš?

V izbe si spokojne žije na kope $n$ rôzne zafarbených ploštíc. Avšak, ich spokojné nažívanie prerušil príchod skupiny ""Kynožíme Spolu Ploštice"", ktorá sa im nabúrala do ich domova a snaží sa ich zbaviť. Preto sa ploštice chcú skryť a byť nenápadné, v nádeji, že ich skupina nenájde.

Momentálne sú ploštice v jednom dlhom rade. Ploštice sú presvedčené, že čím viac homogénnejšie vyzerajú, tým skôr si ich nevšimnú. Preto by sa v rade chceli preorganizovať tak, že čo najmenej párov susediacich ploštíc má inú farbu.

Problém je, že ploštice a) nemajú čas na veľa presúvania a b) myslia _centralizovane_ -- centrálny mozog ploštíc vymyslí ako by sa mali pohybovať. Konkrétne, ploštice sa popresúvajú len v blokoch $k$ ploštíc, a každý takýto blok $k$ ploštíc sa presúva podľa rovnakého pravidla. Ako najlepšie sa vedia popresúvať?

## Úloha

V izbe je vo veľkom rade usporiadaných $n$ ploštíc. Ploštice majú $26$ rôznych farieb (reprezentované písmenami `a` až `z`). Centrálny mozog ploštíc ich preusporiada nasledovne: najskôr si vyberie permutáciu $k$ prvkov (teda nejaké preusporiadanie $k$ pozícii), a nasledne podľa nej presporiadajú ploštice na poziciách $1$ až $k$, rovnako $k + 1$ až $2k$, a tak ďalej až po skupinu ploštíc na pozíciách $n-k+1$ po $n$ (môžete predpokladať že $n$ je deliteľné $k$). Permutácia je vybraná, aby minimalizovala počet susediacich dvojíc ploštíc s rôznymi farbami.

Koľko najmenej takýchto dvojíc vie centrálny mozog ploštíc dosiahnuť?

## Formát vstupu

Na prvom riadku vstupu je číslo $k\\geq 2$ - veľkosť permutovaných skupín ploštíc.

Na druhom riadku vstupu je reťazec zložený z písmen `a`-`z` reprezentujúci farby ploštíc v rade. Je garantované, že dĺžka reťazca je deliteľná $k$.

## Formát výstupu

Vypíšte jediné číslo: najmenší počet susediacich dvojíc, ktoré vie centrálny mozog ploštíc dosiahnuť.

## Hodnotenie

Existujú 4 sady vstupov. Vo všetkých z nich platí, že $k\\leq 16$ a počet ploštíc nepresiahne $5000$. V polovici vstupov navyše platí, že $k\\leq 5$ a počet ploštíc nepresiahne $1000$.

## Príklad

```vstup
4
abcabcabcabc
```

```vystup
6
```

_V tomto prípade sú skupiný ploštíc `abca`, `bcab` a `cabc`. Jedna z optimálnych permutácii je napríklad P = (2, 1, 4, 3), teda rad sa zmení z `(abca)(bcab)(cabc)` (zátvorky sú len na vizualizáciu ktoré ploštice sú spolu v skupine) na `(baac)(cbba)(accb)` -- môžeme vidieť že je $6$ susediacich dvojíc rôznej farby_

```vstup
3
abcabcabcabc
```

```vystup
11
```

_Toto je rovnaký rad ploštíc ako v predchádzajúcom príklade, ale s $k=3$. Teraz ich nevie centrálny mozog ploštíc preorganizovať do lepšieho rozostavenia._
","# Ešte nás vidíš?

Táto osmička výnimočne je vlastne len o hrubeh sile. A ako ju robiť šikovne. Tak poďme na to.

## Skúšame všetky permutácie

Prvé riešenie, ktoré vieme skúsiť je skúšanie všetkých možností. Čo sú v tomto prípade všetky možnosti? Permutácie $k$-tic. Pre každú $k$-ticu si vieme zistiť počet rôznofarebných susediacich dvojíc v linárnom čase. Teda vieme všetky možnosti poskúšať v čase $O(n k!)$ a pamäti $O(n+k)$, čo nám stačí na štyri body.

## Hľadáme cestu

Na vyriešenie úlohy si úlohu preformulujeme ako úlohu na hľadanie najkratšie hamiltonovského cyklu^[cyklu ktorý obsahuje všetky vrcholy] vo vhodnom grafe.

Prvé pozorovanie je, že si počet odlišných susedov napísať ako súčet hodnôt pre ze sebou idúce pozície, teda ako súčet

- počtu úsekov kde má prvá a druhá ploštica rôznu farbu
- počtu úsekov kde má druhá a tretia ploštica rôznu farbu
- ...
- počtu úsekov kde má predposledná a posledná ploštica rôznu farbu
- počtu úsekov kde má posledná ploštica rôznu farbu od prvej ploštice nasledovného úseku

Druhé pozorovanie, že ak sú pozície $i$ a $j$ spermutované vedľa seba, nezáležiac na tom, na ktorom mieste sa relatívne v $k$-tici nachádzajú. Túto hodnotu, si vieme spočítať, pre každú dvojicu jednoduchým prechodom cez všetky $k$-tice, a spočítaním v koľkých z nich majú pôvodne $i$-ta a $j$-ta ploštica rôznu farbu.

Rovnako vieme, pre každý pár pozícií $i, j$, spočítať pre koľko $k$-tic je $i$-tá ploštica inej farby ako $j$-ta ploštica v nasledovnej k-tici.

Takto vlastne dostaneme *kompletný ováhovaný graf* -- vrcholy sú pozície, a hrana medzi vrcholny $i$, $j$ má váhu ""počet úsekov kde majú $i$-ta a $j$-ta ploštica rôznu farbu"".

Permutácia zodpovedá nejakej *hamiltonovskej ceste*^\[ceste obsahuj[cej v3etky vrcholy] v tomto grafe, a hodnotu permutácie (výsledný počet rôznofarebných párov) vieme spočítať ako súčet váh použitých hrán a rôznofarebných dvojíc ktoré dostaneme použitím začiatku a konca cesty.

Takto vieme získať riešenie použítim algoritmu na hľadanie najkratšej hamiltonovskej cesty, raz pre každý možný začiatok, teda $k$-krát.

Vedeli by sme to ešte zrýchliť? Áno -- vieme úlohu vyriešiť len s pomocou jediného vyhľadania hamiltonovskej kružnice (tú vieme nájsť v rovnakom čase ako cestu). A to tak, že si do grafu pridáme špeciálne orientované hrany -- hrana z $i$ do $j$ indikujúca koľko rôznofarebných dvojíc na ""rozmedzí $k$-tic"" dostaneme ak $i$-ta pozícia bola na konci permutácie a $j$-ta na začiatku. Následne musíme implementovať len podmienku, že takúto hranu nevieme použiť dvakrát.

### Ako na hamiltonovskú kružnicu

Ostáva už len nájsť dostatočne rýchly algoritmus na hľadanie najkratšieho cyklu obsajúceho všetky vrcholy (tak že špeciálne hrany nebudú použité viackrát).

Potrebujeme niečo rýchlejšie ako $k!$. Síce nie polynomiálna^[polynomiálny algorithmus zrejme neexistuje], ale zložitosť $O(k^2 2^k)$ bude postačovať.

S technika ktorú použijeme sa môžte stretnúť pod menom *bitmasková dynamika*. Ide o dynamické programovanie, v ktorom sú stavy

- v ktorom vrchole sa nachádzame
- ktoré vrcholy sme už videli (reprezentované ako číslo s tým binárnym zápisom)
- použili sme už špeciálnu hranu?

Všimnite si, že týchto stavov je $2n\\cdot 2^n$, a v každom stave sa jednoducho vieme pozrieť na každý vrchol kde sme ešte neboli (normálnou aj špeciálnou hranou ak sme ju ešte nepoužili). Na zistenie finálnej hodnoty, vždy začíname dynamiku iba z jedného konkrétneho vrcholu (permutácia ho nemusí nutne dať na prvú pozíciu), a potom ku každému možnému koncu pripočítať váhu hrany do poťiatočného vrchola (používajúc špeciálnu hranu, ak v ceste nebola použitá).

Takto vieme v našom kompletnom grafe nájsť najkratšiu hamiltonovskú kružnicu s presne jednou použitou špeciálnou hranou v čase $O(k^2 2^k)$.

Graf vieme vybudovať v čase $O(k^2 (n / k)) = O(nk)$, a teda celková časová zložitosť algoritmu je $O(nk + k^2 2^k)$. Pamätať si potrebujeme vstup, graf a hodnoty dynamiky, teda je pamäťová zložitosť $O(n + k\\cdot 2^k)$.
",10
db9791b9798866dd,ksp,"# Optimalizácia písania na klávesnici

Samko sa nedávno zamestnal ako programátor pre jeden veľký wébový portál. Už počas prvého týždňa zistil, že to nebude jednoduchá práca. Má totiž na starosti opravovanie starého zdrojového kódu s množstvom chýb. Jeho bežný pracovný deň vyzerá tak, že zapne počítač, otvorí si mail a nájde desiatky škaredých správ od frustrovaných užívateľov. Tí sa väčšinou oprávnene sťažujú na množstvo bugov, ktoré sa na stránke nachádzajú. Samko samozrejme musí všetky takéto prípady preveriť, bugy nájsť a opraviť. Preto sa pomocou `ssh` na diaľku pripojí k príkazovému riadku (terminálu) servera a prehľadávaním logov a zdrojového kódu zisťuje, kde nastala chyba.

Keďže práce je veľa, Samko sa snaží využívať svoj čas efektívne. Napríklad sa naučil bezchybne písať všetkými desiatimi prstami. Teraz však objavil novú funkciu jeho terminálu -- slovník často používaných slov (príkazov). Keď do terminálu napíše začiatok nejakého slova zo slovníku a stlačí `TAB`, tak sa mu tam toto slovo celé dopíše. Ak sa viac slov v slovníku začína rozpísaným slovom, tak sa dopíše lexikograficky najmenšie z nich. Ak žiadne slovo v slovníku nezačína rozpísaným slovom, tak v tom prípade kláves `TAB` nespraví nič. Samko po dlhej úvahe dospel k tomu, že táto funkcia mu vie ušetriť veľa zbytočných stlačení klávesnice. Napríklad ak má v slovníku lexikograficky najmenšie slovo `auto` a chce napísať slovo `aut`, tak to môže spraviť tak, že stlačí `TAB` a `Backspace` (kláves na zmazanie posledného znaku). Nemiesto troch stlačení tak spraví iba dve.

Samka by zaujímalo, koľko času mu táto funkcia vie ušetriť. Preto by si chcel spraviť štatistiku o tom, koľko stlačení potrebuje na napísanie určitých slov. Keďže má však ešte veľa roboty s hľadaním bugov, potreboval by, aby mu s tým niekto pomohol. Zvládnete to?

## Úloha

Na vstupe je terminálový slovník často používaných slov a zoznam slov, ktoré Samka zaujímajú. Pre každé slovo zo Samkovho zoznamu vypíšte, koľko stlačení klávesnice je potrebných na jeho napísanie. Samkov terminál nepodporuje používanie šípok a iných kláves na presúvanie kurzora. Jediné klávesy, ktoré Samko používa sú písmená, `TAB` a `Backspace` (na zmazanie posledného znaku).

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú čísla $n$ a $q$, -- prvé určuje počet slov v slovníku $(1 \\leq n \\leq 1,000,000)$ a druhé počet slov v Samkovom zozname $(1 \\leq q \\leq 1,000,000)$. V každom z nasledujúcich $n$ riadkoch je jedno slovo zo slovníka. Na ďalších $q$ riadkoch sa nachádzajú postupne slová v Samkovom zozname. Všetky slová na vstupe sa skladajú z malých písmen anglickej abecedy a majú menej ako $60,000$ písmen. Celkový počet písmen na vstupe nepresiahne $2,150,000$.

## Formát výstupu

Pre každé z $q$ slov v Samkovom zozname vypíšte jeden riadok -- najmenší možný počet stlačení kláves na napísanie daného slova.

## Príklad

```vstup
3 7
autobus
auto
autostrada
auto
aut
a
autobusar
autobus
autob
utobus
```

```vystup
1
2
1
5
3
2
6
```

*Všimnite si, že slovo `auto` je v slovníku lexikograficky najmenšie. Preto na jeho napísanie stačí jedno stlačenie `TAB`.*

*Slovo `autobusar` vieme napísať nasledujúcov postupnosťou kláves: `TAB`, `b`, `TAB`, `a`, `r`.*

*Slovo `utobus` musíme napísať celé znak po znaku.*
","# Optimalizácia písania na klávesnici

Pred tým než sa pustíme do vzoráku si ujasnime niekoľko pojmov:

- Reťazec (angl. *string*) je postupnosť znakov. Môže to byť slovo, jeho časť ale aj celá veta.

- Prefix je začiatočný úsek reťazca. Formálnejšie, reťazec $a$ nazveme prefixom reťazca $b$, ak za $a$ vieme dopísať niekoľko (možno aj nula) znakov tak, aby sme dostali reťazec $b$. Napríklad reťazec `auto` má päť prefixov -- `""""` (prázdny reťazec), `a`, `au`, `aut` a `auto`.

Pri písaní zadaného slova nás zaujíma iba to, čo máme aktuálne napísané. Tento reťazec reprezentuje nejaký stav, v ktorom sa nachádzame. Stlačením klávesy sa náš reťazec zmení a my sa presunieme do iného stavu. Napríklad ak sú v slovníku slová `autobus` a `autostrada`, tak ak sa nachádzame v stave `au`, môžeme sa jedným stlačením presunúť do nasledovných stavov:

- `aut`, tým, že stlačíme `t` (za `t` si môžeme dosadiť ľubovoľné písmeno, stlačením `l` by sme sa dostali do stavu `aul` a podobne)
- ` autobus`, tým že stlačíme `TAB`, automaticky sa nám doplní lexikograficky najmenšie slovo zo slovníka, ktoré začína na `au`
- `a`, tým že stlačíme `Backspace` zmažeme posledný znak

V okamihu ako nám v úlohe vystupujú stavy, medzi ktorými sa presúvame, môžeme sa na ne pozrieť ako na graf. Stavy reprezentujú jednotlivé vrcholy a presun zo stavu do stavu orientovanú hranu. To zásadne zmení aj úlohu, ktorú riešime. V pôvodnom zadaní sme chceli vedieť, ako čo najrýchlejšie dostať z prázdneho reťazca reťazec výsledný. Prázdnemu aj výslednému reťazcu však teraz zodpovedajú nejaké vrcholy a nás zaujíma najkratšia cesta medzi nimi.

Na obrázku môžeme vidieť, ako by vyzerala časť grafu so slovom `auto`. Skutočný graf je totiž nekonečný a obsahuje všetky možné reťazce. Všimnite si, že čierne šipky sú obojsmerné. To značí možnosť dopísania písmena na koniec a jeho vymazania stlačením `Backspace`. Tiež si všimnite zelené šípky, ktoré predstavujú stláčanie klávesy `TAB`.

Povedali sme si, že písanie slova je ekvivalentné hľadaniu najkratšej cesty medzi zadanými vrcholmi. Takže môžeme využiť dobre známy algoritmus prehľadávania do šírky (BFS). Problémom ale je, že náš graf je nekonečný, keďže na klávesnici vieme napísať čokoľvek. Pokúsme sa teda zmenšiť počet stavov, ktorými sa musíme zaoberať.

Kľúčovým pozorovaním je, že si nepotrebujeme pamätať stavy, ktoré nie sú prefixom žiadného slova v slovníku.

Prečo je tomu tak? Keby sme na písanie mohli používať iba písmená, úloha by bola jednoduchá, lebo cestu by sme si nevedeli nijak skracovať a museli by sme proste napísať zadané slovo písmeno po písmene. Nám však pribudli aj klávesy `TAB` a `Backspace`. A klávesa `TAB` dopĺňa slová zo slovníku, ktoré majú rovnaký prefix ako reťazec, ktorý sme doposiaľ napísali. Ak sme teda v stave, ktorý nie je prefixom žiadneho slova v slovníku, klávesa `TAB` nič nerobí.

Klávesa `Backspace` má tiež len obmedzené využitie. Uvedomme si, že v optimálnom riešením nikdy nepoužijeme `Backspace` tesne po tom, čo napíšeme nejaké písmeno. Keby sme to totiž spravili, reťazec by sa vlastne nezmenil a my by sme tieto dve stlačenia mohli radšej vynechať. `Backspace` teda môžeme stlačiť iba po nejakom `TAB` alebo `Backspace`. To znamená, že vymazávanie znakov využijeme iba v prípade, že stlačíme `TAB`, doplnené slovo však bude pridlhé a niekoľko posledných znakov budeme chcieť vymazať. Pri tom všetkom sme sa však neustále pohybovali po reťazcoch, ktoré sú prefixami slov v slovníku.

Z vyššie uvedených pozorovaní tiež vyplýva, že v okamihu ako sa rozhodneme opustiť prefixy slov v slovníku, tak klávesy `TAB` a `Backspace` už nemá zmysel použiť a nám ostáva zvyšný text dopísať písmeno po písmene.

Keď si teda predstavíme ako funguje naše riešenie, ak chceme napísať slovo $s$, tak najskôr sa budeme pohybovať po prefixoch slova $s$, ktoré sú zároveň prefixami niektorých slov v slovníku a keď tieto prefixy opustíme, zvyšok slova $s$ jednoducho dopíšeme.

Na obrázku vidíme, ako vyzerá graf všetkých prefixov slov zo slovníka `auto`, `autobus` a `autostrada`.

Skúsený riešiteľ si isto všimne, že graf ktorý nám ostane pripomína písmenkový strom (po anglicky aj *trie*). Písmenkový strom je dátová štruktúra, v ktorej si pamätáme informácie o slovách v slovníku a ich prefixoch. Každý vrchol reprezentuje konkrétny prefix slova v nej -- presne ako v grafe ktorý vytvárame. Z každého vrcholu vedie najviac 26 hrán do synov -- vrcholov, ktoré reprezentujú stavy do ktorých sa dostaneme pridaním jedného písmenka na koniec reťazca. My si však do tohto písmenkového stromu ešte musíme pridať hrany, ktoré reprezentujú stláčanie kláves `TAB` a `Backspace`.

Písmenkový strom sa tradične konštruuje tak, že začíname s prázdnym stromom, do ktorého postupne pridávame slová. Slovo pridávame po písmenách začnúc v koreni. Postupne sa snažíme posúvať po hranách, ktoré reprezentujú jednotlivé písmená slova. V okamihu, keď sa chceme posunúť po hrane, ktorá ešte z aktuálneho vrcholu nevedie, vytvoríme nový vrchol a do neho vedúcu hranu. Pri vytváraní vrcholu môžeme veľmi jednoducho spraviť hranu aj pre `Backspace` -- stačí si zapamätať otca vrcholu.

Hrany pre autocomplete sú najzložitejšie, vieme ich však vygenerovať rekurzívne. Ak vrchol reprezentuje slovo v slovníku tak jeho autocomplete vedie do neho samého. Ak nie, tak pre každého syna najprv rekurzívne zistíme jeho autocomplete a potom vyberieme autocomplete zo syna, do ktorého vedie hrana s lexikograficky najmenším písmenom v abecede.

Po skompletizovaní grafu na ňom spustíme prehľadávanie do šírky, ktoré nám pre každý vrchol vypočíta, ako najrýchlejšie sa do neho vieme dostať zo začiatku, ktorý reprezentuje prázdny reťazec, a tieto hodnoty si zapamätáme.

Ostáva nám už len odpovedať na otázku, ako najrýchlejšie vieme napísať slovo $s$. Na to nájdeme najdlhší prefix tohto slova, ktorý sa nachádza aj v našom písmenkovom strome. Z predpočítanej informácie vieme, ako najrýchlejšie napísať tento prefix a keďže je to prefix najdlhší, zvyšok už aj tak musíme napísať písmeno po písmene.

Časová zložitosť konštruovania je lineárna od súčtu dĺžok slov v slovníku. BFS tiež spravíme v lineárnom čase od počtu vrcholov v strome. A nájsť najdlhší prefix tiež zvládneme v čase lineárnom od dĺžky hľadaného slova. Celková časová zložitosť je teda lineárna od dĺžky vstupu. Pamäťová zložitosť je lineárna od počtu vrcholov v písmenkovom strome. Naviac, táto zložitosť je určite optimálna, keďže rovnako veľa času nám zaberie načítanie celého vstupu.
",8
29d1b075bd170343,ksp,"# Zajace a mrkva

Keďže je svetová pandémia a všetky obchody sú zatvorené, Emma sa rozhodla, že si bude pestovať potraviny sama. Na začiatok sa rozhodla pre sadenie mrkvy. Ako dni plynuli, mrkva rástla. Avšak, keďže Emma bývala v malej dedine obklopenej lúkami, postupne jej na záhradu začali chodiť kradnúť mrkvu miestne zajace. Bezradná Emma sa rozhodla, že musí tento problém čím skôr vyriešiť a začala zajace sledovať. Tie však boli prefíkané a vyčkávali skryté za plotom pokiaľ sa nebudú môcť bezpečne dostať na záhradu. Jediné, čo bolo spoza plota vidieť, boli ich vytŕčajúce uši. Pozorná Emma si však tento detail všimla a po čase zistila, že čakajúce zajace sú vždy rovnako veľké a teda majú aj rovnakú vzdialenosť medzi ušami. S týmto poznatkom už vedela jednoducho zistiť na koľko zajacov striehnucich za plotom si musí dať pozor. Odvtedy bolo krádežiam mrkvy koniec.

Vedeli by ste vypočítať, koľko zajacov Emma práve vidí?

## Úloha

Pozorujeme zajace. Predpokladáme, že všetky zajace sú rovnako veľké, presnejšie, že majú rovnakú vzdialenosť medzi ušami. Avšak keďže sú plaché, skrývajú sa pred nami a to tak, že vidíme len ich uši `U`. Chceli by sme zistiť, koľko zajacov vidíme, prípadne či je naše pozorovanie chybné a v skutočnosti sa nejedná o zajace. Vašou úlohou je zistiť, na koľkých zajacov sa pozeráme.

## Formát vstupu

Vstup je tvorený 1 riadkom, na ktorom sa nachádza $n$ znakov `U` alebo `.`.

## Formát výstupu

Na výstup vypíšte jedno číslo, a to počet sledovaných zajacov. V prípade zlého pozorovania vypíšte hodnotu $-1$.

## Hodnotenie

Sú 4 sady vstupov, v ktorých platia tieto obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :-------------- | ----: | -------: | ---------: | ------------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $100,000$ | $1,000,000$ |

## Príklad

```vstup
..U..U.U..U
```

```vystup
2
```

V tomto prípade vidíme $2$ zajace, ktoré majú zhodnú vzdialenosť medzi ušami rovnú $2$.

```vstup
..UUU.U
```

```vystup
-1
```

V danom prípade je pozorovanie chybné, nemôže sa jednať o zajace, a teda bude výstup $-1$.
","# Zajace a mrkva {bodypopis=12 bodyprogram=8 vzorak=""Julka"" mail=""julia.krizanova@trojsten.sk""}

## Myšlienka riešenia

Aby sme zistili, koľko zajacov sa skrýva za plotom, musı́me najprv zistiť vzdialenosť medzi prvými dvoma ušami na vstupe. Keďže predpokladáme, že vzdialenosť medzi ušami je pre všetkych zajacov rovnaká, malo by platiť, že pre každého nasledujúceho zajaca, tj. pre každú nasledujúcu dvojicu ušı́ na vstupe bude táto vzdialenosť rovnaká. V prı́pade, že sa daná vzdialenosť lı́ši, nejedná sa o zajace, a teda na výstupe bude $-1$. Pokiaľ bude vzdialenosť pre každé $2$ uši rovnaká, vypı́šeme počet zajacov, pre ktorých sme túto vzdialenosť overovali.

## Časová a pamäťová zložitosť

Keďže sa stačı́ na celý vstup pozrieť iba jeden raz, časová zložitosť bude lineárne závislá od dĺžky vstupu – $O(n)$. Pamäťová zložitosť bude konštantná - $O(1)$, keďže stačı́ ak si budeme počet zajacov uchovávať v jednej premennej a postupne počas čı́tania vstupu túto hodnotu zvyšovať.
",1
79cdbb6337bfa11a,ksp,"# Odrezané dážďovky

Žaba sa jedného dňa rozhodol ísť na prechádzku. Keďže predošlý deň výdatne pršalo, všade bolo množstvo dážďoviek. Po chvíli však našiel také, aké ešte nikdy v živote nevidel. Tieto dážďovky boli neskutočne dlhé, každá mala pozdĺž svojho tela napísané dlhé číslo neobsahujúce nuly a navyše všetky žiarili farbami od výmyslu sveta (brilantne modré, perlovorubínovo červené, opálovo zelené, antukovo hnedé, burgundské fialové, a tak podobne).

Žaba sa rozhodol, že takýchto čudesných dážďoviek by malo byť na svete viac a preto ich začne rozmnožovať delením na menšie^[Nikto mu nepovedal, že u väčšiny druhov prežije len jediná časť, tá s opaskom.]. Zobral si ich za hrsť a hor' sa na vec! Po chvíli ho to však prestalo baviť. Povedal si, že ďalšiu dažďovku už nenareže len tak, hala-bala.

Dážďovku bude rezať len medzi ciframi a každý kus musí obsahovať aspoň jednu cifru. Keď chúďa dážďovku doreže, na každom kuse musí byť číslo aspoň také veľké, ako na každom kuse naľavo od neho.

Napríklad dážďovku s číslom 11131719 môže narezať na kusy 11, 13, 17, 19 alebo na kusy 1, 1, 1, 31, 719, alebo ju môže nechať celú pokope, ale nemôže ju narezať na 111, 31, 719 pretože 31 je menej ako 111.

S takýmito pravidlami už bol spokojný, zábavy s tým bude dosť. Potom si ale uvedomil, že zistiť, koľko najviac kusov vie dostať, ak bude rezať najlepším možným spôsobom, je celkom ťažké. Vedeli by ste mu s tým pomôcť?

## Úloha

Dostanete postupnosť cifier, ktorá neobsahuje nuly. Zistite, na koľko najviac čísel sa dá nasekať tak, aby každé číslo bolo aspoň také veľké, ako všetky naľavo od neho.

Formálnejšie povedané, pôvodnú postupnosť cifier $s$ máte rozdeliť na podreťazce $s_1, s_2, \\dots, s_n$, tak, aby sme zreťazením týchto podreťazcov dostali pôvodnú postupnosť, t.j., $s_1 s_2 \\dots s_n = s$. Zároveň musí vždy platiť, že $s_i \\leq s\_{i+1}$ (porovnávame číselnú hodnotu, čiže $111 > 47$). Máte zistiť, aké najväčšie môže byť číslo $n$ -- počet podreťazcov.

**Veľmi dôležitou súčasťou vášho popisu je zdôvodnenie správnosti vášho algoritmu. Dajte si na ňom záležať.**

## Formát vstupu

Na jedinom riadku vstupu máte postupnosť cifier, ktorej dĺžka neprekročí $1,000,000$.

## Formát výstupu

Na jediný riadok vypíšte jedno číslo, najväčší možný počet kusov, na ktorý je možné nasekať dážďovku.

## Príklad

```vstup
1234
```

```vystup
4
```

_Každý kus dostane po jednej cifre._

```vstup
4321
```

```vystup
2
```

_Nijako si nepomôžeme, jediná možnosť je sekať na 4 a 321._

```vstup
11131719
```

```vystup
6
```

\_Tu je najlepšie nasekať postupnosť na čísla 1, 1, 1, 3, 17, 19. \_
","# Odrezané dážďovky

Táto úloha bola dosť o premýšľaní a to bolo na nej super. Navyše, málokedy sa nám v KSP podarí taká pekná úloha s množstvom rôznych možných prístupov od nesprávnych riešení po správne riešenia so zložitosťami od $O(2^n)$ cez $O(n^3)$, $O(n^2)$, $O(n\\sqrt{n})$, **$O(n^{1.25})$**, $O(n \\log{n})$ až po $O(n)$. Premennou $n$ označujeme v celom vzorovom riešení dĺžku vstupu (dĺžku dážďovky). Všetky tieto riešenia so sebou nesú nejaké ponaučenie, tak vám odporúčame pozorne čítať. Text je možno trochu dlhší, pretože sa snažíme poriadne vysvetliť všetky detaily. Nemusíte ho celý čítať naraz.

Medzi nesprávne riešenia patrí množstvo pažravých prístupov, napríklad *idem od začiatku dážďovky a vždy useknem čo najkratší kus, aby som ich mal na konci čo najviac.* Protipríkladom je napríklad postupnosť 54638291 ktorú by sme pažravo nasekali 5,46,38291 a správne je 54,63,82,91. Pažravé riešenia v tejto úlohe nefungujú.

## Pomalé riešenie $O(n^2)$

Určite by ste všetci zvládli naprogramovať riešenie, ktoré rekurzívne skúša všetky možnosti. V tomto rekurzívnom riešení sa dookola pýtame takéto otázky: *Na koľko najviac kusov môžeme nasekať prvých $i$-cifier vstupu, ak posledný kus má $j$-cifier?* Pričom riešenie úlohy je maximum pre všetky možné $j$ a pre $i=n$. Odpoveď na takúto otázku si označíme `P[i][j]` a vieme ju ľahko spočítať z iných hodnôt $P$, pre iné $i$ a $j$. `P[i][j]` je maximum z `P[i-j][k]+1` pre všetky $k \\geq 1$ také, že posledný kus kratšej dážďovky je menší ako posledný kus dlhšej. Očividne môžeme použiť všetky $k\\le j$, pretože menejciferné číslo je istotne menšie ako viacciferné. A to, či môžeme uvažovať aj hodnotu `P[i-j][j]` zistíme porovnaním dvoch reťazcov dĺžky $j$.

Inak povedané, hodnotu `P[i][j]` vieme zistiť v čase $O(j)$^\[*oujé :D*\], na základe iných hodnôt P. A takto vieme spočítať všetky P pre všetky $1\\leq j\\leq i\\leq n$, čo je $O(n^2)$ možností. Naťukáme túto myšlienku do počítača a dostaneme riešenie so zložitosťou $O(n^3)$.

Ha! S minimálnou úpravou kódu vieme dostať riešenie so zložitosťou $O(n^2)$. Stačí uvažovať také sekania, kde dĺžka každého kusu dážďovky bude $O(\\sqrt{n})$, presnejšie $j\\leq \\sqrt{2n}+1$ (čoskoro si povieme, prečo to stačí) Potom zložitosť tohto riešenia je $O(n \\sqrt{n} \\sqrt{n}) = O(n^2)$.

## Príprava na rýchlejšie riešenie

Na rýchlejšie riešenia ako $O(n^2)$ si potrebujeme spraviť to sľubované premýšľanie. Ukážeme si, že stačí uvažovať len niektoré sekania dážďovky.

Mimochodom, dĺžkou kusu/čísla rozumieme počet jeho cifier. Často budeme využívať fakt, že ak číslo $B$ je dlhšie ako $A$, tak $B$ je určite väčšie.

### Pozorovanie 1.

*Stačí nám uvažovať také riešenia, kde sa dĺžky susedných kusov dážďovky líšia najviac o 2.*

Ak by sa totiž niektoré dva susedné kusy $A,B$ líšili o 3 alebo viac, môžeme ľavý kus $A$ predĺžiť o 1 a pravý kus $B$ skrátiť o 1. Tým pádom všetky ostatné kusy ostanú nezmenené a určite sme nespôsobili žiadny problém pri porovnaniach ktorýchkoľvek z kusov. Číslo $A$ je naďalej väčšie od kusov naľavo, pretože už predtým bolo väčšie a teraz sme ho len zväčšili. Podobne $B$ je menšie od kusov napravo. Napokon $A$ je menšie ako $B$, pretože $B$ má aspoň o jednu cifru viac. Opakovaním takýchto posunov o 1 dosiahneme, že rozdiely dĺžok sú všade najviac dva.

Podobne, nikdy v optimálnom riešení nebude prvý úsek dlhší ako dve cifry, pretože ak by mal viac ako dve cifry, tak ho určite môžeme rozdeliť na prvú cifru a zvyšok, čím dostaneme lepšie riešenie.

Teraz vieme spraviť prvý odhad na dĺžku kusov. Keďže prvý kus je dlhý najviac dva a každý ďalší môže byť najviac o dva dlhší, najväčšie možné dĺžky dosiahneme, ak budú postupne počty cifier v úsekoch $2,4,6,8,10,12,...,2k$.

Celková dĺžka dážďovky potom bude $k(k+1)$. Opačne, ak vieme, že dĺžka dážďovky je $n$, tak $k < \\sqrt{n}$ a dĺžka najväčšieho úseku v nejakom optimálnom riešení bude najviac $2\\sqrt{n}$. Neskôr si ukážeme, že je to dokonca najviac $\\sqrt{2n}+1$.

Zároveň ľahko nájdeme vstupy, kde v optimálnom riešení má najväčšie číslo viac ako $\\sqrt{2n}-1$ cifier, takže tento odhad už sa veľmi nedá zlepšiť.

### Pozorovanie 2.

*V skutočnosti nemusíme hľadať čo najvyšší počet kusov dážďovky, ako nabáda zadanie, ale môžeme nájsť také nasekanie, aby posledný kus bol čo najmenší. Je to totiž takmer to isté.*

Kľúčovým pozorovaním tejto úlohy je to, že nám stačí uvažovať len také riešenia, ktoré končia najmenším možným číslom, resp. najkratším možným kusom^[Pozor, je to niečo úplne iné, ako snažiť sa začať najmenším možným číslom. To by nefungovalo.]. Predstavme si, že sme nasekali dážďovku tak, aby bol posledný kus čo najkratší. Nech má posledný kus dĺžku $m$. Zároveň spomedzi všetkých nasekaní, ktoré majú posledný kus dlhý $m$ vyberieme to, ktoré má najväčší počet kusov. Toto nasekanie volajme $A$ a označíme si jednotlivé pozície rezov $i_1, i_2, i_3,\\dots , i_k$.

*Čo by sa stalo, keby toto nasekanie nebolo optimálne z hľadiska počtu kusov?* Ak sa nám podarí prísť ku sporu, zistíme, prečo toto nasekanie muselo byť optimálne.

Pre spor teda predpokladajme, že existuje iné nasekanie $B$ na pozíciách $j_1, j_2,\\dots ,j\_{k+1}$, ktoré má viac kusov. Z predpokladov vieme, že posledný kus $B$ je dlhší ako posledný kus $A$, preto $j\_{k+1} < i\_{k}$. Navyše si označme myslený nultý rez úplne na začiatku dážďoviek $i_0 = j_0 = 0$.

Pozrime sa na najmenšiu dvojicu indexov $(a,b)$, pre ktoré platí, že $1\\leq a \\le b \\leq k+1$ a zároveň $i_a > j_b$. (Pri výbere najmenšej najprv zoraďujeme podľa a, potom podľa b.) Keďže existuje aspoň jedna taká dvojica (k, k+1) a možných dvojíc je konečne veľa, tak určite existuje najmenšia.

Vieme tiež, že $i\_{a-1}\\leq j\_{b-1}$, inak by $(a,b)$ nebola najmenšia dobrá dvojica. Taktiež $j\_{b-1} < i_a$, pretože $i_b < i_a$.

No ale potom vieme vyrobiť nové nasekanie $C$, ktoré bude pozostávať z rezov $j_1 \\dots j\_{b-1}$ a rezov $i_a \\dots i_k$. O tomto nasekaní vieme povedať, že

- Je korektné a spĺňa nerovnosti so zadania. Totiž, číslo pozostávajúce z cifier medzi rezmi $j\_{b-1}$ a $i_a$ je väčšie ako číslo medzi rezmi $j\_{b-1}$ a $j_b$ a preto je aj väčšie od čísla pred ním. Taktiež je toto číslo menšie alebo rovné od čísla medzi rezmi $i\_{a-1}$ a $i_a$ a tým pádom aj menšie ako číslo za ním. Všetky ostatné nerovnosti platia, pretože platili v pôvodných dážďovkách.
- Má $k+1$ kusov, čiže je dlhšie ako nasekanie $A$.
- Končí rovnakým číslom ako nasekanie $A$.

A to je spor s tým ako sme vybrali nasekanie $A$. $\\square$

Ukázali sme, že nasekanie $A$ je optimálne, pretože ak by existovalo nasekanie s väčším počtom kusov, dostali by sme sa do sporu. Pre lepšiu predstavu si pozrite ilustračný obrázok ku dôkazu.

### Dôsledky

Vďaka druhému pozorovaniu, vieme, že nasledujúci algoritmus funguje správne. Spočítame, akým najkratším kusom vieme ukončiť nasekanie dážďovky. Odsekneme ten najkratší možný kus. Opakujeme postup s kratšou dážďovkou.

Druhý dôsledok je tesnejší odhad pre počet cifier všetkých čísel. Keby mali jednotlivé kusy dĺžky postupne $1,2,3,4,\\dots$ prípadne s jedným vynechaným číslom aby to pasovalo na dĺžku dážďovky, tak dostaneme riešenie, ktoré končí číslom kratším ako $\\sqrt{2n}+1$. Tým pádom riešenie, ktoré končí najkratším možným kusom, končí tiež kusom kratším ako $\\sqrt{2n}+1$. A tým pádom existuje aj optimálne riešenie s kratším kusom na konci. A keďže posledný kus je zo všetkých najdlhší, tak sme dostali horný odhad na dĺžku všetkých kusov.

Tretí dôsledok je rýchlejšie riešenie úlohy.

## Rýchlejšie riešenie -- $O(n \\sqrt {n})$

Pamätáte si ešte pôvodné rekurzívne riešenie, kde sme sa snažili pre každé $i,j$ zistiť, *na koľko najviac kusov môžeme nasekať prvých $i$-cifier vstupu, ak posledný kus má $j$-cifier*? Tak teraz už vieme, že nemusíme rozlišovať, koľko cifier má posledný kus -- stačí uvažovať rozsekanie s najkratším možným koncom.

Takže po novom už budeme počítať $P[i]$ -- na koľko najviac kusov môžeme nasekať prvých $i$ cifier dážďovky a $D[i]$, koľko najmenej cifier môže mať posledný kus.

Celková zložitosť algoritmu bude $O(n\\sqrt{n})$, pretože každé $P[i]$ a $D[i]$ spočítame v čase $O(D[i])$ z týchto hodnôt pre menšie $i$. Najprv prejdeme $O(D[i])$ menších hodnôt $P[j],D[j]$ a potom ešte potrebujeme porovnať dve $D[i]$-ciferné čísla, aby sme zistili, či môžu byť posledné dva úseky rovnako dlhé. A už vieme, že $D[i] \\leq \\sqrt{2n}+1$.

Ak chceme program ďalej zrýchliť, potrebujeme vedieť rýchlo porovnávať dlhé čísla a tiež potrebujeme prechádzať menej hodnôt pri počítaní jednej dvojice $P[i], D[i]$. Už sme si dokázali, že nemá zmysel, aby sa dĺžky susedných čísel líšili o viac ako dva. Takže nemusíme skúšať všetky možnosti, stačí pozrieť len hodnoty $j \\in {D[i]-2, D[i]-1, D[i]}$. Bohužiaľ, keď nepoznáme $D[i]$, tak nevieme, ktoré možnosti skúšať.

Preto budeme tieto hodnoty počítať trocha inak -- odpredu. Pekne od začiatku začneme počítať $P$ a $D$ pre hodnoty $1,2,3,4,\\dots$ A vždy, keď spočítame nejakú hodnotu, $P[i]$ a $D[i]$, vieme, ktoré vyššie hodnoty ovplyvnia. Aktualizujeme teda, hodnoty o $D[i]$, $D[i]+1$ a $D[i]+2$ vyššie, čo už môžeme spraviť, lebo už poznáme $D[i]$. Teda napríklad vieme, že $P\[i+D[i]+1\]$ ani $P\[i+D[i]+2\]$ nebude menej ako $P[i]+1$. A zároveň vieme, že ak číslo pozostávajúce z cifier $i-D[i]$ až $i$ (polouzavretý interval) je menšie ako číslo pozostávajúce z cifier $i$ až $i+D[i]$, tak aj $P\[i+D[i]\] > P[i]+1$.

Tieto myšlienky vieme zapísať do nasledujúceho programu, ktorý už je pomerne rýchly a získa 7 z 8 bodov.

## Vzorové riešenie

Jediná vec, ktorá teraz spomaľuje beh programu je porovnávanie reťazcov. V najhoršom prípade porovnáme všetkých $O(D[i])$ znakov, čo trvá $O(\\sqrt{n})$ času. Ale my predsa vieme porovnávať aj rýchlejšie, ak si dážďovku trocha predspracujeme.

Možností, ako zrýchliť porovnávanie je mnoho. Jeden z tých jednoduchších spôsobov je spraviť väčšie bloky cifier, ktoré budeme schopní porovnávať naraz.

Zvolíme si veľkosť bloku $k$, následne zoberieme všetky možné kusy dážďovky dĺžky $k$. Tieto kusy si radix-sortom utriedime a spočítame indexy -- pre každú $k$-ticu si zapamätáme, koľká najmenšia $k$-tica zo všetkých to je.

Potom, keď budme chcieť porovnať dve dlhé čísla, tak môžeme najprv porovnať prvú $k$-ticu cifier, potom druhú $k$-ticu cifier a tak ďalej. Každú $k$-ticu porovnáme jedným pozretím do poľa indexov. Možno nám ešte na konci ostane niekoľko (najviac $k$) cifier, ktoré budeme musieť porovnať po jednej.

Časová zložitosť predpočítania indexov je $O(nk)$ a časová zložitosť jedného porovnania reťazcov dĺžky $\\sqrt{n}$ je $O(k + \\sqrt{n}/k)$, čo je najmenej pre $k = \\sqrt[4]{n}$.

Takže dostaneme algoritmus s časovou zložitosťou $O(n\\sqrt[4]{n}) = O(n^{1.25})$. Pri implementácii si treba dávať pozor, že keď porovnávame dve $k$-tice, potrebujeme rozlišovať nielen dve možnosti menší/nie menší, ale tri možnosti väčší/menší/rovnaký.

V praxi je radix-sort pomerne pomalý, má zlú konštantu, takže v zdrojovom kóde sme nastavili konštantu $k$ na $10$ pre lepší čas (teoreticky by bolo lepšie $k=30$, pretože to je približne $\\sqrt[4]{10^6}$). Takto vyzerá funkcia `predpocitaj`, ktorú zavoláme raz hneď po načítaní vstupu a funkcia `mensie`, ktorá nahradí pôvodnú funkciu `mensie`.

Táto myšlienka sa dala posunúť ešte ďalej a namiesto jednej sady blokov dĺžky $k$ sme mohli mať bloky dĺžok $1, 2, 4, 8, 16, 32, \\dots, 2^{\\log{n}}$. Predpočítať poradie blokov všetkých dĺžok vieme spraviť v čase $O(n \\log n)$, pretože vieme zistiť poradie blokov dĺžky $2k$ v $O(n)$, ak poznáme poradie blokov dĺžky $k$.

Porovnávanie čísel, resp. funkcia `mensie` by potom bežala tiež v čase $O(\\log n)$, čím by sme dosiahli výbornú celkovú zložitosť $O(n\\log n)$.

Takéto riešenie stačilo na plný počet bodov aj za popis aj za program. Predošlé riešenie $O(n^{1.25})$ by dostalo za program tiež plný počet a za dobrý popis by dostalo 11 bodov z 12.

&#160;

Iný spôsob, ako dosiahnuť rýchle riešenie je hashovanie. Môžeme jednoduchým cyklom spočítať hash pre každý blok dlhý $k$ cifier a potom zasa vieme porovnávať v čase $O(k + \\sqrt{n}/k)$.

Dobrá hash je napríklad $\\sum\\limits\_{i=1}^{k} {c_i 47^i} \\mod p$, kde $c_i$ je $i$-ta cifra čísla a $p$ je nejaké veľké prvočíslo, napr. $10^9 + 9$.

Spočítanie hash-hodnôt vieme spraviť v $O(n)$ a tak je to v praxi oveľa rýchlejšie ako radix-sort. Nevýhoda je, že pri použití hashe nemáme istotu, že program odpovie správne, pretože dve rôzne $k$-ciferné čísla môžu mať rovnakú hash. Taktiež hash čísla nevie povedať, ktorá $k$-tica je menšia, vie len overovať rovnakosť. To nám však príliš nevadí.

Celková zložitosť tohto algoritmu by bola tiež $O(n^{1.25})$.

&#160;

Pomocou hash-funkcií vieme spraviť aj jednoduché riešenie so zložitosťou $O(n \\log n)$. Najprv si spočítame hash pre každý prefix dážďovky $H_i = \\sum\\limits\_{i=1}^{k} {c_i 47^i} \\mod p$, kde $c_i$ je $i$-ta cifra dážďovky.

Potom, ak chceme zistiť, či sú nejaké dva intervaly dážďovky $(a,b)$ a $(c,d)$ rovnaké, stačí zistiť, či $((H_b - H_a)\\cdot 47^c - (H_d - H_c)\\cdot 47^a) \\mod p == 0$.

Potom, ak ideme porovnávať dve dlhé čísla, vieme binárne vyhľadať prvú cifru v ktorej sa líšia a porovnať len tú. Takto dosiahneme zložitosť predpočítania $O(n)$ a zložitosť jedného porovnania $O(\\log n)$.

## Bonusové riešenie

Všetkých vás určite zaujíma, či sa úloha nedala vyriešiť aj v čase $O(n)$. Áno dala, ale zložitosť riešenia výrazne presahuje kategóriu O.

Bolo potrebné dotiahnuť do konca zrýchlenie porovnávania. Povieme si aspoň hlavnú myšlienku pre skúsených čitateľov. Nezúfajte, ak teraz neporozumiete skratkám a názvom algoritmov, keď budete starší, môžete sa k tomuto vzoráku vrátiť a skúsiť to znova.

&#160;

Zostrojíme si pre dážďovku Suffixové pole. Potom, keď budeme chcieť porovnať dva rovnako dlhé kusy dážďovky, najprv overíme, či náhodou nie sú úplne rovnaké. Ak nie sú, tak vieme, že ich poradie je rovnaké ako poradie k nim prislúchajúcich suffixov. Takže ich porovnáme pomocou Suffixového poľa v $O(1)$.

Ako však v $O(1)$ zistiť, či sú kusy dážďovky rovnaké? Jednou možnosťou by bolo opäť hashovať, ale to nechceme, lebo hash nezaručuje správnosť riešenia. Namiesto toho si na začiatku spočítame LCP pole ku Suffixovému poľu a overíme, či minimum zo všetkých LCP medzi suffixami prislúchajúcimi porovnávaným kusom dážďovky je väčší alebo rovný ako dĺžka porovnávaných kusov. Ak áno, tak sú rovnaké, inak sú odlišné.

Takže potrebujeme rýchlo počítať minimum z nejakých intervalov v nejakom poli. Inak povedané, potrebujeme riešiť známy problém Range-Minimum-Query v čase $O(n)$ na predspracovanie a $O(1)$ na query. Pekné riešenie RMQ spomínajú páni Fischer a Heun vo svojom [čĺanku z roku 2006](http://dl.acm.org/citation.cfm?id=2100543). Vraveli sme, že to presahuje kategóriu O.

Ničmenej, dá sa to celé nakódiť, ale v praxi pre $n\\leq 10^6$ je už len zostrojenie Suffixového poľa pomalšie ako pôvodné $O(n\\sqrt n)$ riešenie. Takže máme pekný teoretický výsledok, že sa to celé dá v $O(n)$ ale ponechajme radšej tento výsledok v teoretickej rovine.
",10
ff1e641d1282ed5e,ksp,"# Obrana pobrežia

Kiribatské pobrežie začali nedávno sužovať nájazdy útočných sépií. Sépie priplávajú ku brehu a potom sťahujú do mora slnečníky, lehátka a výletníkov. Minule dokonca odtiahli aj stánok so zmrzlinou.

Určite netreba vysvetľovať, čo by sa stalo s turistickým ruchom, ak by sa to rozkríklo. Kiribatská pobrežná stráž preto rýchlo dostala z príslušného ministerstva dotáciu a dôraznú inštrukciu, nech problém rýchlo vyrieši.

Za peniaze z ministerstva pobrežná stráž nakúpila $n$ balíst. Balista je mechanické zariadenie, schopné strieľať harpúny po sépiách. Harpúna má samozrejme na sebe uviazané lano, takže trafenú sépiu vie pobrežná stráž vytiahnuť na breh (a tam naporcovať a zjesť).

## Úloha

Pobrežie Kiribati si predstavíme ako os $x$, more bude polrovina zodpovedajúca kladnému $y$. Na pobreží stojí $n$ balíst. Z mora sa práve blíži $n$ sépií. Každú balistu aj každú sépiu považujeme za bod.

Pobrežná stráž by chcela uloviť všetkých $n$ sépií naraz. Je zjavné, že na to treba každou balistou uloviť inú sépiu. Existuje teda $n!$ možností, ako priradiť balisty ku sépiám.

Nie všetky možnosti sú však vhodné. Problém je, že keby sme strieľali len tak hala-bala, mohli by sa nám niektoré laná z harpún o seba zamotať. Pobrežná stráž preto musí strieľať takým spôsobom, aby sa tejto nepríjemnosti zaručene vyhla.

Presnejšie: Keď trafíme sépiu harpúnou, lano uviazané o harpúnu tvorí úsečku spájajúcu balistu na brehu s trafenou sépiou vo vode. Priradenie balíst sépiám je *dobré* vtedy, ak sú všetky tieto úsečky navzájom disjunktné (čiže ak žiadne dve nemajú spoločný bod).

Dané sú súradnice balíst aj sépií. Spočítajte, koľko existuje dobrých priradení balíst sépiám. Vypíšte túto hodnotu modulo $10^9 + 7$.

**Dôležité:** V tejto úlohe nie je nutné optimalizovať časovú zložitosť. Presnejšie, ľubovoľné riešenie s polynomiálnou časovou zložitosťou môže dostať plný počet bodov za popis -- ale samozrejme, na plný počet bodov musíte riešenie dobre popísať a ukázať o ňom, že naozaj má polynomiálnu časovú zložitosť.

## Formát vstupu

V prvom riadku vstupu je celé číslo $n$. Platí $1\\leq n\\leq 50$.

V druhom riadku vstupu je $n$ celých čísel $b_1,\\dots,b_n$: x-ové súradnice balíst. Balista $i$ sa teda nachádza na súradniciach $(b_i,0)$.

V treťom riadku je $n$ celých čísel $x_1,\\dots,x_n$: x-ové súradnice sépií.

Vo štvrtom riadku je $n$ celých čísel $y_1,\\dots,y_n$: y-ové súradnice sépií.

Všetky súradnice sú od $-1000$ do $1000$, vrátane. Všetky $y_i$ sú navyše kladné. Žiadne dve balisty ani žiadne dve sépie sa nenachádzajú v tom istom bode.

## Formát výstupu

Vypíšte jeden riadok a v ňom hodnotu $(p\\bmod 10^9 + 7)$, kde $p$ je počet dobrých priradení balíst sépiám.

## Príklady

```vstup
2
4 -4
1 2
1 2
```

```vystup
2
```

*Balisty sú na súradniciach $(4,0)$ a $(-4,0)$. Sépie sú na súradniciach $(1,1)$ a $(2,2)$. Sú dve možné priradenia balíst sépiám. Obe sú dobré.*

```vstup
2
4 -4
4 -4
10 10
```

```vystup
1
```

*Tentokrát je len jedno priradenie balíst sépiám dobré, pri druhom sa laná prekrížia.*

```vstup
3
-1 0 1
0 0 0
1 2 3
```

```vystup
2
```

*Všimnite si, že sú zakázané aj situácie, v ktorých koniec jednej úsečky leží na inej úsečke. (Inými slovami, lano ide priamo ponad inú sépiu.)*

```vstup
4
-2 2 98 102
0 1 100 101
1 2 1 2
```

```vystup
4
```

```vstup
9
5 7 8 9 10 11 12 15 18
13 4 1 6 12 7 9 17 5
15 7 11 2 15 1 6 4 5
```

```vystup
10
```
","# Obrana pobrežia

Už v úlohe 8 minulej série sme sa stretli s elementárnou operáciou, ktorá nám bude užitočná aj tu: dozvedeli sme sa, ako pomocou vektorového súčinu ľahko a presne zistiť, či sa dve úsečky pretínajú. Toto budeme potrebovať aj v tejto úlohe. Kto to už zabudol, nájde to v [Kuchárke](https://ksp.sk/kucharka/skalarny_a_vektorovy_sucin).

## Hrubá sila

Akonáhle máme takúto funkciu, už vieme riešiť zadanú úlohu hrubou silou: postupne vyskúšame všetkých $n!$ permutácií, každú z nich skontrolujeme, a spočítame tie, pre ktoré sa žiadne dve úsečky nepretínajú. Za takéto riešenie síce nebude plný počet bodov, ale ak ste za túto úlohu mali nulu, tak aj toto je od nuly lepšie. A je to naozaj pár riadkov programu -- napr. v C++ máme k dispozícii funkciu `next_permutation` pomocou ktorej sa skúšanie permutácií implementuje ozaj hravo.

## Chceme lepšie

My ale chceme nejaké riešenie, ktoré bude bežať v polynomiálnom čase. Ako na to?

Naše riešenie je založené na nasledujúcom pozorovaní: Zoberme sépiu, ktorá je najďalej od pobrežia. (Ak je takých viac, tak trebárs tú z nich, ktorá má najmenšie číslo.) Položme si teraz otázku: môže byť táto sépia trafená balistou číslo $k$? Odpoveď je jednoduchá: áno, ak sú splnené nasledujúce podmienky.

- Na úsečke medzi balistou $k$ a našou sépiou neležia žiadne iné sépie.

- ""Naľavo"" od našej úsečky je rovnako veľa balíst ako sépií (a napravo teda nutne tiež).

Postupne vyskúšame všetky možnosti pre $k$. Vždy, keď nájdeme nejakú vyhovujúcu, tak sme vlastne pôvodný problém rozdelili na dva menšie: Nech $a$ je počet spôsobov, ktorými vieme spárovať sépie a balisty naľavo od našej úsečky a nech $b$ je počet spôsobov, ktorými to vieme urobiť napravo. Potom dokopy dostávame $ab$ riešení, lebo každé riešenie vľavo vieme skombinovať s každým riešením vpravo.

No a ak sme už zvlášť pre každé $k$ určili, koľko mu zodpovedá riešení, tak celkový počet riešení je jednoducho súčtom všetkých týchto počtov.

Vyššie popísané riešenie nás teda vedie k rekurzívnemu riešeniu našej úlohy: vyskúšame nejaké možnosti ako spraviť jednu dvojicu balista-sépia a následne sa rekurzívne zavoláme na nejaké menšie vstupy.

Ostáva ale celkom veľa nezodpovedaných otázok. Funguje to vôbec? A ak áno, má to polynomiálnu časovú zložitosť?

## Funguje to vôbec?

To, že vyššie uvedené riešenie funguje, je spôsobené práve našou šikovnou voľbou sépie, ktorej pár hľadáme ako prvý. My sme si zvolili sépiu $S$, ktorá je najďalej od pobrežia, a spojili sme ju s nejakou balistou $B$ na pobreží. Ak teraz zoberieme hocijakú sépiu naľavo od $S$ a spojíme ju s balistou napravo od $B$ (alebo naopak), bude táto nová úsečka určite križovať úsečku $SB$. Vďaka našej šikovnej voľbe sépie sa nám teda naozaj nakreslením úsečky $SB$ zadanie rozpadne na dve časti ktoré sú nezávislé.

## Má to polynomiálnu časovú zložitosť?

Nemá. Generuje to postupne po jednom všetky prípustné riešenia, a tých ani omylom nemusí byť len polynomiálne veľa. (Ľahko sa vyrobí napríklad vstup, ktorý bude mať riešení aspoň $2^{n/2}$. Viete dosiahnuť ešte viac?)

## Ako teda dostať polynomiálne riešenie?

Jednoducho: pridáme memoizáciu. Každý konkrétny podproblém, na ktorý narazíme (""tu je podmnožina sépií a úsek balíst, koľkými spôsobmi ich vieme pospájať?"") budeme riešiť len raz. Keď ho prvýkrát vyriešime, zapamätáme si jeho riešenie. Ak by sme na ten istý podproblém narazili inokedy, už nebudeme nič skúšať, len sa pozrieme na jeho zapamätané riešenie a to vrátime na výstup.

## Prečo pridaním memoizácie dostaneme polynomiálne riešenie?

Kvôli konzistencii si predstavme, že naľavo aj napravo od celého vstupu je po jednej sépii (ďaleko na mori) a jednej baliste. Ľubovoľný konkrétny podproblém si teraz môžeme popísať tak, že povieme dve úsečky sépia-balista: jedna tvorí jeho ľavý a druhá jeho pravý okraj.

Všetkých podproblémov je teda nanajvýš toľko, koľko je takých dvojíc úsečiek -- teda $O(n^4)$, lebo máme $n$ možností pre každý koniec každej úsečky. V skutočnosti bude dosiahnuteľných podproblémov výrazne menej. Na dôkaz polynomiálnej časovej zložitosti nám ale stačí takýto horný odhad ich počtu.

No a konkrétny podproblém vyriešime v $O(n^2)$: najskôr overíme, či máme rovnako veľa sépií a balíst (ak nie, odpoveď je 0), potom nájdeme najvzdialenejšiu sépiu, a potom ju postupne vyskúšame spojiť s každou balistou. Keď máme konkrétnu dvojicu sépia-balista, potrebujeme ešte prejsť všetky ostatné a rozdeliť ich na ľavé a pravé (a skontrolovať, že žiadna sépia neleží na práve nakreslenej úsečke).

Celkovo teda dostávame riešenie s časovou zložitosťou $O(n^6)$.

Šlo by aj zlepšiť. Napríklad tak, že keď už máme zvolenú najvzdialenejšiu sépiu, tak si všetky ostatné balisty a sépie okolo nej polárne usporiadame, aby sme vedeli rýchlejšie hovoriť, ktoré objekty sú naľavo a ktoré napravo od práve skúšanej úsečky sépia-balista. Zadanie však hovorí, že čokoľvek polynomiálne je dobré, a tak budeme leniví a nebudeme už nič zlepšovať.

## Implementácia

V mojej implementácii som bol extra lenivý, preto si konkrétny podproblém reprezentujem nie pomocou štyroch čísel (dve balisty a dve sépie) ale pomocou dvoch 64-bitových intov: v jednom sú nastavené bity pre tie harpúny, ktoré ešte mám, a v druhom bity pre sépie. Ono je to skoro jedno, stavov mám stále rovnako a takto sa ten kód stručnejšie písal.

Namiesto 4-rozmerného poľa potom používam na memoizáciu `map`. Tým mi pribudne v časovej zložitosti ešte logaritmus navyše. Spomínal som už, že som bol extra lenivý? :)

Navyše sa ani neobťažujem priebežne kontrolovať, či mám rovnako veľa sépií a balíst. Až ak na konci vetvy rekurzie zistím, že jedny sa už minuli a druhé ešte nie, vrátim nulu.
",10
189cc9186d111fca,ksp,"# Ooo, Vlaky

Píše sa rok $2143$. Presne pred $100$ rokmi sa človek stal multiplanetárnym druhom, keď prví vesmírni osadníci pristáli na Marse a následne vybudovali kolóniu. Na začiatku ich tam bolo presne $157$ a každý tak mal dostatok priestoru, keďže pôvodná kapacita prvej kolónie sa šplhala až k číslu $1223$.

Časom však populácia červenej planéty rástla[^1]. $53%$ terajších obyvateľov pricestovalo zo Zeme alebo z Mesiaca a $47%$ sa na Marse už narodilo. Preto už takýchto kolónií existuje niekoľko (rádovo v stovkách). Čoskoro, teda, dôjde k vyrovnaniu pomeru úplných[^2] a polovičných[^3] ""Marťanov"", a veľkosť populácie prekročí $200,000$.

Znie to veľmi sľubne a prosperujúco, no obyvateľov Marsu stále ešte obmedzuje pár vecí, medzi ktoré patrí napríklad aj doprava. Na prepravu materiálu, potravín alebo osôb sa v tomto nehostinnom teréne používajú elektrické rovery. Tie majú svoje nevýhody: sú pomalé, často sa kvôli prašnému povrchu kazia, majú relatívne malú nosnosť a, samozrejme, z bezpečnostných dôvodov nepremávajú počas Marťanskej búrky. Preto sa Rada kolónií Marsu, Aliancia štátov pre multiplanetárny život a Medzinárodná rada vesmírnych agentúr rozhodli riešiť dopravu na tejto planéte.

Za najvhodnejší spôsob prepravy osôb a tovaru tu považujú vlaky, premávajúce hermeticky uzavretými podzemnými tunelmi. Tie budú môcť premávať aj počas búrok[^4], uvezú veľa nákladu, nebudú vystavené prašnému prostrediu a budú relatívne rýchle[^5]. Okrem toho, odhlasovalo sa, že z bezpečnostných dôvodov[^6] budú všetky tunely vybudované v rovnakej hĺbke, a to znamená, že žiadne dva tunely sa nesmú križovať. V každom tuneli bude premávať práve jeden vlak. Vlaky sú totiž najdrahšou položkou v tomto projekte a preto ich počet, a teda aj počet tunelov, bude čo najnižší. Zároveň ich treba toľko, aby sa bolo možné dostať z ľubovoľnej kolónie do hociktorej inej len použitím vlakov. Ak si teda vlakovú sieť predstavíme ako graf, tak bude vyzerať ako strom, z čoho vyplýva, že počet tunelov bude počet kolónií mínus $1$.

Plán projektu sa skladal z troch tabuliek:

- V jednej boli spárované identifikačné čísla pozícií s ich súradnicami na mape[^7].

| Pozícia | ID pozície | |:---:|:----:| | $[0, 0]$ | $1$ | | $[1, 1]$ | $2$ | | $[2, 3]$ | $3$ |

- V druhej boli pozície priradené číslam a názvom kolónií.

| ID pozície | ID kolónie | Kolónia | |:---:|:---:|:---:| | $1$ | $1$ | Jablkovo | | $2$ | $2$ | Hruškovo | | $3$ | $0$ | Malinovo |

- V tretej sa nachádzal zoznam dvojíc čísel kolónií, ktoré je potrebné prepojiť tunelom.

| ID kolónie $a$ | ID kolónie $b$ | |:---:|:---:| | $1$ | $2$ | | $0$ | $2$ |

Po pár mesiacoch bol plán projektu hotový a išlo sa stavať, no nastal problém. Druhá tabuľka sa záhadne stratila, a tak sú v projekte len súradnice a prepojenia čísel kolónií. Nevieme ale, ktorá kolónia je na ktorých súradniciach.

Stavebníci teraz nevedia, kde treba stavať. Skúste ale z projektu zachrániť, čo sa dá: navrhnite také riešenie, ktoré teoreticky môže byť pôvodne zamýšľaný plán.

\[^1\]: Posledné informácie hovoria o počte $197,359$ \[^2\]: Narodili sa už na Marse \[^3\]: Pricestovali na Mars \[^4\]: Keďže budú chránené v podzemí \[^5\]: 1373 km/h \[^6\]: Ani predseda Medzinárodnej rady vesmírnych agentúr nevedel zdôvodniť toto rozhodnutie \[^7\]: Aj keď je jasné, že Mars nie je plochý, pre účely tejto úlohy postačí, že povrch Marsu budeme považovať za rovinu a použijeme obyčajnú karteziánsku súradnícovú sústavu.

## Úloha

Na Marse sa nachádza $n$ kolónií. Poznáte ich $n$ celočíselných súradníc $x, y$, avšak, neviete konkrétne, ktorá pozícia prislúcha ktorej kolónii. Pozície sú navzájom rôzne, a žiadne tri pozície neležia na jednej priamke.

Ďalej máte plán projektu, v ktorom sú zapísané dvojice čísel $a, b$ označujúce kolónie, medzi ktorými má viesť obojsmerný tunel. Táto vlaková sieť tvorí graf-strom: je teda súvislá a vedie v nej práve $n-1$ hrán.

Navrhnite, medzi ktorými pozíciami majú viesť tunely tak, aby sa žiadne dva tunely nekrižovali, a aby jednotlivé pozície v nejakom poradí zodpovedali jednotlivým kolóniám.

## Vstup

V prvom riadku vstupu sa nachádza číslo $1 \\leq n \\leq 1,000$ udávajúce počet kolónií. Nasleduje $n - 1$ riadkov. V každom z nich sa nachádzajú dve čísla $a, b$ hovoriace, že medzi kolóniami $a$ a $b$ má byť postavený tunel. Kolónie číslujeme $0, 1, \\ldots, n-1$.

Ďalej nasleduje $n$ riadkov. V $i$-tom z nich sa nachádzajú dve čísla $x_i, y_i$, súradnice $i$-tej pozície nejakej kolónie. Tieto súradnice v absolútnej hodnote nepresiahnu $10^9$.

## Výstup

Na výstup vypíšte $n - 1$ riadkov. V každom z nich nech je dvojica čísel $a, b$, ktorá znamená, že medzi $a$-tou pozíciou a $b$-tou pozíciou má viesť tunel. Pozície číslujeme od $0$ po $n-1$.

Na poradí tunelov ani na poradí čísel $a$ a $b$ vo výstupe nezáleží. Ak je správnych odpovedí viac, vypíšte ľubovoľnú z nich.

Je zaručené, že každý vstup má platné riešenie.

## Príklady

```vstup
3
1 2
0 2
0 0
1 1
2 3
```

```vystup
0 1
1 2
```

*Máme tri kolónie. Očíslované sú $0$, $1$ a $2$. Tunel má viesť medzi kolóniami $1$ a $2$ a medzi kolóniami 0 a 2. Tri pozície sú $[0, 0]$, $[1, 1]$ a $[2, 3]$. Príkladový výstup hovorí, že spojíme pozíciu číslo $0$ s pozíciou $1$ a tiež $1$ s $2$. To znamená, že jeden tunel bude medzi $[0, 0]$ a $[1, 1]$ a druhý medzi $[1, 1]$ a $[2, 3]$. Keby sme si to znázornili na štvorčekovú sieť súradníc, videli by sme, že sa žiadne dva tunely nepretínajú. Okrem toho je zachovaný aj spôsob prepojenia kolónií: Buď by bola kolónia číslo $1$ v $[0, 0]$ a kolónia $0$ v $[2, 3]$, alebo naopak.*

*Iné platné riešenie by mohlo spojiť pozície $1$ s $2$ a $2$ s $0$*

```vstup
5
0 1
1 2
2 3
3 4
0 0
9 9
2 3
3 2
7 8
```

```vystup
0 3
3 1
1 4
4 2
```

*Podľa tohto výstupu by boli tunely postavené takto:*
","# Ooo, Vlaky

Keďže zadanie úlohy je pomerne dlhé, zhrňme si najprv, o čo tu ide. Na vstupe máme popísaný graf (strom) s $n$ vrcholmi a $n$ bodov v rovine. Úlohou je položiť vrcholy grafu do bodov v rovine tak, aby sa žiadne hrany nepretínali. Pritom hrany grafu sa zobrazia na úsečky medzi bodmi v rovine. Ako to spraviť?

## Riešenie hrubou silou

Prvou možnosťou by bolo niečo veľmi pomalé. Všetkým bodom v rovine priradíme nejaké vrcholy grafu a skontrolujeme, či nám kolidujú nejaké hrany. Ak áno, skúsime vrcholy rozmiestniť nejako inak. Inak povedané, permutácie usporiadanej množiny vrcholov skúšame zobraziť na usporiadanú množinu bodov, kým nenájdeme správne riešenie.

Hmmm. Jednak by to bolo trochu neefektívne, že aj keď zmeníme medzi jednotlivými permutáciami len malú časť vrcholov, zase musíme kontrolovať všetky dvojice úsečiek, a dvak, asi nechceme skúšať všetky permutácie, chceme tento problém vyriešiť nejako rozumne postupne.

Čo keby sme vrcholy ukladali postupne po jednom a pre každý pridaný vrchol by sme hneď zistili, či sa jeho položením niečo preťalo? Tým pádom by sme vedeli, či má zmysel pokračovať v takomto rozložení vrcholov. Takto by nám stačilo vždy pri uložení vrcholu skontrolovať len tie hrany, ktorými sme tento vrchol pripojili ku zvyšku grafu.

Úlohu si vyriešime rekurzívne tak, že v každom kroku máme $x$ vrcholov už uložených a $n - x$, ktoré sú ešte voľné. Keďže chceme skúšať rôzne možnosti uloženia vrcholov, stačí nám meniť poradie vrcholov a body v rovine necháme napríklad v poradí zo vstupu. Preto majme usporiadanú množinu bodov v rovine. V $i$-tom kroku uložíme nejaký vrchol do bodu $i$.

Na začiatku $x = 0$. Vyberieme si nejaký vrchol, ten uložíme, skontrolujeme, či sa jeho hrany s niečím nepretínajú, a krok opakujeme s $n - x$ vrcholmi. Ak v nejakom kroku zistíme, že ešte máme neuložené vrcholy a nevieme už žiaden uložiť tak, aby nám nič nekolidovalo, vrátime sa o krok späť a skúsime namiesto naposledy uloženého vrcholu uložiť nejaký iný a pokračovať ďalej. Toto opakujeme, až kým nie sú všetky vrcholy uložené. Všimnime si, že keď sa zasekneme a pozmeníme nejako uloženie, nemusíme zase porovnávať všetky dvojice úsečiek, ale len tie, ktoré zahrňajú novo pridané hrany.

Takýto dynamický prístup síce vyzerá pekne, no jeho asymptotická časová zložitosť až tak pekne nevyzerá. Hrozí tu, že v najhoršom prípade potrebujeme preveriť $n!$ uložení grafu, pričom ale pre každú vetvu výpočtového stromu skontrolujeme $n^2$ dvojíc úsečiek. Z toho nám vychádza časová zložitosť $O(n! \\cdot n^2)$.^[Dá sa spraviť šikovnejšia analýza časovej zložitosti, z ktorej vyjde $O(n \\cdot n!)$. Nie že by sme si veľmi pomohli...]

Zamyslime sa. Doteraz sme pracovali s myšlienkou, že budeme nejakým spôsobom skúšať napasovať zadaný graf do zadaných súradníc a testovať pri tom, či je daná možnosť vyhovujúca alebo niečo koliduje. Čo keby sme vedeli nejakým spôsobom vopred zaručiť, že vybrané uloženie je korektné, aj bez potreby overovania?

## Vzorové riešenie

Každý strom si vieme rozdeliť na menšie podstromy a tie na menšie podstromy a tak ďalej, až dostaneme strom hĺbky $1$. Strom hĺbky $1$ môžeme inak nazvať hviezda. Takto nízky strom vieme uložiť do roviny ľubovoľne a aj tak sa nestane, že sa nejaké hrany budú pretínať (samozrejme počítame s tým, že žiadne 3 body neležia ne jedenej priamke).

Ak si zvolíme v zadanom strome nejaký koreň, potom si predstavme podstromy, ktorých koreňmi sú jeho synovia. Každý takýto podstrom bude okupovať nejakú časť roviny, ktorú vieme ohraničiť konvexným obalom jeho vrcholov. Ak by sme vedeli tieto pre každý podstrom vybrať množinu tak, aby sa ich obaly nepretínali, mali by sme už čiastočne vyhrané. Totiž ak sa obaly nepretínajú, nemôžu sa pretínať ani hrany. Ak by sme toto vedeli opakovať rekurzívne do hĺbky, mali by sme vyhrané úplne, lebo takto vieme uložiť všetky vrcholy grafu.

Jediné, čo už teraz potrebujeme vyriešiť je, ako rozdeliť body v rovine do jednotlivých podstromov tak, aby sa ich obaly nepretínali. Keď budú body každého podstromu “pri sebe”, tak snáď nebudú zavadzať iným podstromom. Chceme ich teda “poskupinkovať” nejako lokálne.

Dobre. Z pohľadu ľubovoľného bodu koreňa vidíme každý iný bod pod nejakým uhlom. Zo zadania sme sa dočítali, že žiadne tri body neležia na rovnakej priamke. Preto vieme, že takýto uhol je pre každý bod unikátny. Hmmm. Ak sme v koreni a všetky dostupné body utriedime podľa tohto uhla, vieme si ich v tomto poradí ""poskupinkovať"" a prerozdeliť svojim synom. Tým pádom sa žiadna skupina bodov ""nemieša"" s nejakou inou, pretože body každej tejto množiny pozorujeme pod uhlom z nejakého intervalu, pričom body ďalšej sledujme pod uhlom z iného intervalu, pričom tieto intervaly majú prázdny prienik.

A funguje to vždy? Nie.

Ak si pre koreň vyberieme ľubovoľný bod, môže sa stať, že interval, pod ktorým vidíme istú množinu bodov bude väčší než $\\pi$, čo by znamenalo, že plocha ohraničená konvexným obalom tejto množiny bodov by obsahovala aj koreň. Tým pádom, by sa mohlo stať, že nejaká hrana v tomto území by pretínala hranu medzi koreňom a iným synom. Tento problém vieme ale jednoducho vyriešiť tak, že ako koreň stromu zvolíme najľavejší bod. To nám zaručí, že všetky ostatné body sa budú nachádzať vpravo od neho, čo inak znamená aj to, že interval uhlov, pod ktorými budú viditeľné z koreňa, bude najviac od $\\frac{\\pi}{2}$ po $- \\frac{\\pi}{2}$ otvorený z aspoň jednej strany, keďže žiadne tri body neležia na rovnakej priamke.

Ten istý problém sa môže stať aj na ďalších úrovniach: možno sa podstrom zobraznený na svojej pridelenej podmnožine pretne s hranou, ktorá je medzi jeho koreňom a jeho otcom. To opäť vyriešime extrémnou voľbou koreňa podstromu: ak ho umiestnime do prvého bodu v poradí (podľa uhla). Keďže všetky ostatné body budú zvierať s jeho otcom menší uhol, nebude tak možné, aby sa ľubovoľná úsečka medzi týmito bodmi pretla s tou spomenutou.

Tým pádom všetky usporiadané podmnožiny bodov sú pridelené nejakým podstromom. To znamená, že túto úlohu vieme vyriešiť pekne rekurzívne.

Najprv si porebujeme prehľadaním do hĺbky spočítať veľkosti jednotlivých podstromov, aby sme neskôr vedeli, koľko bodov máme konkrétnemu podstromu vyčleniť. Potom už vieme rekurzívnym prehľadávaním do hĺbky ukladať najprv koreň celého stromu, potom jeho synov a tak ďalej, pričom vždy uložíme koreň, polárne utriedime zvyšné body práve vzhľadom na koreň daného podstromu a rozdelíme tieto body jeho synom, podľa veľkostí ich podstromov.

Zložitosti. To, že vrcholy ukladáme do roviny rekurziou do hĺbky, nás môže ľahko zlákať na myšlienku, že pre každú úroveň rekurzie si potrebujeme pamätať zase novú množinu bodov, lebo si chceme pôvodnú usporiadanú množinu pamätať pre prípad, že sa k nej z rekurzie vrátime a budeme s ňou ďalej pracovať. Najhorší prípad by potom nastal, ak by graf na vstupe bol cesta a zakorenili by sme si ho ma jej konci. Vtedy by sme si najprv pamätali $n$ bodov, potom $n - 1$, $n - 2$, $\\dots$ čo je asymptoticky $n^2$. Z toho dostávame teda zložitosť $O(n^2)$.

Uvedomme si ale, že ak časť (istý súvislý úsek usporiadanej množiny) bodov priradíme nejakému synovi a jeho podstromu, ostatní synovia s touto časťou už nepracujú. Preto nevadí, že v tejto podmnožine zmeníme poradie prvkov predtým, ako rozdelíme aj všetky ostatné prvky. To znamená, že nám úplne postačuje pamätať si množinu všetkých bodov len raz a potom pracovať s jej podmnožinami bez toho, aby sme museli zachovaávať pôvodné poradie. Pamäťovú zložitosť tohto riešenia tak vieme odhadnúť na $O(n)$.

A časová zložitosť? Spočítanie veľkostí podstromov trvá len $O(n)$. Triediť vieme v $O(n \\log n)$, ale potrebujeme to robiť pre každý podstrom, no na druhej strane, pre každý podstrom sa nám mení $n$. V najhoršom prípade by zadaný graf bol cesta. Vtedy by sme vždy v $i$-tej úrovni rekurzie polárne triedili $n - i$ bodov a úrovní by bolo $n$. Z toho nám vychádza asymptotická časová zložitosť $O(n^2 \\log n)$.

Poznámka na záver: to, že týmto spôsobom nájdeme správne riešenie, neznamená, že nájdeme jediné správne. Môže existovať strom uložený v rovine aj keď neexistuje taký jeho koreň, z ktorého by sme videli množiny bodov podstromov jeho synov a vedeli si ich takto rozdeliť do konvexných množín. My sme chceli len nájsť ľubovoľné riešenie pre uloženie stromu, nie všetky.
",6
3b98808d49c02b0e,ksp,"# Areál zavlažovačov

Záhradník Adam sa jedného dňa zobudil a zistil, že zdedil obrovské pole. Pole to nebolo len také, bolo to pole iné, bolo to pole veľké, priam rozsiahle a na Adamove prekvapenie nebolo uložené v počítači, ale jednalo sa o poriadne pole, s traktormi, hnojiskami a zavlažovačmi.

Tak sa Adam rozhodol že bude teda poriadne záhradníčiť.

Prvý krok je inšpekcia pôdy.

Na poli je $n$ zavlažovačov, ktoré sú vskutku atypické -- každý zavlažovač je natočený do jedného zo štyroch smerov (doprava dole, doprava hore, doľava dole alebo doľava hore) a rovnomerne zavlažuje všetku plochu v rohu na ktorý je natočený. Rôzne zavlažovače zavlažujú s rôznou intenzitou. Zavlažovače sú fixne zabudované v poli a Adam s nimi nevie hýbať.

Adam má $m$ miest na poli, kde by chcel začať pestovať. Avšak najskôr by potreboval vedieť, ako veľmi zavlažované jednotlivé miesta sú. Pomôžte mu!

## Úloha

Na poli je $n\\leq 100,000$ zavlažovačov, a $m\\leq 20,000$ miest ktoré Adama zaujímajú.

Každý zavlažovač má danú pozíciu na poli, smer a intenzitu. Zavlažovač zavlažuje tú čast poľa na ktorú je nasmerovaný. Ak je napríklad zavlažovač na pozícii (0,0) a je nastavený doprava-hore, zavlažuje všetky políčka s nezápornými súradnicami.

Vlaha na pozícii je súčet intenzít všetkých zavlažovačov zavlažujúcich túto časť poľa.

Pre všetky miesta, ktoré Adama zaujímajú zistite, aká je ich vlaha.

Navyše, v niektorých sadách by chcel Adam vedieť odpovede ihneď - predtým ako sa spýta ďalšiu otázku. Na získanie plného počtu bodov musí váš program vedieť odpovedať *online*.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ ($1 \\leq n \\leq 100,000$).

Na ďalších $n$ riadkoch sú medzerou oddelené čísla $x_i$, $y_i$ -- pozície $i$-teho zavlažovača, $v_i$ -- intenzita $i$-teho zavlažovača a ukazovateľ smeru. ""DP"" znamená dole-pravo, $DL$ je dole-ľavo, $HL$ je hore-ľavo a $HP$ je hore-pravo.

Nasledujú dve medzerou oddelené celé čísla $m$ ($1\\leq m\\leq 20,000$) -- počet miest, ktoré zaujímajú Adama, a $k$ ($0\\leq k\\leq 1$).

Nasleduje $m$ riadkov, na každom z nich sú dve medzerou oddelené čísla, $x$ $y$. Ak $k = 0$, potom pozície miesta sú $x$ $y$.

Ak $k = 1$, nech $a$ je vlhkosť predchádzajúceho miesta. Potom súradnice sú $x \\oplus a$ $y\\oplus a$, kde $\\oplus$ je bitový xor.

Pozície miest a zavlažovačov sa môžu zhodovať. Dva zavlažovače sa môžu nachádzať na rovnakom mieste.

Všetky súradnice v absolútnej hodnote nepresahujú $10^9$. Všetky intenzity sú celé čísla v rozsahu $1$ až $10^4$.

## Formát výstupu

Vypíšte $m$ riadkov, na každom z nich vlahu na $i$-tom mieste, v poradí v akom boli zadané na vstupe.

## Hodnotenie

Existuje $8$ testovacích sád, každá za jeden bod.

V prvých dvoch sadách sú všetky súradnice medzi $0$ a $1000$.

V prvej a tretej sade platí, že $m, n \\leq 1000$.

V štvrtej a piatej sade navyše platí, že všetky súradnice sú medzi $0$ a $10^5$.

Vo všetkých sadách okrem siedmej a ôsmej platí $k = 0$.

## Príklady

```vstup
5
-1 -1 1 DL
-1 1 2 HL
1 -1 4 DP
1 1 8 HP
0 1 3 DP
7 0
-100 100
0 1
2 1
-1 0
0 -5
2 -2
-1000000000 -1000000000
```

```vystup
2
3
11
0
3
7
1
```

```vstup
5
-1 -1 1 DL
-1 1 2 HL
1 -1 4 DP
1 1 8 HP
0 1 3 DP
2 1
-100 100
2 3
```

```vystup
2
3
```

\*Pozície zavlažovačov a miest sú rovnaké ako v prvom vstupe. Lenže v tomto prípade je $k = 1$.
","# Areál zavlažovačov

## Hrubá sila

Keby mal Adam veľa času a trpezlivosti, mohol by na riešenie ísť hrubou silou: vždy, keď ho začne zaujímať nejaké miesto, pre každý zavlažovač samostatne skontroluje či miesto zavlažuje. To vie zistiť v konštantom čase.

Takto vie zistiť vlahu všetkých miest v $O(nm)$ čase a $O(n)$ pamäti.

Žiaľ, hrubá sila stačí len na prvú a tretiu sadu.

## Malé pole

Čo ak je Adamove pole malé? Potom by si Adam mohol spočítať odpoveď pre *každé* miesto na poli, a potom vie odpovedať na otázku o akomkoľvek mieste, ktoré by ho mohlo zaujímať.

Ako to vie spočítať? Mohol by napríklad použiť 2D prefixové súčty. Viac o tom, ako ich viete použiť sa už dozviete v [KSP kuchárke](https://www.ksp.sk/kucharka/2d_prefixove_sumy/).

Presnejšie, Adam si chce spraviť prefixové súčty pre každý zo štyroch smerov, a vlahu na mieste záujmu potom dostane ako sumu vláh zo všetkých smerov. Toto vie Adam spočítať v časovej zložitosti $O(m + n + (\\max(x_i, y_i))^2)$, a v pamäti $O((\\max(x_i, y_i))^2)$.

## K rýchlemu riešeniu

Hrubá sila očividne nestačí. Skúsme sa najskôr zamyslieť nad prípadom, že všetky zavlažovače sú orientované rovnako. Pozrime sa na miesto ktoré Adama momentálne zaujíma. Ktoré zavlažovače ho zasahujú?

Ako môžme vidieť na ilustračnom obrázku, vyznačené miesto (červeným) zavlažujú všetky zavlažovače v červenom rohu, takže aby sme rýchlo zistili vlahu, chceli by sme vedieť zistiť rýchlo spočítať sumu vláh zavlažovačov umiestnených v danom rohu. Skúsenejšiemu riešiteľovi už možno niečo hovorí, že by sa Adamovi zišiel intervalový strom.

### Vieme miesta vopred

Na prvý pohľad by to mohlo vyzerať, že bude treba dvojrozmerný intervalový strom, ale ukáže sa, že ten vôbec netreba. Najskôr sa pozrime na prípad, že Adam vie, ktoré miesta ho zaujímajú vopred.

Zoberme si prípad, že všetky zavlažovače smerujú hore a doprava (ako na obrázku hore). Utrieďme si ich v smere x-súradnice (zľava doprava), a utrieďme si tiež všetky miesta v smere x-súradníc. Potom postupne prechádzajme miesta a zavlažovače zľava doprava a udržujme si dátovú štruktúru, ktorá nám bude hovoriť, pre každú y-súradnicu, koľko je suma vláh zo všetkých zavlažovačov, ktoré sme videli doteraz, na tejto súradnici. Všimnime si (ak sú všetky orientované hore a doprava), že pokiaľ máme spracované všetky zavlažovače naľavo alebo s rovnakou x-súradnicou ako miesto, ktoré nás zaujíma, tak potom vlaha na mieste záujmu je suma vláh všetkých spracovaných zavlažovačov s y-pozíciou menšou alebo rovnou ako miesto záujmu.

Takže nám na efektívne riešenie stačí vedieť spočítať a aktualizovať sumy na intervaloch. To ide napríklad [intervalovým stromom](https://www.ksp.sk/kucharka/intervalovy_strom/).

### Veľmi veľké pole

Ak by sme si chceli v intervalovom strome pamätať vlahy na všetkých y-súradniciach, potom nám riešenie zaberie $O((n+m)\\log\\max_i y_i + \\max_i y_i)$ času a $O(n + m + \\max_i y_i)$ pamäte. Pre pole veľkosti $10^9$ nám to nestačí.

Ako to zlepšiť? Všimnime si, že nás zaujíma iba relatívna pozícia zavlažovačov a miest, a tých je málo. Teda si zmeňme súradnicovú sústavu pomocou *kompresie súradníc*. To znamená, utrieďme si všetky x a y súradnice na vstupe, a potom zmenňme súradnice vstupu tak, že najmenšia x-súradnica sa zmení na 0, druhá najmenšia na 1, atď. Takto sa nám zmenší počet y-súradníc ktoré nás zaujímajú na dostatočne málo a dostaneme (offline) riešenie v čase $O((n+m)\\log n)$ a pamäti $O(m+n)$.

### Online riešenie

Čo ak nám miesta prichádzajú postupne?

Nevieme použiť predchádzajúce riešenie: miesta nám neprichádzajú utriedene, potrebovali by sme sa vedieť ""dostať"" ku intervalovému stromu v rôznych *časoch*, napríklad ""po pridaní všetkých zavlažovačov s x-súradnicou menšou než $5462$"".

Alebo by sme to mohli urobiť? Ukazuje sa že áno, riešením je *perzistentný intervalový strom*. Vysvetlenie ako na perzistentný intervaláč vám nechávam napríklad v [tomto videovzoráku](https://www.youtube.com/watch?v=bmSa2HAPtE8).

Riešenie pomocou perzistentného intervaláča funguje v čase $O((m+n)\\log n)$ a v pamäti $O(n\\log n)$ a dá vám plný počet bodov.

### Čo s inými smermi?

Pozorný čitateľ ešte zbystrí: hovorím, že už máme riešenie, ale starali sme sa zatiaľ len o jeden smer? Veď zavlažovače vedia byť aj inak orientované!

Ukáže sa, že nám stačí roztriediť si zavlažovače do skupín podľa smeru zavlažovania, a pre každý mať separátny intervaláč. Riešenie vieme použiť pre každý smer rovnaké, len si je treba situáciu vhodne rotovať. Toto nám pridá do časovej a pamäťovej zložitosti iba konštantný faktor.
",10
1da76ad6eb03b427,ksp,"# Tajná aplikácia

Paulínka žije v meste, ktoré si vieme predstaviť ako nekonečnú štvorčekovú sieť. Na serveri Firmy Komerčných Softvérov našla tajný prototyp novej revolučnej aplikácie, ktorá dokáže nájsť trasu do ľubovoľného miesta v tomto meste v konštantnom čase. Hneď ju išla vyskúšať a vytlačila si trasu do nového obchodného centra v meste. Ako vychádzala zo svojho domu, vytlačené inštrukcie sa jej v daždi premočili. Z pôvodne vytlačených šípok zostali len vertikálne a horizontálne čiary. Kam najďalej od pôvodného cieľa sa môže Paulínka dostať?

## Úloha

Paulínka mala zoznam šípok (`<`, `>`, `^` a `v`), z ktorých sa jej stratila informácia o ich smere. Teraz vie iba, či boli šípky vertikálne alebo horizontálne. Na svojej ceste sa Paulínka vždy musí rozhodnúť, či pôjde doľava/doprava, ak má napísanú horizontálnu čiarku, resp. hore/dole, ak má napísanú vertikálnu čiarku. Paulínka býva v bode $(0, 0)$ štvorčekovej siete. Zistite, ako by musela vyzerať Paulínkina cesta, keby sa čo najviac stratila (teda skončila by čo najďalej od pôvodného cieľa cesty).

## Formát vstupu

Na vstupe sa nachádza jeden reťazec dĺžky $n$ -- výpis pôvodnej cesty, zložený zo znakov `<`, `>`, `^` a `v`.

## Formát výstupu

Na výstup napíšte jeden riadok dĺžky `n` -- výpis cesty, zložený zo znakov `<`, `>`, `^` a `v`, ktorú by Paulínka musela prejsť, aby skončila čo najďalej od pôvodného cieľa (Euklidovská vzdialenosť).

## Hodnotenie

Sú 4 sady vstupov, v ktorých platia tieto obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :-------------- | ----: | -------: | --------: | ------------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $10,000$ | $1,000,000$ |

## Príklad

```vstup
>>^
```

```vystup
<<v
```

```vstup
v<<vvv<vv<<<
```

```vystup
^>>^^^>^^>>>
```
","# Tajná aplikácia {bodypopis=12 bodyprogram=8 vzorak=""Gardener"" mail=""adam.zahradnik@trojsten.sk""}

## Myšlienka riešenia

Na to, aby sme vedeli vytvoriť cestu, ktorá bude viesť čo najďalej od tej pôvodnej, musíme najprv zistiť, kde končí cesta na vstupe. Prečítame vstup a pre každý znak posunieme Paulínku na štvorčekovej sieti. Paulínka začína v bode $(0, 0)$. Ak na vstupe máme `>`, pripočítame k jej x-ovej súradnici $1$, ak `<`, jednotku odčítame. Podobne to bude fungovať aj s `^` a `v`. Po prečítaní celého vstupu vieme súradnice bodu, v ktorom Paulínka mala skončiť.

Teraz sa na vstup pozrieme ešte raz a budeme vymieňať šípky tak, že všetky šípky, ktoré sú orientované smerkom **k cieľu** vymeníme za opačné. Teda, ak na vstupe máme šípku `<` a cieľ je naľavo od $(0, 0)$, vymeníme ju za `>`. Keby bol cieľ napravo, šípku necháme tak, ako bola.

## Časová a pamäťová zložitosť

Keďže sa iba niekoľkokrát pozrieme na celý vstup, časová zložitosť bude lineárne závislá od dĺžky vstupu -- $O(n)$.

Pamäťová zložitosť bude tiež $O(n)$, keďže si musíme pamätať celý vstup a konštantný počet premenných -- súradnice pôvodného cieľa.
",1
1f4bb25b26be51b6,ksp,"# Kapustnica Trojstenu

Ako sa sa dni krátili a noci predlžovali, Naďka prehľadávala celú T2 v nádeji, že nájde čokoládu, ktorú plánuje doniesť na kapustnicu Trojstenu ako zákusok. ""Aha, tak tu si!"" zvolala, keď ju konečne našla v Krtkovom zakladači. Naďkina čokoláda však nebola len tak obyčajná. Mala rozmery $1 \\times k$ a každá tablička bola buď mliečna, alebo horká. Dokonca sa Naďka rozhodla, že túto čokoládu nerozdá len tak náhodným spôsobom -- každému Trojstenákovi na kapustnici dá jeden súvislý kus čokolády, ktorý je dlhý najmenej $l$ a najviac $r$ a obsahuje práve jednu horkú tabličku. Dokáže Naďka takúto čokoládu rozdeliť medzi Trojstenákov na kapustnici bez toho, aby jej nejaká zvýšila?

## Úloha

Na kapustnicu príde $n$ Trojstenákov medzi ktorých chce Naďka rozdeliť svoju čokoládu s rozmermi $1 \\times k$. Platia nasledujúce pravidlá:

- každá tablička čokolády je buď mliečna, alebo horká,
- každý Trojstenák dostane práve jeden súvislý kus čokolády, ktorého najmenšia dĺžka môže byť $l$ a najväčšia $r$,
- každý Trojstenák dostane práve jednu horkú tabličku.

Vašou úlohou je povedať, či Naďka dokáže čokoládu rozdeliť bez toho, aby jej nejaký kúsok ostal.

## Formát vstupu

V prvom riadku vstupu dostanete štyri celé čísla oddelené medzerami:

- počet Trojstenákov na kapustnici $n$,
- počet tabličiek čokolády $k$,
- najkratší možný kus čokolády $l$,
- najdlhší možný kus čokolády $r$.

Na nasledujúcom riadku dostanete popis čokolády, ktorý obsahuje zasebou idúce `0` a `1`, pričom `0` je mliečna tablička a `1` je horká tablička.

## Formát výstupu

Vypíšte jeden riadok obsahujúci odpoveď `ano`, ak sa čokoláda dá rozdeliť bez toho, aby nejaká zvýšila alebo `nie`, ak sa to nedá.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:--------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $10$ | $100$ | $1,000$ | $2,000$ | | $1 \\leq k \\leq$ | $200$ | $10,000$ | $500,000$ | $1,000,000$ | | $1 \\leq l \\leq$ | $10$ | $50$ | $500$ | $500$ | | $l \\leq r \\leq$ | $20$ | $100$ | $750$ | $750$ |

## Príklad

```vstup
3 11 2 4
01000010001
```

```vystup
ano
```

_Naďka môže čokoládu rozdeliť napríklad takto: `0100 0010 001`_

```vstup
3 11 2 4
01000000101
```

```vystup
nie
```

_Naďka nevie rozdeliť čokoládu tak, aby splnila všetky podmienky a aby jej žiadna tablička nezvýšila._
","# Kapustnica Trojstenu

Prvá vec, ktorú si treba uvedomiť pri riešení tejto úlohy je, že ak má čokoláda viac alebo menej horkých tabličiek ako je počet Trojstenákov, tak odpoveď je automaticky `nie`, pretože nevieme splniť všetky podmienky.

## Pomalé riešenie

Asi najviac priamočiare riešenie je vyskúšať postupne všetky možné rozdelenia čokolády a skontrolovať, či v každom súvislom kúsku je práve jedna horká tablička. Takéto niečo vieme urobiť jednoduchou rekurziou. Začneme pri tom, že naša rekurzia odkrojí z čokolády súvislý kus, ktorý má $l$ tabličiek. Akonáhle sme čokoládu rozdelili na $n$ kusov -- aby každý Trojstenák dostal jeden kus -- skontrolujeme, či sú všetky podmienky splnené a či nám žiadna čokoláda nezvýši. Ak je všetko v poriadku, môžeme vypísať `ano`. Ak niektorá z podmienok splnená nie je, pokračujeme ďalej v rekurzii. Rekurzia bude rozdelovať čokoládu na kúsky s $l$ až $r$ tabličkami. Akonáhle sme prešli všetky možnosti ako sa dá čokoláda rozdeliť a ani raz sme nenašli riešenie, ktoré spĺňa všetky podmienky, vypíšeme `nie`.

## Vzorové riešenie

Na vyriešenie tejto úlohy však nepotrebujeme zbytočne skúšať všetky existujúce možnosti. Pre každú horkú tabličku nás zaujíma, na akom indexe sa nachádza, aby sme vedeli odvodiť intervaly, v ktorých môžeme rozdeliť čokoládu, aby sme určite mali v každom kúsku práve jednu horkú tabličku. Preto si prejdeme celú čokoládu a zapíšeme si indexy horkých tabličiek do poľa $h$. Na čokoládu pozeráme zľava doprava a počiatočný interval je $(0, 0)$, čo je na začiatku čokolády. Čísla v intervaloch ukazujú na miesta medzi dvoma tabličkami. Ak máme napríklad interval $(2, 5)$, tak čokoládu môžeme rozdeliť pred tabličkou na druhom indexe až za tabličkou na štvrtom indexe.

Vytvoríme si funkciu, ktorá pre každú horkú tabličku vypočíta interval, v ktorom sa môže rozdeliť čokoláda za danou tabličkou. Začiatok intervalu musí byť vždy aspoň o $l$ väčší ako predchádzajúci začiatok intervalu, pretože najmenej $l$ tabličiek môžeme oddeliť od zvyšku čokolády. Avšak, môže sa nám stať, že aj keby oddelíme kus čokolády s $l$ tabličkami, tak medzi nimi nebude horká tablička. Takýmto možnostiam sa chceme vyhnúť, pretože hneď vieme, že nespĺňajú všetky podmienky a nemá zmysel s nimi ďalej pokračovať. V takomto prípade musí byť začiatok intervalu za horkou tabličkou. Takže začiatok intervalu sa dá napísať ako $\\max(\\mathrm{zaciatok_predchadzajuceho_intervalu} + l, h[i] + 1)$.

Koniec intervalu musí byť vždy maximálne o $r$ väčší ako koniec predchádzajúceho intervalu, pretože môžeme od čokolády oddeliť kus s maximálne $r$ tabličkami. Môže však nastať situácia, kedy v týchto $r$ tabličkách už bude aj druhá horká tablička, čo nechceme, pretože by sme nesplnili podmienky. Takže chceme čokoládu rozdeliť najviac pred nasledujúcou horkou tabličkou. Koniec intervalu preto vieme zapísať ako $\\min(\\mathrm{koniec_predchadzajuceho_intervalu} + r, h[i + 1])$.

Aby kód fungoval poriadne, musíme si na koniec poľa $h$ pridať aj index $k$, čo je koniec čokolády, pretože to je najďalej, kde vieme rozdeliť čokoládu. Chceme sa vyhnúť tomu, že by sme chceli rozdeliť čokoládu za jej koncom, pretože toľko čokolády na rozdávanie nemáme.

Vždy, keď si vypočítame interval pre danú horkú tabličku, skontrolujeme či začiatok je menší alebo rovný koncu intervalu. Ak by bol začiatok väčší, tak môžeme rovno vypísať `nie`, pretože neexistuje miesto, kde by sme dokázali čokoládu rozdeliť, aby sme splnili všetky podmienky.

Úplne na koniec nás zaujíma posledný interval. Ak koniec tohoto intervalu je menší ako celková dĺžka čokolády $k$, tak Naďka nevie rozdať celú čokoládu a vypíšeme `nie`. Ak však prešlo hladko a nestretli sme sa so žiadnym problémom, môžeme vypísať `ano`, pretože sme splnili všetky podmienky a každý Trojstenák dostal svoj kus čokolády, bez toho, aby Naďke nejaká zvýšila.

## Časová a pamäťová zložitosť

Na začiatku sme prešli celú čokoládu, aby sme zistili, na akých indexoch sú horké tabličky -- $O(k)$. Potom sme $n$-krát vypočítali interval rezu -- $O(n)$. Dokopy je teda časová zložitosť $O(k + n)$.

Pamätáme si čokoládu a nejaké konštantne veľké premenné k tomu, takže pamäťová zložitosť je $O(k)$.
",4
bbfac1a6f3881311,ksp,"# Absurdne drahá pizza {zadanie=""Marcel"" mail=""marcel.palaj@trojsten.sk"" bodypopis=12 bodyprogram=8}

__Miestnosť T2, niekedy začiatkom novembra:__

""Už ste to počuli? Zdraželi pizzu v matickej jedálni! Čo budeme teraz robiť? Sme chodobní študenti, toľko si nemôžeme dovoliť zaplatiť za pizzu."", rozliehalo sa v T2.

""Nebojte, mám plán"", povedal Krtko, ""Aďo doniesie tú pizza piecku čo sľúbil, a budeme si piecť pizzu tu.""

""To by som nerobil, viete ako veľmi zdraželo droždie?"", ozval sa Kubo, ktorý sa z ničoho nič objavil v T2 tiež.

""Tak budeme robiť kváskové cesto. To len zoženieme zopár kváskov, a oni potom budú rásť samé...""

...

Tak sa aj stalo. Nakúpili sa kvásky do T2, s tým, že sa z nich bude piecť pizza. Bohužiaľ, prišiel lockdown, a vedúci prestali chodiť do T2. A tak tam kvásky len tak ležali, nikto z nich nebral, a nepozorovane sa delili na viac a viac kváskov.

Vedeli by ste vypočítať, koľko kváskov bude v T2, keď sa vrátime do školy?

## Úloha

Do T2 sa nakúpilo presne $n$ kváskov.

Rast kváskov funguje nasledovne: Každý kvások má svoj čas -- počet dní do rozdelenia kvásku na viac kváskov. Tento čas je číslo od $0$ po $8$ (vrátane). Kvások sa rozdelí vtedy, keď je jeho čas rovný $0$. Z každého kvásku vznikne presne $k$ _ďalších_ kváskov s časom $8$. Čas pôvodného kvásku sa nastaví späť na $6$.

Vašou úlohou je povedať, koľko kváskov bude v T2 po $t$ dňoch.

## Formát vstupu

Na prvom riadku sa nachádzajú $3$ medzerou oddelené čísla $n$ -- počet kváskov v T2, $k$ -- počet kváskov na ktoré sa každý kvások rozdelí keď dosiahne čas 0 a $t$ -- deň, v ktorý nás zaujíma počet kváskov.

Na druhom riadku sa nachádza $n$ medzerou oddelených čísel $c_i$ -- časy jednotlivých kváskov v deň $0$.

## Formát výstupu

Na výstup vypíšte jedno číslo, počet kváskov po $t$ dňoch. Dajte si pozor, že toto číslo môže byť veľké. Odporúčame použiť $64$ bitovú premennú (`long long` v C/C++).

Nezabudnite za číslom vypísať znak konca riadku.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |----: | ----: | ----: | ----: | | $1 \\leq n \\leq$ | $20$ | $40$ | $50$ | $60$ | | $0 \\leq k \\leq$ | $1$ | $5$ | $50$ | $150$ | | $1 \\leq t \\leq$ | $20$ | $40$ | $150$ | $180$ |

V druhej sade navyše platí, že všetky časy kváskov sa rovnajú.

## Príklad

```vstup
3 2 3
2 0 6
```

```vystup
7
```

_Kvásky budú vyzerať nasledovne. Po prvom dni vzniknú z druhého kvásky $2$ ďalšie, a teda (ak nové kvásky pridávame na koniec) kvásky budú mať časy `1 6 5 8 8`. Po druhom dni budú mať kvásky časy `0 5 4 7 7`. Po treťom vzniknú ďalšie dva kvásky (tie opäť pridávame na koniec), a teda budú mať časy: `6 4 3 6 6 8 8`. Kváskov po $3$ dňoch bude 7._

```vstup
3 0 2
1 2 3
```

```vystup
3
```

_V tomto prípade z každého kvásku vznikne $0$ ďalších, a teda sa počet kváskov vôbec nemení._

```vstup
1 1 11
1
```

```vystup
4
```

_V tomto prípade v čase 10 budú časy kváskov `4 6 6 8`_
","# Absurdne drahá pizza

## Priamočiare riešenie

Najjednoduchšie riešenie je krok po kroku odsimulovať, ako sa mení počet kváskov. Vieme to urobiť tak, že budeme mať pole, kde na indexe $i$ budeme mať čas kvásku $i$. Potom stačí $t$ krát prejsť celé pole, a každému kvásku znížiť čas o $1$. Ak je nový čas kvásku rovný $0$, tak na koniec poľa pridáme $k$ nových kváskov s časom $8$, a tomuto kvásku nastavíme čas opäť na $6$. Je treba si dať pozor, aby sme v tomto prechode poľom časy novopridaných kváskov už nezmenšovali, alebo aby sme pridávali nové kvásky s vekom $9$ a teda po prejdení celého poľa mali tieto kvásky správny čas.

Výsledok, počet kváskov po $t$ dňoch je rovný dĺžke poľa.

Čo sa týka časovej zložitosti, tak náš program $t$ krát prejde celé pole. Pole bude mať na konci dĺžku najviac $nk^{t/6}$. Prečo? Ak si predstavíme, že by mali všetky kvásky rovnaký čas, a nové kvásky by vznikali s časom $6$, tak každých $6$ dní by z sa počet kváskov zväčšil $k$ krát. To znamená, že po $6$ dňoch by sa počet kváskov zväčšil na $k$ násobok, po $12$ dňoch na $k \\cdot k = k^2$ násobok, a po $t$ dňoch na $k^{t/6}$ násobok. (Všimnite si, že sme urobili horný odhad, keďže sme predpokladali, že nové kvásky vznikajú s menším časom, a teda v skutočnosti z nich nové kvásky vzniknú skôr.) Pole teda prejdeme $t$ krát, a vždy bude mať dĺžku najviac $nk^{t/6}$.

Časová zložitosť je teda rovná tomu, že $t$ krát prejdeme pole s maximálnou dĺžkou $nk^{t/6}$, takže $O(t \\cdot nk^{t/6})$. Pamäťová zložitosť je rovná výslednej dĺžke poľa, teda $O(nk^{t/6})$.

Takéto riešenie stačí na prvé $2$ sady.

## Vzorové riešenie

Môžeme si uvedomiť, že v predchádzajúcom riešení robíme pre všetky kvásky v zásade tú istú vec: zmenšíme ich čas, a poprípade pridáme nejaké nové. Takéto niečo ale nemusíme robiť pre každý kvások zvlášť, môžeme to robiť pre všetky kvásky s rovnakým časom spolu. Ak máme napríklad tri kvásky, a z každého z nich ide akurát vzniknúť $6$ nových, tak dokopy vieme povedať, že z nich vznikne $18$ nových kváskov s vekom $8$.

Skúsme si teda namiesto poľa, v ktorom na indexe $i$ máme čas kvásku $i$ pamätať kvásky inak. Pamätajme si ich tak, že v poli na indexe $i$ budeme mať počet kváskov s časom $i$. Takto dosiahneme, že dĺžka poľa sa nebude zväčšovať, ale bude mať vždy dĺžku $9$ (keďže najväčší možný čas kvásku je $8$).

Ako teda presne budeme simulovať rast kváskov?

Opäť $t$ krát prejdeme celé pole, a kvásky na indexoch $1$ až $8$ posunieme na o $1$ menší index (zmenšíme im čas o $1$), kvásky na indexe $0$ pripočítame ku kváskom na indexe $6$ a vytvoríme príslušný počet nových kváskov s časom $8$. Treba si dať pozor na to v akom poradí to robíme, aby sme kvásky z indexu $0$, ktoré presunieme na index $6$ už viac neposúvali.

Výsledok, teda počet kváskov zistíme tak, že spočítame počty kváskov s jednotlivými časmi.

Náš program $t$ krát prejde celé pole, a každý raz urobí niekoľko málo operácií (pripočítanie a vynásobenie zopár čísel). Pole má celý čas dĺžku $9$, a prejdeme ho $t$ krát, takže časová zložitosť je $O(9t) = O(t)$.

Čo sa týka pamäťovej zložitosti, tak náš program si okrem niekoľko málo premenných pamätá len pole dĺžky $9$, takže pamäťová zložitosť je $O(9) = O(1)$.
",2
9fba5911dd8371da,ksp,"# Obmedzený pohyb

Farmár Bob sa nedávno rozhodol, že si na svoju farmu dá konečne zaviesť inžinierske siete. Už o pár dní sa mu to na záhrade len tak hemžilo robotníkmi kopajúcimi dlhočizné jamy pre rôzne káble a potrubia. Firma, ktorá túto robotu robila, však nanešťastie skrachovala a Boba nechala s rozkopanou záhradou. Bob sa však po záhrade potrebuje pohybovať, musí sa predsa starať o petržlen, baklažán, cibuľku, jahody ... Keďže skákanie cez jamy je príliš nebezpečné, obchádzať sa mu ich nechce a zasypávanie všetkých jám by trvalo príliš dlho, zobral Bob niekoľko dosák a položil ich krížom cez niektoré jamy ako mosty.

Po čase však Bob zistil, že niektoré z týchto dosák by sa mu zišli pri oprave plota. Rozhodol sa teda niektoré jamy zasypať, aby tým nejaké dosky uvoľnil. Ale ktoré? Zišlo by sa mu pre každú jamu vedieť, ktoré dosky cez ňu vlastne vedú.

## Úloha

Na záhrade je $n$ jám očíslovaných $1, 2, \\dots, n$ a $m$ dosák očíslovaných $1, 2, \\dots, m$. Jamy aj dosky budeme pre jednoduchosť považovať za úsečky v rovine. Žiadne dve jamy nemajú spoločný bod, ani žiadne dve dosky nemajú spoločný bod. Navyše platí, že **každá doska sa pretína s práve jednou jamou** (pod pojmom ""pretína sa"" myslíme, že úsečky majú práve jeden spoločný bod a tento bod nie je koncovým bodom žiadnej z nich). Na vstupe dostanete zadané pozície všetkých jám aj dosák. Pre každú jamu vypíšte zoznam dosák, ktoré ju pretínajú.

## Formát vstupu

V prvom riadku vstupu sú dve celé čísla $n, m$ ($1 \\leq n, m \\leq 50,000$) -- počet jám a počet dosák. V každom z nasledujúcich $n$ riadkov je popis jednej jamy. Popis jamy tvoria štyri celé čísla $x_1, y_1, x_2, y_2$ $(-1,000,000 \\leq x_1, y_1, x_2, y_2 \\leq 1,000,000)$, ktoré popisujú to, že daná jama má koncové body $(x_1, y_1)$ a $(x_2, y_2)$. V nasledujúcich $m$ riadkoch sú popisy dosák, v rovnakom formáte. Jamy aj dosky sú očíslované v poradí, v akom sú uvedené na vstupe.

## Formát výstupu

Pre každú jamu (v poradí, ako sú očíslované), vypíšte jeden riadok. Tento riadok má obsahovať čísla dosák, ktoré túto jamu pretínajú, oddelené **presne jednou medzerou**, vo **vzostupnom poradí**. V prípade, že jamu nepretína žiadna doska, vypíšte pre ňu prázdny riadok.

## Príklad

```vstup
3 4
1 -1 1 4
-1 -2 -3 0
4 3 5 0
3 1 -1 1
3 5 -2 2
5 5 4 -4
3 -1 -1 0
```

```vystup
1 2 4

3
```

_Situácia na Bobovej záhrade vyzerá nasledovne (plné čiary sú jamy, prerušované čiary sú dosky):_
","# Obmedzený pohyb

## Pretínanie úsečiek

Kľúčovou časťou tejto úlohy je zisťovanie, či sa dve úsečky pretínajú. Dve úsečky $AB$ a $CD$ sa pretínajú vtedy a len vtedy, keď úsečka $AB$ pretína priamku $CD$ a súčasne úsečka $CD$ pretína priamku $AB$. To, že úsečka $CD$ pretína priamku $AB$ vlastne znamená, že body $C$ a $D$ ležia v opačných polrovinách vzhľadom na priamku $AB$. A to vieme ľahko skontrolovať pomocou vektorového súčinu^\[viac o vektorovom súčine a jeho využití si môžete prečítať na <https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin>\] tak, že skontrolujeme, či majú súčiny $(B - A) \\times (C - A)$ a $(B - A) \\times (D - A)$ opačné znamienka (notáciou $Y - X$ tu myslíme vektor z $X$ do $Y$). Keďže nás zaujíma iba pretínanie vo vnútorných (nie koncových) bodoch úsečiek, budeme vyžadovať, aby oba vektorové súčiny boli nenulové. To, či úsečka $AB$ pretína priamku $CD$ overíme úplne rovnako.

## Jednoduché riešenie

Keď už vieme v čase $O(1)$ overovať, či sa dve úsečky pretínajú, ľahko napíšeme riešenie s časovou zložitosťou $O(n \\cdot m)$ -- pre každú jamu sa pozrieme na všetky dosky a tie, ktoré pretína, vypíšeme.

## Vzorové riešenie

Dá sa to však aj rýchlejšie, konkrétne v čase $O((n+m) \\log (n+m))$. Použijeme techniku s názvom _zametanie_, ktorá sa v geometrii v rôznych obmenách používa pomerne často.

Pre jednoduchosť budeme chvíľu predpokladať, že na vstupe sa nevyskytujú zvislé úsečky. Nakoniec si ukážeme, ako sa vieme vysporiadať aj s nimi.

Vezmeme myslenú zvislú priamku (ďalej ju budeme volať zametacia priamka), ktorú na začiatku umiestnime dostatočne ďaleko naľavo, tak aby bola naľavo od všetkých úsečiek, ktoré sme dostali na vstupe. Postupne posúvame zametaciu priamku doprava, až kým ju nedostaneme napravo od všetkých úsečiek na vstupe. Počas tohto posúvania si vo vhodnej dátovej štruktúre udržiavame zoznam úsečiek, ktoré momentálne zametaciu priamku pretínajú, usporiadaný podľa $y$-ovej súradnice bodu pretnutia (teda úsečka, ktorej priesečník s našou priamkou je najnižšie, bude v zozname prvá a úsečka, ktorá zametaciu priamku pretína najvyššie bude posledná). Keďže v skutočnosti nás zaujímajú iba momenty, keď sa niečo sa deje s týmto zoznamom, stačí nám postupne odsimulovať všetky udalosti, pri ktorých sa zoznam mení (pohyb priamky medzi týmito udalosťami je aj tak nuda).

Zoznam sa bude meniť pri troch druhoch udalostí:

1. Zametacia priamka ,,narazila'' na ľavý koniec nejakej novej úsečky. Pri tejto udalosti treba danú úsečku pridať do zoznamu na správne miesto, keďže odteraz bude našu priamku pretínať aj ona.

1. Zametacia priamka ,,narazila'' na pravý koniec nejakej úsečky. Vtedy treba danú úsečku zo zoznamu vymazať, keďže odteraz už zametaciu priamku pretínať nebude.

1. Zametacia priamka ,,narazila'' na priesečník dvoch úsečiek. Vtedy treba tieto dve úsečky v zozname vymeniť, keďže tá, ktorá doteraz pretínala zametaciu priamku nižšie ju bude odteraz pretínať vyššie a naopak.

Na to, aby sme udalosti mohli spracúvať, musíme, samozrejme, vedieť, kedy nastanú. Za týmto účelom budeme mať haldu (alebo inú prioritnú frontu), na ktorej vrchu bude prvok s najnižšou $x$-ovou súradnicou. Do tejto haldy budeme dávať všetky budúce udalosti, o ktorých už vieme, kedy nastanú. Z nej budeme vždy vedieť vybrať najbližšiu udalosť, ktorú máme spracovať.

Už pri načítaní vstupu vieme povedať, kedy (teda pri akej $x$-ovej súradnici zametacej priamky) nastanú udalosti prvých dvoch druhov. Tieto udalosti si teda môžeme rovno nasypať do haldy. S udalosťami tretieho typu bude trochu väčší problém, keďže na začiatku netušíme, kde sa jednotlivé úsečky pretínajú. Našťastie nás nič nenúti hádzať všetky tieto udalosti do haldy hneď na začiatku, môžeme ich tam pridávať ,,za behu''. Jediným obmedzením je, že každú udalosť musíme do haldy pridať skôr, než nastane (inak by sme nevedeli, že ju máme odsimulovať).

Všimnime si, že keď zametacia priamka ide naraziť na priesečník dvoch úsečiek, tesne predtým sú tieto úsečky v zozname úsečiek pretínajúcich zametaciu priamku hneď vedľa seba. Ak by sme teda pri každej zmene zoznamu celý tento zoznam prešli a pre každú dvojicu susedných úsečiek skontrolovali, či sa niekedy v budúcnosti nepretnú (a ak áno, pridali by sme túto udalosť do haldy), určite by sme žiaden priesečník nevynechali. To by, samozrejme, bolo dosť neefektívne, keďže niektoré dvojice úsečiek by sme takto zbytočne kontrolovali veľakrát. V skutočnosti sa nám stačí po každej zmene v zozname pozrieť na tie dvojice úsečiek, ktoré pred zmenou neboli susedné a po zmene sú. Konkrétne:

1. Po pridaní úsečky do zoznamu sa treba pozrieť, či sa pretne so svojím spodným susedom (ak nejakého má) a či sa pretne s vrchným susedom.

1. Po zmazaní úsečky zo zoznamu sa treba pozrieť, či sa jej niekdajší susedia (ktorí odteraz susedia navzájom) pretnú.

1. Po výmene dvoch úsečiek sa treba pozrieť, či sa tieto dve úsečky pretnú so svojimi novými susedmi (tá, ktorá bola pred výmenou nižšie, má teraz nového horného suseda a tá, ktorá bola vyššie, má nového spodného suseda).

Pri spracovaní ľubovoľnej udalosti sa teda pozrieme na $O(1)$ (jednu alebo dve) novovzniknutých dvojíc susedných úsečiek. Keď o nejakej dvojici zistíme, že sa pretne, poznačíme si to. Ak sme navyše doteraz o tomto priesečníku nevedeli, pridáme ho do haldy. Takýmto spôsobom zaručene nevynecháme žiadnu udalosť, ani žiadnu nespracujeme dvakrát. Navyše popri tom nájdeme všetky priesečníky, čo je presne to, čo potrebujeme.

#### Zvislé úsečky

Ostáva ešte doriešiť niekoľko detailov. Prvým z nich sú zvislé úsečky. Tie môžeme ošetriť napríklad tak, že zavedieme štvrtý typ udalosti: ,,narazenie'' zametacej priamky na zvislú úsečku. O týchto udalostiach vieme už po načítaní vstupu povedať, kedy nastanú. Spracovať ich môžeme tak, že v zozname úsečiek pretínajúcich zametaciu priamku binárne vyhľadáme prvú a poslednú úsečku, ktorá danú zvislú úsečku pretína a pre všetky úsečky v zozname medzi nimi si poznačíme priesečník. Zoznam pritom nemeníme, keďže hneď, ako sa zametacia priamka pohne, zoznam sa vráti do pôvodného stavu.

#### Súčasné udalosti

Druhým problémom je, čo budeme robiť, keď naraz nastane viac ako jedna udalosť. Odpoveď je jednoduchá: odsimulujeme ich jednu po druhej, v ľubovoľnom poradí. Keďže máme zaručené, že úsečky sa pretínajú vždy len vo vnútorných bodoch a v žiadnom bode sa nepretínajú viac ako dve úsečky, udalosti nastávajúce naraz sa nemôžu ovplyvňovať.

#### Poloha priesečníka

Tretí detail je, že počas zametania budeme občas potrebovať pre dané dve úsečky zistiť, kde (na akej $x$-ovej súradnici) sa pretnú. Už sme si ukázali, ako zistiť, _či_ sa pretnú, neukázali sme si však, ako zistiť _kde_ sa pretnú. Priesečník dvoch úsečiek (ak existuje) je priesečník priamok, na ktorých tieto úsečky ležia. Rovnice týchto priamok vieme zapísať v tvare $a_1 x + b_1 y + c_1 = 0$ a $a_2 x + b_2 y + c_2 = 0$. Ak $(x, y)$ je ich priesečník, potom musia $x$ a $y$ spĺňať rovnice oboch priamok. Máme teda sústavu dvoch rovníc o dvoch neznámych, ktorej riešením dostaneme

$$x = \\frac{b_1 c_2 - b_2 c_1}{b_2 a_1 - b_1 a_2} \\text{.}$$

Ak máme úsečku zadanú jej koncovými bodmi $(x_1, y_1), (x_2, y_2)$, parametre $a, b, c$ jej rovnice vieme dopočítať tak, aby jej oba z bodov $(x_1, y_1)$ aj $(x_2, y_2)$ vyhovovali a dostaneme niečo ako

$$a = y_2 - y_1 \\text{,}$$ $$b = x_1 - x_2 \\text{,}$$ $$c = -(a x_1 + b y_1) \\text{.}$$

#### Dátová štruktúra zoznamu

Štvrtým (a najväčším) detailom je voľba vhodnej dátovej štruktúry pre zoznam úsečiek pretínajúcich zametaciu priamku. Vhodnou štruktúrou sa ukazujú byť vyvažované binárne vyhľadávacie stromy (v angličnite Binary Search Trees, skratka BST). Tie nám totiž umožňujú mať usporiadaný zoznam prvkov, v ktorom sa dá vyhľadávať, pridať prvok na ľubovoľnú pozíciu aj zmazať ľubovoľný prvok v čase $O(\\log N)$. V C++ sú vyhľadávacie stromy implementované v `std::set` a táto implementácia sa dá v riešení použiť, je to však dosť bolestivé a silno neodporúčané. Problém je v tom, že `set`e treba povedať, ako má prvky porovnávať a to sa v našom prípade v čase mení -- vždy, keď zametacia priamka prejde nejakým priesečníkom. Preto je veľmi náročné udržať `set` v konzistentnom stave.

Lepšia voľba je napísať si vlastný BST, na naše účely sa dobre hodí napríklad treap^\[viac o treapoch na <https://www.ksp.sk/kucharka/treap>\] s implicitnými kľúčmi. Táto dátová štruktúra sa správa v princípe ako obyčajné pole (teda prvky sú číslované indexami $0, 1, \\dots, N-1$) s tým rozdielom, že prečítanie prvku na danom indexe trvá čas $O(\\log N)$ namiesto obvyklých $O(1)$ pri poli. Na oplátku nám však umožňuje nasledujúce operácie:

- Vymazanie prvku z daného indexu v čase $O(\\log N)$ (ostatné prvky sa automaticky prečíslujú).

- Vloženie prvku na daný index v čase $O(\\log N)$ (ostatné prvky sa automaticky prečíslujú).

- Ak si zapamätáme referenciu (pointer) na niektorý prvok, vieme neskôr v čase $O(\\log N)$ zistiť, aký má index (aj ak sa index medzičasom zmenil). To sa nám obzvlášť hodí pri udalostiach 3. typu (vieme si zapamätať, ktoré dva prvky budeme chcieť vymeniť a keď daná udalosť nastane, vieme ich efektívne nájsť).

- Ak sú v nejakom momente všetky prvky zoznamu podľa niečoho usporiadané, vieme v ňom vďaka stromovej štruktúre binárne vyhľadávať v čase $O(\\log N)$, rovnako ako v obyčajnom poli.

#### Presnosť

Posledný detail je presnosť výpočtov. Jednou z možností je nenechať nič na náhodu a všetko počítať v racionálnych číslach. Druhá, na implementáciu jednoduchšia možnosť je použiť reálnu aritmetiku. Vtedy ale treba použiť typ premennej s dostatočnou presnosťou (v C++ v závislosti od implementácie mohol stačiť `double`, alebo mohlo byť nutné použiť `long double`).

#### Odhad zložitosti

Zamyslime sa, koľko udalostí budeme musieť počas zametania spracovať. Keďže na vstupe je $n + m$ úsečiek, udalostí prvého druhu bude najviac $n+m$, rovnako udalostí druhého a štvrtého druhu. Keďže každá doska sa pretína s práve jednou jamou, úsečky na vstupe majú dokopy $m$ priesečníkov, teda budeme mať $m$ udalostí tretieho druhu. Dokopy teda máme $O(n+m)$ udalostí. Udalosti prvých troch druhov vieme spracúvať v čase $O(\\log(n+m))$ (vybranie udalosti z haldy, konštantne veľa operácii so zoznamom úsečiek pretínajúcich zametaciu priamku, prípadné pridanie konštantného počtu udalostí na haldu). S udalosťami štvrtého druhu (zvislými úsečkami) je to trochu horšie. Ak má daná zvislá úsečka $p$ priesečníkov, jej spracovanie môže trvať až $O((p+1) \\log(n+m))$. Vieme však, že na vstupe je dokopy $m$ priesečníkov, teda súčeť $p$-čiek pre všetky zvislé úsečky dokopy je najviac $m$. To znamená, že spracovanie všetkých udalostí štvrtého druhu nám zaberie dokopy $O((n+m) \\log (n+m))$ času. Spracovanie ostatných udalostí tiež trvá $O((n+m) \\log (n+m))$, teda aj celé zametanie bude trvať $O((n+m) \\log (n+m))$. Načítanie vstupu a nahádzanie udalostí do haldy trvá $O((n+m) \\log (n+m))$ času, vypisovanie výstupu trvá tiež $O((n+m) \\log (n+m))$ (lebo ho pred vypísaním potrebujeme triediť), celková časová zložitosť nášho algoritmu je teda $O((n+m) \\log (n+m))$.

Pamäťová zložitosť je $O(n+m)$.
",10
5f14e52921a62f21,ksp,"# Ipeľ sa vylieva

Iste každý už počul o rieke Ipeľ. Ak si myslíte, že sa jedná o nejakú riečku na juhu Slovenska, tak ste ne omyle. Totiž každý južan (vrátane mňa) si pamätá, ako sa veľtok Ipľu vylial. Záplavy zasiahli aj naše mesto a zničili v ňom bohatú infraštruktúru^[Dva semafory a štyri kruhové objazdy].

V posledných rokoch je však obodbie sucha, a tak veľa ľudí zabúda na toto nebezpečenstvo. Túto zimu mi však istá nemnovaná osoba (Iľko) dala info, že Ipeľ sa vyleje. Ľadové kryhy, ktoré vzniknú pri výkyvoch teploty, totiž upchajú jeho koryto.

Keď teda vieme, že nastane katastrofa, musíme sa pripraviť. Vieme, že vysoké budovy v našom meste zastavia vodu. Máme mapu mesta, na ktorej sú tieto budovy vyznačené. Zaujíma nás, koľko územia ostane nezaplaveného.

## Úloha

Svet si budeme predstavovať ako nekonečnú štvorcovú sieť. Nejaký obdĺžnikový kus tejto štvorcovej siete je naše mesto. Niektoré políčka v meste sú nezastavané (cesty, polia, ...), na ostatných sú budovy. Každá budova zaberá presne jedno políčko. Zo všetkých strán mesta sa začne valiť voda. Voda zaplaví všetky políčka, kam sa vie dostať pohybom v 4 základných smeroch bez toho, aby prešla cez budovu. Zaujíma nás, koľko nezastavaných políčok ostane nezaplavených.

## Formát vstupu

V prvom riadku vstupu sú tri celé čísla $n, m$ a $k$ ($1 \\leq n,m \\leq 10 ^{18}$ a $0 \\leq k \\leq 10^6$): rozmery nášho mesta a počet budov v ňom.

Nasleduje $k$ riadkov, $i$-ty z nich obsahuje dve celé čísla $x_i, y_i$ -- pozícu $i$-tej boudovy na mape. Presnejšie, $i$-ta budova sa nachádza v $x_i$-tom stĺpci a $y_i$-tom riadku obdĺžnika tvoriaceho naše mesto, číslujúc od $0$. Platí teda $0 \\leq x_i < n$ a $0 \\leq y_i < m$. Možete predpokladať, že na každom políčku je najviac 1 budova.

## Formát výstupu

Vypíšte jedno číslo -- počet nezaplavených políčok mapy.

## Hodnotenie

Pre jednotlivé sady testovacích vstupov platia nasledovné obmedzenia:

| číslo sady | $1$ | $2$ | $3$ | $4$ | |:----------:|:---:|:---:|:---:|:-----:| | $n,m \\leq$ | $50$ | $1,000$ | $1,000$ | $10 ^ {18}$ |

## Príklady

```vstup
3 3 4
2 1
0 1
1 0
1 2
```

```vystup
1
```

```vstup
7 5 17
1 0
1 1
1 2
1 3
1 4
2 0
3 0
3 2
3 3
3 4
4 0
4 4
5 0
5 1
5 2
5 3
5 4
```

```vystup
0
```

*Po zaplavení vyzerá mesto takto:*
","# Ipeľ sa vylieva

Našou úlohou bolo pre daný plán mesta zistiť, koľko políčok ostane nezaplavených, keď sa Ipeľ vyleje. Ako už býva zvykom, pod úlohami týchto typov sa ukrýva grafové riešenie.

## Prvé riešenie

Toto riešenie je založené na jednoduchej myšlienke, že pre každé políčko skúsime nájsť cestu, ktorou by ho vedel Ipeľ zaplaviť. Ak takáto cesta neexistuje, tak je dane políčko nezaplaviteľné. Ako overíme, či je nejaké políčko zaplaviteľné? Jednoducho, spustíme z neho [DFS (prehľadávanie do hĺbky)](https://www.ksp.sk/kucharka/dfs/). Políčko je zaplaviteľné, ak sa počas DFS-ka dostaneme mimo mapu.

Takéto riešenie má však zložitosť až $O(n^2 \\cdot m^2)$, pretože políčok je $n \\times m$ a DFS má v tomto prípade zložitosť $O(n \\cdot m)$. *(Zamyslite sa, že ani pri použiti [BFS](https://www.ksp.sk/kucharka/bfs/) sa časová zložitosť nezlepší.)*

## Vylepšenie pôvodného riešenia

Prvé riešenie nebolo zlé, bolo len príliš pomalé. Vieme ho však zrýchliť dostatočne na to, aby sme vyriešili až 3 sady vstupov (v daných sadách sa mapa zmestí do pamäte).

Treba si uvedomiť, že je dosť zbytočné robiť DFS furt z každého políčka. Ak predsa voda zaleje nejaké políčko, tak zaleje aj všetkých jeho susedov, a ich susedov... V grafovej terminologií sa tomu hovorí komponent súvislosti. Stačí mať jedno pole `visited`, a pre každé voľné políčko nájsť celý jeho komponent. Všetky políčka tohto komponentu si potom označíme za spracované a z nich už ďalšie prehľadávanie spúšťať nebudeme. Ak sme počas hľadania komponentu vyšli mimo mapu, vieme, že celý komponent bude nakonci zaliaty vodou.

Takéto pozorovanie nám vylepší zložitosť na $O(n \\cdot m)$, pretože každé políčko mapy spracujeme v DFS najviac raz.

## Plný počet bodov

Na zisk plného počtu bodov sa musíme vysporiadať s tým, že mapa sa nám nezmestí celá do poľa. Tu si veľmi nepomôžeme a musíme vymyslieť niečo nové. Kľučom je pozorovanie, že budov celkom málo ($\\leq 10 ^ 6$).

Každý riadok mesta, ktorý obsahuje nejaké budovy, si rozdelíme na intervaly voľných políčok, ktoré budú určené dvoma budovami. Napríklad, ak máme v riadku budovy na indexoch $0, 13, 72$, tak si spravíme intervaly $[1, 12]$, $[14, 71]$. Každý interval je buď celý zaplavený, alebo celý nezaplavený. Tieto intervaly budeme brať ako vrcholy a vytvoríme si z nich graf. Dva intervaly (vrcholy) sú spojené hranou, ak sú na dvoch po sebe idúcich riadkoch a majú prienik. Pre smrteľníkov to znamená, že ak sa voda dostane do jedného vrchola, dostane sa aj do druhého.

Ak sú medzi dvoma nasledujúcimi riadkami s budovami nejaké prázdne riadky, celú túto skupinu prázdnych riadkov budeme reprezentovať jedným vrcholom, ktorý bude spojený so všetkými intervalmi z riadku nad ním a z riadku pod ním.

Okej, už to skoro máme, teraz stačí spustiť prehľadávanie zo všetkých krajných intervalov. Hmm, ale ako to spraviť tak, aby sme sa nezbláznili? Najjednoduchšie je do každého riadka pridať virtuálne budovy na pozície $-\\infty$ a $\\infty$. Tým nám na začiatku a na konci riadka vzniknú intervaly reprezentujúce kraj mapy. Z týchto intervalov a z intervalov v prvom a poslednom zastavanom riadku potom môžeme spustiť DFS, ktorým zistíme, ktoré intervaly budú zaplavené a ktoré nie.

Počet vrcholov v našom grafe (intervalov) je priamo úmerný počtu budov (nanajvýš trikrát väčší) a dá sa ukázať, že počet hrán tiež. Časová zložitosť nášho algoritmu je teda $O(k \\log k)$, keďže graf dokážeme po utriedení budov zostrojiť v lineárnom čase a DFS navštívi každý vrchol najviac raz. Pamäťová zložitosť je $O(k)$.
",8
0395e979ec00fc71,ksp,"# Vystupovanie

Každý víkend sa Jozef Hovnivál potreboval dostať domov z rodinného výmetu, aby si mohol sadnúť na svoju pohodlnú stolicu. Chodieval autotrusom. No aby to nemal také jednoduché, zakaždým sa rozhodol, akú dlhú prechádzku si chce spraviť domov z autotrusovej zastávky. Teda vystúpil na takej zastávke, ktorá je od jeho domu v správnej vzdialenosti. No toto ho rýchlo omrzelo, pretože chodil často tou istou trusou. Tak si vymyslel ešte jednu podmienku, a to že nepôjde z ktorejkoľvek zastávky, ktorá je v správnej vzdialenosti, ale z $k$-tej takej v poradí. Teda napríklad sa mohol rozhodnúť, že vystúpi na tretej zastávke, z tých, ktoré sú od jeho domu vzdialené 7 metrov. Jozefovi Hovniválovi ale zaberalo veľmi veľa času zistiť, na ktorej zastávke má vystúpiť. Preto potrebuje vašu pomoc.

## Úloha

Na vstupe dostanete $n$ čísel v rozsahu od $1$ po $1,000,000$. Toto sú vzdialenosti jednotlivých zastávok od jeho domu, v takom poradí, v akom ich prejde autotrus. Potom dostanete $q$ otázok. Každá otázka pozostáva z čísla zastávky $l$, na ktorej Jozef nastúpi, čísla zastávky $r$, na ktorej mu skončí platnosť lístka (a teda nemôže pokračovať ďalej v ceste autotrusom). Ďalej dostanete dĺžku prechádzky $v$, ktorú si Jozef praje a nakoniec na koľkej takej zastávke chce Jozef vystúpiť, $k$. Vašou úlohou je vypísať číslo zastávky, ktorá sa nachádza v intervale od $l$ po $r$ vrátane, jej vzdialenosť od domu je $v$ a je to $k$-ta taká zastávka v danom intervale. Ak taká neexistuje, vypíšte $-1$. Číslujeme od jednotky.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú čísla $n$ a $q$ oddelené medzerou, počet zastávok a počet otázok. Na druhom riadku sa nachádza $n$ čísel oddelených medzerami, vzdialenosti zastávok od Jozefovho domu. Nasleduje $q$ riadkov, na každom z ktorých sa nachádzajú medzerami oddelené čísla $l$, $r$, $v$ a $k$, ktorých význam je vysvetlený vyššie.

## Formát výstupu

Vypíšte $q$ riadkov výstupu. Na $i$-tom riadku sa nachádza odpoveď na $i$-tu otázku, teda číslo zastávky, ktorá spĺňa požadované vlastnosti, alebo $-1$ ak taká neexistuje.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3 | 4 | 5--8 | |:--------------- |-----: | ---------: | ------------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $10,000$ | $80,000$ | $100,000$ | | $1 \\leq q \\leq$ | $100$| $10,000$ | $100,000$ | $100,000$ |

V prvej sade navyše platí, že vzdialenosti zastávok od domu sú z množiny ${1, 2}$.

## Príklad

```vstup
5 4
3 4 5 4 5
2 3 4 1
3 4 1 2
1 2 4 1
1 2 4 2
```

```vystup
2
-1
2
-1
```

```vstup
10 5
3 3 1 3 3 2 1 3 3 1
1 5 3 1
1 8 3 1
2 8 3 2
1 4 1 1
1 6 1 2
```

```vystup
1
1
4
3
-1
```
","# Vystupovanie

## Pomalé riešenie

Ako prvé si predstavíme priamočiare riešenie bez žiadnych trikov. Budeme jednoducho vstupné pole lineárne prehľadávať počnúc od indexu $l$ a počítať, koľkokrát sme už narazili na zastávku v správnej vzdialenosti $v$ od Jozefovho domu. Akonáhle narazíme na $k$-tu takú, vypíšeme jej index. Ak ale prekonáme index $r$ pred tým, ako nájdeme odpoveď, odpovieme $-1$. Toto riešenie by bolo optimálne, v prípade, keby sme dostali len $q = 1$ otázok. To, že otázok môže byť veľa, nám ale napovedá, že sa asi dá najprv so vstupnými údajmi vykonať nejaká transformácia, ktorá nám potom umožní odpovede zisťovať rýchlejšie ako v lineárnom čase.

## Vzorové riešenie

Kľúčový trik k riešeniu úlohy je nasledujúci: Pre každú vzialenosť $v$ od domu si vytvoríme pole, v ktorom sa nachádzajú čísla (indexy) zastávok, ktoré majú túto vzdialenosť. Napríklad ak je na vstupe pole: $[3, 4, 5, 4, 5]$ tak by sme si vytvorili v pamäti štruktúru podobnú nasledujúcej:

```
X[3]: 1
X[4]: 2 4
X[5]: 3 5
```

Na jej uskladnenie môžeme použiť buď hash mapu (dict) alebo jednoduché pole veľkosti $10^6$, pretože to je maximálna hodnota $v$.

Všimnime si, že každé pole $X[v]$ je usporiadané. Teraz vieme na otázky odpovedať nasledujúcim postupom: Pozrieme sa do poľa $X[v]$ a nájdeme v ňom najmenšiu hodnotu väčšiu alebo rovnú $l$. Ako na to? Postupné prechádzanie po jednom funguje, ale má zložitosť $O(n)$, takže si moc nepomôžeme. Zachráni nás ale binárne vyhľadávanie, ktoré to spraví v $O(\\log n)$. Zastávka, ktorú takto nájdeme, je prvá taká, cez ktorú prejde autobus s Jozefom a je v správnej vzdialenosti od jeho domu. My chceme ale $k$-tu, nie prvú, takže sa v tomto poli $X[v]$ pozrieme o $k-1$ pozícii ďalej a nájdeme presne to, čo hľadáme. Ešte musíme ale vyriešiť dve prekážky: Ak by sme pri tomto procese vybehli z poľa, tak vieme, že taká zastávka neexistuje a odpovieme $-1$. Druhý problém je $r$ z otázky, no jednoducho sa stačí pozrieť na číslo zastávky, ktorú sme našli a ak je väčšie ako $r$, tak opäť vypíšeme $-1$, pretože zastávka už je mimo Jozefovej platnosti lístka.

Celková časová zložitosť riešenia (s použitím hash mapy) je $O(n+q\\log n)$. $n$ pochádza z predpočítania štruktúry $X$ a $q\\log n$ sú jednotlivé odpovede na otázky. Pamäťová zložitosť je $O(n)$, pretože jediné čo si pamätáme je $X$, pričom dokopy sa v ňom nachádza presne $n$ prvkov. Keby sme pre $X$ nepoužili hash mapu ale pole, zložitosti by boli trochu iné. Museli by sme na začiatku inicializovať pole veľkosti $10^6$, čo je určite viac ako $n$, pretože $n$ dosahuje len $10^5$. Taktiež si ho musíme pamätať. Ak by sme pomenovali $w = 10^6$ maximálnu hodnotu $v$, tak by časová zložitosť bola $O(w+n+q\\log n)$ a pamäťová $O(w+n)$.
",4
5322a13882861b70,ksp,"# Absurdistanské diaľnice

V Absurdistane majú už dlho v pláne postaviť novú sieť diaľnic. Ale viete, ako to chodí: každé štyri roky sú voľby, s ktorými príde nový minister dopravy. Ten vždy najprv preplánuje celú dialničnú sieť a potom už do konca volebného obdobia nič nestihne. Následne príde nový minister a taktiež nanovo prerobí celé plány. Predchádzajúci minister si však rok pred voľbami povedal, že túto tradíciu poruší a diaľnicu stavať naozaj začne. Lenže žiadnu cestu za rok nepostaví, a preto, aby po ňom niečo ostalo, rozhodol sa postaviť aspoň diaľničné križovatky.

Preto zobral svoje plány a náhodne z nich vybral pár miest kde sa do volieb postavili križovatky.

Po ňom však prišiel nový minister. Ten podľa zvyku staré plány zahodil a teraz má pred sebou tažkú úlohu: musí naplánovať celú diaľničnú sieť tak, aby dopĺňala už existujúce križovatky. Keďže chce mať v plánoch poriadok, určil si nasledujúce dva ciele: musí použiť čo najmenej rôznych diaľnic a všetky z nich musia ísť buď v severo-južnom alebo západo-východnom smere. Dokážete aj vy za takýchto podmienok zostrojiť nový plán diaľnic?

## Úloha

Na vstupe dostanete zoznam všetkých diaľničných križovatiek postavených predchádzajúcim ministrom.

Vašou úlohou je navrhnúť diaľničnú sieť tak, aby obsahovala všetky tieto križovatky.

Cez každú križovatku musia prechádzať dve diaľnice (keď už je tam ten nadjazd, je to už vybudovaná diaľnica a teda ju nemožno zrušiť), môžu však byť akokoľvek krátke (stačí keď sa diaľnica končí hneď za nadjazdom). Žiadne dve diaľnice sa nemôžu križovať mimo križovatky (to by bolo divné, nie?). Nemôžete postaviť žiadnu novú križovatku, lebo na to nemáte financie.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ -- počet križovatiek. Na nasledujúcich $n$ riadkoch sú vymenované jednotlivé križovatky. Na každom riadku sú súradnice $1 \\le x_i, y_i \\le 10^9$: zemepisné súradnice jednotlivých križovatiek.

## Formát výstupu

Na výstup vypíšte navrhnutú diaľničnú sieť. V prvom riadku vypíšte číslo $H$: počet západo-východných diaľnic.

Potom vypíšte $H$ riadkov. Na každom riadku vypíšte štyri čísla $1 \\le x_i, y_i, x'\_i, y'\_i \\le 10^9$, ktoré reprezentujú západo-východnú diaľnicu. Musí platiť, že $y_i = y'\_i$.

V ďalšom riadku vypíšte číslo $V$: počet severo-južných diaľnic. Potom vypíšte $V$ riadkov. V každom riadku vypíšte štyri čísla $1 \\le x_i, y_i, x'\_i, y'\_i \\le 10^9$, ktoré reprezentujú severo-južnú diaľnicu. Musí platiť, že $x_i = x'\_i$.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:--------------- | --: | --: | --: | --: | --: | --: | --: | --: | | $0 \\leq n \\leq$ | $6$ | $6$ | $16$ | $16$ | $100$ | $10$ | $1,000$ | $1,000$ | | $0 \\leq x_i, y_i \\leq$ | $6$ | $10^9$ | $16$ | $10^9$ | $100$ | $10^9$ | $1,000$ | $10^9$ |

Príklad:

```vstup
4
2 1
2 3
1 2
3 2
```

```vystup
3
1 1 2 1
1 2 3 2
1 3 2 3
4
1 2 1 2
3 1 3 3
2 1 2 1
2 3 2 3
```

*Všimnite si, že viacero z diaľníc už nepokračuje mimo križovatku.*

*V diaľničnej sieti však musia byť, keďže v každej križovatke sa musia križovať diaľnice.*
","# Absurdistanské diaľnice

Na vstupe máme niekoľko diaľničných križovatiek. Naším cieľom je navrhnúť severojužné a západovýchodné diaľnice tak, aby:

1. každá križovatka bola križovatkou dvoch diaľníc,
1. aby sa žiadne dve diaľnice nekrižovali mimo križovatie,
1. a aby bolo diaľníc čo najmenej.

Skúsme najprv ignorovať poslednú podmienku a pozrieť sa na riešenie iteratívne: Na začiatku máme veľa križovatiek a na každej z nich sa križujú dve samostatné diaľnice. Ak máme $n$ križovatiek tak máme $2n$ diaľníc. Chceme aby diaľníc bolo čo najmenej, preto chceme tieto diaľnice pospájať. Križovatku môžeme napojiť iba na tú ktorá je k nej najbližšia v každom zo štyroch smeroch. Každé takéto spojenie nám zníži počet diaľníc o jedna. Keby sme ignorovali druhú podmienku tak v podstate každú križovatku môžeme spojiť s najbližšími križovatkami vo všetkých štyroch smeroch a tým pádom by nám pre každú x-ovú súradnicu zostala práve jedna zvisĺa diaľnica a pre každú y-novú súradnicu zostala práve jedna vodorovná diaľnica.

Druhá podmienka však situáciu komplikuje. V praxi pre nás znamená že na každej križovatka spojníc diaľníc ktorá nie je na vstupe si musíme vybrať ktorú spojnicu ponecháme a ktorú nie. Toto nám však úlohu transformuje na vcelku štandartný grafový problém: Pre každú spojnicu majme jeden vrchol v grafe. Pre každú križovatku dvoch spojníc ktorá nie je na vstupe majme hranu ktorá spojí dva vrcholy reprezentujúce tieto dve spojnice. Teraz z grafu chceme vybrať čo najviac vrcholov (spojníc), tak aby žiadne dva vybrané vrcholy neboli spojené hranou. Chceme teda vybrať najväčšiu nezávislú množinu (*maximum independent set*).

Tento postup si môžme ozrejmiť aj na nasledovnom príkladnom obrázku. Na obrázku máme jednotlivé križovatky. Na začiatku sa v každej z nich stretávajú dve diaľnice. Keďže chceme počet diaľníc minimalizovať, chceme vybudovať ich spojnice, kde každá spojnica nám zníži počet jedinečných diaľníc o jedna. V ideálnom prípade chceme využiť všetky spojnice, ale v tomto prípade to nie je možné, keďže diaľnice sa nesmú križovať mimo križovatiek. Túto úlohu si pretransformujeme do bipartitného grafu, kde vrcholy reprezentujú spojnice. Hrany sú medzi vrcholmi práve vtedy keď sa dve spojnice križujú a teda nemôžeme postaviť obidve. Chceme teda vybrať čo najviac vrcholov tak aby medzi žiadnou dvojicou vybraných vrcholov nebola hrana.

Problém najväčšej nezávislej množiny v grafe je vo všeobecnosti v kategorí NP-úplných problémov a teda je pravdepodobné, že sa nám naň nikdy nepodarí nájsť riešenie v polynomiálnom čase. Náš graf má však užitočnú vlastnosť -- je bipartitný. To znamená, že vrcholy v ňom vieme rozdeliť do dvoch kategoríi: severojužné spojnice a východozápadné spojnice, pričom hrany sú iba medzi vrcholmi z rôznych kategórii. Tento problém už má známe riešenie, ktoré sme sa pokúsili zhrnúť [tu](https://www.ksp.sk/kucharka/parenie/). Časová zložitosť pre riešenie tohto problému je $O(E \\sqrt {V})$, pre bipartitný graf s $E$ hranami a $V$ vrcholmi ak hľadáme maximálne párovanie pomocou Edmonds–Karp. V našom prípade však absolútne postačí pomalší algoritmus na hľadanie párenia s časovou zložitosťou $O(EV)$. Keď máme križovatiek $n$, tak môže byť medzi nimi $4n \\in O(n)$ spojníc. Tieto spojnice sa však môžu krížiť pomerne veľa krát. Napríklad na obrázku nižšie vidíme situáciu v ktorej máme až $(n/4)^2 \\in O(n^2)$ križovatiek spojníc. Viac ich však nemôže byť, keďže $4 n$ spojníc sa môže križovať najviac v $16n^2 \\in O(n^2)$ miestach. Tým pádom je časová zložitosť výsledného riešenia $O(E \\sqrt {V}) = O(n^2 \\sqrt {n}) = O(n^{2.5})$. Pamäťová zložitosť je $O(n^2)$, keďže potrebujeme vyrobiť graf všetkých hrán (krížení spojníc).
",10
8e533f06c73b5d51,ksp,"﻿# Ako priečinky robia radosť

Každý rok sa v T2 koná Každoročná Slávnosť Priečinkov (KSP). Vedúci púšťajú hity z entertainmenta, popíjajú kofolu a pun-ishujú sa tými najhoršími slovnými hračkami, aké ste kedy počuli.

Odovzdávajú si tiež priečinky! Konkrétne, vedúci ktorí majú v skrini vlastný priečinok ho niekedy prenechajú novému prvákovi. Priečinky sú veľmi praktické - môžu si v nich nechávať zošity do školy, materiály o najbližšom sústredení, pokazené routery, nedojedené desiaty...

Využitie priečinku sa však časom často mení. Niektorí ho v prváku naplnia vecami a potom naňho zabudnú. Iným príde najprv nepodstatný a až po rokoch zistia, že sa bez neho zrazu nezaobídu.

Z historických záznamov máš o mnoho vedúcich informácie o ich narábaním s priečinkami.

Presnejšie, o vedúcom číslo $i$ vieš, že sa stal prvákom v roku $p_i$ a priečinok využíval $a_i$ veľa, zatiaľ čo ho už chcel odovzdať v roku $o_i$ keď svoj priečinok využíval $b_i$ veľa. Samozrejme, prenechal ho na KSP len takému prvákovi, ktorý by jeho priečinok využil ostro viac ako on.

Môže sa stať, že vedúci $x$ odovzdá svoj priečinok prvákovi $y$, ktorý neskôr odovzdá svoj priečinok prvákovi $z$ a tak ďalej. Takúto sériu odovzdávaní nazveme `životná púť` priečinka. Keď vedúci $x$ odovzdá priečinok vedúcemu $y$, využitie priečinka stúpne o $a_y - b_x$. Radosť, ktorú priečinok prináša vedúcemu, ktorý ho vlastní, je úmerná jeho využitu -- preto túto hodnotu nazývame `radosť odovzdávania`. `hodnota` životnej púte priečinka je súčet radostí odovzdávania, ktoré počas tejto púte nastali.

Zo záznamov nie je jasné, kto komu priečinok naozaj aj odovzdal. Životné púte priečinkov sú tak stratené v histórií. Nič ti však nebráni upustiť uzdu fantázií, a predstaviť si tie najlepšie, najhodnotejšie púte, ktoré priečinky v T2 mohli zažiť. Keďže však musíme fantázií pokladať nejaké medze, predstavíš si len $k$ najhodnotnejších z nich...

## Úloha

Zistite, akých $k$ najhodnotnejších životných pútí sa mohlo počas rokov KSP odohrať. Dve životné púte priečinka považujeme za rôzne, ak sú postupnosti vedúcich, ktorí ho vlastnili, iné.

Nemusíš nám ich detailne vypisovať. Stačí, ak vypíšeš súčet ich hodnôt modulo $10^9+7$.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $k$, udávajúce počet vedúcich, o ktorích máš záznam a počet najhodnotnejších životných pútí, ktoré ťa zaujímajú.

V $i$-tom z nasledujúcich $n$ riadkov sú štyri čísla $p_i$, $o_i$, $a_i$ a $b_i$.

Platí $1 \\leq p_i < o_i \\leq 10^9$, $1 \\leq a_i, b_i \\leq 10^9$ a $1 \\leq n \\cdot k \\leq 10^6$.

V jednotlivých sadách platia nasledujúce obmedzenia pre $n$ a $k$:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|----------:|---------:|---------:| | $1 \\leq n \\leq$ | $20$ | $1,000$ | $10^6$ | $10^6$ | | $1 \\leq k \\leq$ | $20$ | $1$ | $1$ | $10^6$ |

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo - súčet hodnôt $k$ najhodnotnejších životných pútí, ktoré mohli počas rokov KSP nastať, modulo $10^9+7$. Ak ich mohlo nastať menej ako $k$, vypíš súčet všetkých z nich (stále modulo $10^9+7$).

## Príklady

```vstup
5 1
1 2 10 9
1 4 7 11
2 4 15 16
4 5 20 1
5 7 2 5
```

```vystup
11
```

*Najhodnotnejšia možná životná púť priečinka je, aby prvý vedúci odovzdal priečinok tretiemu, ten potom štvrtému a ten nakoniec piatemu.*

```vstup
5 4
1 2 10 9
1 4 7 11
2 4 15 16
4 5 20 1
5 7 2 5
```

```vystup
40
```

*Druhá a tretia najhodnotnejšia púť sú prvý-tretí-štvrtý, druhý-štvrtý-piaty s hodnotou 10. Štvrtá najhodnotnejšia púť, s hodnotou 9, je druhý-štvrtý*

```vstup
3 1
1 1000000 1 1
1000000 50000000 1000000000 1
50000000 1000000000 1000000000 474747
```

```vystup
999999991
```

*Najhodnotejšia púť je prvý-druhý-tretí s hodnotou $(1000000000-1)+(1000000000-1)=1999999998$, modulo $10^9+7 = 999999991$*

```vstup
10 1
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
10
```

```vstup
10 5
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
45
```

```vstup
10 25
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
113
```

*Existuje len 22 životných pútí, sčítame teda všetky*
","# Ako priečinky robia radosť

Prevedieme si najprv úlohu do informatickej terminológie. Vedúci sú vrcholy, a odovzdanie priečinka je orientovaná hrana -- ak vedúci $x$ vie odovzdať vedúcemu $y$ priečinok s radosťou odovzdávania $a_y - b_x$, tak z vrcholu $x$ vedie hrana do vrcholu $y$ s váhou $a_y - b_x$. Životná púť priečinka je teda cesta v tomto grafe, a hodnota je súčet váh hrán na nej.

Môžeme si o tomto grafe navyše všimnúť, že je acyklický, keďže každý vedúci vie odovzdať priečinok v ostro neskoršom roku, ako ho dostal. Je to teda DAG (directed acyclic graph).

## N < 20 znamená...

...že použijeme starú dobrú hrubú silu, a prejdeme si všetky možné púte priečinka. Skúsime začať v každom vrchole, pozrieme sa na všetky ostatné, a rekurzívne pokračujeme do každého, do ktorého vedie hrana.

Hodnotu každej púte, ktorú spracujeme si odložíme, a po prehľadávaní ich usporiadame a sčítame $k$ najhodnotejších z nich.

Aby sme určili zložitosti, musíme zistiť, koľko ciest vie existovať v orientovanom acyklickom grafe. Môžeme využiť fakt, že v takomto grafe je cesta jednoznačne určená množinou vrcholov v nej, keďže cez vrcholy na ceste vieme ísť len v jednom poradí, a bez cyklov sa nemôžu ani opakovať. Samozrejme, nie každá podmnožina vrcholov tvorí platnú cestu, ale každá platná cesta je určená podmnožinou, dáva nám teda horný odhad. Počet podmnožín $n$ vrcholov je $O(2^n)$, toľko ciest teda v najhoršiom prípade nájdeme. Každá cesta má najviac $n$ vrcholov, a v každom vrchole prejdeme zvyšné vrcholy aby sme skúsili cestu predĺžiť, náš odhad časovej zložitosti je teda $O(n^2 2^n)$, a pamäťovej $O(2^n)$.

## Najdrahšia cesta v DAGu

Poďme teda vymyslieť niečo prefíkanejšie ako skúšanie všetkých možností. Počet ciest v našom grafe je exponenciálny, ale nás z nich zaujíma len málo z nich -- v ďalších dvoch sadách dokonca len jedna, tá najdrahšia.

Skúsme teda nájsť najdrahšiu cestu tak, že si pre každý vrchol zistíme najdrahšiu cestu, ktorá končí v ňom -- naša celková najdrahšia cesta musí končiť v niektorom vrchole, bude teda jednou z nich.

Môžeme si napríklad všimnúť, že ak máme cestu prechádzajúcu vrcholmi $v_1, v_2, \\cdots, v\_{d-1}, v_d$ kde $d$ je jej dĺžka, tak ak je to najdrahšia cesta končiaca vo $v_d$, tak cesta $v_1, v_2, \\cdots, v\_{d-1}$ je najdrahšia cesta končiaca vo $v\_{d-1}$. Ak by totiž bola iná cesta ktorá je drahšia a končí vo $v\_{d-1}$, tak by sme ju mohli napojiť na $v_d$ a získať drahšiu cestu ako tú s ktorou sme začali, čo je v rozpore s tým že sme začali s najdrahšou cestou končiacou vo $v_d$.

Z tohto pozorovania vyplýva, že na nájdenie najdrahšej cesty končiacej vo vrchole $v$ stačí nájsť najdrahšie cesty končiace vo vrcholoch, z ktorých sa vieme priamo dostať do $v$, a najdrahšia cesta bude jedna z nich plus cena hrany, ktorou sa na ňu napojíme.

Stačí nám teda prejsť vrcholy vo vhodnom poradí, aby sme vždy zrátali cenu najdrahšej cesty pre nejaký vrchol $v$ skôr, ako ju budeme rátať pre vrcholy do ktorých sa vieme dostať z $v$. Keďže vieme, že vedúci môže odovzdať priečinok len takému vedúcemu, ktorý príde do KSP až po ňom, môžeme si vedúcich zoradiť podľa roku príchodu, a prejdeme ich v tomto poradí.

Nakoniec vypíšeme cenu najdrahšej cesty, ktorú sme takto našli.

Keďže pre každého vedúceho prejdeme každého, ktorý prišiel po ňom, budeme mať časovú zložitosť $O(n^2)$. Pre každého si okrem vstupných hodnôt pamätáme len jednu premennú navyše -- najdrahšiu cestu končiacu v ňom -- pamäť bude $O(n)$.

## Najdrahšia cesta v priečinkovom DAGu

V predošlom riešení skúšame veľa nezmyselných dvojíc vedúcich, aj takých, ktorí si nevedia odovzdať priečinok (lebo prvý neodchádza v roku, v ktorom druhý prichádza).

Rozdeľme si teda vedúcich na kôpky -- nech $P_r$ je zoznam vedúcich ktorí prichádzajú v nejaký rok $r$, a $O_r$ je zoznam vedúcich ktorí odchádzajú v rok $r$. Každý vedúci sa vyskytne raz na zozname prichádzajúcich, a raz na zozname odchádzajúcich.

Ak chceme prechádzať vedúcich podľa roku príchodu, prejdeme kôpky vedúcich v $P$ pre postupne stúpajúce roky $r$ (len tie, ktoré boli na vstupe). Potom ich skúšame napojiť na najdrahšie cesty končiace vo vedúcich v $O_r$, keďže priečinky vedia dostať len od nich.

Stále však môžeme mať až kvadraticky veľa dvojíc -- napríklad ak polovica vedúcich odchádza v jednom roku, a druhá polovica vedúcich v tomto roku prichádza.

Skúsme teda namiesto toho, aby sme pre každého prichádzajúceho vedúceho $v$ skúšali všetkých vedúcich, ktorí odchádzajú v rovnaký rok (a majú menšiu hodnotu priečinka) a napojiť sa na ich cestu, priamo určiť, ktorá z nich bude najdrahšia po napojení na $v$.

Zoberme si teda príkladového vedúceho $v$, ktorý príde a bude mať hodnotu priečinka $p$, a majme dve cesty na ktoré sa vieme napojiť -- jednu s hodnotou $h$, končiacu vo vedúcom ktorý ešte využíva svoj priečinok na $o$, a druhú s hodnotami $H$, $O$.

Akú hodnotu budú mať tieto cesty po napojení na $v$? Prvá cesta bude mať $h+(p-o)$, a druhá $H+(p-O)$. Aby bola prvá cesta drahšia ako druhá, $h+(p-o) > H+(p-O)$, tak $h-o > H-O$. Stačí teda zobrať cestu, ktorá má túto hodnotu (určenú jej hodnotou a vedúcim, v ktorom končí) najväčšiu, a tú napojiť na vedúceho $v$. Všimnime si, že na ktorú cestu je najlepšie sa napojiť nezávisí od využitia $p$, ktorý pre priečinok má prichádzajúci vedúci -- jediné čo musíme dodržať je, aby cesty ktoré uvažujeme končili vo vedúcich, ktorí sú mu ochotní priečinok odovzdať.

Usporiadajme si teda vedúcich ktorí prichádzajú a odchádzajú v daný rok, poďla ich využitia priečinka, a prejdime ich v tomto poradí. Udržiavame si pritom vyššie popísanú hodnotu najlepšej doposiaľ nájdenej cesty. Keď prídeme na odchádzajúceho vedúceho, pozrieme sa či cesta, ktorá v ňom končí nie je lepšia ako tá čo sme mali doteraz, a ak áno, prepíšeme si ju. Keď prídeme na prichádzajúceho vedúceho, priradíme mu hodnotu najlepšej cesty, plus jeho využitie priečinka v prváku, tiež ako popísané vyššie.

Takto vieme nájsť najdrahšiu cestu končiacu v každom vedúcom, pričom však nepozeráme na všetky možné odovzdávanie medzi nimi, pozrieme sa len na každého vedúceho práve raz.

V prípade, že sa všetci vedúci vyskytnú v jeden deň, nám ich usporiadanie zaberie $O(n \\log n)$. Pamäť ostane na $O(n)$.

## A teraz už len trochu všeobecnejšie...

Čo potrebujeme, aby sme toto riešenie rozšírili ak nás nezaujíma len najdrahšia cesta, ale $k$ najdrahších ciest? Pôjdeme na to rovnako -- pre každý vrchol si zapamätáme $k$ najdrahších ciest, ktoré v ňom končia. Tu využijeme podmienku zo zadania, že $n \\cdot k \\leq 10^6$, čiže síce vedia byť $n$ aj $k$ veľké, nemôžu byť veľké naraz, a vieme si tieto cesty zapamätať -- bude ich najviac $n \\cdot k$.

Analogicky, aby sme našli $k$ najdrahších ciest končiacich v danom vrchole, musíme skúsiť $k$ najlepších ciest ktoré sa na neho môžu napojiť (ktorých hodnota mínus využitie priečinka vedúceho, v ktorom končia, je najvyššia).

Namiesto jednej hodnoty najlepšej cesty, si teda budeme pamatäť usporiadanú množinu najlepších ciest. Budeme prechádzať vedúcich rovnako ako v predošlom riešení. Keď spracujeme prichádzajúceho vedúceho, vypočítame jeho najlepších (najviac) $k$ ciest ktoré v ňom končia. Keď spracujeme odchádzajúceho vedúceho, hodnoty jeho ciest pridáme do našej množiny, a ak ich v nej je viac ako $k$, zahodíme tie najhoršie.

Počas spracovania prichádzajúcich vedúcich, ktorých je dokopy $n$, vypočítame najviac $k$ najdrahších ciest ktoré v nich končia, spravíme teda $O(nk)$ operácií. Počas spracovania odchádzajúcich vedúcich, ktorých je tiež dokopy $n$, vypočítame hodnoty ciest ktoré v nich končia, a pridáme ich do našej usporiadanej množiny. Ak použijeme rozumnú dátovú štruktúru (napr. v C++ `multiset`), pridávanie hodnoty do, a odstraňovanie najmenšej hodnoty z nej nás bude stáť $O(\\log k)$ operácií, ak jej veľkosť je $O(k)$. Za každého odchádzajúceho vedúceho teda spravíme v najhoršom prípade $O(k \\log k)$ práce, dokopy teda $O(nk \\log k)$. Spolu s usporiadaním vedúcich aby sme ich prešli v správnom poradí teda spravíme $O(n(\\log n + k \\log k))$ operácií.

Pamäťová zložitosť bude $O(nk)$, keďže si pre každého vedúceho pamätáme najviac $k$ hodnôt ciest.
",10
4b1f6293cd259a79,ksp,"# Krášlenie cestičiek

V Adamovej záhradke sa má konať veľká záhradnícka slávnosť, na ktorú prídu záhradníci zo široka-ďaleka. Chce, aby na túto slávnosť jeho záhradka vyzerala čo najlepšie. Už sa postaral o všetky svoje záhony, ale nepáčia sa mu cestičky, ktoré medzi nimi vedú.

Rozhodol sa, že teda záhradníkom dovolí, chodiť iba po niektorých cestičkách. Vyberie také, aby boli čo najmenej škaredé; ostatné kľudne škaredé byť môžu, lebo ich nikto neuvidí. Po vybraných cestičkách sa musí dať dostať od ľubovoľného záhonu k ľubovoľnému inému. Okrem toho mu ešte zostali nejaké peniaze, ktoré môže využiť na skrášlenie cestičiek. Skrášliť každú cestičku stojí rôzne veľa peňazí.

Pomôžte Adamovi vybrať, ktoré cestičky má nechať prístupné a určiť, ktoré ako skrášliť.

## Úloha

Adamovu záhradku tvorí $n$ záhonov, pospájaných $m$ obojsmernými cestičkami.

Každá cestička má nejakú škaredosť $w_i$ a cenu, za ktorú môže znížiť jej škaredosť o $1$, $c_i$. Adam má k dispozícii $S$ peňazí, ktoré môže minúť na skrášľovanie cestičiek.

Vašou úlohou je vybrať $n-1$ takých cestičiek, aby súčet ich škaredostí po skrášlení bol čo najmenší a aby sa po nich dalo dostať od každého záhonu ku každému. Je zaručené, že po pôvodných cestičkách sa dá dostať od každého ku každému. Skrášliť môžete každú cestičku ľubovoľne veľa krát, pričom za každé skrášlenie cestičky $i$ zaplatíte $c_i$ peňazí. Najviac môžete minúť $S$ peňazí. **Je povolené, aby škaredosť cestičky dosiahla 0 alebo aj záporné číslo**.

## Formát vstupu

Prvý riadok obsahuje dve kladné celé čísla $n$ a $m$ oddelené medzerou, označujúce počet záhonov a počet cestičiek. Záhony číslujeme od $0$ do $n-1$ a cestičky od $0$ do $m-1$.

Nasleduje $m$ riadkov popisujúcich cestičky. Riadok $i+1$ obsahuje v tomto poradí štyri čísla $a_i$, $b_i$, $c_i$, $w_i$ ($0 \\leq a_i, b_i < n$, $a_i \\neq b_i$, $1 \\leq c_i, w_i \\leq 10^9$). To značí, že cestička $i$, so škaredosťou $w_i$ a cenou skrášlenia $c_i$, spája záhony $a_i$ a $b_i$. Medzi dvoma záhonmi môže ísť viacero cestičiek.

Posledný riadok obsahuje číslo $S$ ($0 \\leq S \\leq 10^9$), počet Adamových peňazí.

## Formát výstupu

Na prvom riadku vypíšte číslo $K$ -- súčet škaredostí vybraných ciest po skrášlení.

Potom vypíšte $n-1$ riadkov. V každom riadku vypíšte dve čísla $x$, $v_x$, ktoré označujú, že cesta $x$ je medzi vybranými a po skrášlení má škaredosť $v_x$.

Cestičky môžete vypísať v ľubovoľnom poradí. Ak je riešení viacero, vypíšte ľubovoľné z nich.

## Obmedzenia

Sú $4$ sady vstupov po $2$ body. Platia v nich nasledovné dodatočné obmedzenia:

| Sada | $1$ | $2$ | $3$ | $4$ | |:--------------- |------: | ---------: | ---------: | ---------: | | $1 \\leq n \\leq$ | $10^5$ | $300$ | $10^4$ | $10^5$ | | $1 \\leq m \\leq$ | $10^5$ | $300$ | $10^4$ | $10^5$ | | $1 \\leq c_i \\leq$ | $1$ | $10^9$ | $10^9$ | $10^9$ |

## Príklad

```vstup
6 9
1 2 4 1
1 3 1 3
2 3 4 1
2 4 2 1
2 5 2 3
3 5 5 1
3 0 3 2
4 5 1 2
5 0 6 2
7
```

```vystup
0
0 1
2 1
5 1
6 2
7 -5
```

```vstup
3 3
2 1 7 9
0 1 7 5
0 2 2 1
2
```

```vystup
5
2 0
1 5
```
","# Krášlenie cestičiek

V prvom rade si treba uvedomiť, že v optimálnom riešení sa nám oplatí krášliť vždy iba jednu cestičku. Ak by sme krášlili viacero, mohli by sme miesto toho o rovnako veľa skrášlť najlacnejšiu z nich a určite by nám na to vyšli peniaze.

Môžeme teda skúšať možnosti, ktorá cestička to bude. Vždy si vyberieme jednu cestičku a skrášlime ju najviac ako vieme. S touto úpravou nám už zostáva iba vybrať cestičky s najmenšou škaredosťou. To znamená nájsť najlacnejšiu kostru grafu.

Iná možnosť je hľadať najlacnejšiu kostru, ktorá navyše obsahuje danú cestičku (bez úpravy škaredosti).

Najlacnejšia kostra sa dá nájsť v $O(m\\log n)$. To musíme spraviť pre každú hranu, čím dostávame časovú zložitosť $O(m^2\\log n)$. Pamäťová zložitosť je $O(m)$.

## Lepšie riešenie

Povedzme, že sme si zvolili hranu ktorú skúsime skrášliť a chceme nájsť najlacnejšiu kostru ktorá ju obsahuje. Dá sa ukázať, že takúto kostru vieme dostať z najlacnejšej kostry (celkovej) vymenením najviac jednej hrany.

Najlacnejšiu kostru vieme nájsť tak, že postupne pridávame vždy najlacnejšiu hranu ktorá spojí vrcholy, ktoré ešte nie sú v jednom komponente. Najlacnejšiu kostru s nejakou konkrétnou hranou nájdeme podobne, len ešte na začiatku hneď pridáme túto hranu. Pozrime sa, ako sa tieto kostry budú líšiť po každom kroku.

Začíname s dvoma prázdnymi grafmi $A$ a $B$. Do $B$ ešte pridáme hranu medzi vrcholmi $u$ a $v$. V prvých niekoľkých krokoch sa budú líšiť iba v tejto hrane. To tiež znamená, že tieto grafy budú tvorené rovnakými komponentmi, až na to, že $A$ bude mať $u$, $v$ v dvoch rôznych komponentoch a $B$ ich bude mať spojené. Rozdiel nastane, až keď sa rozhodneme pridať hranu medzi vrcholmi, ktoré sú v jednom grafe v rôznych komponentoch a v duhom v rovnakom. To nutne musí byť hrana, ktorá v $A$ spája komponenty obsahujúce $u$ a $v$, keďže všetky ostatné komponenty sú rovnaké. Keď túto hranu pridáme do $A$, dosiahneme úplne rovnaké komponenty (tým aké vrcholy obsahujú) v $A$ aj $B$. Preto každá ďalšia pridaná hrana do $A$ aj $B$ bude rovnaká. To znamená, že výsledné kostry budú rovnaké, okrem hrany, ktorú sme na začiatku pridali do $B$ a jednej hrany ktorú sme pridali do $A$.

Môžeme teda použiť postup, že najprv nájdeme celkovú najlacnejšiu kostru a potom skúšame, ktorú hranu chceme skrášliť. Túto hranu pridáme ku kostre a jednu hranu z nej dáme preč. Spravíme to tak, aby sme získali najlacnejšiu kostru s touto hranou.

Hrana, ktorú odstránime, musí byť nejaká hrana na ceste medzi tými vrcholmi, kam pridávame hranu, inak by vznikol cyklus. Môže to byť ľubovoľná z nich. Najlepšie riešenie dostaneme, ak odstránime najškaredšiu z nich. Zatiaľ to spravíme tak, že prejdeme postupne všetky hrany na tejto ceste a nájdeme maximum.

Nájsť na začiatku najlacnejšiu kostru nám trvá $O(m\\log n)$. Potom pre každú hranu potrebujeme prejsť cestu medzi dvoma vrcholmi v kostre, čo môže trvať $O(n)$. Z toho dostávame časovú zložitosť $O(nm)$. Pamäťová zložitosť je znova $O(m)$.

## Vzorové riešenie

Zlepšiť vieme hľadanie maximálnej hrany na ceste v strome. Začneme tým, že si ho zakoreníme v nejakom ľubovoľnom vrchole. Potom si pre každý vrchol predpočítame skoky o $1, 2, 4, 8, \\dots$ hore, tak ako keď hľadáme najnižšieho spoločného predka. Pre tieto skoky si okrem toho, na akom vrchole skončíme, pamätáme aj najlacnejšiu hranu na ceste ktorú sme preskočili. To vieme jednoducho vypočítať dynamikou od koreňa k listom: skok o $2k$ je ako skok o $k$ a potom ešte raz o $k$ od vrchola na ktorom pristaneme. Okrem toho si potrebujeme vypočítať hĺbku každého vrchola.

Maximálnu hranu na ceste medzi dvoma vrcholmi nájdeme tak, že najprv nájdeme ich najnižšieho spoločného predka. Na to použijeme skoky ktoré sme si predpočítali. Najprv z vrchola s väčšou hĺbkou preskáčeme na vrchol s rovnakou hĺbkou ako druhý vrchol, na čo nám postačí najviac $\\log n$ skokov. Potom binárne vyhľadáme najnižšieho spoločného predka: ak skok z oboch vrcholov pristane na rovnakom vrchole sme vysoko, ak na rôznych sme nízko.

Už sa stačí pozrieť na to, ktoré skoky sme použili aby sme sa dostali od každého z vrcholov k ich spoločnému predkovi. Z týchto skokov zoberieme maximum, čím dostaneme maximálnu hranu na celej ceste.

Takto nám stačí vypočítať najlacnejšiu kostru len raz na začiatku v čase $O(m\\log n)$. Potom si vypočítame skoky z každého vrchola. Každý skok vypočítame v konštantom čase a skokov je najviac $n\\log n$. Následne pre každú hranu vieme nájsť maximálnu (najškaredšiu) hranu na vymenenie v čase $O(\\log n)$. Celkovo má toto riešenie časovú zložitosť $O(m\\log n)$. Pamäťová zložitosť je $O(m + n\\log n)$ keďže si musíme navyše pamätať všetky skoky.
",9
d3927c8baa822f64,ksp,"# Jeden smer

""Ideme dobrým smerom?"" opýtal sa Maťko Kubka. Kubko mal kompas a Maťko mal mapu. ""Ideme niekde medzi severom a východom."" povedal Kubko. Maťko sa pozrel na mapu a povedal: ""Veľmi si mi nepomohol. Ak ideme skôr k severu, tak to minieme o desať kilometrov a ak viac k východu, tak možno aj o päť."" Kubko sa pozrel na kompas a zamyslel sa. Ak ideme viec k severu, to je vlastne medzi severom a severovýchodom. Ak je to bližšie k tomu severovýchodu, tak je to medzi severovýchodom a severoseverovýchodom a presne uprostred medzi nimi bol smer, ktorým išli. Kubko teda spokojne vyhlásil: ""Ideme presne na severovýchodoseveroseverovýchod."". Maťko sa usmial, a povedal: ""Ďakujem, teraz viem, že ideme správne.

Viete aj vy akým smerom idú dvojičky Maťko a Kubko?

## Úloha

Na vstupe dostanete názov nejakej svetovej strany a vašou úlohou je zistiť, akým smerom sa nachádza táto svetová strana. Aby sme vám to zjednodušili^[Áno, naozaj je to jednoduchšie.], chceme od vás uhol medzi severom a danou svetovou stranou, pri čom nechceme radiány, stupne, ani žiadne iné exotické zápisy, ale jednoducho číslo od $0$ do $1$. A toto číslo chceme v dvojkovej sústave.

Názov svetovej strany vždy vznikne spojením dvoch svetových strán medzi ktorými sa nachádza. Nie však hocijakých (juho-severovýchod predsa neexistuje). Musia to byť strany ""o úroveň vyššie"". Predstavme si že na prvej úrovni je sever, východ, juh, západ. Na druhej pridáme **aj** tie medzi nimi (teda S,SV,V,JV,J,JZ,Z,SZ). Môžete si všimnúť, že každá ďalšia nová strana už bude vznikať medzi dvoma stranami, z ktorých jedna vznikla na vyššej úrovni ako druhá. V takomto poradí ich aj skladáme. Máme teda severo-severovýchod a nie severovýchodo-sever, lebo sever vznikol už na prvej úrovni a severovýchod až na druhej.

Teraz sa pozrieme na uhly. Sever je $0$, východ je $1/4$, juh je $1/2$ a západ $3/4$. Uhol $1$ by opäť predstavoval sever, ale to nebudeme používať, lebo sever je už $0$. Ďalšie uhly sú jednoducho uprostred medzi susedmi. Juhozápad je teda medzi $1/2$ a $3/4$, a má uhol $5/8$.

Na koniec sa pozrieme ako vyzerá [binárny zápis](https://en.wikipedia.org/wiki/Binary_number#Decimal). Nula je stále nula. V binárnej sústave predstavujú miesta naľavo smerom od desatinnej čiarky postupne hodnoty $1$, $2$, $4$, $8$, $16$, ... a tie na pravej strane, (desatinné^[v dvojkovej sústave skôr polovičné] miesta) predstavujú zase postupne z ľava do prava $1/2$, $1/4$, $1/8$, $1/16$, ... .

Napríklad $13/16 = \\boldsymbol{1}/2 + \\boldsymbol{1}/4 + \\boldsymbol{0}/8 + \\boldsymbol{1}/16$, teda $0.1101$ v dvojkovej sústave^[pre odvážnejších: zapíšte v dvojkovej sústave $1/3$].

## Formát vstupu

Na vstupe je jeden riadok a na ňom skratka názvu svetovej strany. Skladá sa z veľkých písmen ""S,V,Z,J"". Dĺžka tohoto slova nepresiahne $10^7$

## Formát výstupu

Vypíšte jedno desatinné číslo v dvojkovej sústave, bez núl na konci s výnimkou nuly samotnej pre sever. Na oddelenie desatinných miest použite bodku, nie čiarku.

## Príklady

```vstup
SV
```

```vystup
0.001
```

_Sevorovýchod, $1/8=0/2+0/4+1/8$_

```vstup
SVVSV
```

```vystup
0.00101
```

_Sevorovýchodo-Východosevorovýchod, $5/32=0/2+0/4+1/8+0/16+1/32$_
","# Jeden smer

## Prečo binárny zápis a ako to funguje

Binárny zápis riešenia sme zvolili pre to, že na to, aby sme zistili “uhol”, potom nepotrebujeme žiadne výpočty. Stačí nám zistiť, ako daný názov svetovej strany vznikol. Totiž keď zistíme v ktorej polovici je hľadaná strana, vieme jedno desatinné miesto. Keď zistíme štvrtinu, vieme dve. Keď osminu, vieme tri, a tak ďalej. Riešenie sa teda dá ľahko postupne spresňovať a ľahko sa dá vypísať aj ako dlhý reťazec bez nejakých problémov s presnosťou alebo upravovaním zlomkov. Nasleduje ešte jeden obrázok, na ktorom vidno ako toto “spresňovanie” funguje. Všimnite si, že zelené/modré časti vedla seba sú vždy rovnaké a na červených sa striedajú $0$ a $1$.

## Naivné riešenie

Až $4$ body získame za riešenie, ktoré bude postupne vytvárať všetky svetové strany, a s nimi aj uhly, ktoré ku nim prislúchajú. Následne nám stačí sa pozrieť do tohoto zoznamu a vypísať ten správny uhol, bez zbytočných núl na konci. Keď budeme tieto svetové strany vytvárať po úrovniach, ďalšiu úroveň vyrobíme tak, že vždy zoberieme uhol strany vľavo od nej a pripíšeme na koniec $1$ (viď obrázok vyššie). Keď toto spravíme, treba ešte všetkým starým stranám pripísať na koniec $0$, aby sa nám aj ďalej zachoval rovnaký počet desatinných miest. Zložitosť takéhoto riešenia je $O(2^u)$ kde $u$ je počet úrovní ktoré chceme vyrobiť. Aby náš odhad bol závislí len od veľkosti vstupu, môžeme ho zvýšiť na $O(2^n)$ kde $n$ je dĺžka vstupu, lebo vieme, že viac úrovní potrebovať určite nebudeme.

## Vzorové riešenie

Prvá vec, čo si určite každý všimne je, že už z písmen ktoré máme na vstupe, vieme ľahko určiť štvrtinu, v ktorej je hľadaný smer. Ak sú to napríklad písmená *S* a *V*, vieme, že smer je niekde medzi severom a východom. Uhol ktorý hľadáme v binárnej sústave teda začína $0.00$ (okrem prípadu kedy je to východ samotný a smer je už $0.01$).

Ďalší krok, ktorý by sme mali spraviť je, zistiť či sa nachádzame medzi *S* a *SV* alebo medzi *SV* a *V*. Keď to zistíme, budeme vedieť, že ďalšia cifra je $0$ v prvom prípade resp. $1$ v druhom prípade. Najprv však musíme pochopiť, ako toto skladanie strán prebieha. Keď si napíšeme názov nejakej strany, môžeme si ho ""uzátvorkovať"" tak, ako vznikal až po úroveň, kedy sú v samostatných zátvorkách jednotlivé písmená.

Aby to bolo prehľadnejšie, budeme to demonštrovať na obrázku, na strane *VSVSVVSV*. Každý rámček predstavuje jednu “zátvorku” a pod ním sú naznačené “zátvorky” v ňom, teda dve svetové strany, ktorých zložením vznikol. Farebné odlíšenie nám ešte ukazuje koľko zložení treba na vytvorenie danej srany. Názvy ktoré vznikli bez skladania - základné strany (čierna), strany ktoré vznikli jedným zložením (modrá), dve zloženia (červená), tri (modrá) a štyri (žltá).

Na tomto obrázku si môžeme všimnúť napríklad to, že v jednej farbe sa vždy nachádza to isté (až na čiernu). Čo by sa stalo na ďalšej úrovni? To je veľmi jednoduché. Ďalšia úroveň vznikne tak, že pred tento názov prilepíme to, čo je vľavo alebo to, čo je vpravo od tejto strany. Teraz si stačí uvedomiť, že vlastne tento názov samotný vznikol ako spojenie toho vľavo, a toho vpravo, teda *VSV* a *SVVSV*. Keďže tieto dve veci už máme v našom obrázku (v druhom riadku), nič ""nové"" nám nepribudne.

Späť ku našej úlohe. Chceme zistiť, či sa nachádzame medzi *S* a *SV* aleo medzi *V* a *SV*. Pri ďalšom pohľade na obrázok zistíme, že *S* sa tam vždy nachádza iba ako priama súčasť *SV*, ale V sa tam nachádza aj ako súčasť iných strán (napr *VSV*). Keď sa nad tým ešte chvíľu zamyslíme, ľahko zistíme prečo je to tak. Ak sa nachádzame medzi *SV* a *V* a každá strana vzniká spojením okolitých dvoch, nemá sa tam ako dostať *S* samotné. Teda ak máme viac písmen *V* ako písmen *S*, vieme že okrem *SV* nám tam ostávajú práve písmená *V*. Máme teda ďalšiu cifru nášho dvojkového desatinného zápisu. Nakoľko sme išli do pravej polovice (pri pohľade zo stredu), je to $1$ a teda máme $0.001$.

Teraz nám ostáva celý proces opakovať. Vieme že sme medzi *SV* a *V*, a chceme zistiť, či vpravo alebo vľavo od *VSV*. Vieme teda, že celý názov je zložený zo *SV* a *V* a chceme zistiť, či je zložený z *VSV* a *SV* alebo *VSV* a *V*. Na to sa nám oplatí vedieť, koľko krát je tam *SV* a koľko *V*. Keď si na začiatku spočítame že $#\_S=3$ a $#_V=5$ (mriežkou označujeme počet výskytov písmena) vidíme, že v ďalšom kroku $#_{SV}=#\_S$ a $#_V=#_V-#_S$. Teda minuli sme toľko *V* koľko je *S* aby sme ich pospájali do *SV*. Teraz opäť zistíme, čoho je viac a vieme ďalšiu cifru. Máme teda $#_{SV}=3$ a $#_V=2$, sme bližšie ku *SV*, teda medzi *VSV* a *SV* (uhol $0.0010$). Teraz položíme $#_{VSV}=#_V=2$ a $#_{SV}=#_{SV}-#_V=1$. Sme teda bližšie ku *VSV* a máme uhol $0.00101$. V ďalom kroku nám ostane $#_{SVVSV}=1$ a $#_{VSV}=1$, teda sme priamo medzi týmito dvoma stranami a finálny uhol je $0.001011$ (posledná cifra nám vždy vyjde $1$).

Podobnosť tohto postupu s algoritmom na zistenie najväčšieho spoločného deliteľa sama o sebe naznačuje jednoduchosť implementácie.

Časová zložitosť takéhoto riešenia je $O(n)$ od dĺžky slova na vstupe.

## Iné riešenie

Z predošlého riešenia si môžeme všimnúť, že už počet písmen *S* a *V*, resp. Ich pomer, určuje jednoznačne uhol a je v jednom smere rastúci. Ak teda vieme desatinné dvojkové číslo previesť na názov strany (stačí aj počet písmen *S* a *V*), môžeme výsledný uhol binárne vyhľadávať.
",5
48b2b7debc6c81e3,ksp,"# Obiehanie

Pred pár týždňami sa uskutočnilo školské kolo súťaže Zenit v programovaní a mnohí z vás sa ho pravdepodobne zúčastnili. Mohli ste si na ňom všimnúť, že po odovzdaní úlohy ste museli chvíľku počkať na jej vyhodnotenie. Takú malú, 20-minútovú chvíľku. Táto chvíľka vznikla preto, lebo testovač dostal úžasný nápad, ako robiť vyhodnocovanie odovzdaných riešení. Testovať riešenia v tom poradí, v akom prišli sa mu zazdalo príliš trápne a určite neoptimálne, preto sa rozhodol usporiadať turnaje.

Ako to funguje? Najprv treba počkať, kým riešitelia odovzdajú dosť veľa riešení. Každému riešeniu je potom pridelená jeho úžasnosť^[zjavne padajúci bruteforce v pythone veľmi úžasný nie je, ale taká binárne vyhľadávaná, lazy-loadingová geometria už stojí za to]. Následne sa riešenia zoradia vedľa seba v takom poradí, v akom prišli a začne sa turnaj. Ide o klasického turnajového pavúka -- najprv súperí prvé riešenie s druhým, potom tretie zo štvrtým a tak ďalej. To úžasnejšie z dvojice riešení vyhrá a postupuje do ďalšieho kola. V druhom kole súperia už len víťazi predchádzajúceho kola rovnakým spôsobom. Takto to pokračuje, až kým nezostane len to úplne najúžasnejšie riešenie, ktoré sa naozaj aj otestuje.

Zenitu sa zúčastnil aj Romanko. Porozhliadal sa okolo seba a už na prvý pohľad vedel, ako úžasné riešenia vyprodukujú ostatní riešitelia. Dokonca aj presne vedel, kedy tieto riešenia pošlú na otestovanie a teda ako budú usporiadané počas turnaja. Romanko by teraz chcel odovzdať svoje riešenie a mať ho aj v rozumnom čase^[hneď] otestované. Jeho riešenie ale určite nie je dosť úžasné na to, aby mohlo vyhrať turnaj.

Romanko ale vie, že testovač je mysteriózna entita a dá sa rôzne ovplyvňovať. Ak mu človek správne obetuje horalku^[dá ju najbližšiemu vedúcemu KSP], je možné, že jeho riešenie prejde do ďalšieho kola aj keď nebolo to úžasnejšie. Romanko sa teraz potrebuje vopchať medzi ostatné riešenia (napríklad odovzdá čo najskôr a bude teda v turnaji ako prvý) a rád by vedel, koľko horaliek bude musieť obetovať, ak chce vyhrať turnaj a začína na danej pozícií. Môžete mu s tým pomôcť?

## Úloha

Na vstupe sú dané úžasnosti $n-1$ riešení ostatných riešiteľov v takom poradí, v akom budú na testovači. Taktiež je zadaná úžasnosť Romankovho riešenia. Pre každú pozíciu, na ktorú sa môže Romanko vopchať chceme zrátať, koľko horaliek musí obetovať, aby jeho riešenie vyhralo turnaj a bolo teda otestované najskôr.

## Formát vstupu

Na prvom riadku sa nachádza číslo $n$ -- počet riešení a $k$ -- úžasnosť Romankovho riešenia. V druhom riadku sa nachádza $n-1$ rôznych celých čísiel $a_1 \\dots a\_{n-1}$ -- úžasnosti riešení ostatných riešiteľov. Platí $1 \\leq n, k, a_i \\leq 2^{20} = 1,048,576$ a že $n$ je mocninou $2$. Taktiež platí, že úžasnosti riešení (aj Romanovho) sú navzájom rôzne.

## Formát výstupu

Vypíšte $n$ medzerou oddelených čísiel, pričom $i$-te číslo udáva počet horaliek, ktoré Romanko potrebuje obetovať, ak by jeho riešenie začínalo na $i$-tej pozícií.

## Príklad

```vstup
4 2
1 3 4
```

```vystup
1 1 2 2
```

*V tomto príklade Romanko potrebuje obetovať pre prvé a druhé miesto $1$ horalku. Najprv sa jeho riešenie stretne s riešením úžasnosti $1$ a ľahko sa dostane do ďalšieho kola. Tam sa ale stretne s riešením úžasnosti $4$ a bude musieť obetovať horalku. Pri pozícií $3$ a $4$ bude treba obetovať horalku hneď v prvom kole kvôli riešeniu úžasnosti $4$ a potom aj kvôli riešeniu úžasnosti $3$ (ktoré vyhralo súboj v prvej dvojici). Konkrétne, ak by Romanko začínal na tretej pozícií, na testovači by boli úžasnosti riešení v poradí $1$ $3$ $2$ $4$.*
","# Obiehanie

## Jednoduché riešenie simuláciou

Najjednoduchší spôsob na riešenie tejto úlohy je simulovať celý turnaj postupne pre všetky počiatočné pozície Romankovho submitu.

Turnaj môžeme simulovať po úrovniach, pričom pre každú úroveň budeme mať jedno pole so submitmi, ktoré sa na túto úroveň dostali. Na začiatku si vytvoríme jedno pole so všetkými submitmi a Romankov submit vložíme na jednu pozíciu medzi tie ostatné a začneme simulovať. Pre dvojice submitov vedľa seba sa pozrieme na ich úžasnosti a do ďalšieho kola posunieme ten, ktorý je úžasnejší -- úžasnosť víťaza uložíme do poľa ďalšej úrovne. Keď príde na rad Romankov submit, stačí zistiť, či je submit, s ktorým súperí, úžasnejší a teda či musí Romanko obetovať horalku. Pozíciu Romankovho submitu na každej úrovni si vieme udržiavať napríklad v jednej premennej. Tento postup opakujeme, až kým nám nezostane v aktuálnej úrovni len jeden submit -- ten Romankov.

Takto odsimulujeme celý turnaj pre všetky počiatočné pozície Romankovho submitu a pre každú simuláciu vypíšeme výsledok.

Ako rýchly je tento algoritmus? Potrebujeme $O(n)$-krát simulovať turnaj. Turnaj pozostáva z jednotlivých zápasov, presnejšie z porovnaní submitov. Vieme, že po každom porovnaní prestane byť jeden submit v turnaji, teda na vyradenie $n-1$ submitov potrebujeme spraviť $n-1$ porovnaní. Každý turnaj má teda $O(n)$ zápasov a toto riešenie má preto časovú zložistosť $O(n^2)$. Pri pozornej implementácií vieme dosiahnuť pamäťovú zložistosť $O(n)$. Naprogramovaním tohto postupu by ste dostali približne 3 body v praktickej časti.

## Lepšie riešenie

Stará programátorská múdrosť hovorí, že ak chceme mať efektívny algoritmus, tak nesmieme nič počítať zbytočne a tiež nesmieme nič počítať dvakrát. Robíme niečo zbytočne? Simulujeme napríklad veľmi veľa zápasov, ktoré sa Romanka takmer vôbec netýkajú. Takisto veľmi veľa krát simulujeme presne rovnaké zápasy.

Najprv ale zaveďme trošku formálnejšie pojmy, aby sme sa mohli jednoduchšie vyjadrovať. Prečíslujme si submity ostatných ľudí ako $a_0$ až $a\_{n-2}$ (za číslovanie od $1$ v zadaní sa ospravedlňujeme). Označme si pozície na začiatku ako $p_0, p_1$ až $p\_{n-1}$.

Prvým pozorovaním zistíme, čo sa vlastne deje pri jednotlivých zápasoch. V každom zápase proti sebe súperia **najúžasnejšie submity z konkrétnych intervalov**.

- V prvom kole spolu súperia ,,reprezentanti'' intervalov dĺžky $1$ ($p_0$ proti $p_1$, $p_2$ proti $p_3$, atď.).

- V druhom kole sú to už reprezentanti intervalov dĺžky $2$ (víťaz z $p_0$ až $p_1$ proti víťazovi z $p_2$ až $p_3$).

- V treťom kole sú to intervaly dĺžky $4$ ( víťaz z $p_0$ až $p_3$ proti víťazovi z $p_4$ až $p_7$).

Podobne to ide aj pre ďalšie kolá. Kto ale môže byť reprezentantom pre jeden konkrétny interval? Vždy je to buď najúžasnejší submit z daného intervalu, alebo je to Romanko.

Druhým pozorovaním je, že to, **aký submit začína na pozícií $p_i$ závisí len od umiestnenia Romankovho submitu**.

- Ak je Romankov submit naľavo od $p_i$, tak na $p_i$ je submit $a\_{i-1}$.

- Ak je Romankov submit napravo, tak na $p_i$ je submit $a_i$.

Toto vieme povedať aj pre celé intervaly. Uvažujme interval $p_x$ až $p_y$, na ktorom sa nenachádza Romankov submit. Potom sa na tomto intervale nachádzajú buď submity $a_x$ až $a_y$ (ak je Romankov submit napravo od tohoto intervalu), alebo $a\_{x-1}$ až $a\_{y-1}$ (ak je Romankov submit naľavo od tohoto intervalu).

Ako vieme tieto pozorovania využiť? Keď chceme zistiť, s kým musí Romankov submit v nejakom kole bojovať, nemusíme simulovať celý daný podstrom turnaja. Stačí nám len zistiť maximum z $a\_{x-1}$ až $a\_{y-1}$ alebo $a_x$ až $a_y$. Na to vieme ľahko použiť maximový [intervalový strom](https://www.ksp.sk/kucharka/intervalovy_strom/).

Každý vrchol stromu reprezentuje jeden interval (čísla v krúžkoch sú začiatok a koniec intervalu) a v každom vrchole si budeme pamätať jedno číslo. Vo vrcholoch na najspodnejšej úrovni budú úžasnosti jednotlivých submitov. Hodnoty zvyšných vrcholov budú vždy maximum z ich dvoch synov. V každom vrchole si budeme teda pamätať úžasnosť víťazného submitu na danom intervale.

Výhodou takéhoto stromu je to, že si ho nemusíme pamätať ako graf -- vrcholy a hrany -- ale dá sa dobre reprezentovať ako obyčajné pole $P$ dĺžky $2n$. Na pozícií $1$ bude koreň. Na pozíciach $n$ až $2n-1$ budú listy. (Na obrázku sú indexy jednotlivých vrcholov v poli $P$ napísané mimo krúžkov a $n=8$.) To, čo je najkrajšie na tejto reprezentácií je, že vrchol $x$ má synov na pozíciách $2x$ a $2x+1$ a otca na pozícii $\\lfloor x/2 \\rfloor$. Teda napr. vrchol $7$ má synov $14$ a $15$ a otca $3$. Vieme sa tak po strome rýchlo pohybovať a zistiť víťaza intervalu vo vrchole $x$ ako $\\max(P[2x], P[2x+1])$.

Intervalový strom vie vo všeobecnosti zistiť maximum na ľubovoľnom intervale v čase $O(\\log n)$. Intervaly, ktorých maximá nás zaujímajú, majú ale vždy dĺžku mocninu dvojky a tak sú ich maximá práve čísla uložené vo vrcholoch intervalového stromu. Vďaka tomu vieme víťazov jednotlivých intervalov zistiť v konštantnom čase -- pozretím sa na správny index poľa.

Potrebujeme ale dva intervalové stromy, jeden pre normálne intervaly -- ako keby bol Romankov submit na konci (napravo) -- a jeden pre posunuté -- ako keby bol romankov submit na začiatku (naľavo).

Ako bude teda vyzerať celé riešenie? Najprv si predpočítame víťazov jednotlivých intervalov pomocou dvoch stromov. Ich výpočet nám potrvá $O(n)$. Najprv uložíme na koniec poľa $P$ úžasnosti jednotlivých submitov a potom jedným prechodom od konca spočítame víťazov všetkých intervalov.

Ďalej budeme simulovať turnaje, ale tentokrát len zápasy Romankovho submitu. V každom kole vieme pomocou stromov zistiť úžasnosť submitu, s ktorým musí Romankov submit zápasiť (s víťazom niektorého intervalu). Kôl v turnaji je $O(\\log n)$ a zisťovanie maxima nám trvá $O(1)$. Celý turnaj potrebujeme navyše odsimulovať pre $O(n)$ pozícií. Máme teda riešenie s časovou zložitosťou $O(n \\log n)$ a s pamäťovou zložitosťou $O(n)$. Toto riešenie dokázalo dostať v praktickej časti plný počet bodov.

## Optimálne riešenie

Riešenie však vieme ešte zefektívniť. Stále totiž robíme niektoré veci viackrát. Pozrime sa na posledný zápas. Koľkokrát sa spýtame na maximum z intervalu $p\_{0}, p\_{\\frac{n}{2}}$? Vždy, keď Romankov submit začína v intervale $p\_{\\frac{n}{2}}, p\_{n-1}$, čo je presne $\\frac{n}{2}$ krát. Nevieme sa tohto počítania nejako zbaviť? Vieme!

Ak nám vadí, že sa na nejaký zápas pozeráme viackrát, pozrime sa naň len raz. Napríklad pre posledný zápas máme dve možnosti: buď bol Romankov submit na pozíciách z intervalu $A = (p_0, p\_{\\frac{n}{2}})$, alebo $B = (p\_{\\frac{n}{2}}+1, p\_{n-1})$. Ak bol na intervale $A$, tak vieme, ktoré submity boli na intervale $B$ a teda vieme, s kým bude Romankov submit súperiť. To ale znamená, že pre všetky pozície z intervalu $A$ vieme povedať, či bude musieť Romanko v danom zápase musieť obetovať horalku. Toto isté vieme zjavne urobiť pre pozície z intervalu $B$.

Následne môžeme samostatne riešiť prípady, keď bol Romankov submit v intervaloch $A = (p_0, p\_{\\frac{n}{4}})$ a $B = (p\_{\\frac{n}{4}}+1, p\_{\\frac{n}{2}})$ a v podobných intervaloch v druhej polovici všetkých pozícií. To, že sú intervaly do seba tak pekne vnorené, navádza na použitie rekurzie.

Kým v predošlých riešeniach sme počítali výsledky zdola nahor -- pre každú pozíciu Romankovho submitu sme simulovali súboje od prvého po posledný, teraz budeme úlohu riešiť zhora nadol. Pre všetky možné pozície Romankovho submitu najprv zistíme, v ktorých z nich musel obetovať horalku v poslednom súboji, v ďalšej úrovni rekurzie zistíme, na ktorých pozíciách musel obetovať horalku v predposlednom súboji, atď.

Pozrime sa na interval $I$ pozícií $(p_x, p_y)$. Tento interval si rozdeľme na úsek $A = (p_x, p\_{\\frac{x+y}{2}})$ a $B = (p\_{\\frac{x+y}{2}}+1, p_y)$.

- Ak bol Romankov submit v intervale $B$, musel poraziť najúžasnejší submit z $A$. Jeho úžastnosť vieme ľahko nájsť v našom intervalovom strome, pretože na pozíciách $p_x, p\_{\\frac{x+y}{2}}$ budú submity $a_x, a\_{\\frac{x+y}{2}}$. V rekurzii si ako parameter posielame počet horaliek, ktoré musel Romanko zatiaľ obetovať. Tento počet zvýšime, ak je víťaz intervalu $A$ úžasnejší ako Romankov submit, a zavoláme sa rekurzívne na interval $B$.

- Pokiaľ je Romankov submit z intervalu $A$, musíme si dávať trochu pozor. V $B$ totiž budú submity $p\_{\\frac{x+y}{2}}, p_y-1$, lebo Romanko je od nich naľavo. Pre tie máme druhý intervalový strom. Opäť porovnáme Romankov submit s víťazom $B$ a rekurzívne sa zavoláme na $A$.

- Ak je náš interval $I$ jednoprvkový, rekurziu ukončíme a v posielanom parametri sme dostali odpoveď pre danú pozíciu -- koľko horaliek musel Romanko obetovať, ak začínal na pozícii $i, I = (p_i, p_i)$.

V riešení teda najprv zavoláme rekurzívnu funkciu na celý interval pozícií $(0, n-1)$ s nula obetovanými horalkami. Následne sa v každom volaní rozdvojíme na intervaly $A$ a $B$.

Toto krásne riešenie má časovú zložitosť $O(n)$. Každé rekurzívne volanie spravíme v konštantnom čase, na každý interval sa totiž zavoláme práve raz a intervalov dĺžky $1$ je $n$, intervalov dĺžky $2$ je $n/2$, atď. a teda $n + n/2 + n/4 + \\dots + 2 + 1 = 2n - 1$ ($n$ je mocninou dvojky).
",6
1925a1c354e97f22,ksp,"# Energetické pole

Paulínka si ako každý čerstvý vysokoškolák dopraje dostatočné a zdravé množstvo spánku. Navyše, v záchvate mánie (nebojte sa, mánia už dávno skončila) začala jesť na večeru divné veci. Kombináciou týchto javov sa jej uprostred noci sníval prečudesný sen. Ocitla sa na ostatnom Letnom Tábore Trojstenu (na tom o Power Rangeroch), kde sa práve na poli hrala hra -- strategická behačka.

Družinky účastníkov bojovali o ovládnutie políčok veľkého energetického poľa, ktoré bolo rozdelené na štvorčeky. Prebiehalo to tak, že družinky vysielali svojich rangerov na behy skrz štvorcovú mriežku. Títo rangeri mohli behať iba pozdĺž osí mriežky a nemohli meniť smer. Navyše, aby sa náhodou nezrazili, mohol bežať iba jeden ranger naraz.

Rangeri boli, samozrejme, farební. Keď ranger prebehol cez políčko, políčko sa sfarbilo jeho farbou, a tak bolo ihneď viditeľné, že políčko začalo patriť jeho družinke. Políčka na začiatku hry nemali žiadnu farbu. Aj keď ranger prebehol po už zafarbenom políčku, toto políčko po prebehnutí farbu zmenilo.

Paulínka na túto hru prišla neskoro a celkom by ju zaujímalo, akú časť hry prespala. Na základe ofarbeného poľa zistite, koľko najmenej kôl muselo prebehnúť od začiatku hry do momentu, kedy Paulínka prišla.

## Úloha

Dostanete mriežku rozmerov $r \\times s$, ktorá je na každom políčku ofarbená jednou farbou. Táto mriežka bola na začiatku hry čistá. Potom prebehlo $k$ kôl. V každom kole sa prefarbil práve jeden celý stĺpec alebo riadok tejto mriežky jednou farbou. Na základe výsledného ofarbenia zistite, koľko najmenej kôl mohlo prebehnúť, teda minimálne možné $k$.

## Formát vstupu

V prvom riadku vstupu sú dve čísla: $r, s (1 \\leq r, s \\leq 200)$, počet riadkov a stĺpcov mriežky. Každý z nasledujúcich $r$ riadkov obsahuje $s$ čísel oddelených medzerami $f_i; 0 \\leq f_i \\leq r \\cdot s$, ktoré popisujú farby jednotlivých políčok mriežky.

Farby používajú celý rozsah čísel na vstupe. Inými slovami, ak sa vo vstupe vyskytuje farba číslo $f$, určite sa vo vstupe nachádzdzajú aj farby $0, 1, \\dots, f-1$.

Vo vstupoch je tiež garantované, že tabuľka vznikla podľa pravidiel hry.

## Formát výstupu

Na výstup vypíšte jedno číslo $k$, minimálny počet ofarbení stĺpca/riadku potrebných na dosiahnutie ofarbenia tabuľky.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| ----:| ----:| ----:| | Maximálne $r + s$ | $10$| $20$| $200$| $300$|

## Príklady

```vstup
2 5
0 0 1 1 1
0 0 1 1 1
```

```vystup
4
```

*V optimálnom prípade ofarbíme najprv oba riadky farbou $1$ a potom prvé dva stĺpce farbou $0$*.

```vstup
4 4
0 0 0 0
1 4 4 3
1 5 6 3
1 2 2 2
```

```vystup
7
```

*Ofarbujeme postupne: tretí riadok farbou $6$, druhý stĺpec $5$, druhý riadok $4$, štvrtý stĺpec $3$, posledný riadok $2$, prvý stĺpec $1$, prvý riadok $0$.*
","# Energetické pole

## Hrubá Sila

Na začiatok si preformulujme zadanie úlohy pomocou všeobecnejších pojmov, a potom si ukážeme prvé jednoduché riešenie tejto úlohy.

Máme tabuľku, ktorá bola ofarbená postupnosťou ofarbení jednotlivých stĺpcov a riadkov v nejakom poradí. Platí pritom, že sme vždy ofarbili celý daný stĺpec/riadok tou istou farbou. Našou úlohou je určiť, koľko najmenej takýchto ofarbení potrebujeme použiť na dosiahnutie tabuľky zo vstupu. Všimnime si, že ak jeden riadok či stĺpec ofarbíme druhýkrát, všetka informácia o prvom ofarbení sa stratí. Vďaka tomu môžeme predpokladať, že vo výslednom ofarbení bol každý riadok aj každý stĺpec zafarbený najviac raz.

Tu sa naskytá nápad na jednoduché riešenie: Keďže každý riadok aj stĺpec sme zafarbili najviac raz, ak si zoberieme všetky možné zoradenia stĺpcov a riadkov, tak môžeme v danom poradí skúšať odfarbovať stĺpce a riadky tabuľky. Riadok či stĺpec budeme môcť odfarbiť iba vtedy, ak sú všetky zafarbené políčka v ňom jednej farby. V prípade, kedy sa nám podarí celú tabuľku vyčistiť najskôr, dostaneme optimálne riešenie. V tomto riešení teda hľadamé postupnosť ofarbení riadkov a stĺpcov tak, že pre každú postupnosť odzadu (odfarbovaním) overíme, či vstupná tabuľka mohla vzniknúť touto postupnosťou.

Odfarbenie riadka/stĺpca sa dá jednoducho implementovať tak, že odfarbený riadok/stĺpec z tabuľky odstránime (budeme ho ďalej ignorovať), pretože nám nezáleží na tom, aké farby boli ""pod posledným náterom"". Namiesto skúšania všetkých permutácií riadkov a stĺpcov by sme tiež mohli myšlienku riešenia implementovať aj mierne efektívnejšie -- pomocou backtracku (rekurzívne prehľadávanie s návratom).

Takéto priame a myšlienkovo jednoduché riešenie musí vyskúšať všetky permutácie riadkov a stĺpcov^[Ak neveríte, porozmýšľajte nad vstupom, kde sú všetky políčka tabuľky jednej farby.], ktorých je $(r+s)!$ a pre každú permutáciu musí overiť, či vedie k tabuľke zo vstupu, napríklad v čase $O(rs)$. Celé riešenie tak bude mať časovú zložitosť $O((r+s)! \\cdot rs)$, vďaka čomu na bežnom počítači vyrieši vstupy s $r+s < 10$.

## Greedy riešenie

Pri opravovaní vašich riešení sme sa dozvedeli, že vďaka tomu, že sa na vstupe nachádzali len korektné zadania (každá ofarbená tabuľka bola výsledkom farbenia riadkov a stĺpcov), sa táto úloha sa dala vyriešiť aj pažravým (greedy) prístupom.

Hlavná myšlienka pažravého riešenia je, že sa pokúsime tabuľku postupne od konca odfarbovať tak, ako v riešení hrubou silou. Ak ale máme na výber z viacero možností čo spraviť (môžeme odfarbiť viacero stĺpcov alebo môžeme odfarbiť riadky aj stĺpce), nebudeme sa rekurzívne rozvetvovať a skúšať všetky možné poradia, ale jednoducho odfrabíme všetky jednofarebné stĺpce alebo riadky jednej farby naraz, skoro vždy v ľubovoľnom poradí.

Jediné špeciálne prípady nastanú vtedy, ak nám zostáva tabuľka, kde sú všetky riadky jednofarebné, všetky stĺpce jednofarebné alebo ak sa po odstránení jednofarebných stĺpcov/riadkov dostaneme do takejto situácie. Vtedy sa nám môže oplatiť odfarbiť všetky stĺpce okrem stĺpcov jednej farby a zvyšné stĺpce odfarbiť pomocou odfarbenia riadkov, ak je riadkov menej ako stĺpcov.

Takéto riešenie sa pomerne ľahko vymyslí a naprogramuje, no tá najťažšia časť pri ňom je dokázať, že vždy vedie k optimálnemu riešeniu. Dôkazom si tiež overíte, že ste pri vymýšľaní postupu nezabudli na žiadne špeciálne prípady. Mnohí z vás stratili body na nepremyslení si špeciálnych prípadov alebo na nedôslednom dôkaze (keďže sme greedy riešeniu spočiatku neverili, bolo nás nutné presviedčať). Rozhodli sme sa teda napísať časť dôkazu, ktorý zachytáva hlavné myšlienky toho, prečo pažravé riešenia môžu fungovať a otázky nad ktorými sa bolo potrebné sa zamyslieť.

Zadefinujme si poriadne všetky situácie, ktoré môžu nastať. Počas celého riešenia (odfarbovania) musí platiť, že sa v tabuľke vždy nachádza aspoň jeden celý riadok alebo stĺpec. Vzhľadom na to, že riadky sa stanú stĺpcami keď tabuľku otočíme o 90 stupňov, budeme hovoriť len o prípadoch, kedy máme aspoň jeden jednofarebný riadok.

1. V tabuľke sú **iba jednofarebné riadky**. Rôzne riadky môžu byť rôznych farieb. Takáto situácia je veľmi blízko k odfarbeniu celej tabuľky -- už nám stačí odfarbiť len všetky riadky, prípadne možno riadky poslednej farby odfarbiť po stĺpoch.
1. V tabuľke **je aspoň jeden nejednofarebný riadok**. Tabuľka obsahuje jeden alebo niekoľko jednofarebných riadkov, ktoré sú všetky tej istej farby a neobsahuje žiaden jednofarebný stĺpec. V tomto prípade existuje len jediná cesta ako pokračovať ďalej v riešení -- odstránime všetky tieto riadky.
1. V tabuľke je aspoň jeden nejednofarebný riadok. Tabuľka obsahuje jeden alebo niekoľko jednofarebných riadkov, ktoré sú **aspoň dvoch rôznych farieb** a neobsahuje žiaden jednofarebný stĺpec. V tomto prípade máme na výber -- riadky ktorej farby odstránime najskôr?
1. V tabuľke je aspoň jeden nejednofarebný riadok. Tabuľka obsahuje aspoň jeden jednofarebný riadok a **aspoň jeden jednofarebný stĺpec**, ktoré sú (musia byť) všetky tej istej farby. Tu máme opäť na výber -- odstránime najprv riadky alebo stĺpce?

Môžete si rozmyslieť, že iné situácie (až na triviálne -- všetky políčka jednej farby a prázdna tabuľka) už nikdy nenastanú.

Čo robiť v situácii 4? Ak sa odobraním riadka dostaneme do situácie 1 s jednofarebnými stĺpcami, môže sa nám oplatiť teraz neodstrániť stĺpec tejto farby, lebo výhodnejšie môže byť jeho odstránenie na konci, v podobe riadkov. Existuje ešte nejaká iná situácia, kedy neodstrániť aj riadok aj stĺpec (prípadne všetky jednofarebné riadky aj stĺpce)? Nie. Ak po odstránení riadkov nie sme ešte v situácii 1, znamená to, že na doriešenie úlohy je potrebné odoberať ešte stĺpce a potom ešte riadky inej farby. To ale znamená, že naše jednofarebné stĺpce budeme musiť tiež odobrať, a teda ich môžeme odobrať hneď teraz! V skoro všetkých prípadoch je teda jedno, či odstránime najprv riadky, najprv stĺpce alebo všetko naraz.

Čo robiť v situácii 3? Na to, aby sme pohli v riešení ďalej (do inej situácie) musíme buď odobrať všetky jednofarebné riadky (dostanem sa do 1, 2 alebo 3, kde dostaneme jednofarebné stĺpce) alebo odoberieme všetky riadky okrem riadkov jednej farby (dostaneme sa do 2 alebo 4). Úvahu si môžeme zjednodušiť tak, že nikdy neodstránime všetky riadky ale vždy zachováme riadky jednej farby a potom sa budeme rozhodovať ako keby sme boli v situácii 4 (alebo 2). Ak sa potom znova rozhodneme odobrať riadok, dosiahneme rovnaký výsledok ako keby sme rovno odstránili všetky riadky. Poslednou otázkou teda zostáva to, či závisí na tom, ktoré riadky jednej farby ponecháme ako posledné. Na tomto ale záleží len vtedy, ak by sme sa z následnej situácie 4 dostali do 1. Inak v situácii 4 tieto riadky aj tak ostránime a znova teda vo väčšine prípadov nezáleží na tom, ktorú farbu ponecháme!

Konkrétne riešenia špeciálnych prípadov sa dali vyriešiť najjednoduchšie tak, že v každom kroku odsimulujeme pár krokov algoritmu hrubou silou. Dali sa tiež navrhovať konkrétne postupy riešenia jednotlivých špeciálnych prípadov, no tie by si vyžiadali ešte viac dokazovania.

Daľej nasleduje naše pôvodné vzorové riešenie, ktoré je možno náročnejšie (alebo trikovejšie) na vymyslenie, no jednoduchšie vidno, že je správne.

## Optimálna postupnosť farbení a náčrt lepšieho riešenia

Pozrime sa znovu na nejakú postupnosť farieb, ktorá je optimálnym riešením tejto úlohy. Keďže každé políčko tabuľky je nejako zafarbené, tak musel byť zafarbený buď každý stĺpec alebo každý riadok. Predpokladajme, preto, že počas procesu bol každý riadok aj každý stĺpec zafarbený práve raz. Potom si vieme všetky riadky a stĺpce zoradiť do jednej postupnosti, podľa toho, v akom poradí boli ofarbené. Všimnime si, že prvý stĺpec alebo prvý riadok, ktorý sme ofarbili, na výsledné ofarbenie tabuľky vôbec nevplýva, keďže všetky riadky resp. stĺpce boli neskôr prefarbené. Preto ho v optimálnom riešení nezafarbíme, keďže aj tak nič nemení. Povedzme, že to bol $i$-ty riadok. Keďže sme ho nezafarbili ani raz, tak podľa neho vieme zistiť, akými farbami boli zafarbené všetky stĺpce a podľa týchto stĺpcov vieme zistiť ako (resp. či) boli zafarbené zvyšné riadky. Riešením úlohy potom bude počet stĺpcov $+$ počet riadkov, ktoré sme zafarbili.

## Ideálne riešenie

Keďže vieme, že jeden z riadkov alebo stĺpcov nebol v optimálnom riešení zafarbený, môžeme ich všetky prejsť a pre každý zistiť, či to mohol byť daný riadok/stĺpec. Najprv zistíme, či sú farby riadkov a stĺpcov, ktoré sú implikované týmto riadkom/stĺpcom, konzistenté s tabuľkou vo vstupe. Ak áno, tak vieme, koľko zafarbení by sme museli použiť. Ak je tento počet menší, ako počet prefarbení v doteraz najlpšom riešení (ktoré sme dostali tak, že sme predpokladali, že nezafarbený bol iný riadok/stĺpec), tak sme našli lepšie riešenie, ktoré si uložíme.

Náš program teda bude vyzerať nasledovne. Budeme mať funkciu, ktorej určíme jeden riadok, o ktorom budeme predpokladať, že nebol zafarbený. Táto funkcia nám vráti počet ofarbení riadkov a stĺpcov potrebných na ofarbenie tabuľky. Podľa farieb v určenom riadku určíme farby, ktorými boli zafarbené jednotlivé stĺpce. Potom prejdeme všetky políčka v tabuľke, pričom ak dané políčko nie je farby príslušného stĺpca, priradíme jeho farbu k danému riadku. Ak mal tento riadok už priradenú nejakú farbu, ktorá je odlišná od farby políčka, tak nebude existovať žiadne riešenie, pretože každé políčko môže mať farbu len od stĺpca alebo od riadka. V takomto prípade môžeme vrátiť $r+s$, keďže optimálne riešenie je od $r+s$ ostro menšie. Ak nenájdeme žiaden spor, zrátame počet riadkov, ktorým sme priradili farbu, pripočítame ho ku počtu stĺpcov a toto číslo vrátime.

Túto funkciu spustíme postupne na všetkých riadkoch tabuľky, pričom si uložíme minimum čo nám vrátila. Keďže sme leniví a nechce sa nám robiť samostatnú funkciu pre stĺpce, tabuľku následne transponujeme (vymeníme riadky za stĺpce a naopak) a zopakujeme to isté, čo sme spravili predtým.

Časová zložitosť takéhoto riešenia bude $O((r+s) \\cdot rs)$ keďže pre každý potenciálne nezafarbený riadok/stĺpec prechádzame celú tabuľku. Jeho pamäťová zložitosť bude $O(rs)$, keďže najväčšie, čo si kedy pamätáme, je samotná tabuľka a tú si potrebujeme pamätať celú.

## Nájde náš algoritmus skutočne správne ofarbenie tabuľky?

Tu by bolo na mieste poznamenať, že predpokladáme, že riešenie, ktoré sme našli je naozaj riešením, a že takýmto počtom ofarbení naozaj vieme získať tabuľku zo vstupu. Overili sme to, či sme niektoré riadky neofarbili dvoma farbami. Podobne aj pre stĺpce. No neoverili sme to, či sa tabuľka dá naozaj škontruovať, a či by pri takejto konštrukcii nemohli vzniknúť cykly. Pod cyklom myslíme prípady, kedy by sme museli riadok $i$ zafarbiť skôr ako stĺpec $j$, lenže zároveň by sme museli stĺpec $j$ zafarbiť skôr ako riadok $i$, viď. obrázok, kde sa dané zafarbenie nedá skonštruovať:

Žltý stĺpec bol zafarbený pred zeleným riadkom. Ten bol zafarbený pred modrým stĺpcom. Modrý stĺpec musel byť zafarbený pred červeným riadkom, takže sme červený riadok museli zafarbiť po žltom stĺpci. No vidíme, že žltý stĺpec sme museli zafarbiť po červenom riadku, a obe tieto podmienky sa nedajú splniť naraz.

Jeden spôsob, akým by sme tento problém mohli vyriešiť, je detekcia cyklov. Mohli by sme si skonštruovať orientovaný bipartitný graf, v ktorom vedie hrana z riadku do stĺpca vtedy, keď sme riadok ofarbili neskôr a hrana zo stĺpca do riadku, keď sme ofarbili neskôr stĺpec. Následne by nám stačilo overiť, že sa v grafe nevyskytuje cyklus.

Namiesto toho si ale môžeme dokázať, že za predpokladu, že vstupná tabuľka je ofarbiteľná, sa takýto cyklus nebude v žiadnom nájdenom riešení vyskytovať. Rozoberme si dva prípady: prvý, keď sú všetky hrany tohoto cyklu (čiže políčka, ktoré ležia na prienikoch riadkov a stĺpcov cyklu) mimo určeného nezafarbeného riadku; a druhý, keď sa nejaká hrana (políčko) nachádza v tomto riadku.

V prvom prípade sa tento cyklus v tabuľke nachádzal aj predtým, ako sme sa rozhodli, že náš riadok bude vo výslednom riešení ten, ktorý nebol ofarbený. Toto sa ale nemohlo stať, keďže zadanie úlohy garantuje, že pre tabuľku na vstupe existuje nejaké riešenie.

Druhý prípad, kedy sa náš zvolený riadok nachádza v cykle, sa rovnako nemôže stať. O tomto riadku predpokladáme, že sme ho nezafarbili, a teda nebol zafarbený pred ani po žiadnom stĺpci (mohli by sme povedať, že bol zafarbený pred všetkými stĺpcami, tým by sme ale vylúčili akýkoľvek cyklus).

Pri riešení úlohy by ste si mali byť istí, že váš algoritmus produkuje správne riešenia. V tejto úlohe ste teda mali na výber buď implementovať hľadanie cyklov, alebo dokázať, že aj riešenie bez ich hľadania bude vždy fungovať.
",5
