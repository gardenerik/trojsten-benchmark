id,competition,problem,solution,difficulty
fa6d7fcbc2864bbc,ksp,"# Hlúpa chata

Ako sa tak blíži čas jesenného sústredenia, treba začať hľadať chatu. Keďže však KSP všetky financie od sponzorov drží v kryptomenách, nič luxusné si nemôže dovoliť. ""Zvýšme účastnícky poplatok na 150 eur!"", navrhol Dávid. ""Tak to vôbec! Kde si také niečo videl? To radšej ušetríme na záchodoch..."", rozhorčuje sa Emma vymýšľajúc ako z nedostatku toaliet spraviť zábavu. ""Hmmm, len aby to nebolo nespravodlivé..."".

## Úloha

Chata má iba jeden záchod. Každú hodinu vedúci jednotne náhodne vyžrebujú jedného účastníka alebo účastníčku, ktorej umožnia návštevu toalety. Vediac dĺžku trvania sústredenia a počet účastníkov, Emma by rada vedela odpoveď na nasledovnú otázku. Koľko možných žrebovaní má za následok, že práve jedna osoba navštívi toaletu najviackrát zo všetkých?

## Formát vstupu

Na prvom riadku sa nachádza číslo $t$ -- počet sústredení. Na $i$-tom z nasledovných $t$ riadkov sa nachádzajú čísla $n_i, k_i$ -- počet účastníkov a počet hodín $i$-teho sústredenia.

## Formát výstupu

Vypíšte $t$ riadkov. Na $i$-tom z nich odpoveď na $i$-tu otázku modulo $10^9 + 7$.

## Hodnotenie

Úloha má 8 sád vstupov. Platia v nich nasledovné obmedzenia:

| | **1** | **2** | **3** | **4,5** | **6** | **7,8** | |-----------------|-------|-------|-------|---------|-------|---------| | $1 \\leq t \\leq$ | 10 | 10 | 10 | 10 | 3 | 10 |\
| $1 \\leq n \\leq$ | 10 | 100 | 4 | 50 | 100 | 100 | | $1 \\leq k \\leq$ | 10 | 4 | 100 | 50 | 100 | 100 |

## Príklady

```vstup
4
2 2
6 10
5 9
4 4
```

```vystup
2
2472
600
28
```

_V prvom prípade môže ísť na záchod dvakrát prvý účastník, alebo dvakrát druhá účastníčka. Vo všetkých ostatných možnostiach by nešla na toaletu najviac krát práve jedna osoba._
","# Hlúpa chata

Ked súťažná programátorka počuje ""počet možností"", okamžite by jej malo napadnúť slovo ""dynamika"".

## Hrubá sila

Pár bodov sa dalo získať za riešenie hrubou silou. Mohli sme napríklad vyskúšať všetky možné žrebovania a zrátať vyhovujúce.

## Obmedzenia v sadách

Niektoré sady mali malé obmedzenia na $n$, alebo $k$. Tieto sady sa pravdepodobne dali riešiť odvodením vhodných matematických vzorcov.

## Takmer vzorové riešenie

Nuž, ako by sme sa na túto úlohu mohli pozerať? Ako funkčný sa ukáže prístup, kde postupne skúsime všetky možnosti pre počet návštev záchoda najviackrát vyžrebovaného účastníka.

Keď vieme, koľkokrát bol vyžrebovaný najšťastnejší účastník, nech je to $w$, potrebujeme zodpovedať na nasledovnú otázku. Koľkými spôsobmi možno rozdeliť $k-w$ návštev toalety medzi zvyšných $n-1$ účastníčiek tak, že každá získa nanajvýš $w-1$ návštev?. Pre účastníčku, ktorá bola vyžrebovaná $w$ krát je $n$ možností, preto odpoveď na našu otázku potrebujeme prenásobiť $n$. Odpoveď na celú úlohu potom bude súčet cez všetky možné maximálne počty vyžrebovaní najúspešnejšieho účastníka.

Budeme teda potrebovať zrátať dynamiku `dp[x][y][z]`, ktorá bude hovoriť, koľkými možnosťami možno rozdeliť `x` vyžrebovaní medzi `y` účastničiek tak, že každá bude vyžrebovaná nanajvýš `z` krát. Triviálne prípady, kde aspoň jedno z `x`, `y`, `z` je 0, vieme určiť jednoducho. Ako následne zrátame `dp[x][y][z]`? Skúsime všetky možnosti pre to, koľkokrát bol vyžrebovaný posledný účastník. Bude teda platiť: $$dp[x][y][z] = \\sum\_{i=0}^z dp[x-i][y-1][z]$$

Priamočiary pohľad na toto riešenie hovorí, že jeho časová zložitosť bude $O(nk^3)$. Pamäťová zložitosť je $O(nk^2)$. Keďže nám vždy stačia posledné dva riadky tabuľky `dp`, vieme túto zložitosť zlepšiť na $O(nk)$.

## Vzorové riešenie

Ako pri dynamikách býva, aj predchádzajúce riešenie sa dá zoptimalizovať. Takáto optimalizácia často spočíva v tom, že sa zbavíme jedného rozmeru a možno pri tom nejak pomiešame zvyšné rozmery tak, aby sme tretí rozmer nepotrebovali.

Môžeme iterovať cez maximálny povolený počet vyžrebovaní jedného účastníka. Počas toho budeme počítať dynamiku iba so zvyšnými dvoma rozmermi.

Časová zložitosť riešenia po takejto optimalizácii bude $O(nk^2)$. Pamäťová zložitosť je $O(nk)$.
",8
076130f0f5d3acd5,ksp,"# Zapisovanie trpaslíkov

Všetci určite poznáte rozprávku o Snehulienke a siedmich trpaslíkoch. Snehulienka sa stratila v lese, našla domček v ktorom bývali trpaslíci, bol tam strašný neporiadok, a ona začala upratovať... Viete prečo nemali trpaslíci doma upratané? Nie, nebolo to preto, že by boli leniví... Trpaslíci toho majú len veľa na práci. Preto majú presne rozdelené, kto má čo spraviť, podľa poradia v ktorom sa v daný deň zobudili. Prvý chystá raňajky, druhý pripravuje stôl, tretí varí čaj, štvrtý upratuje... Aby sa v činnostiach vystriedali, a tiež, aby nemusel Spachtoš vždy vstávať ako prvý, každý deň vstávajú v inom poradí.

Aby trpaslíci vedeli zistiť, že sa už vystriedali všetky poradia, používajú nasledovný systém:

- Každý z trpaslíkov má svoju obľúbenú cifru od $0$ do $9$.
- Keď trpaslík ráno vstane, napíše svoju obľúbenú cifru na tabuľu, hneď za poslednú, ktorá tam bola. Takto vznikne každý deň na tabuli jedno číslo.
- Trpaslíci si počítajú súčet čísel, ktoré sa objavujú na tabuli -- predtým, ako idú spať, pripočítajú číslo z tabule k súčtu.
- Keď je súčet dostatočne veľký, vystriedali sa všetky poradia a môžu sa začať striedať (a sčítavať) odznova.

Systém je dokonalý, no trpaslíci majú jeden problém. Nevedia, aký súčet má byť na tabuli po tom, čo sa vystriedali všetky poradia. Niekedy si tak nevšimnú, že sa už vystriedali a nasledujúce ráno nevstane nikto. Práve v takýto deň prišla Snehulienka a tá sa ako silná žena a nádejná programátorka rozhodla vyriešiť tento problém raz a navždy.

## Úloha

Pre jednu domácnosť trpaslíkov dostanete jedno číslo $c_i$, ktoré vzniklo na tabuli v prvý deň. Zistite, aký bude súčet čísel z tabule, keď sa vystriedajú všetky poradia trpaslíkov. Stručne povedané, zistite súčet všetkých permutácií cifier čísla $c_i$.

Úlohu vyriešte pre $n$ rôznych domácností trpaslíkov.

## Formát vstupu

Na prvom riadku je číslo $n$ ($1 \\leq n \\leq 10^5$). Nasleduje $n$ riadkov, v každom z nich je jedno číslo $c_i$ ($0 \\leq c_i \\leq 10^{12}$). Žiadne číslo iné ako 0 nezačína nulou.

## Formát výstupu

Vypíšte $n$ riadkov, na $i$-tom riadku bude súčet permutácií cifier $i$-teho čísla zo vstupu. Každý súčet sa zmestí do 64 bitovej premennej (typu `Int64` v Pascale, `long long` v C++).

## Príklad

```vstup
5
2
47
33
750
4247
```

```vystup
2
121
66
2664
113322
```

_Trpaslík s cifrou $2$ býva sám, preto musí vždy vstať prvý. Pre trpaslíkov s ciframi $4$ a $7$ existujú dve poradia, ako môžu vstať ($47$ a $74$). Trpaslíci v tretej domácnosti majú rovnaké obľúbené cifry, ale aj tak ich rozlišujeme a preto majú tiež dve možnosti._
","# Zapisovanie trpaslíkov

## Hrubá sila

Riešenie hrubou silou vyzerá tak, že postupujeme presne podľa zadania. Postupne si vygenerujeme každú permutáciu cifier zadaného čísla a potom všetky takto vytvorené čísla sčítame. V jazyku `C++` sa to dá robiť pomocou funkcie `next_permutation()`, ktorá generuje ďalšiu permutáciu poľa. V Pythone sa na to dá použiť knižnica `itertools`. Ak si počet cifier zadaného čísla označíme $k$, tak takéto riešenie má časovú zložitosť $O(k!)$ ($k$ faktoriál) a na testovači by malo získať 2 body.

## Optimálne riešenie

Najprv potrebujeme zistiť, koľko rôznych permutácií $k$ cifier vlastne existuje. Ak chceme z $k$ cifier vyrobiť číslo, dôležité je, v akom poradí ich za seba naukladáme. Na prvé miesto môžeme dať ľubovoľnú z cifier, takže máme $k$ možností. Na druhé miesto už nemáme $k$ možností, ale iba $k-1$. Jedna cifra (aj keď nevieme ktorá) totiž leží na prvej pozícii. Preto máme pre druhé miesto iba $k-1$ možností, čo je dokopy pre prvé dve miesta $k\\cdot (k-1)$ možností.

Neprekvapivo, pre tretie miesto máme $k-2$ možností a tak ďalej. Na poslednom, $k$-tom mieste máme len 1 možnosť, lebo nám zostala posledná nezaradená cifra. Dokopy máme teda $k \\cdot (k-1) \\cdot (k-2) \\ldots 2 \\cdot 1$ možností. Takýto súčin čísel od 1 po $k$ zvykneme tiež označovať $k!$ ($k$ faktoriál).

Označme si cifry nášho čísla zľava doprava ako $a_k\\ a\_{k-1} \\ldots a_2\\ a_1$. Toto číslo si teda môžeme zapísať aj ako:

$$10^{k-1}\\cdot a_k+10^{k-2}\\cdot a\_{k-1}+\\ldots +10^1\\cdot a_2+10^0\\cdot a_1$$

Je jasné, že to, koľko zaváži daná cifra, je dané aj jej poradím v čísle. Skúsme teraz vypočítať, akú hodnotu pridá cifra $a_1$ do súčtu všetkých permutácií. Ak dáme cifru $a_1$ na prvú pozíciu zľava, tak nám do súčtu pridá $10^{k-1}a_1$. Potrebujeme už len zistiť, v koľkých permutáciách bude $a_1$ na prvom mieste. Keď si však takýmto spôsobom zafixujeme prvú cifru, ostane nám $k-1$ cifier, ktoré chceme uložiť na $k-1$ pozícií. Máme teda $(k-1)!$ rôznych čísel, kedy je $a_1$ na prvom mieste.

Ak dáme cifru $a_1$ na druhú pozíciu zľava, bude pridávať do súčtu hodnotu $10^{k-2}a_1$ a opäť $(k-1)!$ krát, lebo zafixovaním druhej pozície nám opäť ostane $k-1$ cifier na $k-1$ pozícií. To isté bude platiť pre ľubovoľné miesto, kam našu cifru $a_1$ uložíme. Ak toto všetko sčítame, dostaneme celkovú hodnotu, ktorú do súčtu permutácií pridá cifra $a_1$ a táto hodnota bude:

$$10^{k-1}a_1(k-1)! + 10^{k-2}a_1(k-1)! + \\ldots + 10^1a_1(k-1)! + 10^0a_1(k-1)!$$

Po vyňatí $a_1$ a $(k-1)!$ získame jednoduchší tvar:

$$a_1(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

Táto istá úvaha však platí aj pre ľubovoľnú cifru, nie len pre $a_1$. Keďže sú cifry od seba nezávislé, celkový súčet permutácií bude určite rovný súčtu hodnôt, ktoré pridajú jednotlivé cifry. Výsledný súčet všetkých permutácií preto bude

$$a_1(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1) + a_2(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1) + \\ldots + a_k(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

čo môžeme opäť upraviť na oveľa jednoduchší tvar:

$$(a_1+a_2+\\ldots+a_k)(k-1)!(10^{k-1}+10^{k-2}+\\ldots 10 + 1)$$

Výsledok teda vieme vypočítať ako súčin troch členov. Prvý z nich je súčet cifier, druhý je $(k-1)!$, čo je $(k-1)(k-2)\\ldots 1$ a tretí súčet mocnín 10. Každý z týchto členov vieme vypočítať v čase $O(k)$, čo je teda výsledná časová zložitosť nášho programu. Pamäťová zložitosť je dokonca konštantná $O(1)$, keďže cifry zadaného čísla vieme počítať postupne jeho delením 10.
",2
fe526701d8e066f0,ksp,"# Svinstvo na koberci

Krtko si na oslavu svojho novo zrekonštruovaného bytu pozval všetkých vedúcich. Kubíkovi sa byt tak páčil, že sa rozhodol kúpiť nový nábytok do Klubovne Spokojných Programátorov. Zohnal nové staré stoly, kolieskové stoličky bez koliesok aj pekné preplnené skrine. Nákup zavŕšil novým viacdielnym kobercom. Ten sa skladá z viacerých kúskov uložených tak, že na podlahe tvoria mapu.

Netrvalo dlho a na čistučkom koberci sa začali každý deň objavovať zablatené stopy, zadupaná čokoláda či škrny od kofoly. Tie treba rýchlo odstrániť, inak sa do koberca zažerú nastálo.

Kubík dostal briliantný nápad. Na strop pripevnil kameru namierenú na koberec, takže vie presnú polohu každej škvrny v momente, keď sa objaví. Od vás chce program, ktorý mu povie veľkosť zašpineného kusu koberca, aby mohol objednať správne množstvo čistiacich prostriedkov.

## Úloha

Na vstupe dostanete zadanú mapu koberca v podobe **súvislého** *planárneho grafu* (vrcholy so súradnicami a hrany medzi nimi) a niekoľko bodov. Vašou úlohou je pre každý bod nájsť veľkosť uzavretej oblasti, v ktorej leží (tj. jej obsah). Ak sa bod nenachádza v žiadnej uzavretej oblasti, vypíšte $-1$. **Body ležiace na niektorej hrane grafu (vrátane jej okrajov) považujeme, že nie sú vo vnútri žiadnej uzavretej oblasti.**

Pozor! Túto úlohu je treba riešiť online, čiže testovač vášmu programu posiela otázky postupne. Každú nasledujúcu otázku dostanete až po tom, čo zodpoviete aktuálnu. Nezabudnite flushovat, aby sa vaša odpoveď skutočne testovaču odoslala a netrávila prázdniny v nejakom buffri. (C++ `cout.flush()`, Python `sys.stdout.flush()`, pre iné jazyky si vyhľadajte.)

## Formát vstupu

Na prvom riadku vstupu je číslo $n$---počet vrcholov, $m$---počet hrán a $q$---počet otázok.

Potom prázdny riadok, a nasleduje $n$ riadkov ($n \\geq 1$) obsahujúcich $2$ čísla---súradnice daného vrchola. Môžete predpokladať, že žiadne dve vrcholy nie sú ten istý bod v rovine. Všetky súradnice sú celé čísla, ktoré v absolútnej hodnote neprevýšia $10^9$.

Potom prázdny riadok, a na ďalších $m$ riadkoch ($m \\geq 0$) sú vždy $2$ čísla---čísla vrcholov, medzi ktorými vedú hrany. Vrcholy číslujeme $1, 2, \\ldots, n$. Môžete predpokladať, že ak niektoré tri vrcholy $a, b, c$ ležia na jednej priamke v tomto poradí, tak na vstupe nebude hrana $ac$. Takisto sa žiadna hrana na vstupe nevyskytne viackrát, a žiadne dve hrany sa nekrižujú. Koncové vrcholy každej hrany sú rôzne. Zadaný graf je súvislý.

Potom prázdny riadok, a na každom z posledných $q$ riadkov ($q \\geq 0$) sú $2$ čísla---súradnice bodu z otázky.

Súradnice všetkých bodov sú nezáporné a neprevyšujú $10^9$.

## Formát výstupu

Pre každý bod vypíšte riadok obsahujúci jedno číslo---veľkosť oblasti, v ktorej sa nachádza. Ak bod neleží v žiadnej uzavretej oblasti, vypíšte $-1$. **Pokiaľ je výsledok celočíselný, nevypisujte žiadne desatinné miesta, v opačnom prípade vypíšte jedno desatinné miesto.** (Rozmyslite si, že obsah každej z oblastí je nutne celočíselným násobkom $\\frac{1}{2}$.)

## Hodnotenie

Obmedzenia v jednotlivých sadách sú nasledovné:

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |:------- | ----------:| ----------:| -----------:| -------------:| -----------:| -----------:| -------------:| -------------:| | $n \\leq$ | $300$ | | $2,500$ | | | $50,000$ | | | | $m \\leq$ | $300$ | | $4,000$ | | | $70,000$ | | | | $q \\leq$ | $10,000$ | | | | | $20,000$ | | |

## Príklady

```vstup
5 7 5

10 6
7 10
9 1
0 6
2 0

2 4
5 3
1 3
3 4
5 4
4 1
2 1

8 6
0 3
2 5
7 0
8 1
```

```vystup
-1
-1
25
-1
22
```

Obrázok prvého vstupu:

```vstup
7 10 5

7 3
0 4
0 8
3 2
10 0
7 6
0 10

6 2
6 7
5 4
3 7
5 1
6 5
6 4
2 4
3 2
6 3

5 4
5 2
8 1
2 5
4 4
```

```vystup
-1
18
18
14
10
```

Obrázok druhého vstupu:

```vstup
9 12 5

3 1
4 5
7 0
10 5
8 0
0 6
1 10
5 5
6 5

9 7
8 7
8 2
2 6
4 5
7 2
6 7
3 1
8 9
3 5
3 4
1 8

7 1
3 2
3 7
5 2
9 4
```

```vystup
-1
-1
2.5
-1
-1
```

Obrázok tretieho vstupu:

```vstup
5 5 5

0 0
0 4
4 4
4 0
1 1

1 2
2 3
3 4
4 1
4 5

1 1
0 4
3 3
0 2
2 4
```

```vystup
-1
-1
16
-1
-1
```

Obrázok štvrtého vstupu:
","# Svinstvo na koberci

Táto úloha bola fakt ťažká. Dĺžka vzoráku to celkom odzrkadľuje. Nebojte sa teda vzorák spracovávať po kúskoch, kľudne aj vo viacerých sedeniach.

Na získanie $5$ bodov z programu si stačilo len uvedomiť, čo v skutočnosti znamenajú niektoré geometrické pojmy a ako ich vyjadriť v programe. V geometrii totiž častokrát ""vidíme"", že niečo platí, ale nevieme to poriadne zdôvodniť/vyjadriť. Napríklad, čo znamená, že bod $A$ je vo vnútri nejakej oblasti? Čo to vlastne je oblasť, ako môže vyzerať? Nielen týmito otázkami sa budeme zaoberať v nasledujúcej časti.

## Geometria

### Základy

Ak ste sa s výpočtovou geometriou ešte nestretli, odporúčame vám najprv prečítať si v našej kuchárke [Úvod do výpočtovej geometrie](https://www.ksp.sk/kucharka/uvod_do_vypoctovej_geometrie/).

Vo vzorovom riešení sa často využívajú skalárny súčin, a obzvlášť vektorový súčin. Ak vám niekde vo vzoráku nebude jasné, ako je niektorý zo súčinov použitý, môžete hľadať odpovede v odpovedajúcom článku v kuchárke: [Skalárny a vektorový súčin](https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin/)

### Čím je určená oblasť?

Najprv si rozmyslime jednu vec. Naľavo od každej hrany je vždy práve jedna oblasť, a napravo od hrany je vždy práve jedna oblasť. Pritom to môže byť tá istá oblasť, ako naľavo, a obe oblasti môžu byť nekonečné. Je zrejmé, že v oboch smeroch hrana susedí s aspoň jednou oblasť; zároveň vieme prejsť ""tesne"" popri hrane od jedného konca hrany k druhému, takže oblasť môže byť len jedna.

Tento prechod je umožnený tým, že sa hrany grafu nekrižujú, a že na žiadnej hrane neleží tretí bod. Ak by jedna z týchto podmienok bola porušená, mohlo by na jednej strane hrany byť viacero oblastí. Ilustrujeme na nasledujúcom obrázku:

Každá oblasť má teda svoju hranicu, ktorá obsahuje celé hrany. Pretože zadaný graf je súvislý, hranica oblasti musí byť súvislá: ak sú teda nejaké dve hrany na hranici oblasti, vieme sa od jednej hrany dostať k druhej tak, že pôjdeme po okraji. Toto v nesúvislých grafoch nemusí platiť, ako vidno na nasledujúcom obrázku:

Predstavme si teraz, že ideme po okraji oblasti proti smeru hodinových ručičiek. To samozrejme neznamená, že vždy zatáčame doľava, nakoľko oblasť nemusí byť konvexná. Ako je potom ale definovaný smer ""proti smeru hodinových ručičiek""? Je to taký smer, v ktorom je vnútro oblasti vždy na ľavej strane hrany. Môžete si to predstaviť tak, že hranám na okraji oblasti priradíme takú orientáciu, aby bolo vnútro oblasti vždy naľavo od hrany. Samozrejme, sú prípady, kedy je vnútro aj na pravej strane hrany:

V takom prípade pôjdeme pri našom prechode raz v jednom smere pozdĺž takejto hrany, a raz v druhom smere. Takže tento sled, ktorý ""obtiahne"" okraj oblasti, môže niektoré hrany obsahovať dvakrát: raz v jednej orientácii a raz v druhej orientácii.

Orientované hrany budeme v ďalšom texte volať *šípky*. Budeme hovoriť, že šípka patrí tej oblasti, ktorá je naľavo od šípky.

### Ktoré šípky sú na okraji?

Predstavme si, že pri obťahovaní okraju sme sa zastavili na nejakej šípke $A \\to B$. Vieme povedať, ktorá šípka bude nasledovať? Zrejme to bude niektorá šípka vychádzajúca z vrcholu $B$. Ak si nakreslíme všetky šípky vychádzajúce z $B$, nie je ťažké vidieť, že hľadaná šípka bude $B \\to C$ taká, pri ktorej zatočíme čo najviac doľava:

Prečo je toto tá správna šípka? Totiž, vždy vieme ísť tesne popri šípke $A \\to B$ a potom popri $B \\to C$. Pri tomto prechode neprekrížime žiadnu inú šípku, a teda určite patria tieto šipky do tej istej oblasti. Ak by sme skúšali prejsť podobným spôsobom popri iných šípkach vychádzajúcich z vrcholu $B$, križovali by sme niektorú inú šípku.

Takýmto spôsobom vieme pre každú šípku zistiť celú hranicu oblasti, do ktorej patrí. Pretože každá oblasť má na okraji aspoň jednu šípku, vieme týmto spôsobom získať hranice všetkých oblastí. A pretože šípka je len hrana s priradenou orientáciou, získame týmto pre každú hranu informáciu o tom, ktorá oblasť je na jednej strane a ktorá na druhej strane hrany.

Na celý tento proces sa ale dá pozerať aj iným, prirodzenejším, spôsobom. Pre každú šípku máme dve premenné: číslo oblasti, ktorá je na ľavej strane hrany a číslo oblasti, ktorá je na pravej strane. Pritom pre dvojicu navzájom opačných šípok sú tieto dve premenné iba vymenené -- to, čo je naľavo od jednej šípky, je napravo od druhej, a naopak.

Zoberme si teraz všetky šípky vychádzajúce z nejakého bodu $A$ a usporiadajme si ich polárne (podľa uhlu), proti smeru hodinových ručičiek. Potom pre každú dvojicu po sebe idúcich šípok vieme povedať, že oblasť naľavo od prvej z nich je tá istá, ako oblasť napravo od druhej z nich -- teda že sa príslušné premenné rovnajú.

Toto vieme spraviť pre všetky vrcholy, a dostaneme tak sadu rovností nad $2m$ premennými. Premenné, ktoré sa rovnajú, potom reprezentujú tú istú oblasť. Premenné, ktoré sa nerovnajú, reprezentujú rôzne oblasti. Ak si premenné predstavíme ako vrcholy nejakého grafu a rovnosti ako hrany grafu, tak oblasti zodpovedajú súvislým komponentom tohto grafu.

Dostávame tak jednoduchý algoritmus na výpočet okrajov oblastí, bežiaci v čase $O(m \\log m)$, logaritmus kvôli polárnemu usporiadaniu. Aby sme vedeli šípky polárne usporiadať, potrebujeme vedieť pre dva vektory povedať, ktorý je naľavo od ktorého. To vieme určiť podľa znamienka vektorového súčinu.

### Ako vypočítať obsah oblasti?

Ak poznáme hranicu oblasti, vieme aj vypočítať obsah oblasti, nasledovne. Zoberme si ľubovoľný bod v rovine $S$, napríklad $S = (0, 0)$. Hranica oblasti zodpovedá nejakému sledu $A_1 \\to A_2 \\to \\ldots \\to A_n \\to A_1$, proti smeru hodinových ručičiek. Jednoducho teraz vezmeme orientované obsahy trojuholníkov určených dvojicami vektorov

$$ (\\overrightarrow{SA_1}, \\overrightarrow{SA_2}), (\\overrightarrow{SA_2}, \\overrightarrow{SA_3}), \\ldots, (\\overrightarrow{SA_n}, \\overrightarrow{SA_1})$$

a sčítame ich. Tieto orientované obsahy vieme dostať pomocou vektorového súčinu.

Prečo to ale funguje? Zamyslime sa nad najjednoduchším prípadom, keď máme trojuholník $ABC$. Potom náš výraz je súčtom orientovaných obsahov troch trojuholníkov, jeden pre každú stranu $\\triangle ABC$. Ak je bod $S$ vo vnútri $\\triangle ABC$, tak jednotlivé podtrojuholníky budú mať všetky kladný obsah, nakoľko $\\overrightarrow{SA\_{i + 1}}$ je vždy naľavo od $\\overrightarrow{SA_i}$. Ich súčtom dostaneme celý trojuholník. Ak je bod $S$ mimo $\\triangle ABC$, tak jeden alebo dva podtrojuholníky budú záporné, a všetko sa to vyruší tak, že zostane iba $\\triangle ABC$.

Čo v prípade, keď nemáme trojuholník? Každý (aj nekonvexný) mnohouholník sa dá rozdeliť na niekoľko dizjunktných trojuholníkov (tzv. *triangulácia*). Na každý z týchto trojuholníkov vieme aplikovať vyššie uvedené tvrdenie, a dostaneme tak obsah nášho mnohouholníka vyjadreného ako súčet niekoľkých orientovaných trojuholníkov. Každý z týchto trojuholníkov má ako jeden z vrcholov $S$, a ostatné dva vrcholy patria mnohouholníku -- teda každý trojuholník zodpovedá buď niektorej hrane v triangulácii (ktorá oddeľuje dva z trojuholníkov), alebo hrane na obvode mnohouholníka.

My chceme ukázať, že v skutočnosti tam budú vystupovať iba hrany z obvodu mnohouholníka. To je ale zrejmé: každá vnútorná hrana susedí s dvomi podtrojuholníkmi: v jednom z nich bude vnútro trojuholníka naľavo od hrany (a zarátame ho s kladným znamienkom), v druhom z nich bude vnútro trojuholníka napravo od hrany (záporné znamienko).

Pozorný čitateľ si isto všimne jeden zvláštny prípad. Čo sa stane, ak tá oblasť, po okraji ktorej ideme, je nekonečná? Zrejme vypočítame obsah útvaru určeného týmto okrajom (tj. obsah toho, čo je ""skutočne vnútri"", nie vonku). Aké znamienko ale bude mať takto vypočítaný obsah? Definovali sme ""proti smeru hodinových ručičiek"" tak, že vnútro oblasti je naľavo od šípky. Nie je ťažké rozmyslieť si, že pre (jedinú) nekonečnú oblasť je takto definovaný sled v skutočnosti **v smere** hodinových ručičiek:

Dostaneme teda záporný alebo nulový obsah. Pomocou znamienka teda vieme určiť, či je bod vo vnútri nekonečnej oblasti, alebo v konečnej.

Časová zložitosť výpočtu obsahu oblasti je $O(k)$, kde $k$ je počet vrcholov/hrán na okraji oblasti. Nakoľko každá šípka patrí iba do jednej oblasti, a všetkých šípok je $2m$, celková časová zložitosť tohto predrátania je $O(m)$.

## Prvé riešenie

Už teda vieme, ako nájsť hranice všetkých oblastí, a tiež ako podľa týchto hraníc vypočítať obsah oblasti. Aby sme ale vedeli odpovedať na otázky, musíme ešte vedieť pre ľubovoľný bod $X$ povedať, v ktorej oblasti leží, prípadne, že leží na niektorej hrane.

Zistiť, či bod leží na hrane, vieme v čase $O(m)$: iba postupne prejdeme všetky hrany, a pre každú hranou overíme, či na nej $X$ leží alebo nie. Ako to ale overíme? Pomocou vektorového súčinu vieme zistiť, či $X$ leží na priamke určenej touto hranou. Pomocou skalárneho súčinu zistíme, či je $X$ ""vo vnútri"" úsečky alebo mimo nej.

Ak neleží na hrane, ako zistíme, do ktorej oblasti patrí? Vieme sa pozrieť na najbližšiu hranu, ktorá je ""pod"" naším bodom. Hľadaná oblasť je tá, ktorá je ""hore"" od tejto hrany. Ak žiadna hrana pod bodom $X$ nie je, tak bod zrejme neleží v žiadnej konečnej oblasti.

Čo to ale znamená hore? Ak každú (nezvislú) hranu orientujeme tak, že ide zľava doprava (tj. od menších $x$-ových súradníc k väčším), tak ""hore"" znamená ""vľavo"". Budeme hovoriť, že ľavý koniec hrany je jej *začiatok* a pravý koniec hrany je jej *koniec*.

Potrebujeme teda zistiť, ktoré hrany majú spoločnú $x$-ovú súradnicu s naším bodom $X$. (Ak by sme nakreslili zvislú čiaru cez $X$, tak sú to tie hrany, ktoré majú s touto čiarou nejaký spoločný bod.) Spomedzi týchto hrán chceme nájsť tú, ktorá pretína zvislú čiaru cez $X$ čo najvyššie, ale stále pod bodom $X$. Čo ale v prípade, že takýchto najvyšších hrán je viac? Takýto prípad môže nastať jedine vtedy, ak je bod $X$ priamo nad niektorým vrcholom. Ako ukazuje nasledujúci obrázok, nie je jedno, ktorú hranu vyhlásime za najvyššiu:

V takom prípade chceme vybrať takú hranu, ktorá v tom vrchole začína (končí) a ktorá ide čo najrýchlejšie hore (dole). Inak povedané, spomedzi všetkých hrán začínajúcich (končiacich) v tomto vrchole chceme vybrať tú najľavejšiu (najpravejšiu). Porovnať dve hrany, že ktorá je vľavo (vpravo) od ktorej, vieme jednoducho pomocou vektorového súčinu.

Máme tak algoritmus s časovou zložitosťou $O(m)$ na jednu otázku, celková časová zložitosť je teda $O(m \\log m + mq)$. Toto riešenie si vyslúžilo $5$ bodov z testovania.

## Cesta k lepšiemu riešeniu

Potrebujeme urýchliť dve veci: vedieť rýchlo zistiť, či náš bod $X$ leží na niektorej hrane; a vedieť rýchlo nájsť najbližšiu hranu pod naším bodom.

Rozdeľme si prácu trochu inak: ak by sme za hrany pod naším bodom považovali aj tie, ktoré cez nehoprechádzajú, stačilo by nám v prvej časti overovať iba zvislé hrany. Ak totiž $X$ leží na nezvislej hrane, bude to najvyššia hrana pod $X$. Nezvislé hrany teda vieme vybaviť tak, že pre najvyššiu hranu pod $X$ overíme, či na nej $X$ leží alebo nie.

Ako zistiť, či náš bod leží na nejakej zvislej hrane? Jednoducho: spomedzi vrcholov s rovnakou $x$-ovou súradnicou nájdeme ten vrchol $A$, ktorý je najvyššie, ale stále nižšie, ako $X$. Ak náš bod leží na zvislej hrane, musí to byť zvislá hrana, ktorá vychádza z $A$ a ide ""hore"". Stačí si teda usporiadať všetky vrcholy primárne podľa $x$-ovej, sekundárne podľa $y$-ovej súradnice, a pre každý vrchol si zapamätať (najviac jednu) šípku hore, ktorá z neho vychádza. V tomto zozname potom binárne vyhľadáme najväčší bod menší rovný $X$ a overíme, či $X$ leží na šípke hore alebo nie.

Ako ale rýchlo nájsť tú hranu, ktorá je pod $X$? Ak by sme mohli riešiť úlohu offline, teda ak by sme vedeli dopredu všetky otázky, vedeli by sme použiť prístup zvaný *zametanie*.

### Offline zametanie

Ak by sme mali k dispozícii všetky otázky dopredu, mohli by sme sa rozhodnúť ich spracovať v nejakom konkrétnom poradí. Napríklad si môžeme všimnúť, že keď bod $X$ iba trochu posunieme doprava alebo doľava, množina hrán, ktoré sú pod alebo nad $X$, sa zmení iba trochu. V probléme je istá *lokálnosť*. Dobré poradie, v ktorom spracovať otázky, je potom napríklad zľava doprava.

Predstavme si teda, že nekonečne vľavo máme zvislú priamku, tzv. *zametaciu čiaru*, ktorá sa posúva doprava. Táto čiara nám postupne bude ""skenovať"" všetky hrany a všetky otázky. Keď čiara narazí na začiatok alebo koniec hrany, upraví svoj stav (tj. ktoré hrany ju pretínajú), a keď čiara narazí na otázku, na základe svojho stavu ju zodpovie.

Konkrétnejšie, keď čiara narazí na ľavý koniec hrany, túto hranu pridá do množiny hrán, s ktorými máme aktuálne priesečník. Keď čiara narazí na pravý koniec hrany, danú hranu z množiny vyhodí. A nakoniec, keď narazí na bod $X$ reprezentujúci otázku, nájde spomedzi všetkých aktuálnych hrán tú, ktorá má na tejto $x$-ovej súradnici priesečník čo najvyššie, ale stále nižšie alebo rovnako vysoko, ako je $X$.

Zametacia čiara nám teda musí byť schopná povedať, ktorá hrana je na aktuálnej $x$-ovej súradnici ""tesne pod"" bodom $X$. Tiež musíme vedieť do nej pridávať a odoberať hrany. Vhodnou dátovou štruktúrou na toto je vyvažovaný vyhľadávací strom, v ktorom budeme mať hrany usporiadané podľa ich aktuálnej $y$-ovej súradnice (tj. v akej výške pretínajú zametaciu čiaru).

Môžeme si ho ale dovoliť použiť? V našom prípade je totiž výsledok porovnania dvoch hrán závislý od toho, aká je $x$-ová pozícia zametacej čiary. Nemôže sa počas posúvania čiary stať, že sa výsledky niektorých porovnaní zmenia, a štruktúra stromu už nebude korektná? Dve hrany zmenia svoje relatívne poradie jedine vtedy, keď sa krížia. To sa ale v našom planárnom grafe nikdy nestane: pred tým, než by k tomu došlo, by jedna alebo obe hrany skončili v niektorom (možno v tom istom) vrchole.

Môže sa ale stať, že dve hrany skončia v jednom a tom istom vrchole; alebo že jedna hrana skončí vo vrchole, v ktorom druhá hrana začne; alebo že obe hrany začnú v tom istom vrchole. V tom momente ich nie sme schopní porovnať, lebo ich priesečníky so zametacou čiarou budú ten istý bod. Pritom ale nie je jedno, ktorú z tých hrán prehlásime za väčšiu a ktorú za menšiu.

Ak totiž dve hrany začínajú v tom istom vrchole, v tom momente ich síce nevieme porovnať, ale hneď v nasledujúcom momente (tj. keď sa zametacia čiara posunie o máličko doprava) ich budeme vedieť porovnať: tá hrana, ktorá rastie rýchlejšie (je viac vľavo), je tá väčšia. Teda pri pridávaní nových hrán ich musíme do stromu dať podľa toho.

Naopak, ak dve hrany končia v tom istom vrchole, v tom momente ich síce nevieme porovnať, ale v predchádzajúcom momente sme ich vedeli porovnať: tá hrana, ktorá klesá rýchlejšie (je viac vpravo), je väčšia. Ak by sme ale toto pri mazaní hrany odignorovali, mohli by sme omylom zmazať tú nesprávnu hranu.

A čo v treťom prípade, keď jedna hrana začína v tom vrchole, v ktorom iná hrana končí? Našťastie sa tomuto prípadu vieme vyhnúť tým, že najprv vybavíme všetky hrany končiace vo vrchole, a až potom všetky hrany začínajúce vo vrchole. Týmto zaručíme, že nikdy nebudeme mať v našom vyhľadávacom strome hranu, ktorá v nejakom vrchole začína spolu s hranou, ktorá v tomto vrchole končí.

Takže naše porovnávanie bude závisieť nielen od toho, aká je momentálna $x$-ová súradnica zametacej čiary, ale aj od toho, či sa k nej blížime zľava (vybavujeme konce hrán) alebo sa od nej vzďaľujeme doprava (vybavujeme začiatky hrán). Týmto sme vybavili všetky možné prípady.

Drobný technický detail: vo vyhľadávacom strome vieme porovnávať iba dve hrany, nevieme porovnať bod a hranu. Nebudeme teda porovnávať priamo s bodom $X$, ale s akousi pomocnou hranou, ktorá bude prechádzať cez $X$. Aký bude jej sklon? Nemôže byť ľubovoľný: chceme totiž, aby všetky hrany prechádzajúce cez $X$ boli menšie, aby sme vedeli detekovať, že $X$ leží na hrane. Takže podľa toho, či sa zľava blížime do $x$, alebo sa od neho sprava vzďaľujeme, nastavíme sklon hrany na ""takmer zvislo hore"" alebo ""takmer zvislo dole"".

Na začiatku musíme všetky začiatky, konce hrán a otázky utriediť, čo trvá $O((m + q) \\log {(m + q)})$. Samotné zametanie trvá rovnako dlho, nakoľko v každom kroku robíme jednu operáciu s vyvažovaným vyhľadávacím stromom (`insert`, `delete` alebo `lower_bound`), ktorá trvá $O(\\log {(m + q)})$. Celková časová zložitosť je teda $O((m + q) \\log {(m + q)})$.

Toto riešenie si samozrejme vyslúžilo $0$ bodov, so správou `TLE` -- čakalo totiž na všetky otázky, ktoré mu testovač nebol ochotný dať...

## Perzistentný stav čiary

Ak by sme sa vedeli pozrieť na stav zametacej čiary v ľubovoľnom momente, nemuseli by sme všetky otázky zodpovedať od najľavejšej po najpravejšiu. Stačilo by sa pre každú otázku $(x, y)$ pozrieť na stav zametacej čiary v momente $x$, a podľa neho odpovedať.

Potrebujeme si teda zapamätať celú históriu zametacej čiary a vedieť v nej vyhľadať posledný stav, ktorý predchádzal otázke $X$. Takýmto ""historickým"" dátovým štruktúram (ktoré si vedia pamätať nielen ich aktuálny stav, ale aj všetky predchádzajúce) sa hovorí *perzistentné dátové štruktúry*.

Jedna možnosť je zakaždým, keď chceme zmeniť stav čiary, celý stav skopírovať a vykonať zmenu v kópii. Tieto stavy si potom uložíme do poľa, a pre každý stav si budeme pamätať, v akom časovom momente začal. V tomto poli potom budeme pri otázke $(x, y)$ vedieť binárne vyhľadať poslednú verziu pred (alebo zarovno s) $x$.

Toto je ale pomalé: pri každej udalosti musíme skopírovať celý strom, čo trvá až $O(m)$. Udalostí je tiež $O(m)$, predpočítanie teda bude trvať až $O(m^2)$, a pamäťová zložitosť bude rovnaká.

My si ukážeme dve prístupy, ktoré dosahujú lepšiu časovú zložitosť: *fat nodes* a *path copying*.

### Fat nodes

Pri programovaní používame rôzne objekty, a každý objekt si vieme predstaviť ako zoskupenie niekoľkých údajov, nie nutne rovnakých typov. Napríklad vrchol vo vyhľadávacom strome môže obsahovať tieto údaje: ukazovateľ na ľavého syna, pravého syna, a čo je vo vrchole.

Štandardne, keď zmeníme jeden z týchto údajov na iný, stratíme pôvodnú hodnotu. Nevieme ale zmeny údajov spracovať iným spôsobom, tak, aby sa nám zachovala aj pôvodná informácia? Vieme. Budeme si pamätať všetky doterajšie verzie údaju, a pre každú verziu aj čas, kedy táto verzia vznikla (tj. kedy nahradila starú verziu). Keď teraz chceme pristúpiť k údaju v (diskrétnom) čase $t$, iba binárne vyhľadáme, akú hodnotu v tom čase mal, a vrátime ju. Toto spôsobí iba mierne spomalenie: konkrétne, všetko bude $O(\\log t)$-krát pomalšie, kde $t$ je počet verzii údaju. Pamäť bude ale až $O(t)$ namiesto $O(1)$.

Ak náš vyhľadávací strom implementujeme týmto spôsobom, dostaneme perzistentný vyhľadávací strom. Samozrejme, potrebujeme vyvažovaný vyhľadávací strom, napríklad [treap](https://www.ksp.sk/kucharka/treap/).

Otázka je, o koľko pomalší bude oproti pôvodnému stromu. Udalostí (začiatok alebo koniec hrany) je $O(m)$. Pri každej udalosti sa zmení nanajvýš $O(\\log m)$ vrcholov stromu, a ""narazíme"" pri binárnom vyhľadávaní nanajvýš na všetky doterajšie zmeny. Pred $i$-tou udalosťou bolo týchto zmien $O(i \\log m)$, na jeden vrchol teda pripadá spomalenie $O(\\log \\frac{i \\log m}{\\log m}) = O(\\log i)$.

Spomalenie jednej operácie je teda $O(\\log m)$ a časová zložitosť predpočítania teda bude $O(m \\log^2 m)$. Podobne, zodpovedanie jednej otázky bude o $O(\\log m)$ pomalšie, a teda dokopy $O(q \\log^2 m)$. Pamäťová zložitosť bude $O(m \\log m)$, nakoľko každá zmena prispeje $1$.

### Path copying

Predstavme si, že objekty, ktoré už existujú, nevieme meniť. Jediné, čo vieme robiť, je vytvárať zo starších objektov nové. Takémuto prístupu k programovaniu sa hovorí aj *funkcionálne programovanie*.

Načo také niečo je? Dá sa takto vôbec programovať? Ako to súvisí s perzistentnými dátovými štruktúrami? Hneď uvidíme.

Predstavme si, že chceme funkciu, ktorá zmení stav nejakého objektu. Napríklad vezme ako vstup zoznam čísel a na jeho koniec pridá číslo $4$. Nevieme to spraviť priamo, nakoľko nevieme zmeniť stav vstupného zoznamu. Vieme ale spraviť funkciu, ktorá nám vráti nový zoznam, ktorý bude reprezentovať nový stav vstupného zoznamu. Napríklad ak vstupom je $a = [1, 2, 3]$, výstupom bude nejaké $b = [1, 2, 3, 4]$. Zoznam $a$ ale stále obsahuje pôvodné údaje.

No a tu si môžeme uvedomiť, že čo sa v podstate stalo je, že sme síce dostali novú verziu objektu, ale máme aj starú verziu objektu. Ak by sme týmto prístupom implementovali náš vyhľadávací strom, dostali by sme perzistentný vyhľadávací strom.

Presnejšie, každý vrchol stromu reprezentuje vyhľadávací storm zodpovedajúci podstromu tohto vrcholu. Každá operácia, ktorá mení stav podstromu (`insert`, `delete` a rotácie) nám strom nezmení, ale vráti nový vrchol reprezentujúci nový stav (pod)stromu. Tieto operácie sú z veľkej časti definované pomocou operácii na synoch.

Ilustrujeme operáciu `insert` na nevyvažovanom vyhľadávacom strome nad číslami. Keď chceme vložiť číslo $5$ do koreňa, chceme ho vložiť do ľavého syna, lebo $5$ je menšie ako číslo v koreni. Takže výsledkom insertu bude niečo ako `strom(lavy_syn->insert(5), hodnota_v_koreni, pravy_syn)`, kde `strom` je konštruktor (vytvorí nový strom s daným ľavým synom, danou hodnotou v koreni, a s daným pravým synom). To isté sa potom udeje aj v ľavom synovi, ..., až kým nedôjdeme do listu. Dostaneme tak $O(h)$ nových vrcholov, kde $h$ je hĺbka stromu.

Prístup sa volá *path copying* podľa toho, že v podstate pri každej zmene skopírujeme celú cestu od listu až ku koreňu, a kópiu upravíme. Samozrejme, pre efektívnosť potrebujeme strom vyvažovať, my sme (opäť) zvolili [treap](https://www.ksp.sk/kucharka/treap/).

Aká je časová a pamäťová zložitosť? Vždy, keď sa v najaktuálnejšej verzii stromu zmení nejaký vrchol, musíme zmeniť (skopírovať) aj všetkých jeho predkov. Pri každej operácii v štandardnom treape sa zmení vždy nanajvýš $O(\\log m)$ vrcholov, z tohto by plynul (časový aj pamäťový) odhad $O(\\log^2 m)$ na jednu operáciu. Avšak ukazuje sa, že všetky tieto zmeny v treape sú ""zarovnané"", tj. že väčšinou sa mení iba jeden vrchol a jeho predkovia. Z toho vyplynie lepší odhad $O(\\log m)$.

Časová zložitosť predpočítania teda bude $O(m \\log m)$, pamäťová zložitosť bude rovnaká. Zodpovedanie otázok bude trvať $O(q \\log m)$. Toto je lepšie, ako v prístupe fat nodes.

### Záverečné poznámky

Dátovým štruktúram, ktorých stav sa nemení (ang. *immutable*) a vedia iba vracať nové objekty, sa hovorí *funkcionálne dátové štruktúry*. Ich výhodou oproti iným implementáciám perzistencie je, že sme schopní ""pokračovať"" nielen v aktuálnej verzii objektu, ale aj v starých verziách. Časová os teda nemusí byť os, môže to byť aj strom.

Naproti tomu ale existuje implementácia perzistentného treapu, ktorá potrebuje menej pamäte: iba $O(1)$ amortizovane na každú zmenu, oproti $O(\\log m)$ v prípade funkcionálneho treapu. Pre záujemcov odporučím [tento článok](http://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf) od legiend Sleatora a Tarjana, strany $93$ až $97$.
",10
0395e979ec00fc71,ksp,"# Vystupovanie

Každý víkend sa Jozef Hovnivál potreboval dostať domov z rodinného výmetu, aby si mohol sadnúť na svoju pohodlnú stolicu. Chodieval autotrusom. No aby to nemal také jednoduché, zakaždým sa rozhodol, akú dlhú prechádzku si chce spraviť domov z autotrusovej zastávky. Teda vystúpil na takej zastávke, ktorá je od jeho domu v správnej vzdialenosti. No toto ho rýchlo omrzelo, pretože chodil často tou istou trusou. Tak si vymyslel ešte jednu podmienku, a to že nepôjde z ktorejkoľvek zastávky, ktorá je v správnej vzdialenosti, ale z $k$-tej takej v poradí. Teda napríklad sa mohol rozhodnúť, že vystúpi na tretej zastávke, z tých, ktoré sú od jeho domu vzdialené 7 metrov. Jozefovi Hovniválovi ale zaberalo veľmi veľa času zistiť, na ktorej zastávke má vystúpiť. Preto potrebuje vašu pomoc.

## Úloha

Na vstupe dostanete $n$ čísel v rozsahu od $1$ po $1,000,000$. Toto sú vzdialenosti jednotlivých zastávok od jeho domu, v takom poradí, v akom ich prejde autotrus. Potom dostanete $q$ otázok. Každá otázka pozostáva z čísla zastávky $l$, na ktorej Jozef nastúpi, čísla zastávky $r$, na ktorej mu skončí platnosť lístka (a teda nemôže pokračovať ďalej v ceste autotrusom). Ďalej dostanete dĺžku prechádzky $v$, ktorú si Jozef praje a nakoniec na koľkej takej zastávke chce Jozef vystúpiť, $k$. Vašou úlohou je vypísať číslo zastávky, ktorá sa nachádza v intervale od $l$ po $r$ vrátane, jej vzdialenosť od domu je $v$ a je to $k$-ta taká zastávka v danom intervale. Ak taká neexistuje, vypíšte $-1$. Číslujeme od jednotky.

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú čísla $n$ a $q$ oddelené medzerou, počet zastávok a počet otázok. Na druhom riadku sa nachádza $n$ čísel oddelených medzerami, vzdialenosti zastávok od Jozefovho domu. Nasleduje $q$ riadkov, na každom z ktorých sa nachádzajú medzerami oddelené čísla $l$, $r$, $v$ a $k$, ktorých význam je vysvetlený vyššie.

## Formát výstupu

Vypíšte $q$ riadkov výstupu. Na $i$-tom riadku sa nachádza odpoveď na $i$-tu otázku, teda číslo zastávky, ktorá spĺňa požadované vlastnosti, alebo $-1$ ak taká neexistuje.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3 | 4 | 5--8 | |:--------------- |-----: | ---------: | ------------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $10,000$ | $80,000$ | $100,000$ | | $1 \\leq q \\leq$ | $100$| $10,000$ | $100,000$ | $100,000$ |

V prvej sade navyše platí, že vzdialenosti zastávok od domu sú z množiny ${1, 2}$.

## Príklad

```vstup
5 4
3 4 5 4 5
2 3 4 1
3 4 1 2
1 2 4 1
1 2 4 2
```

```vystup
2
-1
2
-1
```

```vstup
10 5
3 3 1 3 3 2 1 3 3 1
1 5 3 1
1 8 3 1
2 8 3 2
1 4 1 1
1 6 1 2
```

```vystup
1
1
4
3
-1
```
","# Vystupovanie

## Pomalé riešenie

Ako prvé si predstavíme priamočiare riešenie bez žiadnych trikov. Budeme jednoducho vstupné pole lineárne prehľadávať počnúc od indexu $l$ a počítať, koľkokrát sme už narazili na zastávku v správnej vzdialenosti $v$ od Jozefovho domu. Akonáhle narazíme na $k$-tu takú, vypíšeme jej index. Ak ale prekonáme index $r$ pred tým, ako nájdeme odpoveď, odpovieme $-1$. Toto riešenie by bolo optimálne, v prípade, keby sme dostali len $q = 1$ otázok. To, že otázok môže byť veľa, nám ale napovedá, že sa asi dá najprv so vstupnými údajmi vykonať nejaká transformácia, ktorá nám potom umožní odpovede zisťovať rýchlejšie ako v lineárnom čase.

## Vzorové riešenie

Kľúčový trik k riešeniu úlohy je nasledujúci: Pre každú vzialenosť $v$ od domu si vytvoríme pole, v ktorom sa nachádzajú čísla (indexy) zastávok, ktoré majú túto vzdialenosť. Napríklad ak je na vstupe pole: $[3, 4, 5, 4, 5]$ tak by sme si vytvorili v pamäti štruktúru podobnú nasledujúcej:

```
X[3]: 1
X[4]: 2 4
X[5]: 3 5
```

Na jej uskladnenie môžeme použiť buď hash mapu (dict) alebo jednoduché pole veľkosti $10^6$, pretože to je maximálna hodnota $v$.

Všimnime si, že každé pole $X[v]$ je usporiadané. Teraz vieme na otázky odpovedať nasledujúcim postupom: Pozrieme sa do poľa $X[v]$ a nájdeme v ňom najmenšiu hodnotu väčšiu alebo rovnú $l$. Ako na to? Postupné prechádzanie po jednom funguje, ale má zložitosť $O(n)$, takže si moc nepomôžeme. Zachráni nás ale binárne vyhľadávanie, ktoré to spraví v $O(\\log n)$. Zastávka, ktorú takto nájdeme, je prvá taká, cez ktorú prejde autobus s Jozefom a je v správnej vzdialenosti od jeho domu. My chceme ale $k$-tu, nie prvú, takže sa v tomto poli $X[v]$ pozrieme o $k-1$ pozícii ďalej a nájdeme presne to, čo hľadáme. Ešte musíme ale vyriešiť dve prekážky: Ak by sme pri tomto procese vybehli z poľa, tak vieme, že taká zastávka neexistuje a odpovieme $-1$. Druhý problém je $r$ z otázky, no jednoducho sa stačí pozrieť na číslo zastávky, ktorú sme našli a ak je väčšie ako $r$, tak opäť vypíšeme $-1$, pretože zastávka už je mimo Jozefovej platnosti lístka.

Celková časová zložitosť riešenia (s použitím hash mapy) je $O(n+q\\log n)$. $n$ pochádza z predpočítania štruktúry $X$ a $q\\log n$ sú jednotlivé odpovede na otázky. Pamäťová zložitosť je $O(n)$, pretože jediné čo si pamätáme je $X$, pričom dokopy sa v ňom nachádza presne $n$ prvkov. Keby sme pre $X$ nepoužili hash mapu ale pole, zložitosti by boli trochu iné. Museli by sme na začiatku inicializovať pole veľkosti $10^6$, čo je určite viac ako $n$, pretože $n$ dosahuje len $10^5$. Taktiež si ho musíme pamätať. Ak by sme pomenovali $w = 10^6$ maximálnu hodnotu $v$, tak by časová zložitosť bola $O(w+n+q\\log n)$ a pamäťová $O(w+n)$.
",4
77eb84514fe1dbc1,ksp,"# Dalo by sa?!

""Dalo by sa pohnúť?""

""Kto ti dal vodičák?""

""Slečna ja Vás zveziem, moje auto je dosť veľké...""

""Ľudiaaa? Nevideli ste niekto jeden valec z môjho auta?""

""Čo to bola za značka? Nebolo to _Daj prednosť v jazde_?""

""Odtiahnete ma niekto? Asi som zase prerazil olejovú vaňu...""

""Joooj, posunúť sa, aby som mohol odísť? Dalo by sa?""

""Dávam Vám ešte 2 minúty, a potom sa proste pohnem tým smerom, ako stojím.""

""Vajcia? Ja som naozaj do auta nebalila vajcia! Tie musí mať niekto iný, ja ich určite nemám""

Osadenstvo T2^[KSP miestosť na matfyze] tento hluk spočiatku ignorovalo, ale ako neutíchal, postupne sa preberali z letargie a knedliačenia na gaučoch. Hneď ako vstali a pozreli sa z okna, pochopili čo sa stalo. FKS odchádza na sústredenie. A všetci vedúci išli vlastným autom. Pred sústredkom sa všetci stretli na matfyze a zastali autom pred okno T2, na jednu dlhú a úzku cestu. Po čase do áut pobalili veci, a ako už chceli všetci odísť, tak zistili, že nikto sa nie je ochotný autom otočiť, každý chce pokračovať tým smerom, ako teraz stojí.

Aby mali na túto situáciu pamiatku, Adam zobral foťák a odfotil všetky autá, ktoré boli na ceste. Hneď potom sa ale stali naraz dve veci: zapípala mikrovlnka (a všetci sa k nej otočili) a autá sa pohli (a teda do seba ponarážali). Keďže nikto z osadenstva T2 sa na autá nepozeral, tak nikto nevidel priebeh zrážky, ktorá nastala.

Po čase smútenia (nad tým, že nevideli zrážku, nie nad autami) si ale uvedomili, že možno by sa dalo aspoň z fotky povedať, koľko zrážok sa pred oknom udialo. Vedeli by ste im to zistiť?

## Úloha

Vašou úlohou bude určiť počet zrážok, ktoré nastali pred oknom T2. Pred T2 oknom sa nachádzajú autá, ktoré buď smerujú doľava, stoja, alebo smerujú doprava. Všetky autá, ktoré smerujú doľava alebo doprava sa v rovnakom momente pohli rovnakou rýchlosťou. Vašou úlohou je zistiť počet zrážok, ktoré nastanú. Autá po zrážke zastanú na mieste a ostanú stáť.

Zrážka nastane vtedy, keď hýbajúce sa auto do niečoho narazí (teda ak narazí auto do stojaceho auta, je to jedna zrážka, ak sa čelne zrazia dve autá, čo doteraz išli opačne, sú to 2 zrážky).

## Formát vstupu

Na jedinom riadku vstupu dostanete $n$ znakov dlhý reťazec. Tento reťazec sa skladá zo znakov `>` (doprava idúce auto), `<` (doľava idúce auto), `=` (stojace auto).

V jednotlivých sadách platia nasledujúce obmedzenia:

| Sada | 1 | 2 | 3 | 4 | |:--------------- |----: |------: |-------------: |-------------: | | $1 \\leq n \\leq$ | 5 | $1,000$ | $1,000,000$ | $5,000,000$ |

V prvej a druhej sade sa nevyskytujú stojace autá.

V prvej sade sa všetky autá okrem jedného hýbu rovnakým smerom (napríklad `<<<><`, alebo `><<<<<`).

## Formát výstupu

Vypíšte jediný riadok, počet zrážok, ktoré pred oknami T2 nastanú. Nezabudnite za číslom vypísať znak nového riadku.

## Príklady

```vstup
><><
```

```vystup
4
```

```vstup
<=>
```

```vystup
0
```

_Krajné autá odídu a stredné sa nikam nepohne, takže nenastane žiadna zrážka_

```vstup
>>=<><
```

```vystup
5
```

```vstup
>>><><<><<>>==<>==<><<>><><>=><=
```

```vystup
26
```
","# Dalo by sa?!

Našou úlohou bolo spočítať počet zrážok, ktoré nastanú. Vieme, že za zrážku sa ráta všetko, kde idúce auto narazí do niečoho. Vieme tiež, že všetky autá po zrážke ostanú stáť.

## Pomalé riešenie

Prvou možnosťou je pre každé auto, ktoré sa niektorým smerom hýbe (doprava alebo doľava) sa pozrieť, či má do čoho naraziť. Naraziť má do čoho vtedy, keď sa tým smerom, ktorým sa hýbe, nachádza auto, ktoré stojí, alebo smeruje opačne. Takže pre každé auto sa pozrieme, či má do čoho naraziť a spočítame tieto zrážky.

Pre každé auto (ktorých je $n$), pozrieme prinajhoršom všetky ostatné autá (ktorých je $n$), takže spolu urobíme $O(n^2)$ operácií.

Časová zložitosť je $O(n^2)$, a pamäťová $O(n)$, lebo okrem vstupného poľa si nič nemusíme pamätať.

## Vzorové riešenie

Je pomerne jasné, že ak auto, ktoré je na ľavej strane, smeruje doľava, tak do ničho nenarazí. Rovnako je to aj na pravej strane s autom, ktoré smeruje doprava. Môžeme si uvedomiť, že to ale neplatí len pre autá, ktoré sú úplne na kraji, ale aj pre všetky autá, ktoré sú naľavo (tým myslíme také, že naľavo od nich sú len autá, ktoré smerujú doľava), a smerujú doľava. Analogicky to platí aj pre autá, ktoré sú napravo. Napríklad, ak máme autá:

`<<<>=<>>`

Tak vieme povedať, že ľavé 3 autá a pravé 2 autá určite do ničoho nenarazia, iba pekne za sebou odídu preč.

To znamená, že nás nezaujíma súvislý úsek áut, ktoré sú naľavo a smerujú doľava, a súvislý úsek áut napravo, ktoré smerujú doprava.

Z nášho príkladu vyššie nás teda zaujímajú iba tieto autá:

`>=<`

Čo vieme povedať, o zrážkach, ktoré nastanú v tejto strednej časti?

Vieme, že každé auto, ktoré nestojí musí do niečoho naraziť. Prečo? Lebo jediná iná možnosť je, že by odišlo preč, a nikdy do ničoho nenarazilo, ale to sa nemôže stať, keďže také autá sú naľavo, a smerujú doľava, alebo napravo a smerujú doprava, a tie ignorujeme.

Vzorové riešenie teda najprv zistí, ktorý úsek áut nás presne zaujíma, teda zistí aký dlhý je úsek áut, ktoré sú naľavo a smerujú doľava. To isté urobí aj pre pravú stranu. Následne pre každé auto v strednej časti, ktoré nestojí, pripočíta $1$ k výslednému počtu zrážok, a vypíše tento výsledok.

Toto riešenie prejde celé pole práve raz, a teda jeho časová zložitosť je $O(n)$. Pamätať si stále musíme len celé pole, teda pamäťová zložitosť je tiež $O(n)$.

## Vzorovejšie riešenie (v konštantnej pamäti)

Existuje aj riešenie v konštantnej pamäti. Jeho kľúčovou myšlienkou je, že ak ideme po vstupom poli áut, tak vždy keď nájdeme auto, ktoré smeruje doľava (`<`), tak vieme, že všetky autá naľavo od neho, ktoré idú doprava do niečoho narazia. V prípade, že nájdeme auto, ktoré smeruje doprava, tak si iba musíme poznačiť, že sme ho niekde videli. No a v prípade, že nájdeme auto, ktoré stojí na mieste, tak vieme, že všetky autá, čo sme videli, a smerovali doprava tiež majú do čoho naraziť.
",1
189cc9186d111fca,ksp,"# Ooo, Vlaky

Píše sa rok $2143$. Presne pred $100$ rokmi sa človek stal multiplanetárnym druhom, keď prví vesmírni osadníci pristáli na Marse a následne vybudovali kolóniu. Na začiatku ich tam bolo presne $157$ a každý tak mal dostatok priestoru, keďže pôvodná kapacita prvej kolónie sa šplhala až k číslu $1223$.

Časom však populácia červenej planéty rástla[^1]. $53%$ terajších obyvateľov pricestovalo zo Zeme alebo z Mesiaca a $47%$ sa na Marse už narodilo. Preto už takýchto kolónií existuje niekoľko (rádovo v stovkách). Čoskoro, teda, dôjde k vyrovnaniu pomeru úplných[^2] a polovičných[^3] ""Marťanov"", a veľkosť populácie prekročí $200,000$.

Znie to veľmi sľubne a prosperujúco, no obyvateľov Marsu stále ešte obmedzuje pár vecí, medzi ktoré patrí napríklad aj doprava. Na prepravu materiálu, potravín alebo osôb sa v tomto nehostinnom teréne používajú elektrické rovery. Tie majú svoje nevýhody: sú pomalé, často sa kvôli prašnému povrchu kazia, majú relatívne malú nosnosť a, samozrejme, z bezpečnostných dôvodov nepremávajú počas Marťanskej búrky. Preto sa Rada kolónií Marsu, Aliancia štátov pre multiplanetárny život a Medzinárodná rada vesmírnych agentúr rozhodli riešiť dopravu na tejto planéte.

Za najvhodnejší spôsob prepravy osôb a tovaru tu považujú vlaky, premávajúce hermeticky uzavretými podzemnými tunelmi. Tie budú môcť premávať aj počas búrok[^4], uvezú veľa nákladu, nebudú vystavené prašnému prostrediu a budú relatívne rýchle[^5]. Okrem toho, odhlasovalo sa, že z bezpečnostných dôvodov[^6] budú všetky tunely vybudované v rovnakej hĺbke, a to znamená, že žiadne dva tunely sa nesmú križovať. V každom tuneli bude premávať práve jeden vlak. Vlaky sú totiž najdrahšou položkou v tomto projekte a preto ich počet, a teda aj počet tunelov, bude čo najnižší. Zároveň ich treba toľko, aby sa bolo možné dostať z ľubovoľnej kolónie do hociktorej inej len použitím vlakov. Ak si teda vlakovú sieť predstavíme ako graf, tak bude vyzerať ako strom, z čoho vyplýva, že počet tunelov bude počet kolónií mínus $1$.

Plán projektu sa skladal z troch tabuliek:

- V jednej boli spárované identifikačné čísla pozícií s ich súradnicami na mape[^7].

| Pozícia | ID pozície | |:---:|:----:| | $[0, 0]$ | $1$ | | $[1, 1]$ | $2$ | | $[2, 3]$ | $3$ |

- V druhej boli pozície priradené číslam a názvom kolónií.

| ID pozície | ID kolónie | Kolónia | |:---:|:---:|:---:| | $1$ | $1$ | Jablkovo | | $2$ | $2$ | Hruškovo | | $3$ | $0$ | Malinovo |

- V tretej sa nachádzal zoznam dvojíc čísel kolónií, ktoré je potrebné prepojiť tunelom.

| ID kolónie $a$ | ID kolónie $b$ | |:---:|:---:| | $1$ | $2$ | | $0$ | $2$ |

Po pár mesiacoch bol plán projektu hotový a išlo sa stavať, no nastal problém. Druhá tabuľka sa záhadne stratila, a tak sú v projekte len súradnice a prepojenia čísel kolónií. Nevieme ale, ktorá kolónia je na ktorých súradniciach.

Stavebníci teraz nevedia, kde treba stavať. Skúste ale z projektu zachrániť, čo sa dá: navrhnite také riešenie, ktoré teoreticky môže byť pôvodne zamýšľaný plán.

\[^1\]: Posledné informácie hovoria o počte $197,359$ \[^2\]: Narodili sa už na Marse \[^3\]: Pricestovali na Mars \[^4\]: Keďže budú chránené v podzemí \[^5\]: 1373 km/h \[^6\]: Ani predseda Medzinárodnej rady vesmírnych agentúr nevedel zdôvodniť toto rozhodnutie \[^7\]: Aj keď je jasné, že Mars nie je plochý, pre účely tejto úlohy postačí, že povrch Marsu budeme považovať za rovinu a použijeme obyčajnú karteziánsku súradnícovú sústavu.

## Úloha

Na Marse sa nachádza $n$ kolónií. Poznáte ich $n$ celočíselných súradníc $x, y$, avšak, neviete konkrétne, ktorá pozícia prislúcha ktorej kolónii. Pozície sú navzájom rôzne, a žiadne tri pozície neležia na jednej priamke.

Ďalej máte plán projektu, v ktorom sú zapísané dvojice čísel $a, b$ označujúce kolónie, medzi ktorými má viesť obojsmerný tunel. Táto vlaková sieť tvorí graf-strom: je teda súvislá a vedie v nej práve $n-1$ hrán.

Navrhnite, medzi ktorými pozíciami majú viesť tunely tak, aby sa žiadne dva tunely nekrižovali, a aby jednotlivé pozície v nejakom poradí zodpovedali jednotlivým kolóniám.

## Vstup

V prvom riadku vstupu sa nachádza číslo $1 \\leq n \\leq 1,000$ udávajúce počet kolónií. Nasleduje $n - 1$ riadkov. V každom z nich sa nachádzajú dve čísla $a, b$ hovoriace, že medzi kolóniami $a$ a $b$ má byť postavený tunel. Kolónie číslujeme $0, 1, \\ldots, n-1$.

Ďalej nasleduje $n$ riadkov. V $i$-tom z nich sa nachádzajú dve čísla $x_i, y_i$, súradnice $i$-tej pozície nejakej kolónie. Tieto súradnice v absolútnej hodnote nepresiahnu $10^9$.

## Výstup

Na výstup vypíšte $n - 1$ riadkov. V každom z nich nech je dvojica čísel $a, b$, ktorá znamená, že medzi $a$-tou pozíciou a $b$-tou pozíciou má viesť tunel. Pozície číslujeme od $0$ po $n-1$.

Na poradí tunelov ani na poradí čísel $a$ a $b$ vo výstupe nezáleží. Ak je správnych odpovedí viac, vypíšte ľubovoľnú z nich.

Je zaručené, že každý vstup má platné riešenie.

## Príklady

```vstup
3
1 2
0 2
0 0
1 1
2 3
```

```vystup
0 1
1 2
```

*Máme tri kolónie. Očíslované sú $0$, $1$ a $2$. Tunel má viesť medzi kolóniami $1$ a $2$ a medzi kolóniami 0 a 2. Tri pozície sú $[0, 0]$, $[1, 1]$ a $[2, 3]$. Príkladový výstup hovorí, že spojíme pozíciu číslo $0$ s pozíciou $1$ a tiež $1$ s $2$. To znamená, že jeden tunel bude medzi $[0, 0]$ a $[1, 1]$ a druhý medzi $[1, 1]$ a $[2, 3]$. Keby sme si to znázornili na štvorčekovú sieť súradníc, videli by sme, že sa žiadne dva tunely nepretínajú. Okrem toho je zachovaný aj spôsob prepojenia kolónií: Buď by bola kolónia číslo $1$ v $[0, 0]$ a kolónia $0$ v $[2, 3]$, alebo naopak.*

*Iné platné riešenie by mohlo spojiť pozície $1$ s $2$ a $2$ s $0$*

```vstup
5
0 1
1 2
2 3
3 4
0 0
9 9
2 3
3 2
7 8
```

```vystup
0 3
3 1
1 4
4 2
```

*Podľa tohto výstupu by boli tunely postavené takto:*
","# Ooo, Vlaky

Keďže zadanie úlohy je pomerne dlhé, zhrňme si najprv, o čo tu ide. Na vstupe máme popísaný graf (strom) s $n$ vrcholmi a $n$ bodov v rovine. Úlohou je položiť vrcholy grafu do bodov v rovine tak, aby sa žiadne hrany nepretínali. Pritom hrany grafu sa zobrazia na úsečky medzi bodmi v rovine. Ako to spraviť?

## Riešenie hrubou silou

Prvou možnosťou by bolo niečo veľmi pomalé. Všetkým bodom v rovine priradíme nejaké vrcholy grafu a skontrolujeme, či nám kolidujú nejaké hrany. Ak áno, skúsime vrcholy rozmiestniť nejako inak. Inak povedané, permutácie usporiadanej množiny vrcholov skúšame zobraziť na usporiadanú množinu bodov, kým nenájdeme správne riešenie.

Hmmm. Jednak by to bolo trochu neefektívne, že aj keď zmeníme medzi jednotlivými permutáciami len malú časť vrcholov, zase musíme kontrolovať všetky dvojice úsečiek, a dvak, asi nechceme skúšať všetky permutácie, chceme tento problém vyriešiť nejako rozumne postupne.

Čo keby sme vrcholy ukladali postupne po jednom a pre každý pridaný vrchol by sme hneď zistili, či sa jeho položením niečo preťalo? Tým pádom by sme vedeli, či má zmysel pokračovať v takomto rozložení vrcholov. Takto by nám stačilo vždy pri uložení vrcholu skontrolovať len tie hrany, ktorými sme tento vrchol pripojili ku zvyšku grafu.

Úlohu si vyriešime rekurzívne tak, že v každom kroku máme $x$ vrcholov už uložených a $n - x$, ktoré sú ešte voľné. Keďže chceme skúšať rôzne možnosti uloženia vrcholov, stačí nám meniť poradie vrcholov a body v rovine necháme napríklad v poradí zo vstupu. Preto majme usporiadanú množinu bodov v rovine. V $i$-tom kroku uložíme nejaký vrchol do bodu $i$.

Na začiatku $x = 0$. Vyberieme si nejaký vrchol, ten uložíme, skontrolujeme, či sa jeho hrany s niečím nepretínajú, a krok opakujeme s $n - x$ vrcholmi. Ak v nejakom kroku zistíme, že ešte máme neuložené vrcholy a nevieme už žiaden uložiť tak, aby nám nič nekolidovalo, vrátime sa o krok späť a skúsime namiesto naposledy uloženého vrcholu uložiť nejaký iný a pokračovať ďalej. Toto opakujeme, až kým nie sú všetky vrcholy uložené. Všimnime si, že keď sa zasekneme a pozmeníme nejako uloženie, nemusíme zase porovnávať všetky dvojice úsečiek, ale len tie, ktoré zahrňajú novo pridané hrany.

Takýto dynamický prístup síce vyzerá pekne, no jeho asymptotická časová zložitosť až tak pekne nevyzerá. Hrozí tu, že v najhoršom prípade potrebujeme preveriť $n!$ uložení grafu, pričom ale pre každú vetvu výpočtového stromu skontrolujeme $n^2$ dvojíc úsečiek. Z toho nám vychádza časová zložitosť $O(n! \\cdot n^2)$.^[Dá sa spraviť šikovnejšia analýza časovej zložitosti, z ktorej vyjde $O(n \\cdot n!)$. Nie že by sme si veľmi pomohli...]

Zamyslime sa. Doteraz sme pracovali s myšlienkou, že budeme nejakým spôsobom skúšať napasovať zadaný graf do zadaných súradníc a testovať pri tom, či je daná možnosť vyhovujúca alebo niečo koliduje. Čo keby sme vedeli nejakým spôsobom vopred zaručiť, že vybrané uloženie je korektné, aj bez potreby overovania?

## Vzorové riešenie

Každý strom si vieme rozdeliť na menšie podstromy a tie na menšie podstromy a tak ďalej, až dostaneme strom hĺbky $1$. Strom hĺbky $1$ môžeme inak nazvať hviezda. Takto nízky strom vieme uložiť do roviny ľubovoľne a aj tak sa nestane, že sa nejaké hrany budú pretínať (samozrejme počítame s tým, že žiadne 3 body neležia ne jedenej priamke).

Ak si zvolíme v zadanom strome nejaký koreň, potom si predstavme podstromy, ktorých koreňmi sú jeho synovia. Každý takýto podstrom bude okupovať nejakú časť roviny, ktorú vieme ohraničiť konvexným obalom jeho vrcholov. Ak by sme vedeli tieto pre každý podstrom vybrať množinu tak, aby sa ich obaly nepretínali, mali by sme už čiastočne vyhrané. Totiž ak sa obaly nepretínajú, nemôžu sa pretínať ani hrany. Ak by sme toto vedeli opakovať rekurzívne do hĺbky, mali by sme vyhrané úplne, lebo takto vieme uložiť všetky vrcholy grafu.

Jediné, čo už teraz potrebujeme vyriešiť je, ako rozdeliť body v rovine do jednotlivých podstromov tak, aby sa ich obaly nepretínali. Keď budú body každého podstromu “pri sebe”, tak snáď nebudú zavadzať iným podstromom. Chceme ich teda “poskupinkovať” nejako lokálne.

Dobre. Z pohľadu ľubovoľného bodu koreňa vidíme každý iný bod pod nejakým uhlom. Zo zadania sme sa dočítali, že žiadne tri body neležia na rovnakej priamke. Preto vieme, že takýto uhol je pre každý bod unikátny. Hmmm. Ak sme v koreni a všetky dostupné body utriedime podľa tohto uhla, vieme si ich v tomto poradí ""poskupinkovať"" a prerozdeliť svojim synom. Tým pádom sa žiadna skupina bodov ""nemieša"" s nejakou inou, pretože body každej tejto množiny pozorujeme pod uhlom z nejakého intervalu, pričom body ďalšej sledujme pod uhlom z iného intervalu, pričom tieto intervaly majú prázdny prienik.

A funguje to vždy? Nie.

Ak si pre koreň vyberieme ľubovoľný bod, môže sa stať, že interval, pod ktorým vidíme istú množinu bodov bude väčší než $\\pi$, čo by znamenalo, že plocha ohraničená konvexným obalom tejto množiny bodov by obsahovala aj koreň. Tým pádom, by sa mohlo stať, že nejaká hrana v tomto území by pretínala hranu medzi koreňom a iným synom. Tento problém vieme ale jednoducho vyriešiť tak, že ako koreň stromu zvolíme najľavejší bod. To nám zaručí, že všetky ostatné body sa budú nachádzať vpravo od neho, čo inak znamená aj to, že interval uhlov, pod ktorými budú viditeľné z koreňa, bude najviac od $\\frac{\\pi}{2}$ po $- \\frac{\\pi}{2}$ otvorený z aspoň jednej strany, keďže žiadne tri body neležia na rovnakej priamke.

Ten istý problém sa môže stať aj na ďalších úrovniach: možno sa podstrom zobraznený na svojej pridelenej podmnožine pretne s hranou, ktorá je medzi jeho koreňom a jeho otcom. To opäť vyriešime extrémnou voľbou koreňa podstromu: ak ho umiestnime do prvého bodu v poradí (podľa uhla). Keďže všetky ostatné body budú zvierať s jeho otcom menší uhol, nebude tak možné, aby sa ľubovoľná úsečka medzi týmito bodmi pretla s tou spomenutou.

Tým pádom všetky usporiadané podmnožiny bodov sú pridelené nejakým podstromom. To znamená, že túto úlohu vieme vyriešiť pekne rekurzívne.

Najprv si porebujeme prehľadaním do hĺbky spočítať veľkosti jednotlivých podstromov, aby sme neskôr vedeli, koľko bodov máme konkrétnemu podstromu vyčleniť. Potom už vieme rekurzívnym prehľadávaním do hĺbky ukladať najprv koreň celého stromu, potom jeho synov a tak ďalej, pričom vždy uložíme koreň, polárne utriedime zvyšné body práve vzhľadom na koreň daného podstromu a rozdelíme tieto body jeho synom, podľa veľkostí ich podstromov.

Zložitosti. To, že vrcholy ukladáme do roviny rekurziou do hĺbky, nás môže ľahko zlákať na myšlienku, že pre každú úroveň rekurzie si potrebujeme pamätať zase novú množinu bodov, lebo si chceme pôvodnú usporiadanú množinu pamätať pre prípad, že sa k nej z rekurzie vrátime a budeme s ňou ďalej pracovať. Najhorší prípad by potom nastal, ak by graf na vstupe bol cesta a zakorenili by sme si ho ma jej konci. Vtedy by sme si najprv pamätali $n$ bodov, potom $n - 1$, $n - 2$, $\\dots$ čo je asymptoticky $n^2$. Z toho dostávame teda zložitosť $O(n^2)$.

Uvedomme si ale, že ak časť (istý súvislý úsek usporiadanej množiny) bodov priradíme nejakému synovi a jeho podstromu, ostatní synovia s touto časťou už nepracujú. Preto nevadí, že v tejto podmnožine zmeníme poradie prvkov predtým, ako rozdelíme aj všetky ostatné prvky. To znamená, že nám úplne postačuje pamätať si množinu všetkých bodov len raz a potom pracovať s jej podmnožinami bez toho, aby sme museli zachovaávať pôvodné poradie. Pamäťovú zložitosť tohto riešenia tak vieme odhadnúť na $O(n)$.

A časová zložitosť? Spočítanie veľkostí podstromov trvá len $O(n)$. Triediť vieme v $O(n \\log n)$, ale potrebujeme to robiť pre každý podstrom, no na druhej strane, pre každý podstrom sa nám mení $n$. V najhoršom prípade by zadaný graf bol cesta. Vtedy by sme vždy v $i$-tej úrovni rekurzie polárne triedili $n - i$ bodov a úrovní by bolo $n$. Z toho nám vychádza asymptotická časová zložitosť $O(n^2 \\log n)$.

Poznámka na záver: to, že týmto spôsobom nájdeme správne riešenie, neznamená, že nájdeme jediné správne. Môže existovať strom uložený v rovine aj keď neexistuje taký jeho koreň, z ktorého by sme videli množiny bodov podstromov jeho synov a vedeli si ich takto rozdeliť do konvexných množín. My sme chceli len nájsť ľubovoľné riešenie pre uloženie stromu, nie všetky.
",6
40076f8eb04c638d,ksp,"# Lacný polozisk

Kubik zistil, že v Ebaystane sa dá kúpiť notebook a následne sa dá predať aj za dvojnásobok. Niekedy však notebook nefunguje, a tak Kubik získa menej, alebo je dokonca v strate. Predajcovia sú v Ebaystane postavaní, ako inak, do mriežky. O každom predajcovi Kubik vie, ako veľmi sa mu oplatí od neho notebook kúpiť. Presnejšie, pre každého predajcu si zrátal, aký zisk by mal, ak by od daného predajcu kúpil notebook.

V jeden deň sa Kubik vybral na nákupy. Postavil sa do ľavého horného rohu Ebaystanu. Teraz chce prejsť do pravého dolného rohu a chce pri tom dosiahnúť čo najväčší zisk. Má to ale problém. V Ebaystane je zakázané chodiť doľava, aby nenastali zrážky s inými nakupujúcimi, ktorí idú doprava. Kubik ale nemá času nazvyš a tak žiadneho predajcu nechce navštíviť viac, ako raz.

## Úloha

Ebaystan je mriežka rozmerov $R \\times C$. O každom políčku Kubik vie, koľko získa, ak cez dané políčko prejde. Keďže predajcovia sú otravní, po vstupe na políčko Kubik musí od daného predajcu notebook kúpiť.

Kubik začína v ľavom hornom rohu a chce skončiť v pravom dolnom. V týchto dvoch rohoch nie sú predajcovia. Ziskovosť týchto políčok je teda 0.

Kubik môže chodiť iba **hore**, **dole** a **doprava**. Naviac na žiadne políčko nemôže stúpiť viac, ako raz.

Koľko najviac vie Kubik zarobiť touto technikou nákupu za polovičnú hodnotu?

## Formát vstupu

Na prvom riadku vstupu sú dve celé čísla $R$ a $C$, počet riadkov a počet stĺpcov. Platí, že $2 \\leq R,,C \\leq 600$.

Nasleduje $R$ riadkov. V každom z týchto riadkov sa nachádza $C$ celých čísiel. Žiadne z týchto čísiel v absolútnej hodnote neprevýši $1000$. Je zaručené, že v ľavom hornom a pravom dolnom rohu je hodnota 0.

## Formát výstupu

Vypíšte jedno číslo - aký najväčší zisk vie Kubik dosiahnúť, ak začne vľavo hore, skončí vpravo dole, na žiadne políčko nestúpi viac, ako raz a zároveň bude chodiť iba hore, dole, a doprava.

## Hodnotenie

| Sada | 1 | 2 | 3 | 4 | |:----------------- | ---: | ---: | ----: | ----: | | $2\\leq R, C\\leq$ | $4$ | $10$ | $100$ | $600$ |

## Príklad

```vstup
3 5
0 6 3 -2 9
3 6 -1 8 2
5 -7 1 2 0
```

```vystup
37
```

*Kubik použije cestu DRURDDRUURDD, kde D je dole, R je doprava a U je hore. Zoberie teda postupne políčka s hodnotami 0, 3, 6, 6, 3, -1, 1, 2, 8, -2, 9, 2, 0.*
","# Lacný polozisk

Za úlohu sme mali prejsť z ľavého horného do pravého dolného políčka mriežky tak, aby sme maximalizovali súčet hodnôt prejdených políčok. Mohli sme pri tom chodiť iba hore, dole a doprava.

## Jednoducho, neefektívne, funkčne

Ak nevieme, čo s úlohou, niet lepšieho nápadu, ako napísať riešenie hrubou silou. Možno si potom niečo všimneme a budeme takéto riešenie vedieť prerobiť na nejaké rýchlejšie.

Nuž, keďže chceme hrubú silu, vyskúšajme všetky možnosti. Ináč povedané, skúsme postupne každú možnú cestu z ľavého horného, na pravé dolné políčko. Samozrejme, chceme skúšať iba tie cesty, kde nechodíme doľava, pretože to predsa nesmieme. Pre každú cestu zrátame súčet hodnôt prejdených políčok. Z nich nakoniec vypíšeme maximum.

Ako niečo takého naprogramovať? Jednoduchým riešením je rekurzia. O každom políčku si budeme pamätať, či už sme cez neho prešli, alebo nie. Tiež si budeme pamätať, na ktorom políčku aktuálne stojíme.

Aké máme možnosti, keď stojíme na políčku $[r, c]$? Môžeme sa pohnúť hore, teda na políčko $[r - 1, c]$, dole, teda na políčko $[r + 1, c]$, alebo doprava, teda na políčko $[r, c + 1]$. Samozrejme, ak je dané políčko už označené ako navštívené, alebo ak neexistuje (teda je mimo mriežky), tak naň stúpiť nemôžeme. Ktorú možnosť si vybrať? Keďže skúšame všetky možnosti, tak si postupne vyberieme všetky. Políčko, na ktoré sa rozhodneme ísť označíme ako navštívené. K aktuálnemu súčtu si pripočítame hodnotu daného políčka a rekurzívne sa zavoláme na to políčko. Ked sa vrátime z rekurzie, označíme ho opäť ako nenavštívené a skúsime ďalšiu možnosť. Takto postupne preveríme všetky 3 možnosti pre dané políčko.

Samozrejme, ak sa rekurziou zavoláme až na políčko $[R - 1, C - 1]$, tak sa ďalej nevoláme, ale iba si zapamätáme maximum z doterajšieho maxima a aktuálneho súčtu políčok a vrátime sa z rekurzie.

Technika, ktorú sme použili sa volá rekurzívny backtracking a na napísanie riešenia hrubou silou sa dá použiť veľmi často.

Akú to má zložitosť? Keďže skúšame všetky cesty, tak to určite bude aspoň toľko, koľko je ciest. A koľko to je? Nuž, to nie je celkom jednoduché.

Ľahko však spravíme horný odhad. Na každom z $RC$ políčok skúšame 3 možnosti. Každú cestu aj naozaj prejdeme. Najdlhšia možná cesta má nanajvýš $RC$ políčok. Horný odhad teda bude $O(RC \\cdot 3^{RC})$.

Môžeme spraviť aj dolný odhad. Keby sme chodili iba dole a doprava, tak by sme dokopy vždy spravili $R + C$ krokov. Práve $R$ z nich bude doprava. Počet takýchto ciest teda bude $(R + C) \\cdot {R+C \\choose R}$. Tým, že pridáme možnosť chodiť aj hore nám počet týchto ciesť nezníži.

Časová zložitosť nášho programu je niekde medzi tým. Malo by to stačiť na prvú sadu.

Pamäť je $O(RC)$.

## Z hrubej sily vzorák?

Ako sme už povedali, niekedy stačí malé pozorovanie, aby sme z riešenia hrubou silou spravili vzorák.

Skúsme si pre každé políčko zrátať, koľko by sme zarobili, keby sme na ňom začínali, ale nemohli stúpiť na políčko $[r, c]$.

Naša nová rekurzia si okrem súradníc políčka, na ktorom stojíme, pamätá aj to, na ktoré políčko nesmieme stúpiť. Nepotrebujeme teda už veľké dvojrozmerné pole navštívených políčok. Totiž, ak si pamätáme iba to, na ktorom políčku sme boli bezprostredne predtým, ako sme sa dostali na to aktuálne, tak určite na žiadne políčko nestúpime dvakrát. Je to kvôli tomu, že nemôžeme chodiť doľava. Rozmyslite si, že nám táto informácia naozaj stačí.

Dokonca nepotrebujeme ani súradnice predchádzajúceho políčka. Stačí nám vedieť smer, z ktorého sme prišli, čo si môžeme reprezentovať napríklad číslami 1, 2, 3. Naša rekurzia má teda stav `riadok, stlpec, odkial`.

Všimnime si teraz veľmi užitočnú vec. Ak už niekedy zrátame odpoveď pre nejaký stav `riadok, stlpec, odkial`, tak už nikdy ho nemusíme rátať znova. Stačí, ak si zapamätáme výsledok a keď ho budeme potrebovať zrátať nabudúce, iba sa pozrieme na ten výsledok, ktorý máme uložený.

Vnútro našej rekruzívnej funkcie teda bude vyzerať asi tak, že sa najskôr pozrieme, či už nie sme na pravom dolnom políčku. Ak áno vrátime ako odpoveď 0. Ak nie sme, tak sa pozrieme, či už nemáme výsledok pre aktuálny stav uložený. Ak áno, tak ho vrátime. Ak ho nemáme uložený, tak sa rekurzívne zavoláme do tých dvoch, alebo troch smerov, do ktorých môžeme. Skúšame totiž 3, ale z jedného sme možno prišli, takže tam nepôjdeme. Nakoniec si iba zapamätáme odpoveď pre aktuálny stav a vrátime ju.

Na konci iba vypíšeme odpoveď pre stav `0, 0, -1`.

Akú to má zložitosť? Každý stav zrátame v $O(1)$, pretože sa iba dvakrát rekurzívne zavoláme. Stavov je $R \\cdot C \\cdot 3$. Celková časová zložitosť teda bude $O(RC)$. Pamätáme si vstup a odpovede pre všetky stavy, takže aj pamäť bude $O(RC)$.

Jeden problém, ktorý sa môže vyskytnúť je hĺbka rekurzie. Môže nám totiž dôjsť miesto na zásobníku. To má ale jednoduché riešenie. Nezavoláme sa hneď na výsledný stav, ale budeme sa postupne volať od posledných stavov až k tomu, ktorý nás najviac zaujíma.

Technika zapamätávania si už zrátaných výsledkov sa zvykne označovať ako dynamické programovanie. My sme tu použili jeho rekurzívnu formu, ktorá sa často nazýva rekurzia s memoizáciou. Samozrejme, táto úloha sa dá riešiť rovnako jednoducho aj iteratívne, rekurzia je však pre množstvo ľudí o niečo intuitívnejšia.
",4
63e55001297bbfd2,ksp,"# Zuzkino sudoku

Zuzka rada rieši a ešte radšej vytvára sudoku. Vo svojom rodnom meste dokonca vytvárala každý týždeň jedno sudoku pre miestny časopis.

Jedného dňa jej napísal vydavateľ celoslovenského denníka s ponukou, či by nechcela sudokami zásobovať celé Slovensko každý deň. Na každý deň by musela vytvoriť ľahkú, strednú aj ťažkú variantu. To je ale veľa práce, však? Ak by Zuzka ponuku prijala, síce by si zarobila, no nemala by čas na školu, spánok a kamarátov^[Veľa ľudí sa aj bez vytvárania sudoku sťažuje, že majú čas len na dve zo spomenutých troch vecí.].

Zuzka je ale programátorka, a preto nebude sudoku vyrábať ručne, ale programom. Nie je to však také jednoduché. Pri tvorbe si totiž treba dať záležať na tom, aby mali riešitelia z riešenia sudoku dobrý zážitok. Sudoku, v ktorom chýbajú iba jednotky, je veľmi nezáživné. Také, do ktorého treba počas riešenia doplniť rôzne čísla je rozhodne zaujímavejšie.

Pomôžte Zuzke zistiť, ktoré sudoku sú tie zaujímavejšie. Napíšte program, ktorý pre dané sudoku zistí, koľko ktorých čísel treba do sudoku doplniť pre jeho vyriešenie.

## Úloha

Sudoku sa hrá nasledovne. Dostanete tabuľku s $9 \\times 9$ políčkami. Tabuľka je rozdelená na $3 \\times 3$ bloky po $3 \\times 3$ políčkach. Na každom políčku je buď číslo od 1 po 9 alebo je políčko voľné. Úlohou v sudoku je doplniť čísla na všetky prázdne políčka tak, aby sa v žiadnom riadku, stĺpci ani v bloku nezopakovalo žiadne z čísel 1 až 9 viac ako raz.

Vašou úlohou je pre daný popis sudoku zistiť, koľko ktorých čísel doň treba doplniť.

## Formát vstupu

Na vstupe dostanete 9 riadkov. V každom z nich bude 9 čísel v rozsahu od 0 po 9 oddelených medzerami. Čísla 0 reprezentujú nevyplnené políčka sudoku.

Môžete predpokladať, že sudoku zo vstupu sa dá vyriešiť -- teda napríklad v žiadnom riadku, stĺpci ani v bloku sa nezopakuje to isté číslo (okrem nuly).

## Formát výstupu

Vypíšte 9 riadkov. Ak riadky očíslujeme od 1 po 9, na $i$-tom z nich sa má nachádzať jedno celé číslo -- počet čísel $i$, ktoré treba do sudoku doplniť.

## Príklad

```vstup
8 7 0 2 4 5 1 9 3
2 0 1 3 6 0 4 5 7
5 4 3 1 7 9 8 2 6
6 8 0 0 2 3 7 1 0
7 2 5 6 0 4 3 8 9
0 0 0 8 0 0 5 6 2
9 0 8 7 3 1 2 4 5
1 3 2 4 5 6 9 7 8
4 5 7 9 8 2 6 3 1
```

```vystup
2
0
1
2
1
2
1
1
3
```

_Jednotka chýba v piatom a v šiestom riadku. Dvojky sú všade tam, kde majú byť, ..._
","# Zuzkino sudoku

Vzhľadom na to, že každý vstup obsahoval iba $9\\times9$ čísel (čiže každý vstup bol malý), mohli ste v tejto úlohe robiť všeličo. Mohli ste rekurziou vyriešiť sudoku, mohli ste pre každý riadok zisťovať, čo v ňom chýba...

Na vyriešenie tejto úlohy však nebolo nič z toho potrebné a stačilo spraviť jediné pozorovanie: **v každom vyriešenom sudoku sa nachádza každé číslo (1-9) práve deväťkrát**. Raz v každom stĺpci a stĺpcov je 9. Raz v každom riadku a riadkov je 9. Raz v každom bloku a blokov je 9.

Preto nám bude stačiť prečítať vstup, spočítať, koľko je v zadaní jednotiek, dvojok, ..., deviatok a vypísať čísla $9 - pocet_jednotiek, 9 - pocet_dvojok, \\dots, 9 - pocet_deviatok$.

Na pamätanie počtov jednotlivých čísel môžeme použiť 9 premenných, ale krajšie riešenie je použiť pole `pocet_cisel[]`, ktoré si inicializujeme na samé nuly. Potom načítame zo vstupu 81 čísel a zakaždým zvýšime dané políčko poľa.

Veľmi podobným spôsobom si môžeme v poli pamätať, koľko čísel $i$ treba doplniť. Pole inicializujeme na samé deviatky a pri čítaní vstupu odčítame jednotku za každý výskyt čísla.

## Časová zložitosť

Hoci vstup je konštantnej (vždy rovnakej) veľkosti, a mohli by sme povedať, že program pracuje v konštantnom čase $O(1)$^[program beží rovnako dlho pre všetky vstupy $9 \\times 9$ a pre iné vstupy nebude pracovať správne], tak informatívnejšie by bolo povedať niečo takéto: Ak si dĺžku štvorca sudoku označíme ako $n$, potom náš algoritmus pracuje v čase $O(n^2)$.

Z takéhoto tvrdenia sa dá usúdiť, že rovnakým algoritmom by ste vedeli vyriešiť úlohu, v ktorej by bolo sudoku veľkosti $18\\times18$, no trvalo by to 4-krát dlhšie.

Všimnite si rozdiel medzi pojmami $program$ a $algoritmus$. Hoci vyššie uvedené programy by vstupy veľkostí $18 \\times 18$ nevyriešili, rovnaká myšlienka, postup -- algoritmus -- sa dá použiť aj na riešenie vstupov rôznych veľkostí. Preto má zmysel hovoriť o [časovej zložitosti](https://www.ksp.sk/kucharka/zlozitost0/) algoritmu aj v tejto úlohe.

## Pamäťová zložitosť

V našich riešeniach využívame len jedno pole veľkosti $10$ (v riešení, ktoré je napísané v Pythone, si ešte pamätáme jeden riadok vstupu) a niekoľko jednoduchých premenných. Mohli by sme teda, takisto ako v časti o časovej zložitosti, povedať, že pamäťová zložitosť je konštantná od veľkosti vstupu, $O(1)$. Informatívnejšie by ale bolo uviesť pamäťovú zložitosť lineárnu od dĺžky strany sudoku, $O(n)$.
",1
049474da9452d3e2,ksp,"# Nádoby

Samo má doma veľa hadov. Chcel si kúpiť veľa hadíc (samíc hadov), aby neskôr mal aj veľa háďat. Tak si ich objednal z nemenovaného internetového obchodu, ale keď mu prišla zásielka, postihlo ho nepríjemné prekvapenie. Miesto hadíc (samíc hadov) mu omylom poslali hadice (hadice). No čo už, pomyslel si, nájdem si teda inú zábavu. A našiel si inú zábavu.

## Úloha

Máme sústavu $n$ nádob poprepájaných hadičkami. Na začiatku sú všetky nádoby prázdne. Nad prvou nádobou je kohútik, cez ktorý sa do tohto systému napúšťa voda. Funguje princíp spojených nádob.

Hadičkou začne voda pretekať, až jej hladina v niektorej z incidentných nádob dosiahne úroveň najvyššieho bodu danej hadičky. Vtedy sa rast hladiny v tej nádobe zastaví a začne sa napúšťať tá druhá a cez ňu prípadne ďalšie. Až sa hladiny vyrovnajú, zostanú vyrovnané navždy a ak napúšťanie pokračuje, budú stúpať súčasne.

Vašou úlohou je zistiť, z ktorej nádoby voda pretečie.

## Formát vstupu

Na prvom riadku sú dve medzerou oddelené čísla $n$ a $k$ -- počet nádob a počet hadičiek. Nádoby sú očíslované od $1$ po $n$.

Na druhom riadku je $n$ čísel, $d_1$ až $d_n$ -- výšky, v ktorých sa nachádza dno danej nádoby. Na treťom riadku je $n$ čísel, $h_1$ až $h_n$ -- výšky horných okrajov jednotlivých nádob.

Nasleduje $k$ riadkov popisujúcich jednotlivé hadičky. Na $i$-tom riadku je päť medzerou oddelených celých čísel, $x_i$, $y_i$, $a_i$, $b_i$, $c_i$. Táto hadica spája nádoby $x_i$ a $y_i$. Platí $x_i \\neq y_i$. Pripája sa do nádoby $x_i$ vo výške $a_i$ a do nádoby $y_i$ vo výške $b_i$. Jej najvyšší bod je vo výške $c_i$. Platí $a_i < c_i > b_i$ a koncové body hadice sú vyššie ako dno nádoby ku ktorej sa pripájajú. Koncový bod však môže byť vyššie ako horný okraj nádoby, v takomto prípade cez neho môže do nádoby voda iba natekať (vytekať nie).

Medzi tou istou dvojicou nádob môže viesť aj viac ako jedna hadička.

Všetky výškové údaje sú celé čísla z intervalu od $0$ do $10^9$ vrátane a sú navzájom rôzne.

## Formát výstupu

Vypíšte jedno číslo, číslo nádoby ktorá pretečie.

## Hodnotenie

Je 8 sád vstupov. Platia v nich nasledujúce obmedzenia:

| Sada | 1--2 | 3--5 | 6 | 7--8 | |:--------------- |--------: | --------: | ------------: | ---------: | | $1 \\leq n \\leq$ | $100$ | $1,000$ | $10,000$ | $100,000$ | | $1 \\leq k \\leq$ | $1,000$ | $10,000$ | $100,000$ | $100,000$ |

## Príklad

```vstup
3 3
20 10 0
90 50 60
1 2 25 15 35
2 3 30 40 45
1 3 70 75 80
```

```vystup
2
```

*Keď hladina v nádobe 1 dosiahne výšku 35, začne sa napĺňať nádoba 2. Potom čo aj v nádobe 2 dosiahne výšku 35, voda začne stúpať v oboch nádobách súčasne, až kým nedosiahne výšku 45, kedy sa začne napúšťať nádoba 3. Keď voda aj v nej dosiahne výšku 45, začne voda stúpať vo všetkých nádobách súčasne, až dokým nedosiahne výšku 50, keď začne pretekať cez okraj nádoby 2 a hladina už ďalej stúpať nebude nikde.*

```vstup
5 6
30 50 70 40 90
300 280 290 210 110
1 2 220 200 230
3 4 100 120 170
3 4 130 60 150
4 5 160 190 260
1 5 180 250 270
4 2 140 80 240
```

```vystup
4
```

*Hoci je nádoba 5 najnižšia, voda sa do nej nedostane, skôr sa vyleje z nádoby 4.*
","# Nádoby

V tejto úlohe sme mali sústavu spojených nádob poprepájaných hadičkami, pričom do prvej nádoby sa napúšťala voda. Našou úlohou bolo zistiť, z ktorej nádoby sa voda vyleje.

## Pozorovania

Môžme si všimnúť, že mnohé informácie, ktoré na vstupe dostaneme, pre nás vlastne nemajú žiaden význam. Voda začne tiecť z jednej nádoby do druhej, keď hladina dosiahne výšku najvyššieho bodu hadice, ktorou sú prepojené. Výšky koncových bodov hadice na to nemajú žiaden vplyv, môžme ich teda ignorovať. Výška dna nádoby tiež nič neovplyvňuje.

## Pomalé riešenie

Budeme si pamätať, v ktorých nádobách už je voda, a v ktorých ešte nie.

Zakaždým preiterujeme všetky hadičky, aby sme našli tú, ktorá spája už zaplavenú nádobu s ešte nezaplavenou a spomedzi všetkých takýchto má najnižší vrchol. To nám povie, ktorá nádoba sa najbližšie zaplaví. Ak je však najnižšia výška vrchného okraja spomedzi už zaplavených nádob nižšia ako vrchol tejto hadičky, voda sa vyleje z najnižšej spomedzi už zaplavených nádob.

Časová zložitosť takéhoto riešenia je $O(n \\cdot k)$.

## Vzorové riešenie

Problém s predchádzajúcim riešením je, že zakaždým, keď sme chceli vedieť, do ktorej nádoby voda ďalej potečie, nám to zabralo veľmi veľa času. Tu nám pomôže [halda](https://www.ksp.sk/kucharka/halda/).

Použijeme haldu, na ktorej budú udalosti dvoch typov, pretečenie cez okraj nádoby a pretečenie z jednej nádoby do druhej. Halda bude utriedená podľa výšky, ktorú musí voda dosiahnuť, aby udalosť nastala (teda pri udalostiach prvého typu výška nádoby, a pri udalostiach druhého typu výška najvyššieho bodu hadice). Udalosť s najnižšou výškou bude na vrchu haldy.

Na začiatku máme v halde iba udalosti, ktoré sa týkajú prvej nádoby.

Simulácia teda bude vyzerať takto. Zakaždým z haldy vyberieme udalosť s najnižšou výškou. Ak je to pretečenie cez hadičku do druhej nádoby, v ktorej ešte voda nie je, udalosti súvisiace s touto nádobou (pretečenie cez jej okraj, a cez hadičky do susedných nádob) pridáme do haldy a zapamätáme si, že tu je voda. Ak je to pretečenie cez okraj, máme odpoveď, ďalej už simulovať nemusíme.

## Časová zložitosť

Jedna operácia vkladania alebo vyberania z haldy s $s$ prvkami nám zaberie $O(\\log s)$. Na halde môže byť najviac $2k+n$ udalostí (pre každú nádobu pretečenie cez okraj a pre každú hadičku pretečenie do jednej alebo druhej strany). Koľko operácii budeme robiť? Určite nie viac ako $4k+2n$, pretože každú udalosť môžme najviac raz vložiť a raz vybrať z haldy. Časová zložitosť teda bude $O((4k+2n)\\cdot \\log(4k+2n)) = O((n+k)\\cdot \\log(n+k))$.

## Pamäťová zložitosť

Okrem vecí zo vstupu si potrebujeme držať v pamäti ešte našu haldu ($O(n+k)$) a jedno pole, na to, aby sme vedeli, v ktorých nádobách už je voda ($O(n)$), čo je dokopy $O(n+k)$.
",6
ba7c6426869dea51,ksp,"# Trefa do čierneho

Rozpálené slnko už pár dní pieklo, a tak sa Emo so Samom rozhodli, že sa uchýlia do klimatizovanej haly a zahrajú si partičku squashu. Emo využíval všetky svoje tenisové schopnosti. Keď raz napriahol ruku a švihol raketou v snahe odbiť loptičku, trafil miesto nej Samovu nohu. Tak bol ich zápas predčasne ukončený a každý išiel späť svojou cestou.

Samo sa teraz potrebuje vrátiť na internát, ktorý sa nachádza od haly smerom presne na severovýchod. Najradšej by išiel najkratšou trasou -- priamo na severovýchod. Keďže po zničujúcom údere jeho noha nie je úplne v poriadku, nie celkom sa mu to darí. Chvíľu poskakuje na svojej zdravej ľavej nohe, no vtedy namiesto toho, aby išiel na severovýchod, ide smerom na východ. Chvíľu potom kráča po oboch a vtedy sa mu darí kráčať na sever. Potom ho noha ale zase začne bolieť a musí poskakovať, a teda ísť na východ. Toto sa dookola opakuje a Samo teda miesto priamo na severovýchod ide cik-cak, raz na východ, raz na sever.

Keďže si Samo nie je istý, či sa takto vôbec dostane na internát, zaujímalo by ho, koľkokrát by pretol svoju ideálnu trasu (polpriamku idúcu od haly na severovýchod), ak by takýmto spôsobom pokračoval donekonečna.

## Úloha

Samo sa na začiatku nachádza v bode $(0,0)$ súradnicovej sústavy. Jeho pohyb sa dá popísať pomocou dvoch čísel $d_x$ a $d_y$. Samo postupne donekonečna opakuje dva posuny:

- Posun o $d_x$ metrov smerom na východ (v smere rastúcej $x$-ovej súradnice)
- Posun o $d_y$ metrov smerom na sever (v smere rastúcej $y$-ovej súradnice)

Vašou úlohou je zistiť, koľkokrát takto pretne priamku $x=y$, pričom za pretnutie rátame aj dotyk s priamkou.

## Formát vstupu

Aby sme mohli presnejšie testovať rýchlosť vašich riešení, v každom testovacom vstupe bude potrebné vyriešiť úlohu pre viacero dvojíc $d_x, d_y$.

Na prvom riadku vstupu bude číslo $t ~ (1 \\leq t \\leq 1000)$, určujúce počet zadaní úlohy, ktoré treba vyriešiť. Nasleduje $t$ riadkov, každý z nich obsahuje dve celé čísla $d_x, d_y ~ (1 \\leq d_x, d_y \\leq 10^{15})$ oddelené medzerou: číslo $d_x$ predstavujúce dĺžku posunu smerom na východ a číslo $d_y$ predstavujúce dĺžku posunu smerom na sever.

## Formát výstupu

Pre každú zadanú dvojicu $d_x, d_y$ vypíšte do samostatného riadku počet pretnutí Samovej cesty s priamkou $x=y$. V prípade, že priamku cesta pretne nekonečne veľa ráz, vypíšte $-1$. Nezabudnite vypísať znak konca riadku aj za posledným riadkom výstupu.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| ----:| ----:| ----:| | Maximálne $d_x, d_y$ | $1000$| $10^{6}$| $10^{12}$| $10^{15}$|

Všimnite si, že čísla $d_x$ a $d_y$ presiahnu $2^{31} - 1$ (zhruba $2\\cdot 10^9$), čo je najväčšie číslo, ktoré sa dá uložiť v $32$-bitovej premennej so znamienkom. Použite preto $64$-bitové premenné typu `long long` v C++ a `Int64` v Pascale.

## Príklad

```vstup
2
1 1
3 2
```

```vystup
-1
1
```

_Pri prvej ceste sa Samo priamky dotkne nekonečne veľa ráz. Pri druhej ceste sa priamky dotkne iba v bode $(0, 0)$._
","# Trefa do čierneho

## Hrubá sila

Pri tomto riešení budeme často potrebovať zistiť, či sme pod alebo nad priamkou $y = x$. To je jednoduché: pod priamkou sa nachádzame, ak je súradnica $x$ väčšia ako $y$, v opačnom prípade sme nad priamkou.

Najjednoduchšie riešenie, ktoré by nám pri tejto úlohe mohlo napanúť, je postupné simulovanie Samových posunov a rátanie pretnutí s priamkou. Problém ale je, že takéto posuny by mohli trvať potenciálne donekonečna. Preto sa treba najprv zamyslieť, kedy môžeme so simuláciou prestať. Podľa toho, v akom vzťahu sú veľkosti posunov $d_x$ a $d_y$, môžu nastať nasledujúce prípady:

- $d_x=d_y$: po každých 2 posunoch sa ocitneme opäť na priamke $x=y$, teda dotykov s priamkou bude nekonečne veľa.
- $d_x>d_y$: s priamkou sa stretneme iba raz, a to v bode $(0,0)$. Od nášho prvého pohybu sa už budeme stále nachádzať iba pod priamkou (rozmyslite si).
- $d_x\<d_y$: tu sa budeme s priamkou stretávať rôzne veľa krát. Stačí nám ale uvedomiť si, že ak sa pri nejakom pohybe doprava nepretneme s priamkou, už nikdy sa s ňou nepretneme. Od tohto momentu budeme totiž celý čas už iba nad priamkou.

Keď už poznáme tieto tri situácie, môžeme sa pustiť do programovania nášho riešenia. Na začiatku skontrolujeme, či sa veľkosti posunov nerovnajú, alebo či nie je posun doprava väčší ako ten smerom hore. Ak áno, vypíšeme potrebný výsledok. Ak nie, simulujeme pohyb po mriežke a po každom kroku zistíme, či sme sa pretli s priamkou. S priamkou sa pretneme vtedy, ak sme išli spod priamky nad ňu, alebo naopak (samozrejme, nezabúdame na ošetrenie dotyku s priamkou). Ak sme sa pri niektorom pohybe doprava nepretli s priamkou, simuláciu ukončíme a vypíšeme počet pretnutí.

Pamäťová zložitosť tohto riešenia je $O(1)$, keďže miesto, kde sme, a veľkosti posunov si udržiavame v pár premenných.

Časová zložitosť riešenia je priamo úmerná počtu krokov, ktoré odsimulujeme. Ten je zhruba rovný počtu pretnutí s priamkou (ak dva kroky po sebe priamku nepretneme, simuláciu ukončíme). Ako si ukážeme v časti o ideálnom riešení, počet pretnutí je (v zaujímavom prípade $d_x < d_y$) zhruba $d_x/(d_y-d_x)$, časová zložitosť je preto $O(d_x/(d_y-d_x))$ = $O(d_x)$.

## Ideálne riešenie

Ako sme si pri riešení hrubou silou mohli všimnúť, v dvoch prípadoch sme mali odpoveď hneď, bez akejkoľvek simulácie. Ak sa bližšie zamyslíme a nakreslíme si pár obrázkov, zistíme, že aj v poslednom prípade vieme počet dotykov vypočítať v konštantnom čase.

Simuláciu sme ukončovali, keď sme prvý raz urobili krok doprava, pri ktorom sme našu priamku nepretli, ale zostali sme nad ňou. Bol to vlastne prvý krok doprava, po ktorom bola naša $y$-ová súradnica väčšia, než $x$-ová. Pozrime sa preto na body, v ktorých budeme po pohybe smerom vpravo, čiže po prvom kroku, po treťom kroku, atď. a všímajme si, o koľko je ich $x$-ová súradnica väčšia, než $y$-ová. Po prvom posune má $x$-ová súradnica ""náskok"" $d_x$, keďže sme v bode $(d_x, 0)$. Po každých dvoch krokoch však $y$-ová súradnica tento ""náskok"" stiahne o $d_y - d_x$. Na to, aby $y$-ová súradnica ""dobehla"" tú $x$-ovú, teda treba $\\lceil d_x/(d_y-d_x) \\rceil$ takýchto dvojkrokov. Pri každom takomto dvojkroku, možno s výnimkou posledného, pretneme priamku dvakrát, počet pretnutí teda bude zhruba $2 d_x/(d_y-d_x)$.

Do vzorca nesmieme zabudnúť pripočítať pretnutie v bode $(0,0)$ kde začíname. Ďalej je potrebné si uvedomiť, že nám vzniknú 2 prípady, pri ktorých sa počty mierne líšia:

- V prípade, že je $d_x$ deliteľné číslom $d_y-d_x$, po $d_x / (d_y-d_x)$ dvojkrokoch budeme presne na priamke. To znamená, že v každom dvojkroku priamku pretneme dvakrát, spolu s pretnutím v bode $(0, 0)$ teda dostávame vzorec: $2 \\cdot d_x/(d_y-d_x) + 1$

- Ak $d_x$ nie je deliteľné číslom $d_y - d_x$, po $\\lceil d_x / (d_y-d_x) \\rceil$ dvojkrokoch skončíme nad priamkou. To znamená, že v poslednom z týchto dvojkrokov sme priamku pretli iba raz. Spolu s pretnutím v $(0,0)$ teda dostaneme vzorec: $2 \\cdot \\lceil d_x/(d_y-d_x) \\rceil$.

Časová aj pamäťová zložitosť tohto riešenia je konštantná, keďže potrebujeme iba pár premenných na výpočet vzorca, teda $O(1)$.

### Technická poznámka

Pri výpočte hodnoty $\\lceil d_x/(d_y-d_x) \\rceil$ potrebujeme vydeliť dve čísla a výsledok zaokrúhliť nahor. Programovacie jazyky ako Python a C++ však pri celočíselnom delení zaokrúhľujú nadol. Preto v kóde vzorového riešenia využívame fakt, že $d_x$ nie je deliteľné číslom $d_y - d_x$, teda $\\lceil d_x/(d_y-d_x) \\rceil = \\lfloor d_x / (d_y - d_x) \\rfloor + 1$.
",1
bb3eb93986665717,ksp,"# O sústredkových pozvánkach

Jarné sústredenie KSP^[Nie až také jarné, keďže bude 4. až 11. marca.] sa pomaly blíži a vedúci začali s prípravami. Prvou, vcelku dôležitou úlohou je pozvať účastníkov. Zobrali sa preto výsledkové listiny oboch kategorií a spojili sa do jednej, čím vznikol dlhý zoznam, podľa ktorého sa bude pozývať na sústredenie. Postupne sa budú oslovovať účastníci od prvého miesta po posledné, až kým prvých 32 účastníkov nepovie, že ide na sústredenie. Je preto jasné, že čím skôr je niekto v tomto zozname, tým má väčšiu šancu, že sa na sústredenie dostane.

To všetko by bolo pekné, vedúci však začali vyjadrovať svoje súkromné preferencie. Napríklad Mišo povedal, že Paulínka musí byť pozvaná skôr ako prvý človek v zozname, aby sa určite dostala na sústredenie. Žaba tiež vyjadril názor, že dievčatá by sa mali uprednostňovať a pozývať protekčne skorej. A Hopko nástojil^[Prostredníctvom svojho spolubývajúceho Vlejda, ktorý je zhodou okolností priateľ Bašky, ktorá účastníkov pozýva na sústredenie.], aby bol jeho brat Slavo pozvaný na sústredenie skôr ako Andrej.

Aby v tom mala Baška prehľad, spísala si $m$ požiadaviek vedúcich. Môže sa stať, že sa jedna požiadavka niekoľkokrát opakuje. Každá požiadavka je tvaru `""x y""` a vyjadruje, že človek, ktorý je v zozname na $x$-tej pozícii má byť na sústredenie pozvaný skôr ako človek na $y$-tej pozícii. Baška sa teraz zamýšľa, v akom poradí má vlastne pozývať účastníkov z pôvodného zoznamu. Určite chce splniť všetky požiadavky, ktoré majú vedúci. Zároveň ale chce pozvať účastníka, ktorý je na prvom mieste čo najskôr. Z možných poradí, ktoré spĺňajú túto podmienku, chce potom vybrať také, kde pozve účastníka na druhom mieste čo najskôr atď...

## Úloha

Máme $n$ účastníkov očíslovaných $1$ až $n$ v poradí, v akom by sa mali pozývať na sústredenie. Ďalej máme $m$ požiadaviek -- dvojíc $x_i$ a $y_i$. Nájdite takú permutáciu čísel $1$ až $n$, že pre všetky $i$ je číslo $x_i$ pred číslom $y_i$. Spomedzi takýchto permutácií vyberte tú, v ktorej je číslo $1$ najskôr ako sa (za splnenia všetkých požiadaviek) dá, číslo $2$ je najskôr ako sa (za splnenia všetkých predošlých podmienok) dá, a tak ďalej až po $n$.

## Formát vstupu

Na prvom riadku sa nachádzajú dve čísla $n$ a $m$ ($1 \\leq n \\leq 200,000$, $1 \\leq m \\leq 400,000$) -- počet účastníkov a počet požiadaviek. Nasleduje $m$ riadkov, každý obsahuje dvojicu čísel $x_i$ a $y_i$ ($1 \\leq x_i, y_i \\leq n$).

Vstupné súbory sú pomerne veľké. Odporúčame preto používať C++ (keďže Python nemusí stíhať ani pri optimálnej časovej zložitosti) a na načítavanie odporúčame použiť knižnicu `cstdio`.

## Formát výstupu

Na jeden riadok vypíšte $n$ medzerami oddelených čísel -- permutáciu spĺňajúcu podmienky zo zadania. Je zaručené, že aspoň jedna takáto permutácia existuje.

## Príklad

```vstup
4 1
3 1
```

```vystup
3 1 2 4
```

_Účastníka 1 nevieme pozvať ako prvého, ale ak najskôr pozveme účastníka 3, tak ho môžeme pozvať už ako druhého. Následne chceme najskôr pozvať účastníka 2 a až potom 4._

```vstup
5 6
3 1
5 1
5 2
1 4
5 4
3 1
```

```vystup
3 5 1 2 4
```
","# O sústredkových pozvánkach

Keďže zadanie je trochu komplikovanejšie, začnime tým, že si ho zopakujeme. Máme čísla 1 až $n$ a $m$ podmienok, ktoré musíme splniť. Každá podmienka nám o nejakom čísle hovorí, že sa vo výslednej permutácii musí objaviť pred ktorýmsi iným číslom. Naviac, nechceme nájsť ľubovoľnú permutáciu, ktorá spĺňa všetky podmienky, ale takú, kde sa číslo 1 nachádza čo najskôr, potom číslo 2 čo najskôr atď. Uvedomme si, že toto nie je to isté ako hľadať lexikograficky najmenšiu takúto permutáciu, lebo permutácia $(3,1,2)$ je síce lexikograficky väčšia ako $(2,3,1)$, ale číslo 1 sa v nej nachádza skôr.

Pri riešení takýchto úloh je dobré si vstup zakresliť, aby sa nám nad ním lepšie rozmýšľalo -- napríklad formou orientovaného grafu. Každé číslo bude mať priradený jeden vrchol a hrana povedie z vrchola $x$ do vrchola $y$, ak má byť $x$ v permutácii pred $y$. Keďže zadanie nám zaručuje, že existuje aspoň jedna vhodná permutácia, v takomto grafe sa nemôžu nachádzať orientované cykly (rozmyslite si prečo by sme ich nevedeli celé splniť) a takýto graf sa preto volá orientovaný acyklický graf, alebo tiež DAG^[Z anglického Directed Acyclic Graph].

Poďme sa teraz pozrieť na to, ako by sme vedeli vytvoriť vhodnú permutáciu, ktorá by spĺňala všetky podmienky. Ktoré číslo sa môže nachádzať na prvom mieste? Každé, ktoré nemá byť predbehnuté iným číslom. Keď sa teda pozrieme na náš graf, zistíme, že sú to tie vrcholy, do ktorých nevedie žiadna hrana -- hrana vedie z vrchola, ktorý má byť skôr, do takého, ktorý má byť neskôr. Ak do vrchola vedie hrana, musíme najskôr do permutácie vložiť prvok na začiatku tejto hrany.

Ak teda vyberieme nejaké číslo a vložíme ho do permutácie, z nášho grafu si môžeme príslušný vrchol odstrániť. A rovnako všetky hrany, ktoré z neho viedli von, lebo tieto hrany už určite budú splnené. Ich začiatok sa v permutácii nachádza skôr ako ich koniec. Na druhom mieste permutácie môže byť opäť ľubovoľný vrchol, do ktorého nevchádza žiadna hrana.

Postupne by sme teda vedeli vytvoriť permutáciu, ktorá spĺňa všetky podmienky. Ako však vyberieme takú, kde bude 1 čo najskôr? Nemôžeme sa rozhodovať podľa veľkosti čísel, lebo nejaké väčšie číslo nám možno odkryje lepšie menšie a vie nastať pomerne veľa komplikovaných prípadov.

Keď to teda nevyšlo pre začiatok, skúsme vytvárať permutáciu od konca. Ktoré čísla môžu byť na poslednej pozícii? No predsa všetky, po ktorých už nemusí ísť žiadne číslo. V grafe sú to teda vrcholy, z ktorých nevychádza žiadna hrana. A opäť, ak si niektorý z nich vyberieme a odstránime ho z grafu, dostaneme graf, z ktorého môžeme vyberať číslo na pozíciu, ktorá je druhá od konca. Robíme v podstate to isté, len opačným smerom. Vieme však teraz zaručiť aj zvyšné požiadavky, teda aby sa 1 nachádzala vo výslednej permutácií čo najskôr?

Čo keby sme vždy z čísel, ktoré máme k dispozícii na poslednú pozíciu vybrali to, ktoré je najväčšie? Znie to ako nápad, ktorý nič nepokazí. Predsalen, umožníme všetkým menším číslam, aby sa nachádzali skôr. A síce je fajn, že nám intuícia napovedá, že tento postup je správny, musíme si ho aj dokázať.

Predstavme si, že máme optimálnu permutáciu, ktorá na posledné miesto umiestnila číslo $x$, ale na posledné miesto môže ísť aj číslo $y$, ktoré je väčšie ako $x$. Čo sa stane, ak z tejto permutácie vyberieme číslo $y$ a dáme ho na koniec, pričom všetky čísla, čo boli pôvodne za ním posunieme o jedno dopredu? Vo výslednej permutácii sa dozadu posunulo iba číslo $y$. Všetky ostatné buď zostali na svojom mieste, alebo sa posunuli dopredu. A hlavne sa dopredu posunulo číslo $x$. A keďže je menšie ako $y$, tak táto permutácia je lepšie ako pôvodná, s ktorou sme začínali. To je ale spor s tým, že tá permutácia mala byť optimálna. Dokázali sme teda, že náš postup je správny.

Otázkou zostáva už len to, ako takéto riešenie naprogramovať. Musíme vedieť odstrániť ľubovoľný vrchol z grafu a tiež všetky hrany, ktoré z neho viedli. Takisto si musíme udržiavať množinu čísel, z ktorých nevedie žiadna hrana a z tejto množiny rýchlo vybrať číslo, ktoré je najväčšie. Na druhú časť použijeme dátovú štruktúru halda, do ktorej vieme vkladať prvok v čase $O(\\log n)$ a vyberať najväčší prvok v čase $O(\\log n)$, kde $n$ je počet prvkov v halde.

Na začiatku načítame vstup a pre každý vrchol vytvoríme zoznam hrán, ktoré doň vchádzajú. Takisto si v poli $P[]$ budeme pamätať, koľko hrán z neho vychádza. Všetky čísla $x$, pre ktoré je $P[x]$ rovné 0 vložíme do haldy, keďže sú to vrcholy, z ktorých nevychádza žiadna hrana. Z haldy vyberieme najväčšie číslo, označme si ho ako $x$. Vrchol $x$ chceme odstrániť z grafu. Preto prejdeme všetky hrany vychádzajúce z tohto vrchola a každému koncovému vrcholu zmenšíme hodnotu v $P[]$, lebo už z neho vychádza o jednu hranu menej. Ak počas týchto úprav klesne niektoré $P[y]$ na nulu, tak $y$ vložíme do haldy. Na konci vypíšeme čísla v obrátenom poradí ako sme ich vyberali z haldy.

Každý vrchol vložíme aj vyberieme z haldy najviac raz. Takisto raz odstránime každú hranu. Preto je výsledná časová zložitosť tohto riešenia $O(n\\log n + m)$. Pamäťová zložitosť je $O(n+m)$.
",8
25bdfeea5062c4bf,ksp,"#Zárobkom do nového roka

""2016? No do ..... bre."" zahundral hračkár Hilbert. Rozlepil oči, utrel si zemiakový šalát tečúci z ucha a dal si rozbehový krémeš na dobré ráno. Sviatky ako majú byť. Treba ale ísť do práce a urobiť koncoročnú uzávierku. Vianoce sú totiž každoročne výdatné na zákazníkov a aj na tržby. Hilbert už presne vie, ako to funguje. Do obchodu príde človek a kúpi prvý darček, ktorý mu je ponúknutý. Človek zaň zaplatí a beží do ďalšieho obchodu. Je prakticky jedno, o aký predmet sa jedná. Dokonca ani nezáleží na cene, pokiaľ nie je príliš vysoká. Všetko závisí od toho, ako málo času ostáva do Vianoc -- čím menej času, tým väčšie výčitky svedomia má konkrétny nešťastník, a tým viac je ochotný za darček zaplatiť.

Hilbertovi sa stačí pozrieť na hodinky a hneď vie, koľko peňazí môže zákazník minúť. No a to sa dá úžasne využiť. Stačí vždy nájsť najdrahší darček, ktorý je daný človek ešte ochotný kúpiť a ponúknuť mu ho. Hilbertovo podnikavé srdce teraz kruto zaplakalo. Tento prešibaný plán počas minulého roka ani raz nepoužil... To sa však s novým rokom zmení!

Hilbert by predsa len rád vedel, ako by bol jeho biznis prekvital, ak by túto metódu použil už predošlé Vianoce. Podarilo sa mu zrekonštruovať zoznam ľudí, ktorí prišli do jeho obchodu, no nie je si úplne istý, koľko mohol na každom z nich zarobiť.

## Úloha

Na vstupe máte **vzostupne usporiadané** ceny darčekov v Hilbertovom obchode. Postupne k nemu prichádzajú ľudia. Každý človek má maximálne množstvo peňazí, ktoré je ochotný minúť na darček. Človek, ktorý príde neskôr bude vždy ochotný minúť **aspoň toľko** ako ten, čo prišiel pred ním. Pre každého človeka vypíšte cenu najdrahšieho darčeka, ktorý si ešte môže dovoliť, a ktorý mu teda Hilbert ponúkne. Po tom, čo si ho zákazník kúpi, ho už Hilbert nemôže ponúkať ďalej.

## Formát vstupu

Na prvom riadku sú dve čísla $n$ a $m$ ($1 \\leq n \\leq 1,000,000$, $1 \\leq m \\leq 1,000,000$) -- počet darčekov, ktoré má Hilbert v obchode a počet zákazníkov, ktorý k nemu prídu.

Na druhom riadku je **vzostupne usporiadaná** postupnosť $n$ kladných celých čísel $c_i$ ($1\\leq c_i \\leq 10^9$) -- ceny darčekov v Hilbertovom obchode.

Na treťom riadku je **vzostupne usporiadaná** postupnosť $m$ kladných celých čísel $p_i$ ($1\\leq p_i \\leq 10^9$) -- množstvo peňazí, ktoré je ochotný minúť $i$-ty zákazník.

V polovici sád navyše platí, že $1 \\leq n \\leq 1,000$ a $1 \\leq m \\leq 1,000$.

## Formát výstupu

Pre každého zákazníka vypíšte cenu najdrahšieho darčeka, ktorý mu môže Hilbert ponúknuť. Ak taký nie je, vypíšte $0$.

## Príklad

```vstup
8 10
1 2 2 2 5 7 10 20
1 1 2 3 6 6 15 21 21 22
```

```vystup
1 0 2 2 5 2 10 20 7 0

```

_Druhému zákazníkovi nevie Hilbert ponúknuť žiadny darček, lebo jediný predmet s cenou nanajvýš 1 si kúpil prvý zákazník. Takisto si všimnite, že aj keď je deviaty zákazník ochotný za darček zaplatiť až cenu 21, Hilbert mu vie ponúknuť iba predmet s cenou 7, lebo zvyšné rozpredal predošlým zákazníkom._
","# Zárobkom do nového roka

Najjednoduchšie, čo môžeme spraviť, je celú situáciu simulovať. Budeme si jednoducho pamätať všetky darčeky, ktoré ešte Hilbert nepredal, a postupne ich predávať. Otázkou je, ako to vieme robiť rýchlo.

## Riešenie hrubou silou

Stačí mať jedno pole (C++ vector), v ktorom si udržiavame ceny ešte nepredaných darčekov. Na ňom potom potrebujeme robiť nasledovné operácie:

1. Nájdenie darčeku s najvyššou cenou neprevyšujúcou nejakú hranicu
1. Predanie (odstránenie) darčeka

Operáciu 1 vieme robiť triviálne v čase $O(n)$. Stačí prejsť všetky darčeky a pamätať si, aký najdrahší sme zatiaľ videli. Odstraňovanie darčeku je za normálnych okolností tiež lineárne, lebo musíme posunúť všetky darčeky za ním. Dá sa ale urobiť finta na skonštantnenie tohoto času. Môžeme totiž najprv vymeniť chcený darček s posledným a potom iba vector o jedna skrátiť. Podobne by sme daný darček mohli len prepísať na $0$. S časovou zložitosťou si ale aj tak veľmi nepomôžeme.

Pre každého človeka, čo príde do obchodu, musíme nájsť darček v $O(n)$ a teda dostaneme riešenie v čase $O(nm)$ s pamäťou $O(n)$, ktoré nám získa $2$ body.

Mohlo by nám napadnúť, že operácia 1 sa by sa mohla dať vyriešiť binárnym vyhľadávaním. Potom by sme ju vedeli robiť v $O(\\log(n))$. Problém ale je, že pre operáciu 2 by sme nevedeli použiť našu fintu (tá totiž nezachováva usporiadanie) a stále by sme ostali na čase $O(nm)$.

## Riešenie hrubou STL^\[Standard library: [http://www.cplusplus.com/reference/stl/](http://www.cplusplus.com/reference/stl/)\] silou

Binárne vyhľadávanie nám síce veľmi nepomohlo, **binárny vyhľadávací strom** nám ale pomôcť môže. Je to štruktúra, ktorá zvláda pridávanie nových prvkov, vymazávanie a vyhľadávanie prvkov a to všetko v čase $O(\\log(n))$. Takáto funkcionalita je už implementovaná v štandardnej C++kovej knižnici pod krycím názvom **multiset**. Stačí túto čarovnú štruktúru inicializovať, naplniť ju darčekmi, a potom v nej len vyhľadávať pomocou metódy **lower_bound** a vymazávať pomocou **erase**. Nakoľko pridávanie je logaritmické, vieme ju naplniť v čase $O(n\\log(n))$ a pre každého človeka vyhľadávať a mazať tiež v $O(\\log(n))$. Dostaneme teda riešenie v čase $O(n\\log(n) + m\\log(n))$. Vďaka tomu, že sú darčeky na vstupe usporiadané, je vkladanie možné aj v konštantnom čase a teda výsledná časová zložitosť by bola len $O(n + m\\log(n))$, čo ale nie je podstatné zlepšenie. Pamäťovú zložitosť máme stále $O(n)$. Toto riešenie je dostatočne rýchle pre všetky testovacie sady, no plný počet za popis neprinesie.

## Optimálne riešenie

Zatiaľ sme takmer vôbec nevyužili usporiadanie darčekov a ľudí na vstupe. To by nám mohlo napovedať, že ešte nemáme optimálne riešenie. Predstavme si nasledujúcu situáciu: do obchodu príde Ferko a kúpi nejaký darček. Keď po ňom príde Jožko, aký darček kúpi? Jožko je určite aspoň tak bohatý ako Ferko. Buď si kúpi niečo, čo mohol kúpiť aj Ferko, alebo kúpi niečo, čo si Ferko nemohol dovoliť. Inak povedané, keď prišiel do obchodu Ferko, mal množinu darčekov, ktoré si mohol dovoliť. Z nej si vybral ten najdrahší. Keď potom prišiel Jožko, tiež mal množinu darčekov, ktoré si mohol dovoliť. V nej boli **všetky** tie darčeky, čo si mohol dovoliť Ferko (okrem toho, ktorý si Ferko kúpil) a všetky, ktoré si Ferko kúpiť nemohol, no Jožko už áno.

To znamená, že nám stačí udržiavať množinu kúpiteľných a množinu nekúpiteľných darčekov. Keď príde nový človek, presunieme z nekúpiteľných do kúpiteľných všetky darčeky, ktoré si daný človek už môže dovoliť. Teda niekoľko najlacnejších nekúpiteľných darčekov prehlásime za kúpiteľné. Potom zistíme, či je množina kúpiteľných darčekov prázdna a ak nie je, predáme z nej najdrahší darček. Na začiatku sú všetky darčeky nekúpiteľné a vieme, že na vstupe sú **vzostupne** usporiadané. Vďaka tomu si môžeme nekúpiteľné darčeky pamätať vo fronte^[Jednoduchá dátová štruktúra -- zoznam, do ktorého na jednom konci vkladáme prvky a na druhej strane ich vyberáme.], do ktorej ich najprv dáme. Kúpiteľné si potom môžeme pamätať v zásobníku^[Zoznam, do ktorého vkladáme a z ktorého vyberáme na rovnakom konci]. Potom, keď budeme presúvať nejaký darček D z nekúpiteľných do kúpiteľných, tak vieme, že D bol najlacnejší z nekúpiteľných a bude najdrahší z kúpiteľných.

Nakoľko každé presunutie robíme v konštantnom čase a každý darček presunieme maximálne raz, dostávame riešenie s časovou zložitosťou $O(m+n)$ a potrebnou pamäťou $O(n)$.

Všetky spomenuté dátové štruktúry sa dajú pekne implementovať pomocou poľa.

Prípadne vieme použiť aj knižničné funkcie a štruktúry ako queue (fronta) a stack (zásobník).
",4
9d3170ab7657430d,ksp,"# Správne poradie

Život súťažného bojovníka v Ríme je náročná záležitosť. Okrem všetkých zjavných výziev, s ktorými sa každodenne stretávajú je tu aj hlboký a fundamentálny problém, kvôli ktorému to mnohí bojoví géniovia vzdávajú hneď na začiatku. Týmto problémom je príprava tesne pred súbojom.

Asi si to viete predstaviť. *Musím si nasadiť zbroj. Musím si upevniť koženú čiapku. Musím sa obuť. Musím si nasadiť holenné chrániče... Ajajáj, veď som už obutý! Musím sa vyzuť a nasadiť si holenné chrániče. Ej bisťu, zabudol som na správne bojové pomaľovanie!* A všetko odznova.

Uznajte, že takýmto tempom by aj vás akurát tak porazilo. Aby Rím neprichádzal o talenty, všetky významnejšie arény začali zamestnávať prípravných špecialistov. Ich úlohou je pre každého bojovníka usporiadať jeho prípravné akcie tak, aby vzájomne nekolidovali.

## Úloha

V bojovníckom svete existuje $n$ rôznych možných prípravných akcií. Každý bojovník pri príprave na boj potrebuje vykonať niektoré z nich (nie nutne všetky). Pre niektoré dvojice akcií $A$ a $B$ platí, že keď niekedy vykonáme $A$, už nikdy nebudeme vedieť vykonať $B$ (napríklad, ak si oblečieme krúžkovú košeľu, už si nemôžeme obliecť tielko, alebo ak si nasadíme chrániče predlaktí, už si nemôžeme obliecť krúžkovú košeľu). Našťastie existuje poradie, v ktorom sa dajú vykonať **všetky** akcie.

Dostanete zoznam spomenutých závislostí medzi akciami. Ďalej dostanete $q$ bojovníkov, každý z nich bude chcieť vykonať nejaký zoznam akcií. Vašou úlohou bude usporiadať akcie pre každého bojovníka.

## Formát vstupu

Na prvom riadku dostanete čísla $n$, $m$ a $q$ ($1 \\leq n, m, q \\leq 100,000$) -- počet rôznych možných akcií, počet závislostí medzi nimi a počet bojovníkov. Akcie sú očíslované od $1$ po $n$.

Nasleduje $m$ riadkov, v každom z nich dostanete dve rôzne čísla $A_i$ a $B_i$ ($1 \\leq A_i, B_i \\leq n$), ktoré označujú, že keď vykonáme akciu $A_i$, už nebudeme vedieť vykonať akciu $B_i$.

Nakoniec nasleduje $q$ riadkov, $i$-ty z nich začína celým číslom $q_i$ ($1 \\leq q_i \\leq n$) -- počtom akcií $i$-teho bojovníka. Za týmto číslom nasleduje $q_i$ ďalších čísel z rozsahu $1$ až $n$ -- čísla akcií $i$-teho bojovníka.

Počet všetkých akcií, ktoré chcú bojovníci vykonať (súčet všetkých $q_i$), neprekročí $100,000$. Môžete predpokladať, že prípravné kroky každého bojovníka sa dajú usporiadať tak, aby nebola porušená žiadna závislosť.

## Formát výstupu

Vypíšte $q$ riadkov, v $i$-tom z nich $q_i$ čísel -- zoznam krokov $i$-teho bojovníka v poradí, v akom ich má vykonať. Ak existuje viacero možných poradí, vypíšte ľubovoľné z nich.

## Príklad

```vstup
5 5 3
4 3
2 4
3 1
2 1
5 4
4 1 4 3 2
2 1 4
1 5
```

```vystup
1 3 4 2
4 1
5
```

_Prvý bojovník má iba jedno vhodné poradie akcií. Druhý bojovník by mohol akcie vykonať aj v opačnom poradí._
","# Správne poradie

Táto úloha pozostáva z dvoch podproblémov:

- Ako vieme k nejakému zoznamu akcií zistiť poradie, v ktorom ich vieme vykonať

- Ako vieme rýchlo spracovať podmnožiny, v ktorých sa môžu prvky opakovať

Najprv rozoberieme riešenie prvého podproblému a potom to celé poskladáme dohromady. Pre ľahší popis časovej zložitosti budeme celkový počet akcií (súčet $q_i$ zo vstupu) označovať ako $s$.

## Topologické usporiadanie

Prvý problém bol mierne zamaskovaný problém topologického usporiadania. Najprv si uvedomíme, že podmienka ,,po vykonaní $A$ nemôžeš vykonať $B$'' je rovnaká, ako podmienka ,,ak chceš vykonať $A$ aj $B$, musíš najprv vykonať $B$ a až potom $A$''.

Akcie usporiadame nasledovne: Najprv si pre každú akciu spočítame, koľko iných akcií musíme vykonať *pred* ňou, toto číslo budeme dalej volať *počet závislostí*. Niektoré akcie budú mať nula závislostí; ktorúkoľvek z nich vieme vykonať. Keď ju vykonáme, všetkým akciám, ktoré na nej záviseli, znížime počítadlo o jedna. Tým môže niektorým akciám klesnúť počet závislostí tiež na nulu.

Aby sme nemuseli pred vykonávaním každej akcie prejsť cez všetky a hľadať nejakú, ktorú môžeme vykonať, inšpirujeme sa prehľadávaním grafu [do šírky](https://www.ksp.sk/kucharka/bfs/). Na začiatku všetky akcie s nula závislosťami hodíme do fronty na spracovanie. S každým znížením počtu závislostí nejakej akcii skontrolujeme, či tento počet neklesol na nulu. Ak klesol, akciu pridáme do fronty.

Vo všeobecnosti by sa mohlo stať, že v niektorom momente nevieme vykonať žiadnu akciu, lebo všetky majú nejakú nevykonanú závislosť. V zadaní je však garantované, že všetky akcie sa dajú vykonať v nejakom poradí a teda takáto situácia nemôže nastať.

Pokiaľ potrebujeme usporiadať $n$ akcií s $m$ závislosťami, celé nám to bude trvať čas $O(n+m)$, lebo každú závislosť práve raz započítame a raz odpočítame, a každú akciu raz pridáme do fronty a raz spracujeme.

## Viacero bojovníkov

Keď vieme robiť topologické usporiadanie, môžeme rovno spraviť riešenie polohrubou silou. Pre každého bojovníka vezmeme jeho zoznam akcií, vyberieme relevantné závislosti a topologicky ich usporiadame. Dostaneme tým riešenie s časovou zložitosťou $O((n+m) \\cdot q)$.

Lepšie riešenie však dostaneme, keď využijeme nasledujúce pozorovanie: Ak vieme vykonať všetky akcie v nejakom poradí, v tom istom poradí môžeme vykonať akcie každého bojovníka (s tým, že niektoré jednoducho vynecháme).

Na začiatku teda zistíme poradie, v ktorom sa dajú vykonať všetky akcie. Pre každého bojovníka usporiadame jeho zoznam akcií svojim obľúbeným ([rýchlym](https://www.ksp.sk/kucharka/mergesort/)) [triediacim algoritmom](https://www.ksp.sk/kucharka/triedenie/). Keď nasčítame členy v tvare $q_i \\cdot \\log(q_i)$, dostaneme časovú zložitosť $O(s \\log(s) + n + m)$.

## Optimálne riešenie

Predošlé riešenie stačilo na to, aby sme získali všetky body od testovača. Existuje však komplikovanejšie riešenie, ktoré bude mať lepšiu časovú zložitosť. Využijeme fakt, že bojovníci sa pýtajú stále na ,,tie isté'' akcie.

Najprv nájdeme topologické usporiadanie všetkých akcií v čase $O(n+m)$. Ďalej načítame akcie všetkých bojovníkov, ale uložíme si ich ,,čudne'': Pre každú z $n$ akcií si budeme pamätať zoznam bojovníkov, ktorí ju chceli vykonať (v čase $O(s + n)$).

Nakoniec budeme vytvárať pre každého bojovníka jeho usporiadaný zoznam akcií, na začiatku prázdny zoznam. Spracujeme všetky akcie v ich topologickom usporiadaní. Keď spracúvame akciu $X$, pre všetkých bojovníkov, ktorí ju chcú vykonať, ju pridáme na koniec ich aktuálnych zoznamov. Táto časť programu sa bude vykonávať v čase $O(n + s)$.

Nakoniec vypíšeme všetky skonštruované zoznamy pre bojovníkov. Celková časová zložitosť bude $O(n + m + s)$.
",6
eb131ebfea45acb5,ksp,"# Obedové menu: ryža

V Číne majú veľa malých chlapcov a dievčat. Chlapcov trochu viac. A ešte viac ryže.

V poslednom čase je ale v ich škôlkach stále viac a viac plačúcich a nešťastných detí. Začali sa totiž učiť matematiku. Konkrétne, zatiaľ sa naučili počítať do veľkých čísel a tiež násobiť a deliť dvomi.

Mohli by ste si myslieť, že majú množstvo domácich úloh, alebo že ich matematika nebaví. Opak je však pravdou. Akonáhle získali túto novú superschopnosť, využívajú ju každý deň. Hlavne pri obede. Skôr než sa pustia do jedenia, každý si spočíta svoje zrnká ryže.^[Vďaka tejto zábavke tiež obedujú niekoľko hodín, a tak nemusia ísť poobede spať.]

Keď má každý spočítanú svoju ryžu, začne sa druhá fáza obeda. Porovnávanie. Ak niekto zistí, že má dvakrát viac zrniek ako spoluškôlkar, má právo povyšovať sa a vysmievať sa mu. Potom nasleduje plač, alebo si ublížený chlapec či dievča nájde niekoho, kto má ešte dvakrát menej ryže. Deti niekedy bývajú kruté.

Pani vychovávateľky sú bezradné. Toľko plaču a kreatívnych nadávok, koľko počuli za posledné obdobie ešte nikdy nezažili. Proces výučby sa samozrejme rýchlo zastavil, no nedá sa deti odnaučiť od toho, čo už vedia.

Preto by, ako náhradné riešenie, chceli niektorým deťom zobrať ryžu a dať im tofu. Ryžu treba zobrať deťom tak, aby nemali žiadni dvaja škôlkari $x$ a $2x$ zrniek ryže. Pani vychovávateľky si uvedomujú, že tofu nemá nikto rád^[A všetku tú ryžu musí tiež niekto zjesť.], a preto by ho chceli dať **čo najmenej** deťom. Tiež by ich zaujímalo, koľkými spôsobmi sa dá deťom zobrať najmenší počet ryžových tanierov a rozdať tofu.

## Úloha

Na obed je pripravených $n$ porcií ryže. O každej porcii sa dozviete jedno číslo -- počet zrniek ryže. Tieto čísla sú na vstupe usporiadané vzostupne. Niektoré porcie potrebujete odobrať tak, aby nikto nedostal dvakrát viac ryže ako hocikto iný. Inak povedané, aby nezostali žiadne dve porcie, ktoré majú $x$ a $2x$ zrniek. Snažíte sa odobrať čo najmenej porcií.

Zistite tiež, koľkými spôsobmi sa dajú porcie odobrať tak, aby boli splnené predošlé požiadavky. Dva spôsoby sú rôzne ak existuje aspoň jedna porcia, ktorú sme v jednom spôsobe nechali a v druhom nie. Keďže týchto spôsobov môže byť veľmi veľa, vypíšte len zvyšok po delení prvočíslom $1,000,000,009$.

## Formát vstupu

Na prvom riadku vstupu je kladné celé číslo $n$ neprevyšujúce $1,000,000$ udávajúce počet porcií. Na ďalšom riadku nasleduje $n$ čísel $r_i$ oddelených medzerami, pričom pre každé z nich platí $0 < r_i < 10^{18}$. Čísla $r_i$ sú zoradené od najmenšieho po najväčšie.

## Formát výstupu

Vypíšte dve celé čísla oddelené medzerou: najväčší možný počet porcií, ktoré zostanú po odobratí potrebných tanierov a počet spôsobov ich výberov premodulovaný $1,000,000,009$. Výstup ukončite znakom nového riadku.

## Príklad

```vstup
8
1 2 2 3 4 5 5 6
```

```vystup
5 4
```

_Žiadne povyšovanie a čo najmenej tofu dosiahneme ak necháme deťom tieto porcie: 1 3 4 5 5, 1 4 5 5 6, 2 2 3 5 5, 2 2 5 5 6_
","# Obedové menu: ryža

Najprv si povieme, prečo je výhodné rozdeliť čísla zo vstupu na reťaze. Ďalej sa dozviete, ako spočítať celkový výsledok z čiastkových výsledkov pre reťaze a potom ukážeme rôzne spôsoby ako rozdeliť vstup na reťaze a ako vypočítať najlepší výber prvkov a počet týchto výberov pre jednu reťaz.

## Stačí sa pozerať na $60$ čísel z $1,000,000$

Podľa zadania je potrebné z $n$ čísel odstrániť čo najmenej tak, aby nezostali žiadne $2$ čísla $x, 2x$. Prvé pozorovanie, ktoré urobíme je, že každé číslo $x$ sa vylučuje s najviac dvoma inými číslami: $\\frac{x}{2}, 2x$. Ďalej sa $2x$ vylučuje s $x$ a $4x$, $4x$ s $2x$ a $8x$ atď.

$x,2x,4x,...,2^{k}x$ sa navzájom ovplyvňujú. Ostatné čísla, ku ktorým sa nevieme dostať z $x$ násobením a delením dvomi, môžeme pri riešení $2^{k}$-násobkov $x$ úplne ignorovať.

- Každé prirodzené číslo vieme jednoznačne zapísať ako $x = 2^{u} \\cdot z$, kde $z$ je nepárne číslo, ktoré z čísla $x$ získame tak, že ho delíme $2$ kým sa dá, teda $u$-krát. Pokiaľ majú dve čísla rôzne $z$, určite sa nebudú ovplyvňovať.

- Ak máme vo vstupe čísla $x, 2x, 8x$ ale nie $4x$, zjavne ani $8x$ nebude nijak závisieť od toho, či $x, 2x$ odstránime alebo necháme.

Vstup sa nám teda oplatí porozdeľovať na **reťaze** čísel, ktoré spolu súvisia. Podľa predošlých dvoch argumentov budú dve čísla v jednej reťazi, ak vieme **jedno z nich prerobiť na druhé opakovaným násobením $2$ a každý medzivýsledok je vo vstupnej postupnosti**.

Keďže čísla na vstupe sú najviac $10^{18} \\approx 2^{60}$, reťaze budú mať dĺžku najviac 60 a budú navzájom nezávislé. Ak teda zistíme najlepší výber čísel a počet týchto výberov pre každú reťaz zvlášť, budeme vedieť vypočítať aj celkové výsledky.

## Ako spočítať celkové výsledky z čiastkových

Vstup sme si porozdeľovali na reťaze a predpokladajme, že vieme pre každú reťaz zistiť, aký najväčší **počet čísel** v nej môže zostať^[Ako to spočítať si ukážeme neskôr.] -- označíme $C(retaz)$. **Počet rôznych možností** ako poodstraňovať čísla z jednej reťaze si označíme ako $M(retaz)$.

Keďže každé číslo sa nachádza v práve jednej reťazi, najväčší počet čísel, ktoré vieme zachovať spočítame jednoducho ako súčet $C(r)$ pre každú reťaz.

Keďže reťaze sa nijak neovplyvňujú, pre každú z nich môžeme zvoliť ľubovoľný spôsob výberu čísel, a vďaka tomu bude celkový výsledok súčin $M(r)$ pre všetky reťaze.

## Ako porozdeľovať čísla do reťazí

Po rozdelení čísel do reťazí už nebude záležať na hodnote čísel, iba na ich poradí v reťazi a na počtoch rovnakých čísel. Reťaz $3,3,3,6,6,12,24,48,48$ si preto zapamätáme len ako postupnosť počtov čísel s rovnakými mocninami dvojky (podľa hodnoty $u$ v zápise $x = 2^{u} \\cdot z$), t.j. ako $3,2,1,1,2$.

Na vytvorenie reťaze potrebujeme rýchlo zisťovať, **či je vo vstupnej postupnosti číslo $x$, ak áno, koľkokrát**. Pri tvorení reťaze si vyberieme začiatočné číslo a pridáveme dvojnásobky. Ak sú také čísla vo vstupnej postupnosti, pridáme ich do reťaze, ak nie sú, ukončíme reťaz a pokračujeme s ďalšou.

## Rozdeľovanie do reťazí -- Binárne vyhľadávanie

Vstup je utriedená postupnosť a preto v nej vieme binárne vyhľadávať. Ak chceme zisiť koľkokrát sa nachádza $x$ v postupnosti, stačí binárne vyhľadať najmenšiu pozíciu čísla $x$ a pozíciu najmenšieho väčšieho čísla. V C++ presne tieto úlohy plnia funkcie \\texttt{lower_bound, upper_bound}. Pokiaľ sa číslo $x$ nachádza v poli, počet jeho výskytov je jednoducho \\texttt{upper_bound(x) - lower_bound(x)}.^[Tieto funkcie v C++ vracajú iterátory, ktoré sú adresami prvkov, nie indexami do poľa. Pokiaľ chceme zistiť index x, potrebujeme od iterátora odpočítať adresu začiatku poľa.] V najhoršom prípade -- ak sú všetky čísla vstupu rôzne -- musíme každé z nich binárne vyhľadať, teda časová zložitosť takéhoto delenia na reťaze bude $O(n \\log n)$.

## Rozdeľovanie do reťazí -- Fronta / dvaja bežci

Vďaka utriedenému vstupu sa čísla dajú rozdeliť do reťazí aj v lineárnom čase.

Predstavme si, že čísla načítavame postupne tak, ako sú na vstupe a vkladáme ich do fronty -- queue. Načítali sme číslo $x$ a pozrieme sa, čo s ním môžeme urobiť:

- ak je $x$ rovnaké ako predošlé číslo, vložíme ho do rovnakej reťaze
- ak je vo fronte číslo $\\frac{x}{2}$ vložíme $x$ na koniec reťaze, v ktorej je $\\frac{x}{2}$
- ak vo fronte nie je $\\frac{x}{2}$ vytvoríme novú reťaz so začiatkom $x$

Vieme rýchlo odpovedať na otázku, či je vo fronte $\\frac{x}{2}$? Z fronty vieme vyberať prvky iba zo začiatku, teda z nej budeme musieť vyhadzovať všetky prvky menšie ako $\\frac{x}{2}$. Nakoniec buď nájdeme $\\frac{x}{2}$, alebo najmenšie väčšie číslo. Dôležité je uvedomiť si, že týmto spôsobom nikdy nevyhodíme čísla, ktoré budeme v budúcnosti hľadať. Zjavne polovice väčších čísel ako $x$ sú tiež väčšie ako $\\frac{x}{2}$, teda zostanú vo fronte.

Každé číslo zo vstupnej postupnosti najviac raz vložíme do fronty a najviac raz vyberieme, a tak spravíme len $O(n)$ operácií. Ak máme čísla načítané v poli, frontu môžeme simulovať pomocou dvoch ukazovateľov (bežcov), ktorí budú ukazovať na začiatok a koniec fronty.

## Rozdeľovanie do reťazí -- Hashovacia tabuľka

Pole veľkosti $10^{18}$ by zaberalo niekoľko miliónov terabajtov, ale ak by boli čísla na vstupe malé ($\\approx$ menšie ako $10,000,000$), na riešenie by nám stačilo pole malej veľkosti (napr. 10 miliónov prvkov pre čísla menšie ako 10 miliónov). Políčku $pole[x]$ by sme pripočítali $1$ za každý výskyt $x$ vo vstupe a na požadovanú otázku -- koľko $x$-ov je na vstupe by sme vedeli odpovedať v konštantnom čase. Reťaze by sme tak vedeli vytvoriť v čase $O(n)$.

Pre veľké čísla si presne takéto údaje môžeme ukladať a odpovedať na otáky v konštantnom čase pomocou hash mapy, ktorá si ,,premenuje'' prvky -- zahashuje -- aby sa zmestili do poľa, do ktorého potom indexuje. V C++11 ju nájdete pod názvom \\texttt{unordered_map}. Jej réžia si však vyžaduje konštantne viac času a pamäte oproti riešeniu s frontou/2 bežcami.

## Výpočet pre jednu reťaz

V tejto časti popíšeme ako pre jednu reťaz spočítať najväčší možný počet zachovaných prvkov a počet výberov ktorými sa to dá dosiahnuť. Budeme sa sústrediť už len na nasledovnú úlohu:

Máme postupnosť čísel -- počty prvkov v reťazi. Chceme vybrať niekoľko čísel tak, aby sme nevybrali žiadne dve vedľa seba a aby počet vybratých bol čo najväčší. Chceme zistiť aj počet rôznych výberov.

## Výpočet pre jednu reťaz -- Neopakujúce sa čísla

3 body sa dali získať aj za vyriešenie jednoduchšej úlohy -- pre neopakujúce sa čísla na vstupe. V takejto verzii úlohy nám stačí poznať len dĺžky jednotlivých reťazí -- v reprezentácii, ako bola spomenutá na začiatku časti o rozdeľovaní čísel do reťazí, by sme mali reťaze uložené ako postupnosti samých jednotiek.

Výber čísel z reťaze budeme značiť ako postupnosť $0/1$, kde $0$ bude znamenať, že sme číslo odstránili a $1$, že sme ho zachovali.

- Pokiaľ je dĺžka reťaze nepárna existuje len jedna možnosť ako dosiahnuť najvačší počet zachovaných čísel a zachová sa ich $\\lfloor \\frac{l}{2} \\rfloor + 1$, kde $l$ je dĺžka reťaze a $\\lfloor x \\rfloor$ je dolná celá časť x. Výber čísel bude vyzerať nasledovne: $1010\\dots0101$.

- Ak je dĺžka párna, najväčší počet zachovaných je $\\lfloor \\frac{l}{2} \\rfloor$. Koľko je ale rôznych možností výberov? Pre $l=4$ to môže byť $0101$, $1010$, ale aj $1001$. Pre ľubovoľnú párnu dĺžku sú 2 možnosti výberov, kedy sú na krajoch $0/1, 1/0$. Ak sú však na oboch krajoch jednotky, vnútri postupnosti sme museli odstrániť 2 čísla vedľa seba. Takýchto potenciálnych miest je vo vnútri reťaze $\\lfloor \\frac{l}{2} \\rfloor - 1$, teda počet možností výberov je celkovo pre párne dlhú reťaz $\\lfloor \\frac{l}{2} \\rfloor + 1$.

## Výpočet pre jednu reťaz -- Hrubá sila

Ak by boli všetky reťaze krátke, môžeme dovoliť použiť hrubú silu. Skonštruovali by sme všetky výbery, ako niektoré čísla vynechať -- všetky podmnožiny reťaze. V každom takomto výbere by stačilo skontrolovať, či sme v ňom nenechali 2 nasledujúce čísla. Počet rôznych výberov by sme jednoducho zväčšovali o $1$ za každý výber s najlepším výsledkom.

Ako prakticky prezerať všetky možné výbery? Ak si opäť označíme výber prvkov ako reťazec núl a jednotiek, potrebujeme skontrolovať všetky výbery medzi $00\\dots00$ a $11\\dots11$. Tieto binárne reťazce ale môžeme považovať aj za čísla od $0$ po $2^l-1$. Stačí nám teda v cykle prejsť cez tieto čísla a pre každé číslo -- výber, skontrolovať či v ňom nie sú 2 jednotky za sebou a spočítať súčet čísel, čo zostanú v reťazi.

Ak by sme ohraničili dĺžku reťazí číslom $l$, časová zložitosť takéhoto riešenia by sa dala odhadnúť ako $O(n \\cdot 2^l)$. Za takéto riešenie ste mohli získať až 6 bodov z praktickej časti.

## Výpočet pre jednu reťaz -- Dynamické programovanie

Na záver si ukážeme, ako spočítať všetko, čo chceme, optimálne -- teda v lineárnom čase.

Skúsme **výber prvkov z reťaze postupne konštruovať zľava doprava**. Na začiatku nech je výber prázdny a postupne do neho budeme pridávať niektoré čísla z reťaze. Pri každom čísle budeme mať na výber dve možnosti: ,,pridať, či nepridať?''

Začnime prvým prvkom zľava. Ak ho nepridáme, je zjavne len jeden výber s najlepším súčtom -- nulovým. Ak ho pridáme, najlepší možný súčet je prvé číslo z reťaze a počet výberov je $1$.

Poďme pridať ďalšie číslo z reťaze. Ak sme pridali predošlé číslo, druhé číslo pridať nemôžeme. Ak sme predošlé číslo nepridali, môžeme sa rozhodnúť či pridáme alebo nepridáme ďalšie.

Všimnite si, že akonáhle sa rozhodneme jedno číslo nepridať do výberu, zvyšok výberu bude úplne nezávislý od všetkého naľavo. Nemusíme teda výbery konštruovať, stačí nám zapamätať si, aký je doterajší najlepší súčet a koľkými rôznymi spôsobmi sa dá dosiahnuť.

Na základe týchto úvah nájdeme najväčší súčet a počet rôznych výberov postupne pre prvých $1,2,\\dots,i$ prvkov reťaze.

Označme si ako \\texttt{S[i][0]} **najväčší súčet**, ktorý môžeme dosiahnuť výberom z prvých $i$ prvkov, ak prvok $i$ nepridáme. \\texttt{S[i][1]} bude označovať maximálny možný súčet z prvkov $0,1,\\dots,i$ ak $i$-te číslo pridáme.

Podobne označíme **počet rôznych výberov** z prvkov $0,1,\\dots,i$ s najlepším súčtom ako \\texttt{V[i][0]} a \\texttt{V[i][1]} opäť podľa toho, či sme $i$-te číslo pridali.

Celkový výsledok pre reťaz zistíme ako najväčší súčet čísel z výberu všetkých prvkov, teda\
\\texttt{max(S[dĺžka reťaze - 1][0], S[dĺžka reťaze - 1][1])} a počet výberov, pri ktorých dosiahneme tento súčet, sa dozvieme z príslušného \\texttt{V[dĺžka reťaze - 1][0], V[dĺžka reťaze - 1][1]}.

**Najlepšie súčty** pre prvých $i$ prvkov vieme určiť z informácií pre prvých $i-1$ prvkov takto:

- Ak chceme pridať prvok $i$, $(i-1)$-vý sme pridať nemohli. Preto \\texttt{S[i][1] = S[i-1][0] + retaz[i]}.
- Ak prvok $i$ nepridávame, pre výber prvých $i$ prvkov sa môžeme rozhodnúť či v ňom bude $(i-1)$-vé číslo z reťaze alebo nie. Vtedy \\texttt{S[i][0] = max(S[i-1][0], S[i-1][1])}.

**Počet výberov** prvých $i$ prvkov s najlepším súčtom vieme tiež zistiť len z informácií pre prvých $i-1$ prvkov:

- Keď pridávame prvok $i$, počet možností výberu zostane rovnaký ako počet výberov prvých $i-1$ prvkov, keď $(i-1)$-vý v tomto výbere nebude, teda \\texttt{V[i][1] = V[i-1][0]}.
- Ak $i$ do výberu prvých $i$ prvkov nepridáme, môžeme sa rozhodnúť, či je lepší výber prvých $i-1$ prvkov s alebo bez $(i-1)$-vého prvku.
  - Ak je jeden výber lepší, počet možností výberov \\texttt{V[i][0]} bude rovnaký ako \\texttt{V[i-1][ten lepší]}.
  - Ak sú najlepšie výbery s a bez $i-1$ rovnocenné, teda ak vieme dosiahnuť rovnaký najlepší súčet bez aj s $(i-1)$-vým prvkom, môžeme použiť všetky tieto výbery a tak výsledný počet rôznych výberov je súčtom počtov výberov \\texttt{V[i][0] = V[i-1][0] + V[i-1][1]}.

Pre každý prvok reťaze vypočítame štyri čísla \\texttt{S[i][0], S[i][1], V[i][0], V[i][1]}. Každý takýto výpočet je nanajvýš súčtom alebo maximom dvoch čísel, teda sa stíha v konštantnom čase a teda každú reťaz vieme spracovať v čase lineárnom v závislosti od jej dĺžky, teda $O(l)$. Spracovanie všetkých reťazí dokopy nám potrvá $O(n)$, lebo každé políčko tabuľky \\texttt{S, V} zodpovedá aspoň jednému číslu zo vstupu.

Keďže vo výpočte $i$-teho políčka používame len údaje z $(i-1)$-vého, mierne množstvo pamäte sa dá ušetriť tak, že si nepamätáme celé pole ale len tieto posledné údaje o $(i-1)$ prvých prvkoch.

## Záver

Rozdelenie vstupu na reťaze sa dá robiť nezávisle od počítania údajov pre jednu reťaz a tak ste si mohli zvoliť rôzne kombinácie algoritmov. Celkovo sa dala úloha vyriešiť spojením prístupu s frontou s dynamickým programovaním v $O(n)$. Toto je zjavne aj najlepšia asymptotická zložitosť, ktorá sa dá dosiahnuť, keďže už len načítanie vstupu nám potrvá lineárne dlho.
",8
2ef468b17e3a77b6,ksp,"﻿# Láska kvitne v júni

Záhradník rád záhradníčil, pestoval ovocie a zeleninu a užíval si pokojný život. Táto idylka však skončila, keď jedného dňa na Záhradníkovu hlavu vyskočil Krtko a začal Záhradníka ovládať. Záhradník sa už viac nestaral o baklažány, kaleráby, jablká, ananásy či petržleny a namiesto toho kopal krtince a organizoval sústredenia. A hoci už nemal viac v živote pokoja, aspoň robil radosť mnohým deťom, ktoré sa na sústredenia veľmi tešili.

Ani táto radosť však netrvala dlho, lebo Záhradníkove schopnosti sa rozhodla využiť aj hlavná kubrická ploštica. Tej bolo smutno, že ploštice kvôli svojej zlej reputácii medzi ľuďmi klesajú na počtoch a rozhodla sa proti tomuto trendu bojovať a pre ostatné ploštice zorganizovať speed dating. Vyskočila na hlavu Krtkovi, ktorý sedel na hlave Záhradníkovi a začala ho ovládať, aby jej speed dating pripravil.

Speed dating ploštíc prebieha následovne. Máme $n$ ploštíc a každá dvojica z nich pôjde na rande na večeru. Večerať budú účastníkov sústredenia a každá ploštica si na svojho účastníka počká v jednej z dvoch postelí na izbe. No každá ploštica má rada iný typ posteľných obliečok a chce byť iba v posteli s tými obliečkami. Tie bude Záhradník ovládaný Krtkom ovladaný kubrickou plošticou medzi jednotlivými rande v prípade potreby prezliekať. Toto sťažuje fakt, že postele v izbe sú rôzne veľké, čo plošticiam síce neprekáža, no znamená to, že treba kúpiť iný rozmer obliečky na jednu posteľ, a iný na druhú.

Kubrická ploštica potrebuje nakázať Krtkovi, nech nakáže Záhradníkovi koľko kusov obliečok treba nakúpiť, nech každá dvojica z jej $n$ ploštíc môže spolu ísť na rande.

## Úloha

Pre daný počet ploštíc a ich preferencie zistite minimálny počet obliečok, ktoré treba nakúpiť na sústredenie, aby každá dvojica ploštíc mohla ísť spolu na rande, každá do inej postele s jej obľúbeným typom obliečok. Ak na speed dating príde iba jedna ploštica, pôjde sa navečerať osamote (a spoznať sa sama so sebou).

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $k$ ($1 \\leq n,k \\leq 2 \\cdot 10^5$) udávajúce počet ploštíc a počet rôznych typov obliečok.

V druhom riadku následuje $n$ čísel, $p_1, p_2, \\cdots, p_n$ kde $p_i$ je preferovaný typ obliečok $i$-tej ploštice.

Sú dve sady. Pre prvú sadu platí, že $p_i$ sa rovná $i$.

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo - počet kusov obliečok, ktoré treba nakúpiť.

## Príklady

```vstup
5 5
1 2 3 4 5
```

```vystup
8
```

*Aj keď každú obliečku chce iba jedna ploštica, aj tak musíme z niektorých typov kúpiť dva kusy. Keby sme napríklad kúpili obliečku typu 4 a 5 len v rozmeroch prvej postele, keď pôjdu ploštice 4 a 5 na rande, nebudeme vedieť obliecť druhú posteľ tak, aby ju niektorá z nich chcela. Rozmyslite si, ktoré obliečky stačí kúpiť pre obe postele, aby nám ich stačilo dokopy 8 kusov.*

```vstup
6 4
1 2 3 2 3 2
```

```vystup
5
```

*Záhradník potrebuje kúpiť obliečky typu 2 a 3 pre obe postele, a obliečku typu 1 len pre jeden rozmer. Bez ohľadu na to, ktoré dve ploštice pôjdu na rande, budeme každej vedieť obliecť posteľ do jej obľúbenej obliečky.*
","# Láska kvitne v júni

Zádrhel tejto úlohy spočíva v tom, že dve postele na izbe potrebujú obliečky rôznych veľkostí. To znamená, že v niektorých prípadoch budeme musieť kúpiť dva kusy obliečok rovnakého typu (ale rôzných veľkostí). Keď sa rozhodujeme, z ktorých typov obliečok potrebujeme dva kusy, potrebujeme zvážiť niekoľko prípadov.

## Každá ploštica preferuje iný typ obliečok

Tento prípad zodpovedá prvej sade, kde platí, že preferencia ploštice $p_i$ sa rovná $i$.

V tomto prípade, keď $n$ sa rovná 1, vieme, že ploštica pôjde na rande sama a je jedno, akú veľkosť obliečok kúpime, stačiť bude jeden kus.

Ak $n$ sa rovná 2, tak vieme, že každá z ploštíc pôjde na rande presne raz, a to naraz s druhou plošticou z páru. Tým pádom pre každú plošticu potrebujeme presne jedny obliečky (rôznej veľkosti) a výsledok, ktorý hľadáme je 2.

Komplikovanejšie to začína byť v prípade, že máme viac, ako dve ploštice. Bez ujmy na všeobecnosti si môžeme povedať, že prvá z $n$ ploštíc sa bude vždy nachádzať na posteli číslo 1, a tak pre ňu zaobstaráme iba jednu veľkosť obliečok. Pri druhej ploštici si podobne môžeme povedať, že sa vždy bude nachádzať na posteli číslo 2, a tak pre ňu stačí tiež zaobstarať iba jednu veľkosť obliečok. Zatiaľ nám v tom nič nebráni, keďže tieto ploštice vedia spokojne ísť spolu na rande. No akonáhle by sme chceli povedať, že tretia ploštica bude vždy na posteli číslo 1, zistíme, že nebude vedieť ísť na rande s prvou plošticou. Takisto, ak povieme, že bude vždy na posteli číslo 2, nebude môcť ísť na rande s druhou plošticou.

Vieme teda povedať, že pre tretiu plošticu musíme kúpiť obe veľkosti obliečok, aby mohla ísť na rande s prvou aj s druhou plošticou. Toto platí aj pre všetky zvyšné ploštice. Tým pádom máme 2 ploštice (prvú a druhú), pre ktoré kúpime jeden kus obliečok a $n-2$ ploštíc, pre ktoré kupime dve obliečky. Celkový počet obliečok, ktorý kúpime je teda $2 * (n - 2) + 2$, po úprave $2n - 2$.

## Ploštice môžu preferovať rovnaký typ obliečok

V druhej sade sa stretneme so situáciou, kde rôzne ploštice môžu preferovať rovnaký typ obliečok. Tu je dôležité si uvedomiť, že ak existujú aspoň dve ploštice, ktoré majú rady rovnaký typ, potrebujeme presne dva kusy tohoto typu, aby dve ploštice s touto preferenciou mohli ísť spolu na rande. Taktiež nepotrebujeme viac ako 2 kusy, každý na jednu posteľ, keďže jeden kus obliečok môže byť použitý viackrát.

Poďme sa pozrieť len na tie typy obliečok, ktoré sú preferované len jednou plošticou. Zmenila sa nám situácia tým, že sme niektoré obliečky rovno kúpili dva krát? Nie, keďže bezohľadu na to, ako pokúpime tie obliečky, ktoré preferuje len jedna ploštica, budú vedieť ísť randiť s plošticami, ktorým sme práve kúpili obliečky na obe postele.

Obliečky, ktoré preferuje práve jedna ploštica, teda môžeme ponakupovať úplne nezávisle a spravíme to tak, ako sme si vysvetlili v predošlej sekcií. Čiže z týchto obliečok môžeme zobrať maximálne dva rôzne typy, z ktorých nám stačí kúpiť jeden kus a pre zvyšné typy platí, že musíme kúpiť dva kusy.

Dokázali sme si, že opäť môžeme mať maximálne dva typy obliečok, z ktorých kúpime jeden kus. A podmienkou je, že tieto typy musia byť preferované len jendou plošticou. Otázkou je, ako zistíme, či takéto typy existujú a koľko ich je.

Potrebujeme použiť dátovú štruktúru, ktorá nám pre každý typ obliečok povie, koľko ploštíc danú obliečku preferuje.

Jednou takouto dátovou štruktúrou je vector (v pythone list) veľkosti $k$, v ktorom každá pozícia prezentuje typ obliečky a hodnota na danej pozícii reprezentuje počet ploštíc, ktoré danú obliečku preferujú. Pri načítavaní sa pozrieme na preferenciu konkrétnej ploštice a navýšime zodpovedajúcu hodnotu vo vectore o 1. Na konci celý vector prejdeme a v osobitnej premennej $raz$ si zapamätáme, koľko hodnôt vo vectore sa rovnalo 1 a v premennej $viac$ koľko ich bolo aspoň 2.

Každú z $viac$ typov obliečky budeme musieť kúpiť dva krát a obliečok z $raz$ typov kúpime podľa predošlého vzorca: $raz$ kusov, ak sú najviac 2, inak $2raz - 2$.

Časová zložitosť načítania vstupu a prejdenia listu je $O(n + ǩ)$ a pamäťová je $O(k)$, keďže si vytvárame pole veľkosti $k$.

## Použitie mapy

Riešenie, ktoré sme si predstavili, môže byť ešte efektívnejšie, ak použijeme dátovú štruktúru map (dictionary v pythone). Táto štruktúra nám dovoľuje držať v pamäti a prechádzať hodnoty zodpovedajúce len tým typom obliečok, čo sú preferované aspoň jednou plošticou. Ak napríklad máme veľké $k$ ($10^9$), ale všetky ploštice preferujú ten istý typ obliečok, v mape si budeme pamätať údaje práve o tomto jednom type.

Časová a pamäťová zložitosť sa nám teda zhodí na $O(n)$. Nebolo nám to však pri daných obmedzeniach treba.
",2
7dd3340b5ae824c2,ksp,"# Zúfalo málo miesta

Matúš má problém s nedostatkom miesta na svojom počítači. Jeho uši sú ochotné počúvať len najkvalitnejšiu hudbu v bezstratovom formáte, oči mu krvácajú, ak uzrú video v kvalite horšej od Blu-ray a so svojim fotoaparátom spravil obrovské množstvo fotiek vo vysokom rozlíšení, ktoré odmieta zmazať. Zábavný priemysel je neúprosný a chudák Matúš už nemá svoje dáta kam uložiť.

Nezostáva mu teda nič iné, len sa opäť raz ponoriť do divokých vôd e-shopov a rozšíriť pamäťovú kapacitu svojho počítača. Stiahol si preto celú ponuku diskov z najväčších internetových obchodov do jediného prehľadného súboru a teraz rozmýšľa, ktorý disk kúpiť.

Matúš je ekonomicky cítiaci človek a tak by rád zistil, ktorý z diskov má najlepší pomer ceny ku kapacite. Pomôžete mu v tom? Najlepšie bude, ak pri tom použijete len celé čísla, pretože ostatným Matúš veľmi neverí.

## Úloha

Na vstupe máte zoznam dostupných diskov v obchodoch. Vašou úlohou je nájsť disk, ktorý je najvýhodnejší -- teda taký, ktorý má najnižšiu jednotkovú cenu za gigabajt (teda spomínaný pomer ceny a kapacity). Ak je najlepších diskov viacero, vypíšte ľubovoľný z nich. Snažte sa vymyslieť taký algoritmus, ktorý pri výpočtoch používa len celé čísla. Najlepšie bude, ak nebudete vôbec nikde deliť.

## Formát vstupu

V prvom riadku vstupu je kladné číslo $n$ udávajúce počet diskov. V každom znasledujúcich $n$ riadkov sú celé čísla $c$ a $k$ udávajúce cenu (v eurách) a kapacitu (v gigabajtoch) daného disku.

## Formát výstupu

Vypíšte dve medzerami oddelené čísla -- cenu a kapacitu hociktorého najvýhodnejšieho disku v zozname. Nezabudnite za nimi vypísať koniec riadku.

## Hodnotenie

Za popis riešenia, ktoré používa aj iné ako celé čísla sa dajú získať najviac 3 body zo 7. Počet bodov za program závisí len od toho, ktoré vstupy váš program vyrieši správne. Vstupy sú rozdelené do sád podľa obtiažnosti, za každú sadu sa dá získať pol boda, ale celkový počet bodov za program sa zaokrúhľuje nadol.

| Sada | 1 | 2 | 3 | 4 | 5 | 6 | |---| ---:| ---:| ---:| ---:| ---:| ---:| ---:| | Maximálny počet | $2$ | $3$ | $10$ | $1,000$ | $10,000$ | $100,000$ | | Maximálna cena | $100$ | $100$ | $1,000$ | $1,000$ | $10,000$ | $10,000$ | | Maximálna kapacita | $100$ | $100$ | $1,000$ | $1,000$ | $10,000$ | $10,000$ |

## Príklad

```vstup
5
500 100
750 130
1500 200
250 60
1000 147
```

```vystup
250 60
```
","# Zúfalo málo miesta

Základná myšlienka algoritmu pre hľadanie najlepšieho disku je veľmi jednoduchá. Budeme si pamätať najlepší disk, aký sme doteraz našli (na začiatku si zoberieme nejaký fiktívny, naozaj zlý disk), postupne prejdeme všetky disky a každý porovnáme s tým, ktorý bol doteraz najlepší. Vždy, keď je nejaký disk výhodnejší ako ten, čo vyhrával doteraz, stane sa najlepším on.

To, čo ostáva vymyslieť, je, ako porovnať dva disky, bez toho, aby sme spočítali samotnú cenu za gigabajt. Ak by sme mohli používať reálne čísla, cenu za gigabajt by sme porovnávali nasledovne:

$$\\frac{cena_aktualny}{kapacita_aktualny} \\gtreqqless \\frac{cena_najlepsi}{kapacita_najlepsi}$$

Delenie je však operácia, pri ktorej vznikajú desatinné čísla, preto sa chceme tejto operácii vyhnúť. Obe strany môžeme prenásobiť kapacitami diskov. Dostaneme:

$$cena_aktualny \\cdot kapacita_najlepsi \\gtreqqless cena_najlepsi \\cdot kapacita_aktualny$$

Výsledok tohto porovnania bude rovnaký, ako výsledok toho predošlého. Ak v pôvodnej nerovnosti platilo ""\<"", "">"" alebo ""="", bude rovnaký vzťah platiť aj v druhej nerovnosti. Avšak, pri použití tohto porovnania sa nemusíme obávať vzniku desatinných čísel, lebo nepoužívame delenie.

\\medskip

Aká je zložitosť tohto algoritmu? Keďže na vstupe máme $n$ diskov, ktoré musíme načítať, zložitosť bude aspoň $O(n)$. Pri porovnávaní diskov sa na každý pozrieme iba raz, keď ho porovnávame so zatiaľ najvýhodnejším. Každé porovnanie používa iba násobenie čísel s konštantnou zložitosťou a teda celková časová zložitosť bude $O(n)$. Pamäťová zložitosť je $O(1)$, pretože si stačí pamätať len doteraz najlepší disk. Na ostatné môžeme zabudnúť.

\\medskip

Niektorí z vás si zbytočne sťažovali život hľadaním najmenšieho spoločného násobku kapacít alebo cien diskov. To však algoritmu nepomôže a akurát ho to môže spomaliť, pretože hľadanie $nsn(a,b)$ trvá $O(\\log b)$.
",1
c608ee2b7d425e4f,ksp,"# Ováľané mince

V meste hovniválov sa deje veľká udalosť -- ide sa stavať obrovský palác z trusových gulôčok. Stavia sa na počesť Hovnivála I. , ktorý zjednotil všetky kmene hovniválov do jednej veľkej ríše a priniesol medzi nich pokoj a mier. Keď sa zhromažďovali gulôčky, bolo jasné, že ho nebude také ľahké postaviť. Začal sa konkurz na stavbu paláca. Tento konkurz vyhrala firma, kde pracujú Janko a Ferko, a práve oni dostali poverenie postaviť tento palác. Ako roky plynuli, stavbári čakali už len na jedno -- peniaze za túto neľahkú stavbu. A ten čas nastal dnes.

Kto vykonal viac práce? Janko či Ferko? Boli ste poverení vyplatiť im ich zaslúžené peniaze. Ale pozor! Nechcete, aby sa ich výplaty veľmi odlišovali, inak sa pobijú!

## Úloha

Máme $n$ mincí s hodnotami $1$ až $n$. Keďže chceme, aby sa nepobili, musíme rozdeliť tieto mince čo najviac rovnomerne obidvom stavbárom. Každú mincu máte k dispozícii len raz. Pochopiteľne ju musíte dať len jednému stavbárovi. Vašou úlohou je nájsť čo najmenší rozdiel výplat Janka a Ferka.

## Formát vstupu

Na prvom riadku vstupu dostanete číslo $t, 1\\leq t \\leq 1000$, počet výplat, ktoré chcete rozdeliť. Na každom z ďalších $t$ riadkov sa nachádzajú dve medzerou oddelené čísla $n_i$ a $p$, kde číslo $n_i$ znamená počet mincí, ktoré máme pre danú výplatu (mince majú teda hodnoty $1, 2, ... , n_i$), a $p \\in {0,1}$. Platí, že $1 \\leq n_i \\leq 3000$

## Formát výstupu

Ak sa $p=0$, na výstup vypíšte pre danú výplatu jedno číslo na samostatnom riadku -- minimálny rozdiel výplat Janka a Ferka.

Ak sa $p=1$, na výstup pre danú výplatu okrem jedného čísla na samostatnom riadku -- minimálneho rozdielu výplat, vypíšte aj príklad na nejaké rozdelenie mincí, kde je rozdiel výplat minimálny. Pre každú výplatu okrem minimálneho rozdielu vypíšte ďalšie dva riadky.

Prvý z nich na začiatku obsahuje číslo $j$ -- počet mincí, ktoré dostane Janko. V tom istom riadku nasleduje medzera a $j$ medzerou oddelených čísiel -- hodnoty Jankových mincí.

Druhý z nich na začiatku obsahuje číslo $f$ -- počet mincí, ktoré dostane Ferko. V tom istom riadku nasleduje medzera a $f$ medzerou oddelených čísel -- hodnoty Ferkových mincí.

## Obmedzenia

V prvej štvrtine sád platí $p=0$.

## Poznámka

V posledných sadách je treba vypisovať pomerne veľa čísel, a v prípade, ak to robíte pomaly (a najmä v pomalom programovacom jazyku ako napr. Pythone), vám môže byť neakceptované riešenie, ktoré má vzorovú časovú zložitosť. Na vypisovanie poľa odporúčame namiesto:

použiť

## Príklad

```vstup
2
3 0
5 0
```

```vystup
0
1
```

*V prvom prípade máme mince hodnôt $1, 2, 3$. Medzi dvoch ľudí ich vieme rozdeliť tak, že prvý dostane mince $1$ a $2$ a druhý dostane mincu $3$. Rozdiel medzi súčtami ich mincí je teda $0$. V druhom prípade máme mince $1, 2, 3, 4, 5$. Tieto mince vieme najlepšie rozdeliť tak, že prvý dostane mince $1, 2, 5$ a druhý mince $3, 4$, teda rozdiel medzi súčtami ich mincí je 1.*

```vstup
2
3 1
5 1
```

```vystup
0
2 1 2
1 3
1
3 1 2 5
2 3 4
```

*Iný príklad na 5 mincí môže byť napríklad aj tak, že prvý človek dostane mince $1, 2, 4$ a druhý $3, 5$*
","# Ováľané mince

Skúsme si najprv rozdeliť rovnomerne nejaké čísla $a, a+1, ..., b$. Veľmi rýchlo si môžeme všimnúť, že ak berieme najväčšie a najmenšie, druhé najväčšie a druhé najmenšie, tak tieto dvojice majú vždy rovnaký súčet.

Bohužiaľ, nám to ešte nepovie, ako rozdeliť čísla, aby bol medzi nimi čo najmenší rozdiel. Povedzme si najprv, že kedy vieme mince $1,2, ..., n$ rozdeliť na rovnaké časti. Aby bolo možné rozdeliť mince rovnomerne, tak ich súčet musí byť párny, a teda v ňom musí byť párny počet nepárnych čísiel. To, či to v našej postupnosti platí, vieme šikovne zisťovať tak, že (počet čísel označme ako $n$), $n % 4 = 3$ alebo $n % 4 = 0$.

Ľahko si všimneme, že ak $n % 4 = 0$, tak mince vieme rovnomerne rozdeliť tak, že zoberieme dvojice $1$ a $n$, $2$ a $n-1$, ... . Takýchto dvojíc je párny počet, a teda ich vieme rozdeliť na dve rovnaké polovice.

V prípade ak $n % 4 = 3$, tak je to už trochu zložitejšie. Ak ale vieme, že $n+1$ mincí (teda $n % 4 = 0$) sa dá rozdeliť, tak toto sa líši len o $n+1$ a teda ak jednej strane zoberieme mincu/mince v hodnote $(n+1)/2$, tak budú obe polovice vyrovnané. (Dá sa to jednoduchšie predstaviť ak si to napíšete na papier.)

Čo ale v prípade, ak sa nedajú mince rozdeliť rovnomerne? Ak $n % 4 = 2$, tak máme vlastne oproti prípadu, ktorý vieme rovnomerne rozdeliť ($n % 4 = 0$), naviac čísla $n+1$ a $n+2$, a tieto čísla sa líšia len o $1$, a to je minimálny rozdiel, čo vieme dosiahnuť. (Nech robíme čo robíme, nepárny súčet na dve rovnaké polovice nerozdelíme.)

A ostáva posledný prípad, keď $n % 4 = 1$. Tento prípad je zase veľmi podobný prípadu keď $n % 4 = 3$, a rovnako tu máme naviac dve čísla, a rovnako je minimálny rozdiel $1$.

Keď už máme vypočítanú hodnotu, akú má dostať každý stavbár, teraz pokiaľ $p = 1$, tak musíme vypísať aj aké mince každý dostane.

Čísla vieme získavať buď tak, ako sme písali, teda po dvojiciach, alebo jednoduchšie, pažravo. Pažravo ich získame tak, že ideme od najväčších mincí, a počítame si súčet už zobraných mincí. Ak si danú mincu vieme zobrať (pripočítať k súčtu) bez toho, aby sme presiahli polovicu cekovej sumy, zoberieme ju.

Možno si kladiete otázku, či to takto pažravo môže fungovať. Odpoveď je, áno. Naše mince majú v súčte určite väčšiu hodnotu ako potrebujeme, a máme mince s každou hodnotou, ktorú by sme mohli potrebovať. Teda máme zaručené, že nech zmenšíme rozdiel medzi sumou, ktorú chceme získať a sumou, ktorú sme zatiaľ nazbierali, na ľubovoľnú hodnotu, tak určite bude existovať minca, ktorá sa nám do tohto rozdielu zmestí.

Čo sa týka časovej zložitosti, pokiaľ $p = 0$, tak časová zložitosť je $O(1)$, lebo odpoveď na jednu otázku vypočítame v konštantnom čase, vzorcom. V prípade, že $p = 1$, musíme dokopy vypísať $n$-prvkové pole, ktoré ale vieme získať v čase priamo úmernom od $n$, takže zložitosť je $O(n)$. Pamätať si nemusíme nič, pretože hodnoty poľa môžeme vypočítať vo for-cykle bez toho, aby sme si okrem niekoľko málo premenných niečo naviac pamätali, a preto je pamäťová zložitosť konštantná = $O(1)$.
",2
d72124dfa05ab7fa,ksp,"# Ako Marianka blúdila

Predstavte si dom. Velikánsky dom na kopci s ešte väčšou záhradou. Skoro až taký zámok. No, tak presne v takom dome býva Samo. Tento dom má veľa izieb a rôznych pozoruhodností vnútri aj vonku. Jednou z nich je napríklad obrovské bludisko zo živého plotu v záhrade.

Možno to znie ako z rozprávky, veľký dom, záhrada; čiže veľa zábavy. Ale Samo je jedináčik, jeho rodičia šli na týždeň na dovolenku a on ostal doma úplne sám. To už nie je taká zábava. Tak si jedného dňa pozval Marianku na návštevu.

Tú, hneď ako prišla, očarilo bludisko v záhrade. Chcela ho vyskúšať, no bála sa, že sa stratí a už sa odtiaľ nedostane. Samo jej povedal, že aj keby chodila uplne náhodne, dostane sa von v konečnom čase. To ju síce veľmi neohúrilo, no hneď nato jej navrhol, nech si vždy zapíše ktorým smerom spravila krok. Keď potom bludisko prejde, môžu si spolu z tohoto popisu zostrojiť mapku a spočítať, kolko krát Marianka spravila zlé rozhodnutie (teda išla jedným smerom, ale kratšie by to mala iným).

Marianka sa nakoniec predsalen odhodlá a vydá sa do bludiska s tým, že si bude zapisovať svoju cestu na papier. Prešiel nejaký čas, Marianka bola vonku z bludiska a spolu so Samom objavujú ďalšie pozoruhodnosti Samovho domu. Na papier s Mariankinou trasou z bludiska zabudli. Ale vás ako zvedavých čitateľov tohto príbehu zaujíma, koľkokrát Marianka v bludisku zle odbočila.

## Úloha

Na vstupe dostanete popis Mariankinej cesty bludiskom. Celú mapu bludiska ale nepoznáme. O dvoch políčkach vieme že sú priechodné teda iba vtedy, ak tade Marianka niekedy prešla. Teda aj ak sú susedné, môže medzi nimi ešte byť živý plot. Vašou úlohou je na základe tohoto popisu povedať, koľkokrát Marianka zle odbočila. To znamená, koľkokrát spravila taký krok, že iným smerom by to mala bližšie do cieľa. Ak teda počas cesty napríklad prechádza cieľom, prvý krok smerom od cieľa nepovažujeme za zlý, nakoľko žiadnym iným smerom by sa ku cieľu tiež nepriblížila.

## Formát vstupu

Na prvom riadku vstupu je jedno číslo $n$ ($1\<n\<10^5$) -- počet Mariankiných krokov v bludisku. Nasleduje $n$ riadkov, kde na $i$--tom riadku sú súradnice $x_i$ a $y_i$ ($-10^5\<x_i, y_i\<10^5$), označujúce bod, na ktorý sa Marianka posunula. Pre každé po sebe idúce súradnice platí, že sa líšia v práve jednej súradnici o 1 (teda krok je jedným zo 4 smerov).

Prvé súradnice sú vždy $(0,0)$ a posledné súradnice značia cieľ.

## Formát výstupu

Vypíšte jedno celé číslo -- počet miest, na ktorých Marianka zle odbočila.

## Príklad

```vstup
7
0 0
0 1
0 2
0 1
0 0
0 -1
-1 -1
```

```vystup
2
```

Prvé dva Mariankine kroky išli zlým smerom, no potom už išla priamo do cieľa.

```vstup
7
0 0
-1 0
-2 0
-2 1
-1 1
-1 0
-1 -1
```

```vystup
2
```

Marianka spravila koliečko. 3. a 4. krok išli zlým smerom -- bližšie by bolo ísť naspäť.
","# Ako Marianka blúdila

Cestu, ktorou Marianka prechádza, si môžeme predstaviť ako graf. Políčka sú vrcholy a hrana je medzi nimi práve vtedy, ak medzi nimi Marianka niekedy prešla. Formát vstupu je na grafy pomerne nezvyčajný, ale stačí si uvedomiť, že táto cesta je len akýsi zoznam hrán ktoré sa môžu opakovať. Aby sa nám lepšie pracovalo, graf si potrebujeme uložiť ako zoznam susedov. Ak na to použijeme mapu, nemusíme sa ani trápiť nejakým očíslovaním vrcholov ale môžeme si ich pamätať rovno podľa súradníc.

Teraz ešte potrebujeme zistiť, ako ďaleko je ktorý vrchol od cieľa, aby sme vedeli povedať, či išla Marianka správnym smerom. Na to nám poslúži štandardné [prehľadávanie do šírky](https://www.ksp.sk/kucharka/bfs/).

Ako posledný krok už len prejdeme cestu tak, ako bola na vstupe a pre každý krok zistíme, či bol správnym smerom, teda či vzdialenosť od ciela je pre nasledujúce políčko najmenšia z pomedzi susedných políčok.

## Časová a pamäťová zložitosť

Veľmi ľahko môžeme nahliadnuť, že jediný netriviálny cyklus v tomto riešení je BFS, o ktorom však vieme že má lineárnu zložitosť, teda aj celková časová zložitosť je $O(n)$ od počtu krokov na vstupe. Pamäťová zložitosť je tiež $O(n)$, pretože si potrebujeme pamätať celý vstup, a ukladáme si ho efektívne.
",6
9fba5911dd8371da,ksp,"# Obmedzený pohyb

Farmár Bob sa nedávno rozhodol, že si na svoju farmu dá konečne zaviesť inžinierske siete. Už o pár dní sa mu to na záhrade len tak hemžilo robotníkmi kopajúcimi dlhočizné jamy pre rôzne káble a potrubia. Firma, ktorá túto robotu robila, však nanešťastie skrachovala a Boba nechala s rozkopanou záhradou. Bob sa však po záhrade potrebuje pohybovať, musí sa predsa starať o petržlen, baklažán, cibuľku, jahody ... Keďže skákanie cez jamy je príliš nebezpečné, obchádzať sa mu ich nechce a zasypávanie všetkých jám by trvalo príliš dlho, zobral Bob niekoľko dosák a položil ich krížom cez niektoré jamy ako mosty.

Po čase však Bob zistil, že niektoré z týchto dosák by sa mu zišli pri oprave plota. Rozhodol sa teda niektoré jamy zasypať, aby tým nejaké dosky uvoľnil. Ale ktoré? Zišlo by sa mu pre každú jamu vedieť, ktoré dosky cez ňu vlastne vedú.

## Úloha

Na záhrade je $n$ jám očíslovaných $1, 2, \\dots, n$ a $m$ dosák očíslovaných $1, 2, \\dots, m$. Jamy aj dosky budeme pre jednoduchosť považovať za úsečky v rovine. Žiadne dve jamy nemajú spoločný bod, ani žiadne dve dosky nemajú spoločný bod. Navyše platí, že **každá doska sa pretína s práve jednou jamou** (pod pojmom ""pretína sa"" myslíme, že úsečky majú práve jeden spoločný bod a tento bod nie je koncovým bodom žiadnej z nich). Na vstupe dostanete zadané pozície všetkých jám aj dosák. Pre každú jamu vypíšte zoznam dosák, ktoré ju pretínajú.

## Formát vstupu

V prvom riadku vstupu sú dve celé čísla $n, m$ ($1 \\leq n, m \\leq 50,000$) -- počet jám a počet dosák. V každom z nasledujúcich $n$ riadkov je popis jednej jamy. Popis jamy tvoria štyri celé čísla $x_1, y_1, x_2, y_2$ $(-1,000,000 \\leq x_1, y_1, x_2, y_2 \\leq 1,000,000)$, ktoré popisujú to, že daná jama má koncové body $(x_1, y_1)$ a $(x_2, y_2)$. V nasledujúcich $m$ riadkoch sú popisy dosák, v rovnakom formáte. Jamy aj dosky sú očíslované v poradí, v akom sú uvedené na vstupe.

## Formát výstupu

Pre každú jamu (v poradí, ako sú očíslované), vypíšte jeden riadok. Tento riadok má obsahovať čísla dosák, ktoré túto jamu pretínajú, oddelené **presne jednou medzerou**, vo **vzostupnom poradí**. V prípade, že jamu nepretína žiadna doska, vypíšte pre ňu prázdny riadok.

## Príklad

```vstup
3 4
1 -1 1 4
-1 -2 -3 0
4 3 5 0
3 1 -1 1
3 5 -2 2
5 5 4 -4
3 -1 -1 0
```

```vystup
1 2 4

3
```

_Situácia na Bobovej záhrade vyzerá nasledovne (plné čiary sú jamy, prerušované čiary sú dosky):_
","# Obmedzený pohyb

## Pretínanie úsečiek

Kľúčovou časťou tejto úlohy je zisťovanie, či sa dve úsečky pretínajú. Dve úsečky $AB$ a $CD$ sa pretínajú vtedy a len vtedy, keď úsečka $AB$ pretína priamku $CD$ a súčasne úsečka $CD$ pretína priamku $AB$. To, že úsečka $CD$ pretína priamku $AB$ vlastne znamená, že body $C$ a $D$ ležia v opačných polrovinách vzhľadom na priamku $AB$. A to vieme ľahko skontrolovať pomocou vektorového súčinu^\[viac o vektorovom súčine a jeho využití si môžete prečítať na <https://www.ksp.sk/kucharka/skalarny_a_vektorovy_sucin>\] tak, že skontrolujeme, či majú súčiny $(B - A) \\times (C - A)$ a $(B - A) \\times (D - A)$ opačné znamienka (notáciou $Y - X$ tu myslíme vektor z $X$ do $Y$). Keďže nás zaujíma iba pretínanie vo vnútorných (nie koncových) bodoch úsečiek, budeme vyžadovať, aby oba vektorové súčiny boli nenulové. To, či úsečka $AB$ pretína priamku $CD$ overíme úplne rovnako.

## Jednoduché riešenie

Keď už vieme v čase $O(1)$ overovať, či sa dve úsečky pretínajú, ľahko napíšeme riešenie s časovou zložitosťou $O(n \\cdot m)$ -- pre každú jamu sa pozrieme na všetky dosky a tie, ktoré pretína, vypíšeme.

## Vzorové riešenie

Dá sa to však aj rýchlejšie, konkrétne v čase $O((n+m) \\log (n+m))$. Použijeme techniku s názvom _zametanie_, ktorá sa v geometrii v rôznych obmenách používa pomerne často.

Pre jednoduchosť budeme chvíľu predpokladať, že na vstupe sa nevyskytujú zvislé úsečky. Nakoniec si ukážeme, ako sa vieme vysporiadať aj s nimi.

Vezmeme myslenú zvislú priamku (ďalej ju budeme volať zametacia priamka), ktorú na začiatku umiestnime dostatočne ďaleko naľavo, tak aby bola naľavo od všetkých úsečiek, ktoré sme dostali na vstupe. Postupne posúvame zametaciu priamku doprava, až kým ju nedostaneme napravo od všetkých úsečiek na vstupe. Počas tohto posúvania si vo vhodnej dátovej štruktúre udržiavame zoznam úsečiek, ktoré momentálne zametaciu priamku pretínajú, usporiadaný podľa $y$-ovej súradnice bodu pretnutia (teda úsečka, ktorej priesečník s našou priamkou je najnižšie, bude v zozname prvá a úsečka, ktorá zametaciu priamku pretína najvyššie bude posledná). Keďže v skutočnosti nás zaujímajú iba momenty, keď sa niečo sa deje s týmto zoznamom, stačí nám postupne odsimulovať všetky udalosti, pri ktorých sa zoznam mení (pohyb priamky medzi týmito udalosťami je aj tak nuda).

Zoznam sa bude meniť pri troch druhoch udalostí:

1. Zametacia priamka ,,narazila'' na ľavý koniec nejakej novej úsečky. Pri tejto udalosti treba danú úsečku pridať do zoznamu na správne miesto, keďže odteraz bude našu priamku pretínať aj ona.

1. Zametacia priamka ,,narazila'' na pravý koniec nejakej úsečky. Vtedy treba danú úsečku zo zoznamu vymazať, keďže odteraz už zametaciu priamku pretínať nebude.

1. Zametacia priamka ,,narazila'' na priesečník dvoch úsečiek. Vtedy treba tieto dve úsečky v zozname vymeniť, keďže tá, ktorá doteraz pretínala zametaciu priamku nižšie ju bude odteraz pretínať vyššie a naopak.

Na to, aby sme udalosti mohli spracúvať, musíme, samozrejme, vedieť, kedy nastanú. Za týmto účelom budeme mať haldu (alebo inú prioritnú frontu), na ktorej vrchu bude prvok s najnižšou $x$-ovou súradnicou. Do tejto haldy budeme dávať všetky budúce udalosti, o ktorých už vieme, kedy nastanú. Z nej budeme vždy vedieť vybrať najbližšiu udalosť, ktorú máme spracovať.

Už pri načítaní vstupu vieme povedať, kedy (teda pri akej $x$-ovej súradnici zametacej priamky) nastanú udalosti prvých dvoch druhov. Tieto udalosti si teda môžeme rovno nasypať do haldy. S udalosťami tretieho typu bude trochu väčší problém, keďže na začiatku netušíme, kde sa jednotlivé úsečky pretínajú. Našťastie nás nič nenúti hádzať všetky tieto udalosti do haldy hneď na začiatku, môžeme ich tam pridávať ,,za behu''. Jediným obmedzením je, že každú udalosť musíme do haldy pridať skôr, než nastane (inak by sme nevedeli, že ju máme odsimulovať).

Všimnime si, že keď zametacia priamka ide naraziť na priesečník dvoch úsečiek, tesne predtým sú tieto úsečky v zozname úsečiek pretínajúcich zametaciu priamku hneď vedľa seba. Ak by sme teda pri každej zmene zoznamu celý tento zoznam prešli a pre každú dvojicu susedných úsečiek skontrolovali, či sa niekedy v budúcnosti nepretnú (a ak áno, pridali by sme túto udalosť do haldy), určite by sme žiaden priesečník nevynechali. To by, samozrejme, bolo dosť neefektívne, keďže niektoré dvojice úsečiek by sme takto zbytočne kontrolovali veľakrát. V skutočnosti sa nám stačí po každej zmene v zozname pozrieť na tie dvojice úsečiek, ktoré pred zmenou neboli susedné a po zmene sú. Konkrétne:

1. Po pridaní úsečky do zoznamu sa treba pozrieť, či sa pretne so svojím spodným susedom (ak nejakého má) a či sa pretne s vrchným susedom.

1. Po zmazaní úsečky zo zoznamu sa treba pozrieť, či sa jej niekdajší susedia (ktorí odteraz susedia navzájom) pretnú.

1. Po výmene dvoch úsečiek sa treba pozrieť, či sa tieto dve úsečky pretnú so svojimi novými susedmi (tá, ktorá bola pred výmenou nižšie, má teraz nového horného suseda a tá, ktorá bola vyššie, má nového spodného suseda).

Pri spracovaní ľubovoľnej udalosti sa teda pozrieme na $O(1)$ (jednu alebo dve) novovzniknutých dvojíc susedných úsečiek. Keď o nejakej dvojici zistíme, že sa pretne, poznačíme si to. Ak sme navyše doteraz o tomto priesečníku nevedeli, pridáme ho do haldy. Takýmto spôsobom zaručene nevynecháme žiadnu udalosť, ani žiadnu nespracujeme dvakrát. Navyše popri tom nájdeme všetky priesečníky, čo je presne to, čo potrebujeme.

#### Zvislé úsečky

Ostáva ešte doriešiť niekoľko detailov. Prvým z nich sú zvislé úsečky. Tie môžeme ošetriť napríklad tak, že zavedieme štvrtý typ udalosti: ,,narazenie'' zametacej priamky na zvislú úsečku. O týchto udalostiach vieme už po načítaní vstupu povedať, kedy nastanú. Spracovať ich môžeme tak, že v zozname úsečiek pretínajúcich zametaciu priamku binárne vyhľadáme prvú a poslednú úsečku, ktorá danú zvislú úsečku pretína a pre všetky úsečky v zozname medzi nimi si poznačíme priesečník. Zoznam pritom nemeníme, keďže hneď, ako sa zametacia priamka pohne, zoznam sa vráti do pôvodného stavu.

#### Súčasné udalosti

Druhým problémom je, čo budeme robiť, keď naraz nastane viac ako jedna udalosť. Odpoveď je jednoduchá: odsimulujeme ich jednu po druhej, v ľubovoľnom poradí. Keďže máme zaručené, že úsečky sa pretínajú vždy len vo vnútorných bodoch a v žiadnom bode sa nepretínajú viac ako dve úsečky, udalosti nastávajúce naraz sa nemôžu ovplyvňovať.

#### Poloha priesečníka

Tretí detail je, že počas zametania budeme občas potrebovať pre dané dve úsečky zistiť, kde (na akej $x$-ovej súradnici) sa pretnú. Už sme si ukázali, ako zistiť, _či_ sa pretnú, neukázali sme si však, ako zistiť _kde_ sa pretnú. Priesečník dvoch úsečiek (ak existuje) je priesečník priamok, na ktorých tieto úsečky ležia. Rovnice týchto priamok vieme zapísať v tvare $a_1 x + b_1 y + c_1 = 0$ a $a_2 x + b_2 y + c_2 = 0$. Ak $(x, y)$ je ich priesečník, potom musia $x$ a $y$ spĺňať rovnice oboch priamok. Máme teda sústavu dvoch rovníc o dvoch neznámych, ktorej riešením dostaneme

$$x = \\frac{b_1 c_2 - b_2 c_1}{b_2 a_1 - b_1 a_2} \\text{.}$$

Ak máme úsečku zadanú jej koncovými bodmi $(x_1, y_1), (x_2, y_2)$, parametre $a, b, c$ jej rovnice vieme dopočítať tak, aby jej oba z bodov $(x_1, y_1)$ aj $(x_2, y_2)$ vyhovovali a dostaneme niečo ako

$$a = y_2 - y_1 \\text{,}$$ $$b = x_1 - x_2 \\text{,}$$ $$c = -(a x_1 + b y_1) \\text{.}$$

#### Dátová štruktúra zoznamu

Štvrtým (a najväčším) detailom je voľba vhodnej dátovej štruktúry pre zoznam úsečiek pretínajúcich zametaciu priamku. Vhodnou štruktúrou sa ukazujú byť vyvažované binárne vyhľadávacie stromy (v angličnite Binary Search Trees, skratka BST). Tie nám totiž umožňujú mať usporiadaný zoznam prvkov, v ktorom sa dá vyhľadávať, pridať prvok na ľubovoľnú pozíciu aj zmazať ľubovoľný prvok v čase $O(\\log N)$. V C++ sú vyhľadávacie stromy implementované v `std::set` a táto implementácia sa dá v riešení použiť, je to však dosť bolestivé a silno neodporúčané. Problém je v tom, že `set`e treba povedať, ako má prvky porovnávať a to sa v našom prípade v čase mení -- vždy, keď zametacia priamka prejde nejakým priesečníkom. Preto je veľmi náročné udržať `set` v konzistentnom stave.

Lepšia voľba je napísať si vlastný BST, na naše účely sa dobre hodí napríklad treap^\[viac o treapoch na <https://www.ksp.sk/kucharka/treap>\] s implicitnými kľúčmi. Táto dátová štruktúra sa správa v princípe ako obyčajné pole (teda prvky sú číslované indexami $0, 1, \\dots, N-1$) s tým rozdielom, že prečítanie prvku na danom indexe trvá čas $O(\\log N)$ namiesto obvyklých $O(1)$ pri poli. Na oplátku nám však umožňuje nasledujúce operácie:

- Vymazanie prvku z daného indexu v čase $O(\\log N)$ (ostatné prvky sa automaticky prečíslujú).

- Vloženie prvku na daný index v čase $O(\\log N)$ (ostatné prvky sa automaticky prečíslujú).

- Ak si zapamätáme referenciu (pointer) na niektorý prvok, vieme neskôr v čase $O(\\log N)$ zistiť, aký má index (aj ak sa index medzičasom zmenil). To sa nám obzvlášť hodí pri udalostiach 3. typu (vieme si zapamätať, ktoré dva prvky budeme chcieť vymeniť a keď daná udalosť nastane, vieme ich efektívne nájsť).

- Ak sú v nejakom momente všetky prvky zoznamu podľa niečoho usporiadané, vieme v ňom vďaka stromovej štruktúre binárne vyhľadávať v čase $O(\\log N)$, rovnako ako v obyčajnom poli.

#### Presnosť

Posledný detail je presnosť výpočtov. Jednou z možností je nenechať nič na náhodu a všetko počítať v racionálnych číslach. Druhá, na implementáciu jednoduchšia možnosť je použiť reálnu aritmetiku. Vtedy ale treba použiť typ premennej s dostatočnou presnosťou (v C++ v závislosti od implementácie mohol stačiť `double`, alebo mohlo byť nutné použiť `long double`).

#### Odhad zložitosti

Zamyslime sa, koľko udalostí budeme musieť počas zametania spracovať. Keďže na vstupe je $n + m$ úsečiek, udalostí prvého druhu bude najviac $n+m$, rovnako udalostí druhého a štvrtého druhu. Keďže každá doska sa pretína s práve jednou jamou, úsečky na vstupe majú dokopy $m$ priesečníkov, teda budeme mať $m$ udalostí tretieho druhu. Dokopy teda máme $O(n+m)$ udalostí. Udalosti prvých troch druhov vieme spracúvať v čase $O(\\log(n+m))$ (vybranie udalosti z haldy, konštantne veľa operácii so zoznamom úsečiek pretínajúcich zametaciu priamku, prípadné pridanie konštantného počtu udalostí na haldu). S udalosťami štvrtého druhu (zvislými úsečkami) je to trochu horšie. Ak má daná zvislá úsečka $p$ priesečníkov, jej spracovanie môže trvať až $O((p+1) \\log(n+m))$. Vieme však, že na vstupe je dokopy $m$ priesečníkov, teda súčeť $p$-čiek pre všetky zvislé úsečky dokopy je najviac $m$. To znamená, že spracovanie všetkých udalostí štvrtého druhu nám zaberie dokopy $O((n+m) \\log (n+m))$ času. Spracovanie ostatných udalostí tiež trvá $O((n+m) \\log (n+m))$, teda aj celé zametanie bude trvať $O((n+m) \\log (n+m))$. Načítanie vstupu a nahádzanie udalostí do haldy trvá $O((n+m) \\log (n+m))$ času, vypisovanie výstupu trvá tiež $O((n+m) \\log (n+m))$ (lebo ho pred vypísaním potrebujeme triediť), celková časová zložitosť nášho algoritmu je teda $O((n+m) \\log (n+m))$.

Pamäťová zložitosť je $O(n+m)$.
",10
55b863b33f7d7688,ksp,"# Pochúťka

Paulinka^[s krátkym i] mala jedného dňa robiť úlohu z databáz. Ako písala riešenie, uvedomila si, že jedáleň práve zatvorila. Bola nedeľa, takže aj všetky obchody boli zatvorené. Žiaľ, musela pokračovať v písaní o hlade a tak miesto databáz Paulinka premýšľala o koláčoch. A tak to aj skončilo. Jej domáca úloha obsahovala databázy všelijakých koláčov.

Keď prišla z ďalekého západu na prázdniny domov, rozhodla sa, že taká databáza koláčov je výborný nápad. Išla ho teda zrealizovať. Po chvíli plánovania prišla na to, že databáza predsalen nie je najlepší spôsob pre uloženie koláčov a namiesto databázy upečie maticu koláčov.

Matica mala $r$ riadkov a $s$ stĺpcov a Paulinka upiekla $n + m$ koláčov. Najskôr prvých $n$ položila tak, že $i$-ty bol v $(i \\mod r)$-tom riadku a $(i \\mod s)$-tom stĺpci.

Následne ešte na niektoré políčka matice položila zvyšných $m$ koláčov tak, ako sa jej to páčilo. Paulinka mohla položiť aj viacero koláčov do jedného políčka.

Ako finalizovala svoju maticu, rozhodla sa, že niektoré koláče ozdobí maslovým krémom. Samozrejme, nie len tak ledabolo! Každý riadok a každý stĺpec musí obsahovať nepárny počet ozdobených koláčov. Samozrejme, žiadne rearanžovanie koláčov!

Paulinka s krémom stojí nad maticou a premýšľa, ako to urobiť. Ide to vôbec? Koľkými spôsobmi?

## Úloha

Koľkými spôsobmi ide ozdobiť koláče v horeuvedenom rozložení tak, aby v každom riadku a stĺpci matice bol nepárny počet ozdobených koláčov?

Dva spôsoby sú rôzne, ak je nejaký koláč ozdobený v jednom a neozdobený v druhom. V jednom políčku môže byť aj viac koláčov.

## Formát vstupu

Na prvom riadku dostanete rozmery mriežky $r, s \\leq 10^{9}$ a čísla $r + s \\leq n \\leq 10^{9}$ a $m \\leq 10^{5}$ oddelené medzerou.

Na ďalšom riadku je $m$ čísel, $r_0$ až $r\_{r-1}$, kde $r_i$ je riadok $n + i$-teho koláča.

Na treťom riadku je $m$ čísel, $s_0$ až $s\_{s-1}$, kde $s_i$ je stĺpec $n + i$-teho koláča.

Riadky a stĺpce číslujeme od nuly.

V jednotlivých sadách vstupov platia pre $r$, $s$, $n$ a $m$ nasledovné obmedzenia:

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | | ---------------:| ----------------:| -----------------:| ----------------:|------------------:|----------------------:|-----------------:|-----------------:| | $r, s \\leq 10$ | $r \\leq 10$ | $r, s \\leq 10^6$ | $r, s \\leq 10^6$ | $r, s \\leq 10^6$ | $\\gcd(r, s)\\leq 10^6$ | $r, s \\leq 10^9$ | $r, s \\leq 10^9$ | | $n + m \\leq 20$ | $s < 10^3$ | $n \\leq 5(r + s)$ | $n = r\\cdot s$ | $n \\leq 5(r + s)$ | $n \\leq 10^9$ | $n \\leq 10^9$ | $n \\leq 10^9$ | | | $n \\leq 2^{16}$ | $m \\leq 10^5$ | $m = 0$ | $m \\leq 10^5$ | $m \\leq 10^5$ | $m \\leq 10^5$ | $m \\leq 10^5$ | | | $m \\leq 10^5$ | | | | | | |

Navyše, v tretej a siedmej sade stačí vypísať, či existuje aspoň jedno riešenie. Presnejšie, ak je odpoveď nula, tak program má vypísať nulu, a inak môže vypísať akékoľvek kladné číslo.

## Formát výstupu

Vypíšte jedno číslo -- počet rôznych spôsobov ozdobení koláčov. Keďže toto číslo môže byť veľmi veľké, vypíšte ho modulo $1,000,000,009$.

## Príklad

```vstup
2 4 6 2
1 1
3 0
```

```vystup
8
```

*Jeden možný spôsob ozdobenia koláčov:*

```vstup
6 4 50 5
0 1 2 3 4
3 3 3 3 3
```

```vystup
743544352
```

*Tu je možností veľa.*

```vstup
2 4 6 2
1 0
3 2
```

```vystup
0
```
","# Pochúťka

Prvé pozorovanie, ktoré môže skúseným riešiteľom napadnúť je, že pri riešení úloh, ktoré sa odohrávajú v tabuľke si vieme situáciu zakresliť ako bipartitný graf. V jednej časti (partícii) vrcholy reprezentujú riadky a v druhej časti vrcholy reprezentujú jednotlivé stĺpce. Hrany medzi nimi reprezentujú políčka tabuľky. Týmto spôsobom si môžeme úlohu pretransformovať na nasledovnú: Máme bipartitný graf v ktorom môže byť medzi niektorými dvojicami vrcholov viac hrán (počet hrán reprezentuje počet koláčov v danom políčku). Koľkými spôsobom vieme vybrať hrany (ozdobiť koláče/vyfarbiť hrany) tak aby podgraf tvorený všetkými vrcholmi a vybranými (vyfarbenými) hranami spĺňal podmienku, že každý vrchol má nepárny stupeň?

Ďalšie pozorovanie je, že v rôznych komponentoch môžeme hrany vyfarbovať nezávisle od seba. To znamená, že celkový počet možností akým vyfarbíme hrany je súčinom počtu možností ako vyfarbiť hrany v jednotlivých komponentoch.

Poďme si na chvíľu predstaviť, že nejaký z komponentov je strom. To znamená že neobsahuje cykly. Kedy ho vieme vyfarbiť a ako? Ak je vrchol list tak potrebuje aby z neho išiel nepárny počet vyfarbených hrán. Keďže list má iba jednu hranu tak táto hrana musí byť určite vyfarbená. A toto nám teda jednoznačne určuje, že všetky hrany k listom budú vyfarbené. Čo teda ostatné hrany? Uvažujme nasledovný rekurzívny algoritmus na vyfarbenie hrán v strome: Zoberme si vrchol rekurzívne ofarbime všetky hrany v jeho podstorme. Ak sme vyfarbili párny počet hrán vedúcich z vrcholu musíme vyfarbiť ešte aj hranu k otcovi, aby sme pre tento vrchol dostali nepárny počet zafarbených hrán. Keď sa lepšie pozriete na tento algoritmus zistíte že vďaka invariantom v rekurzií vždy je jednoznačne určené, ktoré hrany v strome budú zafarbené. Môže sa však stať, že zistíme, že koreň má zafarbený iba párny počet hrán a s tým nevieme nič spraviť. (Nevedie totiž od neho hrana k otcovi.) Vďaka tomuto algoritmu však vieme, že v každom strome vieme zafarbiť hrany najviac jedným povoleným spôsobom a aj to, že môžu existovať stromy v ktorých sa to nedá.

Prichádza čas na otázku, kedy sa strom nedá zafarbiť. Každý vrchol v storme má nejakú hĺbku. Zoberme si vrcholy v párnych hĺbkach. (koreň je BUNV v hĺbke 0). Z týchto vrcholov všetky hrany idú do vrcholov v nepárnych hĺbkach. Počet zafarbených hrán z vrcholov v párnych hĺbkach sa preto musí rovnať počtu zafarbených hrán z vrcholov v nepárnych hĺbkach. To znamená že musia mať aj rovnakú paritu. Keďže z každého vrchola vedie nepárny počet zafarbených hrán, tak parita počtu vrcholov v párnej hĺbke musí byť rovná parite počtu vrcholov v nepárnej hĺbke na to aby strom išiel zafarbiť. Ak sú rôzne tak práve vtedy sa stane ten prípad že po jednoznačnom zafarbení hrán v strome zistíme že z koreňu vychádza párny počet zafarbených hrán. Ak sú však parity rovnaké práve tento prípad nastať nemôže.

Tento princíp vieme využiť aj na nestromové bipartitné grafy. Teda ak máme ľubovolný komponent tak sa bude dať zafarbiť práve vtedy keď má počet vrcholov na jednej jeho strane a na druhej strane rovnakú paritu. Toto sa dá ľahko dokázať. Ak má počet vrcholov na jednotlivých stranách rôznu paritu a z každého vrcholu vychádza nepárny počet zafarbených hrán potom nám nesedí celkový počet zafarbených hrán z týchto strán(partícii) grafu. Zároveň ak má počet vrcholov rovnakú paritu tak si môžeme z komponentu zobrať jeho kostru. Poďla predchádzajúceho odseku vieme, že táto kostra (strom) sa dá zafarbiť jednoznačným spôsobom a preto existuje aspoň jedno zafarbenie tohoto bipartitného grafu, tak aby boli splnené podmienky zo zadania.

Myšlienka s kostrou je kľúčom k najdôležitejšiemu pozorovaniu úlohy. Uvažujme komponent pre ktorý existuje zafarbenie. Vyberme si z neho ľubovolnú kostru. Všetky ostatné hrany môžeme zafarbiť úplne ľubovolne a stále bude existovať zafarbenie kostry, také aby nám sedela parita v každom vrchole. Ako toto dokážeme? Konštrukciou. Nech všetko v komponente okrem kostry je zafarbené ľubovolne. Teraz poďme zafarbiť hrany v kostre. Opätovne postupujme rekurzívnym prehľadávaním do hĺbky. Keď sa dostaneme k nejakému vrcholu tak najprv zistíme, ako majú byť zafarbené hrany v jeho podstrome. Potom zafarbíme poslednú hranu, ktorá sa ho týka (tú ktorá vedie k jeho otcovi) a to iba v prípade, že pred jej zafarbením by mal vrchol párny počet zafarbených hrán. Takto vieme zafarbiť celý strom okrem koreňu jednoznačným spôsobom. To, že bude mať správnu paritu počtu zafarbených hrán ukážeme nasledovne: Vieme, že počet vrcholov v komponente na jednotlivých stranách (partíciach) má rovnakú paritu. Preto je ich súčet párny. Predstavme si, že by zo všetkých vrcholov vychádzal nepárny počet hrán okrem koreňu z ktorého vychádza párny počet hrán. Potom z vrcholov okrem koreňu celkovo vychádza nepárny počet hrán a z koreňa párny. Celkový súčet počtu vychádzajúcich hrán z vrcholov je nepárny. To je ale v spore s tým že každá hrana vychádza dva krát - raz z každého vrcholu. Preto aj z koreňu musí vychádzať nepárny počet zafarbených hrán.

Ako zistíme počet zafarbení nejakého komponentu? Je to 0, keď je počet vrcholov v komponente nepárny. (Ak je párny tak počet vrcholov na jednotlivých stranách má rovnakú paritu). A je to $2^k$ keď je počet vrcholov v komponente párny, kde $k$ je počet hrán ktoré nie sú v kostre. Každú z nich totiž vieme zafarbiť jedným z dvoch spôsobov. Aký je teda celkový počet možných zafarbení? Je to súčin počtu zafarbení jednotlivých komponentov. Ak je teda nejaký komponent nezafarbiteľný tak je výsledok nula. Inak je to súčin mocnín dvojky, teda súčet exponentov. Takže by sme mohli povedať, že je to $2^{n+m-l}$, kde $n+m$ je počet hrán a $l$ je počet hrán v kostrách jednotlivých komponentov. Všimnime si, že tento počet hrán môžeme zase vypočítať nasledovne. Nech $u$ je počet komponentov. Ak si spojíme kostry, pričom použijeme $u-1$ hrán, tak dostaneme jednu megakostru ktorá bude mať o jednu hranu menej ako je počet vrcholov. ^[Toto vieme z vlastností stromov] Preto je teda celkový počet zafarbení $2^{n+m-((r+s-1)-(u - 1))} = 2^{n+m+u-r-s}$. Vypočítať zvyšok tohoto čísla po delení iným (malým číslom) vieme jednoducho cez známy algoritmus v logaritmickom čase od veľkosti tohoto čísla.

Zostala posledná časť úlohy: Zistiť počet komponentov. O čo by to bolo jednoduchšie keby nám v zadaní nenadiktovali dodatočné hrany...

Zoberme si teda ľubovoľný takýto graf. Bez ujmy na všeobecnosti nech $r>s$. Potom doňho pridáme aspoň $n>=r+s$ hrán. Pozrime sa na tieto hrany podrobnejšie. Prvých $r$ hrán nám spojí každý riadok so stĺpcom, ktorý ma číslo rovnaké, ako číslo riadku modulo počet stĺpcov. Týmto nám v grafe zostane už iba $s$ komponentov. Teraz pridáme ešte $s$ hrán. Každá spoji riadok s číslom $i$ (ktorý je už spojený so stĺpcom číslo i) s riadkom s číslom $i+r \\pmod r$. Nech sú všetky komponenty definované číslom stĺpca ktorý sa v nich nachádza po prvých $r$ hranách. Potom týchto $s$ ďaľších hrán nám spojí pre všetky $i$ stĺpec $i$ so stĺpcom $i+r \\pmod s$. Poďme sa pozrieť na situáciu po pridaní $r+s$ hrán.

Máme $s$ stĺpcov (riadky už môžeme ignorovať lebo ku každému máme už jednoznačne priradený stĺpec, ktorý ho zastupuje. (Riadok $i$ zastupuje stlpec $(i \\pmod s)$. Vieme nasledovné: Stĺpec $i$ je spojený so stĺpcom $i+r \\pmod s$, žiadne ďalšie dodatočné hrany momentálne nemáme. Teda predstavme si to ako situáciu, kde mame nasledovný graf: Každý stĺpec predstavuje jeden vrchol. Stĺpec $i$ je spojený so stĺpcom $i+r \\pmod s$ a so stĺpcom $i-r \\mod s$.

Tvrdím nasledovné: Stĺpec $a$ je v jednom komponente so stĺpcom $b$ práve vtedy, keď $\\gcd(r,s)$ ^\[*Greatest Common Divisor*, po Slovensky najväčší spoločný deliteľ\] delí $a-b$.

Dôkaz: Ak existuje cesta z $a$ do $b$ tak prechádza nejakými vrcholmi. Všimnime si, že dvojice susediacich vrcholov majú rovnaký zvyšok po delení $\\gcd(r,s)$. Preto počas celej cesty prechádzame vrcholmi s rovnakým zvyškom po delení $\\gcd(r,s)$. Ak teda existuje cesta z $a$ do $b$ tak vtedy musia mať $a$ aj $b$ rovnaký zvyšok po delení $\\gcd(r,s)$.

Podobne môžeme dokázať, ze ak $a-b$ delí $\\gcd(r,s)$ tak existuje cesta z $a$ do $b$: Z $a$ sa vieme dostať na najviac $\\frac{s}{\\gcd(r,s)}$ vrcholov vrátane $a$. To je preto, že toľko vrcholov má rovnaký zvyšok po delení $\\gcd(r,s)$ ako $a$. Vieme sa odtiaľ dostať napríklad na vrcholy $(a \\mod s)$, $(a + r \\mod s)$, $(a+2r \\mod s)$, $(a+3r \\mod s)$... Všimnite si, ze napriek tomu že táto postupnosť je nekonečne dlhá, môže obsahovať len konečne veľa čísel. Preto sa niekedy stane že bude obsahovať dva krát to isté číslo a teda sa nutne niekde zacyklí. Zoberme si teda jej najkratší cyklus a zistime aký je dlhý. Pre nejaké $k$ a $j$ nutne platí že $a+kr \\equiv a+jr \\pmod s$. Potom ale $(k-j) r \\equiv 0 \\pmod s$. Počet riadkov $r$ si vieme rozpísať ako súčin $r=x \\cdot \\gcd(r,s)$, kde $x$ je nesúdeliteľné s $s$. Potom dostaneme $(k-j)r \\equiv (k-j) \\cdot x \\gcd(r,s) \\equiv 0 \\pmod s$. Keďže x je nesúdeliteľné nijako nám neovplyvňuje deliteľnosť $s$. Preto $(k-j) \\gcd(r,s) \\equiv 0 \\pmod s$, no nato aby bolo nejaké číslo deliteľné $s$ tak musí byť buď 0 alebo aspoň s. Preto $(k-j)\\gcd(r,s) \\ge s$, teda $k-j >= s/\\gcd(r,s)$ a tým pádom má najkratší cyklus dĺžku aspoň $s/\\gcd(r,s)$. No lenže všimnite si, že už vieme, že v komponente s $a$ bude najviac $s/\\gcd(r,s)$ vrcholov. Preto v komponente s $a$ musia byť práve tie vrcholy ktoré majú rovnaký zvyšok po delení $s/\\gcd(r,s)$.

Pozrime sa ešte na to, čo sa stane ak je $n>r+s$. Všimnite si, že sa vzniknú hrany medzi $(i \\pmod r \\pmod s)$ a $i \\pmod s$. Tieto čísla však zaručene majú rovnaký zvyšok po delení $\\gcd(r,s)$. Preto sa tým už žiadne ďalšie komponenty nespoja.

Tým pádom po pridaní $n$ hrán, budú dva stĺpce v jednom komponente práve vtedy keď $\\gcd(r,s)$ delí ich vzdialenosť.

Všimnite si že takto dostaneme $gcd(r,s)$ komponentov a každý z nich je rovnako veľký, takže si ľahko spočítame ich veľkosť a z toho paritu.

Teraz už zostáva len posledná otázka -- ako si zistiť koľko komponentov vlastne máme, keď ich dodatočne pospájame $m$ hranami. Na tento účel vieme použiť Union-Find, no nebude úplne jednoduché keďže si možno nebudeme vedieť zapamätať všetky vrcholy. Preto spravíme pár drobných zmien. V prvom rade si budeme hlavné vrcholy každého komponentu pamätať v mape namiesto poľa. (Tým pádom si nemusíme pamätať všetky vrcholy, stačia iba tie kde nastala zmena.) Taktiež si budeme pamätať celkový počet komponentov a počet komponentov s nepárnym počtom vrcholov. Okrem toho si zapamätáme o každom komponente či ma párny alebo nepárny počet hrán. Pomocou Union Findu budeme vždy vedieť ľahko zistiť, či hrana spája dva komponenty, ktoré ešte spojené neboli a ak áno, tak budeme vedieť, určiť ktoré to sú. Tým pádom budeme vedieť aktualizovať paritu počtu ich vrcholov a tiež počet komponentov s nepárnym počtov vrcholov. Tým pádom nakoniec budeme vedieť či je komponent s nepárnym počtom vrcholov a koľko komponentov je celkovo v grafe, z čoho budeme vedieť vyrátať odpoveď.

Union find bude potrebovať $O(m log (r+s))$ krokov vzhľadom k tomu že bude uložený v mape. Umocňovanie spravíme na rádovo $\\log (n+m)$ krokov. Najväčší spoločný deliteľ vieme pomocou Euklidovho algoritmu zrátať radovo v čase $O(\\log (r+s))$. Celková časová zložitosť je teda $O(m log ^2 (r+s) + log(n+m))$.
",10
d11b95bab7ee0270,ksp,"# Zabezpečenie

V centrále Kryptografickej Spravodajskej Pobočky berú bezpečnosť veľmi vážne. Nedávno zistili, že niektoré semináre (napríklad Korešpondenčný Seminár z Programovania) nezabezpečujú svoju komunikáciu dostatočne. Preto navrhujú použiť nový Kryptografický Šifrovací Protokol. Je založený na technológii, ktorú používali už v starovekom Ríme.

Text sa zašifruje tak, že každé písmeno textu sa nahradí písmenom, ktoré je v abecede o $k$ pozícií ďalej. Napríklad, ak by sme mali $k=3$, tak všetky *A* sa nahradia písmenom *D*, *B* sa nahradí *E*, *C* sa nahradí *F*... No a v prípade, že by sme potrebovali použiť písmeno, ktoré sa nachádza v abecede za písmenom *Z*, pokračujeme opäť od začiatku abecedy. Písmeno *X* sa preto pri posunutí $k=3$ nahradí za *A*, *Y* za *B* a *Z* za *C*. Medzery medzi slovami zostávajú nezmenené.

No a keďže toto šifrovanie bolo dobré pre Rímske impérium, musí byť dobré aj pre KSP. Avšak doba o pár (tísíc) rokov pokročila, preto skôr než KSP začne používať KŠP odporúčané KSP, musí byť jeho bezpečnosť otestovaná. Práve spúšťame najväčšie testovanie KŠP v histórií KSP^[Ktorého?]. A na to potrebujeme práve teba.

## Úloha

Tvojou úlohou je napísať program, ktorý bude dešifrovať text zašifrovaný pomocou KŠP.

## Formát vstupu

V prvom riadku vstupu je celé číslo $n$, pričom platí $1\\leq n \\leq 20,000$. Nasleduje $n$ riadkov, každý obsahuje text pozostávajúci z veľkých písmen anglickej abecedy a medzier, ktorý je určený na dešifrovanie. Dĺžka riadku nepresiahne $100$ znakov. Je známe, že každý text, pred tým ako bol zašifrovaný, začínal *V MENE KSP*.

## Formát výstupu

Pre každý riadok textu na vstupe vypíšte do samostatného riadku dešifrovaný text (taktiež tvorený veľkými písmenami anglickej abecedy a medzerami).

## Príklad

```vstup
3
W NFOF LTQ WTFUDJ NVTJB OPTJU SVAPWF TVLOF
V MENE KSP NEZABUDAJTE POUZIVAT SIFROVANIE
L CUDU AIF FHEWHQCELQDYU ZU IKFUH
```

```vystup
V MENE KSP VSETCI MUSIA NOSIT RUZOVE SUKNE
V MENE KSP NEZABUDAJTE POUZIVAT SIFROVANIE
V MENE KSP PROGRAMOVANIE JE SUPER
```

*V prvom riadku je posun $k=1$, v druhom sa text vôbec nedešifroval, teda $k=0$ a v treťom je $k=16$.*

## Nápoveda

V prípade, že nevieš, ako spracovávať text, nasledujúce odstavce sú určené práve pre teba.

V programovacích jazykoch máme okrem číselných premenných typu `int`, `integer` aj premenné na ukladanie znakov, ktoré zvyknú byť označované `char`. Premenná typu `char` má v podstate uložené číslo od $0$ po $256$ v Pascale (od $-128$ po $127$ v C++), pričom každému číslu zodpovedá nejaký znak: napríklad kde napríklad číslu $65$ zodpovedá písmeno `'A'`, číslu $66$ zodpovedá písmeno `'B'` atď. -- pozri si ASCII tabuľku na odkaze [www.asciitable.com](http://www.asciitable.com/).

## Nápoveda -- PASCAL

Na načítanie jedného znaku zo vstupu do premennej typu `char` môžeme použiť funkciu `read(c)`. Pole znakov dĺžky 255 (`var s : array[0..255] of char`) sa nazýva `string` (na nultej pozícii uložená je dĺžka `string`u, `s[1]` je prvý znak, `s[n]` je $n$-tý znak). Na načítanie celého riadku do premennej `s` typu `string` sa používa `readln(s)`. Dĺžku tohto stringu zistíme príkazom `length(s)`. Znaky konca riadku sa nenačítajú. ASCII hodnotu daného znaku (jeho číselný kód) vieme zistiť pomocou `ord(c)`. Ak chceme získať znak z jeho kódu (opačný smer ako `ord`) použijeme `chr(cislo_znaku)`. Napríklad `writeln(ord('A'))` vypíše 65. Ak by sme napísali `writeln(chr(ord('A')))`, tak program vypíše `A`, pretože `chr` zoberie hodnotu znaku `A` vrátenú `ord` a vráti daný znak.

## Nápoveda -- C++, iostream

Premennú typu `char` môžeme považovať za jednobajtové číslo alebo za jeden znak. V prípade, že používame knižnicu iostream (`#include <iostream>`) môžeme jeden znak načítať nasledovne: `cin >> c`, kde `c` je typu `char`. Ak chceme znak vypísať: `cout << c`. Ak chceme vypísať jeho číslo: `cout << int(c)` -- takto už program vie, že ten kus pamäte, čo považoval za `char`, má považovať za `int`. Na prácu s reťazcami znakov sa dá využiť typ *string*. Prístup k $n$-tému znaku stringu `s` je podobný ako v Pascale (**ale nie rovnaký**): `s[n-1]`. V C++ a podobných jazykoch sa totiž indexuje od nuly (takže prvý znak je `s[0]`). ^\[`string` v C++ je v skutočnosti `vector<char>` s nejakými dodatočnými funkciami.\]

Keď chceme číslo vypísať ako znak, môžeme to spraviť nejako takto: `cout << char(66);` vypíše `B`, keďže práve `B` má hodnotu 66. Funkcia `s.size()` vráti dĺžku `s`. Vtipnou záležitosťou sú ""biele znaky"" (*whitespace characters*) -- to sú tie, ktoré nevidíme (medzera, tabulátor, enter). `cin >> s` štandardne načíta text iba po prvý biely znak. Na načítanie celého riadku do `string`u `s` môžeme použiť `getline(cin,s)`.

V C++ vieme s `char` pracovať aj ako s číslom, napríklad `'B'+1` je `'C'`.

## Nápoveda -- C++, cstdio

Ukážeme si jednoduchý program, ktorý najprv načíta jedno číslo, potom načítava znaky až po koniec riadku (znak `'\n'`) a tento riadok vypíše. Následne načíta dve slová (slová sú oddelené bielymi znakmi) a vypíše ich na samostatné riadky.

```
#include <cstdio>
int main(){
    int cislo;
    char znak;
    char slovo[256];
    scanf(""%d"", &cislo);
    while(scanf(""%c"", &znak)>0 && znak!='\n') printf(""%c"", znak);
    printf(""\n"");
    scanf(""%s"", slovo);
    printf(""%s\n"", slovo);
    scanf(""%s"", slovo);
    printf(""%s\n"", slovo);
}
```

Odporúčame spustiť si tento program na ukážkovom vstupe zo zadania.
","# Zabezpečenie

Vo všeobecných šifrách potrebujeme na dešifrovanie poznať šifrovací algoritmus a kľúč na dešifrovanie. Šifrovací algoritmus už poznáme -- je popísaný v zadaní. Pravdepodobne nebude problém celý proces obrátiť a dešifrovať text. Avšak na to potrebujeme kľúč -- v našom prípade číslo udávajúce posun v abecede. Tento kľúč zatiaľ nepoznáme, preto ho musíme zistiť z jednotlivých správ.

Na začiatok, keď nevieme prísť na nejaký prefíkaný spôsob, ako odhaliť kľúč, môžeme skúšať všetky možné kľúče, kým použitie jedného nevráti zmysluplný dešifrovaný text. V našom jednoduchom príklade spoznáme ""zmysluplný"" text tak, že na jeho začiatku sa nachádza *V MENE KSP*. Môžeme teda v cykle postupne prechádzať všetky možné posuny. Pre každý posun ""zmenšíme"" každé písmeno o 1, a v prípade, že by sme sa mali dostať pod *A*, tak pokračujeme od *Z*. Po takomto pokuse o dešifrovanie overíme, či text začína v *V MENE KSP*.

Predošlé riešenie má časovú zložitosť $O(n \\cdot k)$, kde $n$ je maximálna dĺžka textu a $k$ je počet možných kľúčov. V našom prípade riešenie nie je až také zlé, keďže texty sú pomerne krátke a písmen v abecede je len 26.

Keby však správa mohla pozostávať zo všetkých ASCII znakov, alebo nebodaj z UTF-8 znakov a bola by veľká niekoľko gigabajtov, bol by to už trochu problém. Existuje však aj rýchlejšie a jednoduchšie riešenie.

Vieme, že prvý znak textu (označme ho $e$) musel vzniknúť zašifrovaním *V* (lebo to je prvé písmeno *V MENE KSP*). Kľúč môžeme jednoducho vypočítať ako hodnotu $e-V$.

V niektorých programovacích jazykoch ako napríklad C++ môžeme pracovať so znakmi priamo ako s číslami, napríklad `'D'-'A'` bude číslo $3$. V iných jazykoch musíme najprv konvertovať znaky na čísla. `ord('D')-ord('A')` bude mať hodnotu $3$.

Tiež ak nám vadí, keď vyjde záporná hodnota ($F-V$ je $-16$), môžeme k tomuto číslu pričítať hodnotu $26$.

Akonáhle vypočítame $k$, stačí dešifrovať text podobne ako v predošlom riešení, a keďže už vieme správny kľúč, stačí odčítavať od každého znaku iba raz. Takto dostaneme časovú zložitosť $O(n)$. Pamäťovú zložitosť vieme mať dokonca $O(1)$, keby sme vstup načítavali postupne znak po znaku a rovno vypisovali výsledok, ale pre jednoduchosť budeme načítavať celý riadok do pamäte naraz.
",2
db026532a7d6cfa9,ksp,"# Objednaná elektronika

Adam, Buj, Cecília^[Naozaj neexistuje KSPák, ktorého meno sa začína na C.] a Dávid nedávno zistili, že každému z nich chýba nejaký kus elektroniky. Adamovi chýba server, Bujovi lietajúci dron, Cecílii elektrická zubná kefka a Dávidovi obrazovka s ešte väčším rozlíšením, ako má teraz. Čo teda spravili? Išli na stránku Internetového obchodu s najotravnejšou reklamou na svete^[ Ďalej len IONRS.] a objednali si, čo potrebovali.

I nastal deň, keď si všetci štyria mali vyzdvihnúť svoju objednávku. Prišli preto do centrály IONRS, zaplatili a každý z nich dostal papierik, na ktorom bolo napísané nejaké číslo a ich meno^[Keby náhodou prišli do predajne ľudia s rovnakým menom, treba ich odlíšiť číslami.]. Následne sa zaradili do množstva ľudí čakajúcich na výdaj. V IONRS to totiž funguje tak, že objednané (a už zaplatené) predmety prichádzajú zo skladu na bežiacom páse, kde ich zloží šikovná pracovníčka, vyhlási číslo a meno priradené k danému predmetu a príslušný človek si ho ide zobrať.

Naši štyria kamaráti teda počúvali vyvolávané čísla a čakali, kedy odznie to ich. Ako prvý prišiel na rad Adam so svojím serverom. O niečo neskôr bolo vyvolané Bujove číslo a on si radostne začal rozbaľovať svojho drona. Keď už dron lietal, prišla po páse Cecíliina zubná kefka a posledný prišiel na rad Dávid.

Keď sa vracali z tohto výletu, stretli na ulici vešticu, a tá sa ich spýtala, aké čísla mali v IONRS na papierikoch. Tvrdila totiž, že sa podľa toho dá odhadnúť ich budúcnosť. Ak by v tom čísle boli samé štvorky a sedmičky, mali by nesmierne šťastie, pokiaľ ale spomenuté číslo bolo deliteľné trinástkou, nemuselo by to pre nich dopadnúť práve najlepšie.

Naši hrdinovia však zistili, že si svoje čísla nepamätajú a papieriky odovzdali, keď si vyzdvihovali nákup. Pamätali si len, že súčin Adamovho a Bujovho čísla bol rovnaký, ako súčin Cecíliinho a Dávidovho. Na internete sa tiež dá pozrieť zoznam čísel vyhlásených v daný deň, samozrejme už bez priradených mien a predmetov. Teraz by chceli vedieť, koľko takých štvoríc čísel zo zoznamu mohlo patriť im. Ak by tam bola len jedna, bolo by to jasné...

## Úloha

Na vstupe dostanete postupnosť $n$ čísel, označme si ich postupne $x_1$ až $x_n$. Nájdite počet všetkých rôznych štvoríc $(a,b,c,d)$, pre ktoré platí, že

- $x_a \\cdot x_b = x_c \\cdot x_d$
- $1 \\leq a < b < c < d \\leq n$

($a$, $b$, $c$, $d$ vyjadrujú pozíciu Adamovho, Bujovho, Cecíliinho a Dávidovho čísla v zozname.)

## Formát vstupu

Na prvom riadku je číslo $n ~ (1 \\leq n \\leq 1,000)$ -- počet čísel v postupnosti.

Na druhom riadku sa nachádza $n$ čísel oddelených medzerou, $x_1$ až $x_n$, čiže jednotlivé čísla, ktoré boli vyhlásené v IONRS. Platí, že $0\\leq x_i\\leq 10^9$.

## Formát výstupu

Na výstup vypíšte jedno číslo -- počet takých štvoríc $a$, $b$, $c$ a $d$, že $x_a\\cdot x_b = x_c \\cdot x_d$ a $1 \\leq a < b < c < d \\leq n$.

## Príklady

```vstup
5
1 12 3 4 3
```

```vystup
2
```

*Buď mali čísla $1,12,3,4$ alebo $1,12,4,3$.*

```vstup
6
1 1 1 1 1 1
```

```vystup
15
```

*Ľubovoľná štvorica spĺňa $x_a \\cdot x_b = x_c \\cdot x_d$*

```vstup
10
1 2 3 4 5 6 7 8 9 10
```

```vystup
0
```

*Ak by boli vyhlásené tieto čísla, tak určite $x_a \\cdot x_b < x_c \\cdot x_d$*
","# Objednaná elektronika

## Hrubá sila

Máme zistiť, koľko rôznych kombinácií štyroch čisel zo vstupu je dobrých. Teda, koľko je štvoríc $(A, B, C, D)$ takých, že $x_A \\cdot x_B = x_C \\cdot x_D$ a $1 \\leq A < B < C < D \\leq n$. Spravíme to teda prvým spôsobom, ktorý nás napadne -- vyskúšame všetky štvorice. Tento bruteforce spravíme vnorením štyroch for-cyklov a jeho časová zložitosť je $O(n^4)$.

## Nepočítajme nič dvakrát

Problém s naším riešením je, že veľa vecí v ňom počítame stále dookola. Pre každú kombináciu indexov $A, B$ totiž raz prejdeme celý zvyšok poľa, kde kontrolujeme súčin čísel na pozíciách $C, D$. Ak by sme vedeli využiť informáciu o súčinoch $C, D$ viackrát, bez prechádzania poľa, mohli by sme náš algoritmus výrazne zrýchliť.

Rovnako dobré by bolo, keby sme vedeli rýchlo nájsť počet dvojíc indexov $A, B$ pre konkrétne $C, D$.

Vezmime si nasledujúce riešenie hrubou silou: postupne vyberáme dvojice $C, D$, a pre ne počítame výskyty dvojíc $A, B$ s rovnakým súčinom.

Zo zadania vieme, že $A, B$ sú vždy naľavo od $C, D$. Náš algoritmus teda prejde všetky dvojice čísel naľavo od $C$ a porovná ich súčin s $x_C \\cdot x_D$. Keď prejde všetky, tak si posunie $D$ doprava a začne počítať od začiatku. Keď program doráta všetky $D$, tak si posunie $C$, nastaví nové $D$ na $C+1$ a znova prezerá dvojice $A, B$ a posúva $D$, kým skontroluje všetky.

Pozrime sa na výpočet pre konkrétne $C$. Všimnime si, že pre každé $D$ hľadáme jemu príslušné $A, B$ medzi tými istými číslami. Nám však stačí, ak si na začiatku raz **predrátame počet výskytov súčinov $x_A \\cdot x_B$**. Potom už pre jednotlivé $D$ vieme rýchlo zistiť, koľko dvojíc $A, B$ má súčin $x_C \\cdot x_D$.

Takto si pre každé $C$ najprv spočítame počty dvojíc $A, B$ s rôznymi súčinmi, uložíme si počty do nejakej dátovej štruktúry a potom stačí posúvať $D$ a rýchlo vyberať z dátovej štruktúry počty dvojíc s daným súčinom $x_C \\cdot x_D$. Ak by sme odhadli čas vkladania/výberu z dátovej štruktúry ako $O(t)$, mohli by sme odhadnúť čas potrebný pre tento algoritmus ako $O\\left(n \\cdot (tn^2 + tn)\\right) = O(tn^3)$.

Keď už sme zrýchlili výpočet pri posúvaní $D$, pozrime sa, čo vieme zlepšiť na posúvaní $C$. Tu si môžeme všimnúť, že po posunutí $C$ sú počty súčinov vľavo od neho skoro také isté, ako pri starom $C$. Všetko, čo sa stalo je, že sme pridali súčiny so starým $C$ -- možnosti, kde sa vybrané $B$ rovná starému $C$. Teda keď si posunieme $C$, tak nemusíme zahodiť všetky predpočítané súčiny, ale stačí k nim pridať tieto nové.

Pre každé $C$ si teda do dátovej štruktúry najprv pridáme súčiny dvojíc prvkov na pozíciách $A$ a starého $C$ a potom opäť posúvame $D$ a vyberáme záznamy o počtoch dvojíc s požadovaným súčinom, čo trvá $O(tn + tn)$. Čas tohto algoritmu vieme odhadnúť ako $O\\left(n \\cdot (tn + tn)\\right) = O(tn^2)$.

## Ako si pamätať počty dvojíc s rovnakými súčinmi?

Už len zostáva vymyslieť, ako si počet súčinov zapamätáme -- akú dátovú štruktúru použijeme. Najjednoduchšie by bolo ukladať si počty do poľa, kde index bude hodnota súčinu. Avšak súčiny môžu nadobúdať hodnoty až $10^{18}$, a pole s takouto veľkosťou sa nám do pamäte nezmestí. Čísel na vstupe je ale najviac $1,000$, čiže rôznych súčinov bude najviac $10^6$. Ak by sme použili pole, väčšina indexov by teda mala hodnotou $0$, a sem-tam by sa nám tam objavila iná hodnota.

Našťastie, problém, ako si zapamätať a rýchlo pracovať s rozumne malým počtom ($10^6$) veľkých záznamov, už niekto vyriešil. Použijeme dátovú štruktúru [map](http://www.cplusplus.com/reference/map/map/), ktorá nám dovolí ukladať si dvojice `<súčin, počet dvojíc indexov A, B s daným súčinom>` tak, ako budeme potrebovať, ale nebude si zbytočne ukladať hodnoty, ktoré nepotrebujeme.

## Zložitosť

Podľa toho, či si zvolíme implementáciu mapy ako binárneho vyhľadávacieho stromu (`map`) alebo ako hashovacej tabuľky (`unordered_map`) dostaneme časovú zložitosť vkladania/upravovania/čítania $t = O(\\log n)$ alebo $t=O(1)$, teda celkovo $O(n^2 \\log n)$ alebo $O(n^2)$, keď použijeme predošlé odhady.

Pre pamäť si zoberieme najhorší prípad. Ak sú súčiny čísel na vstupe rôzne, tak si musíme do mapy uložiť $n(n-1)$ čísel. Pamäťová zložitosť bude teda $O(n^2)$
",8
8e533f06c73b5d51,ksp,"﻿# Ako priečinky robia radosť

Každý rok sa v T2 koná Každoročná Slávnosť Priečinkov (KSP). Vedúci púšťajú hity z entertainmenta, popíjajú kofolu a pun-ishujú sa tými najhoršími slovnými hračkami, aké ste kedy počuli.

Odovzdávajú si tiež priečinky! Konkrétne, vedúci ktorí majú v skrini vlastný priečinok ho niekedy prenechajú novému prvákovi. Priečinky sú veľmi praktické - môžu si v nich nechávať zošity do školy, materiály o najbližšom sústredení, pokazené routery, nedojedené desiaty...

Využitie priečinku sa však časom často mení. Niektorí ho v prváku naplnia vecami a potom naňho zabudnú. Iným príde najprv nepodstatný a až po rokoch zistia, že sa bez neho zrazu nezaobídu.

Z historických záznamov máš o mnoho vedúcich informácie o ich narábaním s priečinkami.

Presnejšie, o vedúcom číslo $i$ vieš, že sa stal prvákom v roku $p_i$ a priečinok využíval $a_i$ veľa, zatiaľ čo ho už chcel odovzdať v roku $o_i$ keď svoj priečinok využíval $b_i$ veľa. Samozrejme, prenechal ho na KSP len takému prvákovi, ktorý by jeho priečinok využil ostro viac ako on.

Môže sa stať, že vedúci $x$ odovzdá svoj priečinok prvákovi $y$, ktorý neskôr odovzdá svoj priečinok prvákovi $z$ a tak ďalej. Takúto sériu odovzdávaní nazveme `životná púť` priečinka. Keď vedúci $x$ odovzdá priečinok vedúcemu $y$, využitie priečinka stúpne o $a_y - b_x$. Radosť, ktorú priečinok prináša vedúcemu, ktorý ho vlastní, je úmerná jeho využitu -- preto túto hodnotu nazývame `radosť odovzdávania`. `hodnota` životnej púte priečinka je súčet radostí odovzdávania, ktoré počas tejto púte nastali.

Zo záznamov nie je jasné, kto komu priečinok naozaj aj odovzdal. Životné púte priečinkov sú tak stratené v histórií. Nič ti však nebráni upustiť uzdu fantázií, a predstaviť si tie najlepšie, najhodnotejšie púte, ktoré priečinky v T2 mohli zažiť. Keďže však musíme fantázií pokladať nejaké medze, predstavíš si len $k$ najhodnotnejších z nich...

## Úloha

Zistite, akých $k$ najhodnotnejších životných pútí sa mohlo počas rokov KSP odohrať. Dve životné púte priečinka považujeme za rôzne, ak sú postupnosti vedúcich, ktorí ho vlastnili, iné.

Nemusíš nám ich detailne vypisovať. Stačí, ak vypíšeš súčet ich hodnôt modulo $10^9+7$.

## Formát vstupu

V prvom riadku vstupu sú čísla $n$ a $k$, udávajúce počet vedúcich, o ktorích máš záznam a počet najhodnotnejších životných pútí, ktoré ťa zaujímajú.

V $i$-tom z nasledujúcich $n$ riadkov sú štyri čísla $p_i$, $o_i$, $a_i$ a $b_i$.

Platí $1 \\leq p_i < o_i \\leq 10^9$, $1 \\leq a_i, b_i \\leq 10^9$ a $1 \\leq n \\cdot k \\leq 10^6$.

V jednotlivých sadách platia nasledujúce obmedzenia pre $n$ a $k$:

| Sada | 1 | 2 | 3 | 4 | |:-----------------------|---------:|----------:|---------:|---------:| | $1 \\leq n \\leq$ | $20$ | $1,000$ | $10^6$ | $10^6$ | | $1 \\leq k \\leq$ | $20$ | $1$ | $1$ | $10^6$ |

## Formát výstupu

Vypíš jeden riadok a v ňom jedno celé číslo - súčet hodnôt $k$ najhodnotnejších životných pútí, ktoré mohli počas rokov KSP nastať, modulo $10^9+7$. Ak ich mohlo nastať menej ako $k$, vypíš súčet všetkých z nich (stále modulo $10^9+7$).

## Príklady

```vstup
5 1
1 2 10 9
1 4 7 11
2 4 15 16
4 5 20 1
5 7 2 5
```

```vystup
11
```

*Najhodnotnejšia možná životná púť priečinka je, aby prvý vedúci odovzdal priečinok tretiemu, ten potom štvrtému a ten nakoniec piatemu.*

```vstup
5 4
1 2 10 9
1 4 7 11
2 4 15 16
4 5 20 1
5 7 2 5
```

```vystup
40
```

*Druhá a tretia najhodnotnejšia púť sú prvý-tretí-štvrtý, druhý-štvrtý-piaty s hodnotou 10. Štvrtá najhodnotnejšia púť, s hodnotou 9, je druhý-štvrtý*

```vstup
3 1
1 1000000 1 1
1000000 50000000 1000000000 1
50000000 1000000000 1000000000 474747
```

```vystup
999999991
```

*Najhodnotejšia púť je prvý-druhý-tretí s hodnotou $(1000000000-1)+(1000000000-1)=1999999998$, modulo $10^9+7 = 999999991$*

```vstup
10 1
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
10
```

```vstup
10 5
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
45
```

```vstup
10 25
1 2 1 4
1 3 5 3
3 5 7 2
2 4 6 9
2 3 7 5
3 5 8 2
1 8 9 1
4 5 10 3
5 8 6 47
8 9 10 5
```

```vystup
113
```

*Existuje len 22 životných pútí, sčítame teda všetky*
","# Ako priečinky robia radosť

Prevedieme si najprv úlohu do informatickej terminológie. Vedúci sú vrcholy, a odovzdanie priečinka je orientovaná hrana -- ak vedúci $x$ vie odovzdať vedúcemu $y$ priečinok s radosťou odovzdávania $a_y - b_x$, tak z vrcholu $x$ vedie hrana do vrcholu $y$ s váhou $a_y - b_x$. Životná púť priečinka je teda cesta v tomto grafe, a hodnota je súčet váh hrán na nej.

Môžeme si o tomto grafe navyše všimnúť, že je acyklický, keďže každý vedúci vie odovzdať priečinok v ostro neskoršom roku, ako ho dostal. Je to teda DAG (directed acyclic graph).

## N < 20 znamená...

...že použijeme starú dobrú hrubú silu, a prejdeme si všetky možné púte priečinka. Skúsime začať v každom vrchole, pozrieme sa na všetky ostatné, a rekurzívne pokračujeme do každého, do ktorého vedie hrana.

Hodnotu každej púte, ktorú spracujeme si odložíme, a po prehľadávaní ich usporiadame a sčítame $k$ najhodnotejších z nich.

Aby sme určili zložitosti, musíme zistiť, koľko ciest vie existovať v orientovanom acyklickom grafe. Môžeme využiť fakt, že v takomto grafe je cesta jednoznačne určená množinou vrcholov v nej, keďže cez vrcholy na ceste vieme ísť len v jednom poradí, a bez cyklov sa nemôžu ani opakovať. Samozrejme, nie každá podmnožina vrcholov tvorí platnú cestu, ale každá platná cesta je určená podmnožinou, dáva nám teda horný odhad. Počet podmnožín $n$ vrcholov je $O(2^n)$, toľko ciest teda v najhoršiom prípade nájdeme. Každá cesta má najviac $n$ vrcholov, a v každom vrchole prejdeme zvyšné vrcholy aby sme skúsili cestu predĺžiť, náš odhad časovej zložitosti je teda $O(n^2 2^n)$, a pamäťovej $O(2^n)$.

## Najdrahšia cesta v DAGu

Poďme teda vymyslieť niečo prefíkanejšie ako skúšanie všetkých možností. Počet ciest v našom grafe je exponenciálny, ale nás z nich zaujíma len málo z nich -- v ďalších dvoch sadách dokonca len jedna, tá najdrahšia.

Skúsme teda nájsť najdrahšiu cestu tak, že si pre každý vrchol zistíme najdrahšiu cestu, ktorá končí v ňom -- naša celková najdrahšia cesta musí končiť v niektorom vrchole, bude teda jednou z nich.

Môžeme si napríklad všimnúť, že ak máme cestu prechádzajúcu vrcholmi $v_1, v_2, \\cdots, v\_{d-1}, v_d$ kde $d$ je jej dĺžka, tak ak je to najdrahšia cesta končiaca vo $v_d$, tak cesta $v_1, v_2, \\cdots, v\_{d-1}$ je najdrahšia cesta končiaca vo $v\_{d-1}$. Ak by totiž bola iná cesta ktorá je drahšia a končí vo $v\_{d-1}$, tak by sme ju mohli napojiť na $v_d$ a získať drahšiu cestu ako tú s ktorou sme začali, čo je v rozpore s tým že sme začali s najdrahšou cestou končiacou vo $v_d$.

Z tohto pozorovania vyplýva, že na nájdenie najdrahšej cesty končiacej vo vrchole $v$ stačí nájsť najdrahšie cesty končiace vo vrcholoch, z ktorých sa vieme priamo dostať do $v$, a najdrahšia cesta bude jedna z nich plus cena hrany, ktorou sa na ňu napojíme.

Stačí nám teda prejsť vrcholy vo vhodnom poradí, aby sme vždy zrátali cenu najdrahšej cesty pre nejaký vrchol $v$ skôr, ako ju budeme rátať pre vrcholy do ktorých sa vieme dostať z $v$. Keďže vieme, že vedúci môže odovzdať priečinok len takému vedúcemu, ktorý príde do KSP až po ňom, môžeme si vedúcich zoradiť podľa roku príchodu, a prejdeme ich v tomto poradí.

Nakoniec vypíšeme cenu najdrahšej cesty, ktorú sme takto našli.

Keďže pre každého vedúceho prejdeme každého, ktorý prišiel po ňom, budeme mať časovú zložitosť $O(n^2)$. Pre každého si okrem vstupných hodnôt pamätáme len jednu premennú navyše -- najdrahšiu cestu končiacu v ňom -- pamäť bude $O(n)$.

## Najdrahšia cesta v priečinkovom DAGu

V predošlom riešení skúšame veľa nezmyselných dvojíc vedúcich, aj takých, ktorí si nevedia odovzdať priečinok (lebo prvý neodchádza v roku, v ktorom druhý prichádza).

Rozdeľme si teda vedúcich na kôpky -- nech $P_r$ je zoznam vedúcich ktorí prichádzajú v nejaký rok $r$, a $O_r$ je zoznam vedúcich ktorí odchádzajú v rok $r$. Každý vedúci sa vyskytne raz na zozname prichádzajúcich, a raz na zozname odchádzajúcich.

Ak chceme prechádzať vedúcich podľa roku príchodu, prejdeme kôpky vedúcich v $P$ pre postupne stúpajúce roky $r$ (len tie, ktoré boli na vstupe). Potom ich skúšame napojiť na najdrahšie cesty končiace vo vedúcich v $O_r$, keďže priečinky vedia dostať len od nich.

Stále však môžeme mať až kvadraticky veľa dvojíc -- napríklad ak polovica vedúcich odchádza v jednom roku, a druhá polovica vedúcich v tomto roku prichádza.

Skúsme teda namiesto toho, aby sme pre každého prichádzajúceho vedúceho $v$ skúšali všetkých vedúcich, ktorí odchádzajú v rovnaký rok (a majú menšiu hodnotu priečinka) a napojiť sa na ich cestu, priamo určiť, ktorá z nich bude najdrahšia po napojení na $v$.

Zoberme si teda príkladového vedúceho $v$, ktorý príde a bude mať hodnotu priečinka $p$, a majme dve cesty na ktoré sa vieme napojiť -- jednu s hodnotou $h$, končiacu vo vedúcom ktorý ešte využíva svoj priečinok na $o$, a druhú s hodnotami $H$, $O$.

Akú hodnotu budú mať tieto cesty po napojení na $v$? Prvá cesta bude mať $h+(p-o)$, a druhá $H+(p-O)$. Aby bola prvá cesta drahšia ako druhá, $h+(p-o) > H+(p-O)$, tak $h-o > H-O$. Stačí teda zobrať cestu, ktorá má túto hodnotu (určenú jej hodnotou a vedúcim, v ktorom končí) najväčšiu, a tú napojiť na vedúceho $v$. Všimnime si, že na ktorú cestu je najlepšie sa napojiť nezávisí od využitia $p$, ktorý pre priečinok má prichádzajúci vedúci -- jediné čo musíme dodržať je, aby cesty ktoré uvažujeme končili vo vedúcich, ktorí sú mu ochotní priečinok odovzdať.

Usporiadajme si teda vedúcich ktorí prichádzajú a odchádzajú v daný rok, poďla ich využitia priečinka, a prejdime ich v tomto poradí. Udržiavame si pritom vyššie popísanú hodnotu najlepšej doposiaľ nájdenej cesty. Keď prídeme na odchádzajúceho vedúceho, pozrieme sa či cesta, ktorá v ňom končí nie je lepšia ako tá čo sme mali doteraz, a ak áno, prepíšeme si ju. Keď prídeme na prichádzajúceho vedúceho, priradíme mu hodnotu najlepšej cesty, plus jeho využitie priečinka v prváku, tiež ako popísané vyššie.

Takto vieme nájsť najdrahšiu cestu končiacu v každom vedúcom, pričom však nepozeráme na všetky možné odovzdávanie medzi nimi, pozrieme sa len na každého vedúceho práve raz.

V prípade, že sa všetci vedúci vyskytnú v jeden deň, nám ich usporiadanie zaberie $O(n \\log n)$. Pamäť ostane na $O(n)$.

## A teraz už len trochu všeobecnejšie...

Čo potrebujeme, aby sme toto riešenie rozšírili ak nás nezaujíma len najdrahšia cesta, ale $k$ najdrahších ciest? Pôjdeme na to rovnako -- pre každý vrchol si zapamätáme $k$ najdrahších ciest, ktoré v ňom končia. Tu využijeme podmienku zo zadania, že $n \\cdot k \\leq 10^6$, čiže síce vedia byť $n$ aj $k$ veľké, nemôžu byť veľké naraz, a vieme si tieto cesty zapamätať -- bude ich najviac $n \\cdot k$.

Analogicky, aby sme našli $k$ najdrahších ciest končiacich v danom vrchole, musíme skúsiť $k$ najlepších ciest ktoré sa na neho môžu napojiť (ktorých hodnota mínus využitie priečinka vedúceho, v ktorom končia, je najvyššia).

Namiesto jednej hodnoty najlepšej cesty, si teda budeme pamatäť usporiadanú množinu najlepších ciest. Budeme prechádzať vedúcich rovnako ako v predošlom riešení. Keď spracujeme prichádzajúceho vedúceho, vypočítame jeho najlepších (najviac) $k$ ciest ktoré v ňom končia. Keď spracujeme odchádzajúceho vedúceho, hodnoty jeho ciest pridáme do našej množiny, a ak ich v nej je viac ako $k$, zahodíme tie najhoršie.

Počas spracovania prichádzajúcich vedúcich, ktorých je dokopy $n$, vypočítame najviac $k$ najdrahších ciest ktoré v nich končia, spravíme teda $O(nk)$ operácií. Počas spracovania odchádzajúcich vedúcich, ktorých je tiež dokopy $n$, vypočítame hodnoty ciest ktoré v nich končia, a pridáme ich do našej usporiadanej množiny. Ak použijeme rozumnú dátovú štruktúru (napr. v C++ `multiset`), pridávanie hodnoty do, a odstraňovanie najmenšej hodnoty z nej nás bude stáť $O(\\log k)$ operácií, ak jej veľkosť je $O(k)$. Za každého odchádzajúceho vedúceho teda spravíme v najhoršom prípade $O(k \\log k)$ práce, dokopy teda $O(nk \\log k)$. Spolu s usporiadaním vedúcich aby sme ich prešli v správnom poradí teda spravíme $O(n(\\log n + k \\log k))$ operácií.

Pamäťová zložitosť bude $O(nk)$, keďže si pre každého vedúceho pamätáme najviac $k$ hodnôt ciest.
",10
5129029332c35051,ksp,"# Prestavba bytu

Krtko rekonštruuje byt. Posledné, čo mu zostáva je vydláždiť novú kúpeľňu. Zhodou náhod sa mu v schránke objavil leták obľúbeného veľkoskladu - Kúpeľňového Sveta Podláh - a v ňom zľava na dlaždice L-kového tvaru. Táto ponuka bola natoľko lákavá, že Krtko nakúpil oveľa viac dlaždíc, ako potreboval. Teraz sedí pred svojou dokonalou dokonalo-štvorcovou kúpeľňou a premýšľa, či on vôbec bude vedieť pomocou týchto kachličiek svoju kúpeľňu vydláždiť. Akoby nestačilo, v jeho inak príjemne dokonalo-štvorcovej kúpeľni sa nachádza otvor na odtok sprchy, ktorý nemôže kachličkami prekryť. Pomôžte Krtkovi vydláždiť jeho kúpeľňu alebo zistite, že to nie je možné.

## Úloha

Štvorcovú kúpeľňu si môžeme predstaviť ako štvorcovú sieť $n \\times n$. Pre dokonalo štvorcovú kúpeľňu navyše platí, že veľkosť jej strany $n$ je mocnina dvojky. Odtok zaberá v myslenej sieti práve jedno celé políčko. Pod dlaždicou L-kového tvaru myslíme tri štvorce veľkosti $1 \\times 1$, spojené do tvaru L.

Vykachličkovanie je možné, ak pomocou L-kových kachličiek vieme prekryť všetky voľné miesta v našej kúpeľni (okrem odtoku) bez toho, aby sme nejaké kachličky akokoľvek delili alebo ľubovolne prekrývali. Taktiež sa nesmie stať, že by nejaká kachlička vyčnievala z kúpeľne. Samozrejme, nakúpené kachličky je možné akokoľvek otáčať. Kachlička teda môže byť orientovaná 4 rôznymi spôsobmi.

Na vstupe od nás dostanete veľkosť kúpeľne. Ďalej od nás dostanete pozíciu odtoku. Ak je možné kúpeľňu takýchto rozmerov s odtokom na danom mieste vykachličkovať iba pomocou nakúpených L-kových kachličiek, vypíšte ľubovolné takéto vykachličkovanie. Ak to možné nie je, podajte o tom správu.

## Formát vstupu

Na prvom riadku vstupu sa nachádza číslo $n$ $(1 \\leq n \\leq 256)$ -- dĺžka hrany štvorca reprezentujúceho kúpeľňu, pričom platí, že $n$ je mocnina 2. V ďalšom riadku nasleduje dvojica čísel $r, s$ $(1 \\leq r, s \\leq n)$ -- číslo riadku a stĺpca v našej mriežke, kde sa nachádza odtok.

## Formát výstupu

Ak vykachličkovanie nie je možné, vypíšte na jeden riadok výstupu reťazec `Neda sa`. Inak si označme všetky použité kachličky číslami od 1 do $x$, kde $x$ je ich počet (je zrejmé, že $x = (n^2-1) \\div 3$). Na výstup vypíšte $n$ riadkov. V každom takomto riadku sa má nachádzať $n$ medzerou oddelených reťazcov. Ako $j$-ty reťazec v $i$-tom riadku vypíšte číslo kachličky, ktorá prekrýva poličko v $i$-tom riadku a $j$-tom stĺpci mriežky alebo vypíšte znak `X` ak sa na danom políčku nachádza odtok. Korektných riešení môže byť viac (napríklad prečíslovaním kachličiek dostaneme z jedného korektného riešenia iné korektné riešenie). Vypíšte ktorékoľvek z nich.

## Hodnotenie

Vaše riešenia budú testované na štyroch sadách testovacích vstupov, pre ktoré platí:

| Sada | 1 | 2 | 3 | 4 | |:------------------- | ----:| -----:| ------:| -------:| | $$ 1 \\leq n \\leq $$ | $4$ | $16$ | $64$ | $256$ |

## Príklady

```vstup
2
1 1
```

```vystup
X 1
1 1
```

*Kúpeľna veľkosti $2 \\times 2$ s odtokom v ľavom hornom rohu. Je len jedno možné riešenie.*

```vstup
4
2 3
```

```vystup
2 2 1 1
2 3 X 1
4 3 3 5
4 4 5 5
```

*Jedno z možných riešení. Akékoľvek iné riešenie s iným prečíslovaním či inou pozíciou kachličiek bude tiež akceptované.*
","# Prestavba bytu

Zadanie tejto úlohy bolo pomerne priamočiare. Máme zadanú štvorcovú mriežku nejakých špeciálnych rozmerov a máme ju celú okrem jedného daného políčka vykachličkovať veľa kachličkami tvaru L.

## Riešenie hrubou silou

Prvé riešenie, ktoré môžeme vyskúšať pokiaľ nevieme s ničím lepším prísť, je riešenie hrubou silou, teda skúšanie všetkých možností. V tomto prípade ale nie je úplne jasné, ako takéto skúšanie pekne a dobre implementovať. Ako teda v tomto prípade rozumne postupovať?

Začneme tým, že asi najprirodzenejšou reprezentáciou podlahy kúpeľne je klasické dvojrozmerné pole. To chceme vyplniť číslami kachličiek a následne ho vypísať na výstup. Ďalej vieme už vopred povedať, koľko kachličiek použijeme: stačí si vypočítať počet políčok, odrátať jedno za odtok a vydeliť tromi. Ostáva teda už len zistiť, ako majú byť jednotlivé kachličky otočené a rozmiestnené.

Chceli by sme teraz vymyslieť nejaký systematický postup skúšania všetkých možností. Vezmime si nejaké políčko, ktoré ešte nie je pokryté kachličkou (a ani odtokom). Toto políčko musíme nejako pokryť. Kedže máme iba malý (a hlavne konečný) počet možností, ako to spraviť, môžeme postupne vyskúšať všetky. Presnejšie, budeme postupovať nasledovne: vždy si vyberieme nejakú možnosť, ako toto políčko pokryť, tú si zaznačíme do poľa a rekurzívne sa zavoláme (""vyskúšaj všetky možnosti ako dokončiť toto aktuálne kachličkovanie""). Ak sa z rekurzie vrátime s tým, že žiadne riešenie sme nenašli, odstránime z poľa zaznačený spôsob pokrytia aktuálneho políčka a prejdeme na ďalšiu možnosť, ako ho pokryť.

Naše konkrétne riešenie bude prechádzať pole systematicky: zhora dole a v rámci riadku zľava doprava. Zakaždým, keď nájdeme prázdne políčko, spravíme preň vyššie popísaný postup, pričom pri rekurzívnom volaní si odovzdáme súradnice, kde sme boli, aby sme vedeli, odkiaľ ďalej stačí hľadať nasledujúce voľné políčko. Jeden možný stav počas behu tohto riešenia je znázornený na nasledujúcom obrázku:

Akými možnými spôsobmi ide vo všeobecnosti takéto políčko pokryť? Pri našom systematickom postupe máme zaručené, že všetky políčka v skorších riadkoch aj všetky políčka v aktuálnom riadku naľavo od práve pokrývaného sú už pokryté. Stačí nám teda vyskúšať nanajvýš štyri možnosti, a to tieto:

Na implementáciu tohto riešenia nám stačí jedna funkcia, ktorá ako parametre dostane súradnice prvého políčka (v nami zvolenom poradí), ktoré sme ešte neskontrolovali. Pri každom volaní skontrolujeme jedno políčko. Ak už je pokryté, alebo je to odtok, len sa zavoláme na nasledujúce. Ak nie, tak vyskúšame všetky štyri možnosti, ako ho pokryť, a pre každú, ktorá naozaj pasuje, sa rekurzívne zavoláme na nasledujúce políčko. No a akonáhle sa dostaneme k tomu, že úspešne skontrolujeme, že posledné políčko v poslednom riadku je pokryté, môžeme vyhlásiť, že sme našli riešenie.

Táto funkcia tiež musí mať prístup k poľu, do ktorého zostrojujeme popis kachličkovania. Toto sa dá riešiť rôznymi spôsobmi, napríklad tak, že si referenciu na pole budeme odovzdávať ako ďalší parameter našej rekurzívnej funkcie. (Treba si dať pozor na to, aby sme nekopírovali celé pole pri každom rekurzívnom volaní.)

Technika pre skúšanie všetkých možností, ktorú sme si práve popísali, je známa pod menom backtracking. Pamäťová zložitosť tohto riešenia je zjavne $O(n^2)$, kedže nám stačí pamätať si iba aktuálne pokrytie mriežky, ktoré sa práve pokúšame doplniť. Časová zložitosť môže byť v najhoršom prípade rádovo až $O(4^{(n^2/3)})$ kedže pri prikladaní každej kachličky máme na výber nanajvýš 4 možnosti.

Niektoré implementácie tohto riešenia však fungujú v skutočnosti prekvapivo dobre. Riešenie totiž nielen že vždy existuje, je ich dokonca tak veľa, že sa často stane, že už prvá možnosť priloženia kachličky, ktorú vyskúšame, vedie k riešeniu -- a tak skutočné skúšanie možností budeme robiť až pri okrajoch, kde už niektoré umiestnenia kachličiek budú robiť problémy.

## Vzorové riešenie

Ako by sme mohli začať hľadať nejaké riešenie, ktoré bude zaručene efektívne? Dobrým začiatkom je skúsiť ručne vyriešiť nejaké mriežky menších rozmerov a získať tak trochu obraz o tom, ako riešenia vyzerajú a pre ktoré kombinácie (veľkosť mriežky, poloha odtoku) riešenie neexistuje.

Ak sa pozrieme na mriežky veľkosti $2\\times 2$ či $4\\times 4$, zistíme, že nech je odtok kdekoľvek vždy nájdeme nejaké riešenie. To by nám mohlo napovedať, že by to mohlo ísť aj pre úplne všetky väčšie mriežky -- len budeme musieť náš postup nejak zovšeobecniť.

Skúsme sa pozrieť napríklad na to, ako vieme vykachličkovať mriežku veľkosti $4\\times 4$ s odtokom v ľavom hornom rohu. Ľahko zistíme, že vieme doložiť jednu kachličku tak, aby sme doplnili celý ľavý horný štvorec veľkosti $2\\times 2$. Ako teraz pokryť ostatné tri štvorce rozmerov $2\\times 2$? Každý z nich by sme vedeli pokryť samostatne, ak by obsahoval odtok. Inými slovami, každý z nich vieme pokryť celý okrem jedného jeho políčka. A už sme skoro vyhrali. Všimnite si kachličku, ktorá je na nasledujúcom obrázku zelenou farbou. Jej priložením sme pokryli práve jedno políčko v každom štvorci $2\\times 2$, ktorý neobsahoval odtok. A teda nám ostali štyri štvorce $2\\times 2$, z ktorých každý má práve jedno pokryté a tri nepokryté políčka.

Teraz uvažujme mriežku $4\\times 4$, ktorá má odtok niekde inde. Zjavne aj tú vieme celú pokryť, a to presne rovnakým postupom. Jediný rozdiel bude v tom, že bude inak otočená kachlička v tom štvorci $2\\times 2$, ktorý obsahuje odtok.

Ako je to s väčšími mriežkami? Mriežku $8\\times 8$ si môžeme rozdeliť na štyri mriežky rozmerov $4\\times 4$. Je jasné, že iba v jednom z týchto blokov je práve jedno políčko zabrané odtokom. Vhodným uložením jednej ""zelenej"" kachličky ku stredu mriežky teraz vieme zabrať po jednom políčku aj v každom zo zvyšných troch blokov. No a každý z týchto blokov vieme vyriešiť vyššie popísaným spôsobom.

No a tento postup už ľahko zovšeobecníme: ľubovoľnú mriežku veľkosti $2^k\\times 2^k$ vieme rozdeliť na štyri mriežky veľkosti $2^{k-1}\\times 2^{k-1}$ a následne vieme vhodne priložiť jednu kachličku tak, aby každá mriežka menších rozmerov mala jedno políčko, ktoré už netreba pokryť. Potom sa na každú z menších mriežok rekurzívne zavoláme, čiže pre každú z nich znova zopakujeme túto istú úvahu.

Vhodnou implementáciou tohto riešenia je jedna rekurzívna funkcia, ktorá si bude pamätať, akú časť mriežky vypĺňa a kde v nej sa nachádza ""odtok"", teda to jedno políčko, ktoré je už pokryté. Pamäťová zložitosť tohto riešenia je $O(n^2)$, kedže si pamätáme iba mriežku, do ktorej zároveň hneď dopĺňame kachličky.

Časová zložitosť je tiež $O(n^2)$, čiže priamo úmerná veľkosti mriežky. Prečo? Pri každom zavolaní našej funkcie totiž spravíme konštantne veľa výpočtov a priložíme jednu kachličku. No a keďže kachličiek je $(n^2-1)/3$, toľko bude aj volaní našej funkcie.
",6
db9791b9798866dd,ksp,"# Optimalizácia písania na klávesnici

Samko sa nedávno zamestnal ako programátor pre jeden veľký wébový portál. Už počas prvého týždňa zistil, že to nebude jednoduchá práca. Má totiž na starosti opravovanie starého zdrojového kódu s množstvom chýb. Jeho bežný pracovný deň vyzerá tak, že zapne počítač, otvorí si mail a nájde desiatky škaredých správ od frustrovaných užívateľov. Tí sa väčšinou oprávnene sťažujú na množstvo bugov, ktoré sa na stránke nachádzajú. Samko samozrejme musí všetky takéto prípady preveriť, bugy nájsť a opraviť. Preto sa pomocou `ssh` na diaľku pripojí k príkazovému riadku (terminálu) servera a prehľadávaním logov a zdrojového kódu zisťuje, kde nastala chyba.

Keďže práce je veľa, Samko sa snaží využívať svoj čas efektívne. Napríklad sa naučil bezchybne písať všetkými desiatimi prstami. Teraz však objavil novú funkciu jeho terminálu -- slovník často používaných slov (príkazov). Keď do terminálu napíše začiatok nejakého slova zo slovníku a stlačí `TAB`, tak sa mu tam toto slovo celé dopíše. Ak sa viac slov v slovníku začína rozpísaným slovom, tak sa dopíše lexikograficky najmenšie z nich. Ak žiadne slovo v slovníku nezačína rozpísaným slovom, tak v tom prípade kláves `TAB` nespraví nič. Samko po dlhej úvahe dospel k tomu, že táto funkcia mu vie ušetriť veľa zbytočných stlačení klávesnice. Napríklad ak má v slovníku lexikograficky najmenšie slovo `auto` a chce napísať slovo `aut`, tak to môže spraviť tak, že stlačí `TAB` a `Backspace` (kláves na zmazanie posledného znaku). Nemiesto troch stlačení tak spraví iba dve.

Samka by zaujímalo, koľko času mu táto funkcia vie ušetriť. Preto by si chcel spraviť štatistiku o tom, koľko stlačení potrebuje na napísanie určitých slov. Keďže má však ešte veľa roboty s hľadaním bugov, potreboval by, aby mu s tým niekto pomohol. Zvládnete to?

## Úloha

Na vstupe je terminálový slovník často používaných slov a zoznam slov, ktoré Samka zaujímajú. Pre každé slovo zo Samkovho zoznamu vypíšte, koľko stlačení klávesnice je potrebných na jeho napísanie. Samkov terminál nepodporuje používanie šípok a iných kláves na presúvanie kurzora. Jediné klávesy, ktoré Samko používa sú písmená, `TAB` a `Backspace` (na zmazanie posledného znaku).

## Formát vstupu

Na prvom riadku vstupu sa nachádzajú čísla $n$ a $q$, -- prvé určuje počet slov v slovníku $(1 \\leq n \\leq 1,000,000)$ a druhé počet slov v Samkovom zozname $(1 \\leq q \\leq 1,000,000)$. V každom z nasledujúcich $n$ riadkoch je jedno slovo zo slovníka. Na ďalších $q$ riadkoch sa nachádzajú postupne slová v Samkovom zozname. Všetky slová na vstupe sa skladajú z malých písmen anglickej abecedy a majú menej ako $60,000$ písmen. Celkový počet písmen na vstupe nepresiahne $2,150,000$.

## Formát výstupu

Pre každé z $q$ slov v Samkovom zozname vypíšte jeden riadok -- najmenší možný počet stlačení kláves na napísanie daného slova.

## Príklad

```vstup
3 7
autobus
auto
autostrada
auto
aut
a
autobusar
autobus
autob
utobus
```

```vystup
1
2
1
5
3
2
6
```

*Všimnite si, že slovo `auto` je v slovníku lexikograficky najmenšie. Preto na jeho napísanie stačí jedno stlačenie `TAB`.*

*Slovo `autobusar` vieme napísať nasledujúcov postupnosťou kláves: `TAB`, `b`, `TAB`, `a`, `r`.*

*Slovo `utobus` musíme napísať celé znak po znaku.*
","# Optimalizácia písania na klávesnici

Pred tým než sa pustíme do vzoráku si ujasnime niekoľko pojmov:

- Reťazec (angl. *string*) je postupnosť znakov. Môže to byť slovo, jeho časť ale aj celá veta.

- Prefix je začiatočný úsek reťazca. Formálnejšie, reťazec $a$ nazveme prefixom reťazca $b$, ak za $a$ vieme dopísať niekoľko (možno aj nula) znakov tak, aby sme dostali reťazec $b$. Napríklad reťazec `auto` má päť prefixov -- `""""` (prázdny reťazec), `a`, `au`, `aut` a `auto`.

Pri písaní zadaného slova nás zaujíma iba to, čo máme aktuálne napísané. Tento reťazec reprezentuje nejaký stav, v ktorom sa nachádzame. Stlačením klávesy sa náš reťazec zmení a my sa presunieme do iného stavu. Napríklad ak sú v slovníku slová `autobus` a `autostrada`, tak ak sa nachádzame v stave `au`, môžeme sa jedným stlačením presunúť do nasledovných stavov:

- `aut`, tým, že stlačíme `t` (za `t` si môžeme dosadiť ľubovoľné písmeno, stlačením `l` by sme sa dostali do stavu `aul` a podobne)
- ` autobus`, tým že stlačíme `TAB`, automaticky sa nám doplní lexikograficky najmenšie slovo zo slovníka, ktoré začína na `au`
- `a`, tým že stlačíme `Backspace` zmažeme posledný znak

V okamihu ako nám v úlohe vystupujú stavy, medzi ktorými sa presúvame, môžeme sa na ne pozrieť ako na graf. Stavy reprezentujú jednotlivé vrcholy a presun zo stavu do stavu orientovanú hranu. To zásadne zmení aj úlohu, ktorú riešime. V pôvodnom zadaní sme chceli vedieť, ako čo najrýchlejšie dostať z prázdneho reťazca reťazec výsledný. Prázdnemu aj výslednému reťazcu však teraz zodpovedajú nejaké vrcholy a nás zaujíma najkratšia cesta medzi nimi.

Na obrázku môžeme vidieť, ako by vyzerala časť grafu so slovom `auto`. Skutočný graf je totiž nekonečný a obsahuje všetky možné reťazce. Všimnite si, že čierne šipky sú obojsmerné. To značí možnosť dopísania písmena na koniec a jeho vymazania stlačením `Backspace`. Tiež si všimnite zelené šípky, ktoré predstavujú stláčanie klávesy `TAB`.

Povedali sme si, že písanie slova je ekvivalentné hľadaniu najkratšej cesty medzi zadanými vrcholmi. Takže môžeme využiť dobre známy algoritmus prehľadávania do šírky (BFS). Problémom ale je, že náš graf je nekonečný, keďže na klávesnici vieme napísať čokoľvek. Pokúsme sa teda zmenšiť počet stavov, ktorými sa musíme zaoberať.

Kľúčovým pozorovaním je, že si nepotrebujeme pamätať stavy, ktoré nie sú prefixom žiadného slova v slovníku.

Prečo je tomu tak? Keby sme na písanie mohli používať iba písmená, úloha by bola jednoduchá, lebo cestu by sme si nevedeli nijak skracovať a museli by sme proste napísať zadané slovo písmeno po písmene. Nám však pribudli aj klávesy `TAB` a `Backspace`. A klávesa `TAB` dopĺňa slová zo slovníku, ktoré majú rovnaký prefix ako reťazec, ktorý sme doposiaľ napísali. Ak sme teda v stave, ktorý nie je prefixom žiadneho slova v slovníku, klávesa `TAB` nič nerobí.

Klávesa `Backspace` má tiež len obmedzené využitie. Uvedomme si, že v optimálnom riešením nikdy nepoužijeme `Backspace` tesne po tom, čo napíšeme nejaké písmeno. Keby sme to totiž spravili, reťazec by sa vlastne nezmenil a my by sme tieto dve stlačenia mohli radšej vynechať. `Backspace` teda môžeme stlačiť iba po nejakom `TAB` alebo `Backspace`. To znamená, že vymazávanie znakov využijeme iba v prípade, že stlačíme `TAB`, doplnené slovo však bude pridlhé a niekoľko posledných znakov budeme chcieť vymazať. Pri tom všetkom sme sa však neustále pohybovali po reťazcoch, ktoré sú prefixami slov v slovníku.

Z vyššie uvedených pozorovaní tiež vyplýva, že v okamihu ako sa rozhodneme opustiť prefixy slov v slovníku, tak klávesy `TAB` a `Backspace` už nemá zmysel použiť a nám ostáva zvyšný text dopísať písmeno po písmene.

Keď si teda predstavíme ako funguje naše riešenie, ak chceme napísať slovo $s$, tak najskôr sa budeme pohybovať po prefixoch slova $s$, ktoré sú zároveň prefixami niektorých slov v slovníku a keď tieto prefixy opustíme, zvyšok slova $s$ jednoducho dopíšeme.

Na obrázku vidíme, ako vyzerá graf všetkých prefixov slov zo slovníka `auto`, `autobus` a `autostrada`.

Skúsený riešiteľ si isto všimne, že graf ktorý nám ostane pripomína písmenkový strom (po anglicky aj *trie*). Písmenkový strom je dátová štruktúra, v ktorej si pamätáme informácie o slovách v slovníku a ich prefixoch. Každý vrchol reprezentuje konkrétny prefix slova v nej -- presne ako v grafe ktorý vytvárame. Z každého vrcholu vedie najviac 26 hrán do synov -- vrcholov, ktoré reprezentujú stavy do ktorých sa dostaneme pridaním jedného písmenka na koniec reťazca. My si však do tohto písmenkového stromu ešte musíme pridať hrany, ktoré reprezentujú stláčanie kláves `TAB` a `Backspace`.

Písmenkový strom sa tradične konštruuje tak, že začíname s prázdnym stromom, do ktorého postupne pridávame slová. Slovo pridávame po písmenách začnúc v koreni. Postupne sa snažíme posúvať po hranách, ktoré reprezentujú jednotlivé písmená slova. V okamihu, keď sa chceme posunúť po hrane, ktorá ešte z aktuálneho vrcholu nevedie, vytvoríme nový vrchol a do neho vedúcu hranu. Pri vytváraní vrcholu môžeme veľmi jednoducho spraviť hranu aj pre `Backspace` -- stačí si zapamätať otca vrcholu.

Hrany pre autocomplete sú najzložitejšie, vieme ich však vygenerovať rekurzívne. Ak vrchol reprezentuje slovo v slovníku tak jeho autocomplete vedie do neho samého. Ak nie, tak pre každého syna najprv rekurzívne zistíme jeho autocomplete a potom vyberieme autocomplete zo syna, do ktorého vedie hrana s lexikograficky najmenším písmenom v abecede.

Po skompletizovaní grafu na ňom spustíme prehľadávanie do šírky, ktoré nám pre každý vrchol vypočíta, ako najrýchlejšie sa do neho vieme dostať zo začiatku, ktorý reprezentuje prázdny reťazec, a tieto hodnoty si zapamätáme.

Ostáva nám už len odpovedať na otázku, ako najrýchlejšie vieme napísať slovo $s$. Na to nájdeme najdlhší prefix tohto slova, ktorý sa nachádza aj v našom písmenkovom strome. Z predpočítanej informácie vieme, ako najrýchlejšie napísať tento prefix a keďže je to prefix najdlhší, zvyšok už aj tak musíme napísať písmeno po písmene.

Časová zložitosť konštruovania je lineárna od súčtu dĺžok slov v slovníku. BFS tiež spravíme v lineárnom čase od počtu vrcholov v strome. A nájsť najdlhší prefix tiež zvládneme v čase lineárnom od dĺžky hľadaného slova. Celková časová zložitosť je teda lineárna od dĺžky vstupu. Pamäťová zložitosť je lineárna od počtu vrcholov v písmenkovom strome. Naviac, táto zložitosť je určite optimálna, keďže rovnako veľa času nám zaberie načítanie celého vstupu.
",8
f4b8398078b751e7,ksp,"# Obojstranná čokotuba

Samo a Jano sú influenceri. Od čokofirmy dostali masívnu reklamnú obojstrannú tubu rôznofarebných čokoládiek pre dvojičky. Vraj aby sa odfotili, ako im chutí a aké skvelé to je, že sa nemusia hádať, kto si vytiahne čokoládu prvý. Každý vie, že rôzne farby čokoládiek znamenajú rôzne obsiahnuté živiny. Keďže Samo a Jano chcú všetkým ukázať, ako vyvážene sa stravujú, zrátali si, koľko ktorých čokoládiek chcú zjesť. Dve purpurové, šesť egyptských modrých, jedna nachová, tri indigové, sedem sivých...

Tuba s čokoládkami je otvorená z dvoch strán. Samo a Jano začali zbesilo vyťahovať čokošky z jednej strany. Keď nejakú vytiahnú, tak ju rovno aj zjedia, aj keď nepatrí do ich požiadaviek na vyváženú stravu. Keby ju nezjedli, určite by sa niekde stratila. To by bola škoda. Rýchlo si však uvedomili, že čím viac nechcených čokoládiek zjedia, tým horšiu mienku o nich budú mať ich sledovatelia.

Nuž, Samo začal hútať, koľko čokoládiek z ktorej strany to majú vlastne vybrať, aby sa najedli čo najmenej, ale aby zároveň uspokojili svoje potreby vyváženej stravy. Ak budú musieť tých zlých čokolád zjesť priveľa, nebudú ani chcieť pristúpiť na takúto ponuku sponzora. A podobných ponúk určite príde ešte veľa. Hodil by sa im preto program, ktorý pre danú tubu čokoládiek a ich potreby vyváženej stravy vypočíta, koľko najmenej čokoládiek budú musieť vytiahnúť, aby sa dostali k tým, čo chcú. Pomôžete im udržať priazeň publika?

## Úloha

Tuba je priehľadná a otvorená z dvoch strán. Vnútri sú čokoládky naskladané v rade vedľa seba. Samo a Jano chcú vybrať z tuby **aspoň** $a_1$ čokoládiek farby $f_1$, **aspoň** $a_2$ čokoládiek farby $f_2$, ..., **aspoň** $a_m$ čokoládiek farby $f_m$.

Vašou úlohou je zistiť, koľko najmenej čokoládiek musia dokopy z tuby vybrať tak, aby splnili svoje požiadavky. V každom momente môžu vybrať buď čokoládku úplne zľava, alebo čokoládku úplne sprava.

## Formát vstupu

Na prvom riadku dostanete čísla $n$ - počet všetkých čokoládiek v tube, $m$ - počet Samových a Janových požiadaviek a $f$ - počet rôznych farieb čokoládiek, ktoré sa môžu vyskytovať v tube. Platí, že $1 \\leq f \\leq n \\leq 500,000$ a $0 \\leq m \\leq f$.

Na druhom riadku je $n$ čísiel $c_1$ až $c_n$ - farby čokoládiek tak, ako sú v tube zľava doprava. Farby majú čísla od $1$ po $f$. To však neznamená, že sa na vstupe musia nutne vyskytovať všetky farby od $1$ po $f$.

Nasleduje $m$ riadkov. V $i$-tom z nich sú čísla $a_i$ a $f_i$. Tie znamenajú, že Samo a Jano chcú z tuby vybrať **aspoň** $a_i$ čokoládiek farby $f_i$. Môžete predpokladať, že všetky $f_i$ sú navzájom rôzne a tiež, že pre zadanú tubu sú všetky požiadavky vždy splniteľné.

## Formát výstupu

Na výstup vypíšte jedno číslo - koľko najmenej čokoládiek musia Samo s Janom z tuby vybrať, aby splnil všetky svoje požiadavky.

## Príklady

```vstup
6 2 3
1 2 2 1 3 2
1 1
3 2
```

```vystup
4
```

*Naši súrodenci chcú jednu čokoládu farby 1 a tri čokolády farby 2. Môžu teda zobrať napríklad 3 čokolády zľava a jednu sprava.*

```vstup
5 1 3
1 2 2 3 1
1 2
```

```vystup
2
```

*Teraz chcú iba jednu čokoládu farby 2. Tá ale nie je na kraji, tak sa k nej musia dostať cez najľavejšiu čokoládu farby 1.*
","# Obojstranná čokotuba

## Iba jedna strana

Pozrime sa, ako by sa úloha zmenila, keby sme mohli brať čokolády iba zľava. Skúsme všetky možnosti a pre každú overme, či vyhovuje. Najskôr teda overíme, či nám stačí zobrať iba prvú čokoládu. Potom skúsime zobrať prvú a druhú, potom skúsime prvú, druhú a tretiu... Z vyhovujúcich možností zoberieme tú najkratšiu. Ako ale zistiť, či možnosť vyhovuje?

Pre každú testovanú možnosť si zrátame, koľko čokolád ktorej farby obsahuje. Majme pole $p$ veľkosti $f$ so samými nulami. Číslo $p_i$ nám hovorí, koľko čokolád farby $i$ momentálne máme. Ak zoberieme čokoládu farby $u$, tak ku $p_u$ pripočítame $1$. Keď si teda napočítame čokolády v testovanom úseku, môžeme prejsť všetky požiadavky a pre každú požiadavku overiť, či je splnená. Takéto riešenie jednoduchšej úlohy bude fungovať v čase $O(n(n + m + f))$, pretože pre každú z $n$ možností prejdeme nanajvýš $n$ políčok, vynulujeme pole $p$ veľkosti $f$ a prejdeme všetkých $m$ požiadaviek.

## Iba jedna strana, rýchlejšie

V pôvodnom riešení sme veľa vecí robili zbytočne. Napríklad, ak sme už poznali počty čokolád v úseku $[1,,x]$ a chceli sme zistiť počty čokolád v úseku $[1,,x+1]$, nemuseli sme nulovať celé pole $p$. Úplne nám stačí pridať do poľa $p$ čokoládu na pozícií $x+1$. Všetky ostatné čokolády totiž budú tie isté, ako v starom úseku. Ku $p\_{c\_{x+1}}$ teda iba pripočítame $1$. Teraz, keď nezahadzujeme informácie zo skúmania predchádzajúcej možnosti, vieme každú novú možnosť spracovať v $O(m)$. Možností je stále $n$, takže časová zložitosť je $O(f + nm)$. Stále totiž pre každú možnosť prechádzame cez všetky požiadavky. Pole $p$ však nastavujeme už iba raz.

## Iba jedna strana, ešte rýchlejšie

Asi je celkom očividné, že slabou časťou nášho doterajšieho riešenia je to, že pre každú možnosť prechádzame všetky požiadavky, aby sme overili, či sú splnené. Ako to zlepšiť?

Vieme, že keď sme ešte nezobrali žiadnu čokoládu, tak nie je splnená žiadna požiadavka. Majme teda počítadlo $nesplnene$, ktoré bude hovoriť, koľko máme ešte nesplnených požiadaviek. Na začiatku, je samozrejme nastavené na $m$. Postupne pridávame čokolády, až niekedy nastane zaujímavá udalosť. Pridaním čokolády farby $w$ sa nám mohol zvýšiť počet týchto čokolád na minimálnu hranicu požadovanú Samom a Janom. To znamená, že požiadavka na čokolády farby $w$ doteraz nebola splnená, ale teraz už splnená je. Môžeme teda od $nesplnene$ odčítať $1$.

Keď niekedy $nesplnene$ dosiahne hodnotu $0$, vieme, že už sú všetky požiadavky splnené. Nemusíme teda už ani skúšať brať ďalšie čokolády. Určite by sme tým už nenašli lepšie riešenie, ako máme teraz.

Ako ale zistiť, že nejaká požiadavka doteraz nebola splnená a teraz už je? Na začiatku si spravíme pole $t$ veľkosti $f$, ktoré nám pre každú farbu povie, koľko jej je žiadanej. To vieme spraviť už počas načítavania požiadaviek. Potom s týmito hodnotami vieme porovnávať hodnoty z poľa $p$. Ak doteraz platilo, že $p_i < t_i$ a zobratím nejakej čokolády farby $i$ začalo platiť, že $p_i = t_i$, tak požiadavka na farbu $i$ je už splnená. Časová zložitosť teda bude $O(n + m + f)$.

## Dve strany, hrubá sila

Jednoduchým riešením pôvodnej úlohy je vyskúšať všetky možnosti pre zobratie prefixu a suffixu a každú takúto možnosť overiť. Podľa toho, ako dobre spravíme overovanie môže mať toto riešenie časovú zložitosť zhruba niekde medzi $O(n^2)$ a $O(n^3)$. Rôzne spôsoby overovania sme si popísali vyššie.

## Dve strany, vzorové riešenie

Poďme sa ale pozrieť, ako môžeme riešenie úlohy, kde berieme čokolády iba zľava rozšíriť na obojstrannú verziu.

V jednoduchšej úlohe sme spravili pozorovanie, že ak vieme splniť požiadavky najľavejšími $x$ čokoládami, tak už nemusíme skúšať brať ďalšie, pretože by sme tým určite nezískali lepšie riešenie. Ako toto pozorovanie využiť? Nuž, skúsme nezobrať žiadne čokolády sprava. Zľava teraz zoberieme iba toľko čokolád, koľko nám stačí na splnenie všetkých požiadaviek. Máme teda nejaké riešenie. Možno je najlepšie, možno nie, no určite spĺňa všetky požiadavky. No dobre, zľava už určite nechceme zobrať viac čokolád.

Čo ale sprava? Čo sa môže stať, keď zoberieme naviac ešte jednu čokoládu sprava? Ak to bola čokoláda, ktorej farba sa nijak nevyskytuje v požiadavkách, tak nič neriešime. Zhoršili sme si síce doterajšie riešenie, ale to nás nijak netrápi, pretože výsledok lepšieho riešenia si pamätáme ako doteraz najlepšie nájdené. Čo sa ale stane, ak sa farba najpravejšej čokolády nachádza niekde v požiadavkách na vyváženú stravu? Znamená to, že možno môžeme na ľavú stranu vrátiť čokoládu, ktorú sme odtiaľ zobrali ako poslednú. Môžeme ju vrátiť, ak má rovnakú farbu, ako tá, ktorú sme teraz zobrali sprava. No a aby sme sa z ľavej strany dostali k čokoláde, ktorú sme tam teraz vrátili, museli sme možno prejsť cez nejaké čokolády, ktoré sme vôbec nechceli. Môžeme tam teda vrátiť aj tie. A ľaľa, možno sme práve našli nové najlepšie riešenie.

Pozrime sa na to naopak. Máme riešenie, ktoré berie čokolády iba zľava. Vieme, že všetky požiadavky sú splnené. Skúsme vrátiť čokoládu, ktorú sme zobrali ako poslednú. Tým možno prestala byť splnená nejaká požiadavka. To znamená, že teraz budeme brať čokolády sprava, až kým neopravíme túto pokazenú požiadavku. Tento postup teda začne s riešením, ktoré berie iba čokolády zľava a opakuje dva jednoduché kroky:

1. Vráť na ľavú stranu čokoládu, ktorú si odtiaľ zobral ako poslednú
1. Ber čokolády sprava, kým opäť nie sú splnené všetky požiadavky

Môžeme si všimnúť, že niekedy nám vrátenie čokolády na ľavú stranu žiadnu požiadavku nepokazí. Vtedy teda nemusíme brať žiadne ďalšie čokolády sprava.

Akú to má celé časovú zložitosť? Najskôr nájdeme nejaké riešenie, ktoré berie čokolády iba zľava. To už vieme v $O(n + m + f)$. Potom vždy vrátime jednu čokoládu na ľavú stranu a zoberieme niekoľko, možno aj 0, čokolád sprava. Každú čokoládu teda najviac raz zoberieme a najviac raz vrátime. Bude to teda celé v $O(n + m + f)$. Vieme ale, že $m$ ani $f$ nikdy nebudú väčšie, ako $n$. Môžeme teda povedať, že časová zložitosť je $O(n)$.

Pamäťová vyzerá ako $O(n + m + f)$. Požiadavky si ale nemusíme pamätať ako zoznam, takže sa dostávame na $O(n + f)$ a stále platí, že $f \\leq n$, takže aj o pamäti môžeme povedať, že je $O(n)$.
",4
8c4882990a98a0e3,ksp,"# Veľmi pokazená tlačiareň

Od neskorého večera do neskorého rána, tlačiaren v T2 tlačila. Mišof a Hodobox vstúpili dnu. Po chvíli skúmania zistili, že vytlačené sú iba dva druhy obrázkov. Mišofovi hneď napadlo, že by časť, alebo aj všetky obrázky mohli použiť na oblepenie stien. A tak sa s Hodoboxom zhodli, že na vyfarbenie každého obrázku použijú béžovú, ružovú a modrú. Z týchto farieb však mali obmedzený počet voskoviek, ktoré mohli použiť na vyfarbovanie obrázkov. A preto chcú zistiť, koľko najviac obrázkov dokážu vyfarbiť.

## Úloha

Mišof s Hodoboxom Vám povedali, koľko majú voskoviek jednotlivých farieb. Pre oba typy obrázka viete, koľko voskoviek ktorej farby potrebujú na jeho vyfarbenie.

Vašou úlohou je povedať, koľko najviac obrázkov Mišof a Hodobox dokážu vyfarbiť.

## Formát vstupu

Na prvom riadku vstupu sú 3 medzerou oddelené prirodzené čísla $b,,r,,m$ -- počet béžových, ružových a modrých voskoviek, ktoré majú Mišof s Hodoboxom k dispozícii.

Nasledujú dva riadky. V $i$-tom z nich sú čísla $b_i,,r_i,,m_i$ -- počty voskoviek jednotlivých farieb, ktoré sa spotrebujú na jeden obrázok typu $i$.

## Formát výstupu

Na jediný riadok výstupu vypíšte najväčší počet obrázkov, ktoré vedia Mišof a Hodobox vyfarbiť.

## Hodnotenie

Sú 4 sady vstupov. Platia v nich nasledovné obmedzenia:

| Sada | 1 | 2 | 3 | 4 | | :------------------------------ | ----: | --------: | ---------: | ------------: | | $1 \\leq b,,r,,m, \\leq$ | $100$ | $10,000$ | $100,000$ | $1,000,000$ | | $1 \\leq b_i,,r_i,,m_i, \\leq$ | $300$ | $30,000$ | $300,000$ | $3,000,000$ |

## Príklad

```vstup
6 6 6
1 2 2
2 1 1
```

```vystup
4
```

_Mišof a Hodobox vyfarbia po dva obrázky z každého druhu._

```vstup
3 4 5
1 1 1
2 2 2
```

```vystup
3
```

_V tomto prípade vedia vyfarbiť 3 obrázky prvého druhu._
","# Pokazená tlačiareň

V tejto úlohe sme mali zistiť, koľko obrázkov vedia Mišof a Hodobox vyfarbiť, keď majú dané koľko ktorých voskoviek majú k dispozícii a koľko ktorých voskoviek je potrebných na vyfarbenie každého typu obrázku.

## Vzorové riešenie

Nech v optimálnom riešení máme $x$ obrázkov typu 1 a $y$ obrázkov typu 2. Našou úlohou je zistiť čísla $x, y$ tak, aby $x + y$ bolo maximálne možné.

Môžeme postupne skúšať všetky dosiahnuteľné hodnoty $x$. Ku každej z nich si ľahko vieme dorátať, koľko ktorých voskoviek nám ostane po vyfarbení $x$ obrázkov typu 1. Všetky tieto zvyšné voskovky môžeme použiť na vyfarbenie čo najviac obrázkov druhého typu. Jednoducho si teda dorátame číslo $y$.

Skúsme sa bližšie pozrieť na to, ako dopočítať číslo $y$. Ak sme na $x$ obrázkov prvého typu použili $x_b = x \\cdot b_1$ voskoviek béžovej, $x_r = x \\cdot r_1$ ružovej a $x_m = x \\cdot m_1$ voskoviek modrej farby, tak na obrázky typu 2 nám ostalo $y_b = b - x_b$ voskoviek béžovej, $y_r = r - x_r$ ružovej a $y_m = m - x_m$ modrej farby. Ako zistíme, koľko obrázkov druhého typu vieme týmito voskovkami zafarbiť? Na vyfarbenie jedného obrázku typu 2 potrebujeme $b_2, r_2, m_2$ voskoviek príslušných farieb. Jedna z týchto farieb voskoviek sa nám minie ako prvá. Obrázkov typu 2 teda vieme vyfarbiť $y = \\min{ \\frac{y_b}{b_2}, \\frac{y_r}{r_2}, \\frac{y_m}{m_2} }$.

Pre nejaké nami zvolené $x$ sme teda dopočítali maximálne možné $y$. Na doriešenie úlohy nám teda stačí postupne skúsiť všetky možné $x$, ku každému dopočítať $y$ a vypísať tú možnosť, kde bolo $x + y$ najväčšie.

Prečo to funguje? Pretože skúšame všetky možnosti. Žiadna nám teda neunikne.

### Zložitosť

Koľko rôznych $x$ potrebujeme skúšať? Na každý obrázok spotrebujeme aspoň jednu voskovku každého druhu. Stačí nám teda vyskúšať $\\min{ b, r, m }$ možností pre $x$. Ku každému vieme potom dopočítať $y$ v konštantnom čase. Časová zložitosť teda bude $O(\\min{ b, r, m })$.

Pamätať si nám stačí jednotlivé počty voskoviek, ktoré máme k dispozícii a doteraz najlepšie nájdené $x, y$. Stačí nám teda konštantná pamäť a pamäťová zložitosť bude $O(1)$.
",1
2fdf703f37431fee,ksp,"# Utrápený Michallius

Každý dobre vie, že Michallius sa rád bije. Chcel sa prihlásiť na bitkársky turnaj konajúci sa na konci semestra, zaškrtol však zlú kolónku a ocitol sa na prestížnom gladiátorskom deathmatch-i^[To znamená, že súboj pokračuje, dokým jeden z dvojice nezomrie], na ktorý sa bude pozerať aj sám cézar. Na začiatku dostane každý gladiátor 1 bitkoin^[bitkoin -- drobná zlatá minca používaná medzi bitkármi (odtiaľ názov)] a za porazenie súpera získava všetky jeho bitkoiny. Takže gladiátori sa vedia pekne nabaliť. Bojuje sa v dvoch typoch súbojov: v boji s mečom a boji s kopijou. Na začiatku súboja sa vždy vyberie typ zbrane a táto zbraň sa počas súboja nezmení.

Chudák Michallius bol sprvu veľmi utrápený a bál sa. Kašľal na svoj bitkoin, chcel iba prežiť. Musel preto teda niečo robiť. Rozhodol sa preskúmať svoje sily a sily ostatných súperov. O každom gladiátorovi (vrátane seba) si poznačil jeho silu s mečom a s kopijou. Robil to dôkladne, žiadni dvaja bojovníci nemajú rovnakú silu v jednom type boja. Michallius cez skúškové trénoval, poctivo posilňoval, a aj sa správne stravoval. Zistil, že nakoniec je v tom bojovaní celkom dobrý, preto ho už začína zaujímať koľko by si vedel maximálne odniesť z tohto turnaja.

Zistite, aký maximálny zárobok si vie Michallius odniesť. A vlastne, keď už to zistíte o Michalliovi, zistite to isté o každom ďalšom gladiátorovi.

## Úloha

Na turnaj sa prihlásilo $n$ gladiátorov. O každom gladiátorovi vieme jeho silu v boji s mečom a silu v boji s kopijou (obe tieto sily sú celé čísla). Každý gladiátor dostane na začiatku 1 bitkoin. Turnaj má pomerne voľnú štruktúru, ktorá vyzerá nasledovne:

1. Vylosujú sa dvaja gladiátori, ktorí ešte neprehrali.
1. Vylosuje sa, či budú bojovať s kopijami, alebo s mečmi.
1. Pobijú sa. Gladiátor, ktorý je v danom type boja silnejší, zvíťazí.
1. Víťaz získa všetky bitkoiny porazeného a porazený vypadáva z turnaja (z pochopiteľných dôvodov).

Tieto štyri kroky sa opakujú, až kým turnaj cézara neomrzí. Môže sa tak stať, že na konci prežije viacero gladiátorov.

Chceme vedieť o každom gladiátorovi, koľko bitkoinov môže na turnaji maximálne zarobiť, ak by všetky losovania dopadli preňho najlepším možným spôsobom.

## Formát vstupu

Na prvom riadku vstupu sa nachádza celé číslo $n$ -- počet gladiátorov na turnaji. Platí: $1 \\leq n \\leq 100,000$. Nasleduje $n$ riadkov. V $i$-tom riadku sa nachádzajú dve celé čísla oddelené medzerou: sila $i$-teho gladiátora v boji s mečom $m_i$ a jeho sila v boji s kopijou $k_i$. Platí $1 \\leq m_i , k_i \\leq n$. Môžete predpokladať, že žiadni dvaja gladiátori nemajú rovnakú silu s mečom, ani rovnakú silu s kopijou.

## Formát výstupu

Vypíšte $n$ riadkov. V $i$-tom riadku vypíšte počet bitkoinov, ktoré môže $i$-ty gladiátor získať.

## Príklady

```vstup
4
2 3
3 2
1 1
4 4
```

```vystup
3
3
1
4
```

*Michallius (prvý gladiátor) dokáže poraziť druhého gladiátora ak budú bojovať s kopijou, tretieho v ľubovolnom boji. Druhý gladiátor porazí Michallia v boji s mečom a tretieho v ľubovolnom boji. Tretí gladiátor je bezmocná ovca, a štvrtý je Spartakus.*

```vstup
4
3 3
4 1
1 4
2 2
```

```vystup
4
4
4
4
```

*Všimnime si, že posledný gladiátor dokáže získať aj Michalliov bitkoin, hoci je slabší v oboch typoch boja.*
","# Utrápený Michallius

## Koľko bitkoinov vie vyhrať gladiátor $\\boldsymbol{a}$?

Aby sme zistili _koľko_ bitkoinov môže zarobiť nejaký gladiátor $a$, skúsme najskôr zistiť _ktoré_ bitkoiny môže $a$ získať.

Aby gladiátor $a$ získal bitkoin, ktorý na začiatku turnaja patril gladiátorovi $b$, musí k nemu tento bitkoin nejako doputovať. Táto púť bude vyzerať tak, že najskôr $b$ prehrá súboj s nejakým iným gladiátorom, ten (ak to ešte nie je gladiátor $a$) potom prehrá s ďalším gladiátorom, ten prehrá s ďalším, atď., až nakoniec posledný gladiátor z tejto reťaze prehrá s gladiátorom $a$.

Povedané formálne, $a$ dokáže získať bitkoin od $b$, vtedy a len vtedy, keď existuje postupnosť gladiátorov $b = g_1, g_2, \\ldots, g_k = a$ taká, že pre všetky prípustné $i$ vie $g\_{i+1}$ poraziť $g_i$ v aspoň jednom type súboja.

\\smallskip

Máme teda dobre popísaný vzťah ""$a$ vie získať bitkoin $b$"". Viac bitkoinov než počet takýchto gladiátorov $b$ gladiátor $a$ nevie získať. Ale to, že $a$ vie získať bitkoiny od $b_1, \\ldots, b_m$ ešte neznamená, že ich vie získať všetky **v priebehu jedného turnaja**. Ukazuje sa ale, že sa to dá.

\\smallskip

Dobre sa to vysvetľuje z grafového hľadiska. Uvažujme orientovaný graf, v ktorom vrcholy reprezentujú gladiátorov, a je v ňom hrana $x \\rightarrow y$ vtedy, keď $x$ vie poraziť $y$ aspoň v jednom type súboja. Potom $a$ vie získať bitkoiny práve tých gladiátorov, ktorí sú dosiahnuteľní z $a$ (rozmyslite si).

Postupnosť zápasov, v ktorej $a$ získa bitkoiny od všetkých takýchto gladiátorov, vieme nájsť nasledovne:

1. Začneme s prázdnou postupnosťou zápasov.
1. Spustime prehľadávanie (napríklad [do hĺbky](https://www.ksp.sk/kucharka/dfs/)) z $a$ a vždy, keď prejdeme po hrane do nejakého ešte nenavštíveného vrcholu, zafarbime túto hranu na červeno. Po skončení prehľadávania budú červené hrany tvoriť strom obsahujúci práve vrcholy dosiahnuteľné z $a$.
1. Z tohto stromu odstránime hranu $x \\rightarrow y$ vedúcu do listu a do postupnosti pridáme zápas medzi $x, y$, pričom typ zápasu zvolíme tak, aby $x$ vyhral.
1. Opakujeme predchádzajúci krok, kým sú v grafe hrany.

\\smallskip

*(Prvá tabuľka zobrazuje sily jednotlivých gladiátorov. Druhá tabuľka obsahuje gladiátorov usporiadaných podľa ich síl. Tretia tabuľka zobrazuje zápasy v takom turnaji, v ktorom by gladiátor $g_7$ získal všetky bitkoiny, ktoré vie získať.)*

## Prvý správny algoritmus

Predchádzajúca úvaha nám dáva jednoduchý algoritmus na riešenie úlohy: zostrojíme graf a postupne z každého vrcholu $a$ spustíme prehľadávanie, ktorým zistíme, koľko vrcholov z neho vieme dosiahnuť. To je zároveň aj počet bitkoinov, ktorý si vie gladiátor $a$ z turnaja odniesť.

Graf obsahuje $n$ vrcholov a $O(n^2)$ hrán, časová zložitosť je preto $O(n^3)$. Pamäťová zložitosť je $O(n^2)$ (ak v pamäti vytvoríme všetky hrany), prípadne $O(n)$ (ak si pamätáme iba sily gladiátorov).

Predchádzajúce riešenie možno o rád zrýchliť nasledujúcim trikom: usporiadajme si gladiátorov do postupnosti $g'\_1, g'\_2, \\ldots, g'\_n$ podľa rastúcej sily v boji s mečom. Potom nemusíme mať v grafe všetky hrany $g'\_i \\rightarrow g'\_j$ pre $i > j$, stačí, ak v ňom budú hrany $g'_i \\rightarrow g'_{i - 1}$ pre všetky prípustné $i$.

\\smallskip

*(Graf, v ktorom neuvažujeme zbytočné hrany. Pre každú silu $k > 1$ a každý typ boja máme hranu vedúcu od gladiátora so silou $k$ ku gladiátorovi so silou $k - 1$. Zelené hrany zodpovedajú boju s mečom, modré hrany boju s kopijou.)*

\\medskip

Prečo? Ak v pôvodnom grafe existovala cesta z $a$ do nejakého $b$, tak v novom grafe dostaneme cestu z $a$ do $b$ tak, že každú hranu na pôvodnej ceste, ktorá má tvar $g_i \\rightarrow g_j$ pre $i > j$, nahradíme postupnosťou hrán $g_i \\rightarrow g\_{i - 1}, g\_{i - 1} \\rightarrow g\_{i - 2}, \\ldots, g\_{j + 1} \\rightarrow g_j$. Takže pre ľubovoľný vrchol $a$ je množina vrcholov dosiahnuteľných z $a$ rovnaká, ako v pôvodnom grafe.

Rovnako vieme zredukovať počet hrán, ktoré zodpovedajú súbojom s kopijou. V novom grafe budeme mať $2 \\cdot (n - 1) = O(n)$ hrán, a vylepšíme tým časovú zložitosť algoritmu na $O(n^2)$.

## Vzorové riešenie

Majme gladiátorov $g_1, g_2, \\ldots, g_n$ usporiadaných vzostupne podľa sily v boji s mečom. Všimnime si, že všetky bitkoiny, ktoré vie získať $g_i$, vie získať aj $g\_{i + 1}$. To ale znamená, že keď hľadáme vrcholy dosiahnuteľné z $g\_{i + 1}$, tak nám stačí hľadať iba také vrcholy, ktoré nie sú dosiahnuteľné z $g_i$. Vrcholy dosiahnuteľné z $g_i$ totiž môžeme zarátať automaticky.

Budeme teda púštať prehľadávanie postupne od najslabších gladiátorov k najsilnejším, teda v poradí $g_1, g_2, \\ldots, g_n$. Pre každého gladiátora si pamätáme, či sme ho už v niektorom prehľadávaní navštívili, a pamätáme si tiež počet už navštívených gladiátorov. Keď prehľadávame z $g_i$, tak nenavštevujeme vrcholy, ktoré sme už navštívili v niektorom z predchádzajúcich prehľadávaní.

Rozmyslite si, že takýmto spôsobom sú po $i$-tom prehľadávaní navštívení práve tí gladiátori, ktorí sú dosiahnuteľní z $g_i$. Práve od nich vie $g_i$ získať bitkoin. Ich počet je teda počet bitkoinov, ktoré vie $g_i$ získať.

## Zložitosť

Na začiatku si potrebujeme utriediť gladiátorov podľa sily. To nám bude trvať $O(n \\log n)$. Počas prehľadávaní navštívime každý vrchol grafu najviac raz, čo je $O(n)$ roboty (lebo graf má len $n$ vrcholov a $O(n)$ hrán). Preto je časová zložitosť celého algoritmu $O(n \\log n)$. Pamäťová zložitosť ostáva $O(n)$.

Pritom časová zložitosť $O(n \\log n)$ je iba kvôli triedeniu, my však máme čísla z rozsahu od $1$ po $n$. Vieme ich teda utriediť count sortom, a dostaneme tak lepší čas $O(n)$.
",9
